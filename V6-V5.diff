diff --git a/CHANGELOG b/CHANGELOG
new file mode 100644
index 0000000..43864d2
--- /dev/null
+++ b/CHANGELOG
@@ -0,0 +1,9 @@
+07 Feb 2021
+===========
+1. Update the 'be:name' field of the Timer output files as 'GWB'.
+2. Fine tuned the files deleted to ensure that only files created by pinta are removed.
+3. Create an summary file (pinta_summary.txt) containing the pdmp DM and SNR of each output file.
+4. Convert the summary PS files to PDF format.
+5. Default NBin value can be accessed by using NBin=-1 in the pipeline.in file (Power of 2 closest to and less than P0/Tsmpl).
+6. '--xnbin <x>' option to fold the data to x*NBin bins in addition to NBin bins.
+7. Check if dspsr has created the folded profile archive.
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..d159169
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,339 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+                            NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/README.md b/README.md
index c40d2e2..4c26177 100644
--- a/README.md
+++ b/README.md
@@ -2,10 +2,10 @@
 `pinta` is a data analysis pipeline for upgraded GMRT pulsar data. It RFI mitigates and folds uGMRT data to form Timer archives. 
 
 A detailed description of `pinta` is given in 
-Susobhanan et al., 2020 (https://arxiv.org/abs/2007.02930).
+Susobhanan et al., 2020 (https://doi.org/10.1017/pasa.2021.12).
 If you use this pipeline in your research, please cite this paper,
 along with those for the two RFI excision tools that `pinta` heavily
-make use of (`RFIClean`: https://arxiv.org/abs/2012.11630, `gptool`:to be updated).
+make use of (`RFIClean`: https://doi.org/10.1051/0004-6361/202040164, `gptool`:to be updated).
 
 ## Installing
 
@@ -17,22 +17,12 @@ Install the following pulsar packages by following the installation instructions
 - psrchive (http://psrchive.sourceforge.net/)
 - RFIClean (https://github.com/ymaan4/RFIClean)
 - gptool (https://github.com/chowdhuryaditya/gptool)
+- ugmrt2fil (https://github.com/abhisrkckl/ugmrt2fil)
 
 Install the python dependencies.
 
     $ pip3 install parse astropy pyyaml --user
 
-### Installing `filterbank-gmrt`
-
-    $ cd filterbank-gmrt
-    $ ./configure
-
-This script will ask for a directory where the executable will be created. Enter an appropriate path.
-Note that the `filterbank` executable must be in `$PATH` for `pinta` to work. 
- 
-    $ make filterbank
-    $ cd ..
-
 ### Permissions
 
 One persistent issue that arises while analyzing data using a pipeline is maintaining correct permissions for the data files. 
@@ -106,7 +96,7 @@ Each row in `pipeline.in` represents a raw data file. The columns are as follows
 2. RawData - The raw data file name (not the full path)
 3. Timestamp - The timestamp file name (not the full path)
 4. Freq - The local oscillator frequency (MHz)
-5. Nbin - The number of phase bins for folding
+5. Nbin - The number of phase bins for folding (Set to -1 to use the default. The default is the largest power of 2 less than psr_period/Tsmpl.)
 6. Nchan - Number of frequency channels
 7. BandWidth - Observation bandwidth (MHz)
 8. TSmpl - Sampling time of observation (s)
diff --git a/filterbank-gmrt/README.md b/filterbank-gmrt/README.md
deleted file mode 100644
index 79199bd..0000000
--- a/filterbank-gmrt/README.md
+++ /dev/null
@@ -1,18 +0,0 @@
-This is a version of the `sigproc` package written by Duncan Lorimer customized for GMRT by B.C. Joshi.
-
-`pinta` only uses the `filterbank` command in this package. 
-
-I will clean up this distribution and remove code unnecessary for `pinta` later.
-
-# Usage
-
-    $ filterbank <raw_data_file> -mjd <starting_time> -rf <frequency> -nch {nchan} -bw {channelwidth} -ts {sampling_time} -df {sideband} > {output_file}
-
-- `raw_data_file` is the path to the input file in GMRT raw data format.
-- `starting_time` is the timestamp at the start of observation in MJD.
-- `frequency` is the frequency label (in MHz) of the highest frequency channel in the observing band.
-- `nchan` is the number of frequency channels.
-- `channelwidth` is the bandwidth of a single channel.
-- `sampling_time` is the sampling time at which the data is recorded.
-- `sideband` is a code for the sideband used. "gmgwbf" represents upper sideband and "gmgwbr" represents lower sideband.
-- `output_file` is the path to the output file in filterbank format.
diff --git a/filterbank-gmrt/accn.csh b/filterbank-gmrt/accn.csh
deleted file mode 100755
index 7218fc7..0000000
--- a/filterbank-gmrt/accn.csh
+++ /dev/null
@@ -1,37 +0,0 @@
-###############################################################################
-#
-# accn - script to do an acceleration search on a dedispersed time series
-#
-# The script requires a .tim file with the dedispersed data and an "aclist" file
-# which is an ASCII list of the trial ACs and ADOTs to use in the search.
-#
-###############################################################################
-set seek       = $bin/seek
-set source = $1
-if ($source == "") then
-	echo "usage: accn filestem (option)"
-	exit
-endif
-if (! -e $source.tim) then
-	echo "Time series file: $source.tim not found..."	
-	exit
-endif
-if (! -e aclist) then
-	echo "File aclist with AC ranges not found..."
-	exit
-endif
-if (! -e adlist) then
-	echo 0.0 > adlist
-endif
-echo "Hunting file $source.fil for periodicities... check back here later"
-echo "AC/AD:" | awk '{printf "%s ", $1}'
-set append = ""
-foreach ac (`cat aclist`)
-	echo $ac | awk '{printf "%s/", $1}'
-	foreach ad (`cat adlist`)
-		echo $ad | awk '{printf "%s ", $1}'
-		$seek $source.tim -q -a$ac -d$ad $append $2
-		set append = "-A"
-	end
-end
-exit
diff --git a/filterbank-gmrt/accspec.f b/filterbank-gmrt/accspec.f
deleted file mode 100644
index 9db92d6..0000000
--- a/filterbank-gmrt/accspec.f
+++ /dev/null
@@ -1,41 +0,0 @@
-c==========================================================================
-      subroutine accspec(npf, nfl, ifile)
-c==========================================================================
-      implicit none
-c
-c     Accumalates the power spectrum from the real and imaginary
-c     parts ffted array series(ntim) (see seek.inc) to nsampacc
-c
-c c Code Added for GMGPS BCJ 03-06-2011  full new sub
-
-      include 'seek.inc'
-      include 'csampacc.inc'
-      integer npf, nfl, ifile
-      integer i,j
-      real arl,ail,a1,a2,ar,ai,anf
-
-      anf=series(2)**2
-      arl=0.0
-      ail=0.0
-      do i=1,2*nfl
-         series(i)=0.0
-      enddo
-
-      npf=ntim/2
-      do j=1,npf-1
-        ar=series(2*j+1)
-        ai=series(2*j+2)
-        a1=ar**2+ai**2
-        a2=((ar-arl)**2+(ai-ail)**2)/2.
-        if( ifile .eq. 1 ) then 
-           sampacc(j)=sqrt(max(a1,a2))
-        else
-           sampacc(j)= sampacc(j) + sqrt(max(a1,a2))
-        endif
-        arl=ar
-        ail=ai
-      enddo
-      sampacc(npf)=0.0
-
-      end
-c==========================================================================
diff --git a/filterbank-gmrt/add_channels.c b/filterbank-gmrt/add_channels.c
deleted file mode 100644
index e226ead..0000000
--- a/filterbank-gmrt/add_channels.c
+++ /dev/null
@@ -1,23 +0,0 @@
-void add_channels(float *data, int nsamples, int nadd) /* includefile */
-{
-  int i,j,k;
-  float sum,n;
-
-  if (nadd <= 1) return;
-
-  j=k=0;
-  sum=0.0;
-  n=(float) nadd;
-
-  for (i=0; i<nsamples; i++) {
-    sum+=data[i];
-    j++;
-    if (j==nadd) {
-      data[k]=sum/n;
-      k++; 
-      j=0;
-      sum=0.0;
-    }
-  }
-
-}
diff --git a/filterbank-gmrt/add_samples.c b/filterbank-gmrt/add_samples.c
deleted file mode 100644
index 4c3706a..0000000
--- a/filterbank-gmrt/add_samples.c
+++ /dev/null
@@ -1,18 +0,0 @@
-void add_samples(float *data, int nifs, int nchans, int nadd) /* includefile */
-{
-  int i,c,t,inc,nxc;
-  float n;
-
-  if (nadd <= 1) return;
-
-  nxc=nifs*nchans;
-  for (t=1; t<nadd; t++) 
-    for (i=0; i<nifs; i++) {
-      inc=i*nchans;
-      for (c=0; c<nchans; c++) data[inc+c]+=data[t*nxc+inc+c];
-    }
-
-  n=(float) nadd;
-  for (i=0; i<nxc; i++) data[i]/=n;
-
-}
diff --git a/filterbank-gmrt/ahunt.csh b/filterbank-gmrt/ahunt.csh
deleted file mode 100755
index 67210c7..0000000
--- a/filterbank-gmrt/ahunt.csh
+++ /dev/null
@@ -1,39 +0,0 @@
-###############################################################################
-#
-# ahunt - script to dedisperse and search data using seek over a given DM range
-#
-# Also does accelerated search at each DM. MJK 2005
-# 
-# The script requires a filterbank file with the raw data and a "dmlist" file
-# which is an ASCII list of the trial DMs to use in the search.
-#
-###############################################################################
-set dedisperse = $bin/dedisperse
-set seek       = $bin/seek
-set accn       = $bin/accn
-set source = $1
-if ($source == "") then
-	echo "usage: ahunt filestem (option)"
-	exit
-endif
-if (! -e $source.fil) then
-	echo "Filterbank file: $source.fil not found..."	
-	exit
-endif
-if (! -e dmlist) then
-	echo "File dmlist with DM ranges not found..."
-	exit
-endif
-###############################################################################
-echo "Hunting file $source.fil for periodicities... check back here later!"
-echo "DM:" | awk '{printf "%s ", $1}'
-set append = ""
-foreach dm (`cat dmlist`)
-	echo $dm | awk '{printf "%s ", $1}'
-	$dedisperse $source.fil -d $dm > $source.tim
-	$accn $source.tim $append > /dev/null
-	set append = "-A"
-end
-echo DONE
-exit
-###############################################################################
diff --git a/filterbank-gmrt/alfa_position.c b/filterbank-gmrt/alfa_position.c
deleted file mode 100644
index 6a71252..0000000
--- a/filterbank-gmrt/alfa_position.c
+++ /dev/null
@@ -1,2999 +0,0 @@
-/* standalone file for computing alfa position offsets */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
-#include <math.h>
-
-/*
- * Cactus File @(#)deg_trig.c	1.1
- *         SID 1.1
- *        Date 02/04/98
- */
-
-static char SccsId[] = "@(#)deg_trig.c	1.1\t02/04/98";
-
-#include <math.h>
-
-#define PI		3.14159265358979323846
-#define DEG_TO_RAD	PI/180.0
-#define RAD_TO_DEG	180.0/PI
-
-double  deg_sin(double);
-double  deg_cos(double);
-double  deg_tan(double);
-double  deg_asin(double);
-double  deg_acos(double);
-double  deg_atan(double);
-double  sin(), cos(), tan();
-
-/* Calculates trigonometric fn's with 'angle' in degrees, not radians.  */
-
-double deg_sin(angle)
-double angle;
-{
-  double sin();
-
-  return( sin(DEG_TO_RAD * angle) );
-}
-
-double deg_cos(angle)
-double angle;
-{
-  double cos();
-
-  return( cos(DEG_TO_RAD * angle) );
-}
-
-double deg_tan(angle)
-double  angle;
-{
-  double tan();
-
-  return( tan(DEG_TO_RAD * angle) );
-}
-
-double deg_asin(value)
-double  value;
-{
-  double asin();
-
-  return( RAD_TO_DEG*asin(value) );
-}
-
-double deg_acos(value)
-double  value;
-{
-  double acos();
-
-  return( RAD_TO_DEG*acos(value) );
-}
-
-double deg_atan(value)
-double  value;
-{
-  double atan();
-
-  return( RAD_TO_DEG*atan(value) );
-}
-
-
-
-/*
-   precession and nutaton routines converted to 'C'
-   These are taken from the not so latest SLALIB sources - may 1992
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include <string.h>
-#include <time.h>
-#include <sys/time.h>
-#include "prec_proto.h"
-
-double fmod(), sin(), cos(), sqrt(), atan2();
-double  deg_sin(double);
-double  deg_cos(double);
-double  deg_tan(double);
-double  deg_asin(double);
-double  deg_acos(double);
-double  deg_atan(double);
-double  sin(), cos(), tan();
-double sla_epco(), sla_epj2d();
-double current_time();
-static double eqeq = 0.0;
-int sla_deuler ( char *, double, double, double, double rmat[3][3]);
-int sla_prec ( double,double, double rmatp[3][3]);
-
-#define max(a,b) (((a)>(b))?(a):(b))
-   
-/* rambo usage: precess( epoch_ra, epoch_dec, &curr_ra, &curr_dec, when) */
-
-double precess( epoch_ra, epoch_dec, ret_ra, ret_dec, curtime, src )
-double epoch_ra, epoch_dec, *ret_ra, *ret_dec, curtime;
-int src;
-{
-  double curr_ra, curr_dec, current_time();
-  double d2r = PI/180.0;
-  double h2r = 2.0*PI/24.0;
-
-  curr_ra = epoch_ra*h2r; 
-  curr_dec = epoch_dec*d2r;
-
-  if( src == 'J' ) {
-    sla_preces("FK5",sla_epco("J","J",2000.0),2000.0,
-                &curr_ra, &curr_dec);
-  } else {
-/*              Proper motions not supplied */
-
-/*              Precess to B1950 */
-                sla_preces("FK4",sla_epco("B","B",1950.0),1950.0,
-                  &curr_ra, &curr_dec);
-
-/*              Add E-terms to make FK4 position */
-                sla_addet(curr_ra,curr_dec,1950.0,&curr_ra,&curr_dec); 
-
-/*              Convert to J2000 FK5 without proper motion */
-                sla_fk45z(curr_ra,curr_dec,
-                    sla_epco("J","B",1950.0),&curr_ra,&curr_dec);
-  }
-
-/*           Apparent */
-
-/*           Convert to geocentric apparent  */
-  sla_map(curr_ra,curr_dec,0.0,0.0,0.0,0.0,2000.0,
-    sla_epj2d(sla_epco("J","J",curtime)), &curr_ra, &curr_dec );
-
-  curr_ra = curr_ra/h2r;
-  curr_dec = curr_dec/d2r;
-
-  *ret_ra = curr_ra;
-  *ret_dec = curr_dec;
-
-  return(eqeq);
-}
-
-/*
-*     - - - - - - -
-*      P R E C E S
-*     - - - - - - -
-*
-*  Precession - either FK4 (Bessel-Newcomb, pre IAU 1976) or
-*  FK5 (Fricke, post IAU 1976) as required.
-*
-*  Given:
-*     SYSTEM     char   precession to be applied: 'FK4' or 'FK5'
-*     EP0,EP1    dp     starting and ending epoch
-*     RA,DC      dp     RA,Dec, mean equator & equinox of epoch EP0
-*
-*  Returned:
-*     RA,DC      dp     RA,Dec, mean equator & equinox of epoch EP1
-*
-*  Called:    sla_DRANRM, sla_PREBN, sla_PREC, sla_DCS2C,
-*             sla_DMXV, sla_DCC2S
-*
-*  Notes:
-*
-*     1)  Lowercase characters in SYSTEM are acceptable.
-*
-*     2)  The epochs are Besselian if SYSTEM='FK4' and Julian if 'FK5'.
-*         For example, to precess coordinates in the old system from
-*         equinox 1900.0 to 1950.0 the call would be:
-*             CALL sla_PRECES ('FK4', 1900D0, 1950D0, RA, DC)
-*
-*     3)  This routine will NOT correctly convert between the old and
-*         the new systems - for example conversion from B1950 to J2000.
-*         For these purposes see sla_FK425, sla_FK524, sla_FK45Z and
-*         sla_FK54Z.
-*
-*     4)  If an invalid SYSTEM is supplied, values of -99D0,-99D0 will
-*         be returned for both RA and DC.
-*
-*  P.T.Wallace   Starlink   20 April 1990
-*/
-sla_preces (system, ep0, ep1, ra, dc)
-char *system;
-double ep0,ep1,*ra,*dc;
-{
-
-  double pm[3][3],v1[3],v2[3];
-  double sla_dranrm();
-
-/*  Convert to uppercase and validate SYSTEM */
-    if( strcasecmp(system, "FK4")!=0 && strcasecmp(system, "FK5")!=0 )
-      return;
-
-/*     Generate appropriate precession matrix */
-    if(strcasecmp(system, "FK4") == 0)
-      sla_prebn(ep0,ep1,pm);
-    else
-      sla_prec(ep0,ep1,pm);
-
-/*     Convert RA,Dec to x,y,z */
-    sla_dcs2c(*ra,*dc,v1);
-
-/*     Precess */
-    sla_dmxv(pm,v1,v2);
-
-/*     Back to RA,Dec */
-    sla_dcc2s(v2,ra,dc);
-    *ra=sla_dranrm(*ra);
-}
-
-/*
-*     - - - -
-*      N U T
-*     - - - -
-*
-*  Form the matrix of nutation for a given date - IAU 1980 theory
-*  (double precision)
-*
-*  References:
-*     Final report of the IAU Working Group on Nutation,
-*      chairman P.K.Seidelmann, 1980.
-*     Kaplan,G.H., 1981, USNO circular no. 163, pA3-6.
-*
-*  Given:
-*     DATE   dp         TDB (loosely ET) as Modified Julian Date
-*                                           (=JD-2400000.5)
-*  Returned:
-*     RMATN  dp(3,3)    nutation matrix
-*
-*  The matrix is in the sense   V(true)  =  RMATN * V(mean) .
-*
-*  Called:   sla_NUTC, sla_DEULER
-*
-*  P.T.Wallace   Starlink   10 May 1990
-*/
-
-sla_nut (date, rmatn)
-double date,rmatn[3][3];
-{
-  double dpsi,deps,eps0;
-
-/*  Nutation components and mean obliquity */
-  sla_nutc(date,&dpsi,&deps,&eps0);
-
-/*  Rotation matrix */
-  sla_deuler("xzx",eps0,-dpsi,-(eps0+deps),rmatn);
-}
-
-/*
-*     - - - - -
-*      N U T C
-*     - - - - -
-*
-*  Nutation:  longitude & obliquity components and mean
-*  obliquity - IAU 1980 theory (double precision)
-*
-*  Given:
-*
-*     DATE        dp    TDB (loosely ET) as Modified Julian Date
-*                                            (JD-2400000.5)
-*  Returned:
-*
-*     DPSI,DEPS   dp    nutation in longitude,obliquity
-*     EPS0        dp    mean obliquity
-*
-*  References:
-*     Final report of the IAU Working Group on Nutation,
-*      chairman P.K.Seidelmann, 1980.
-*     Kaplan,G.H., 1981, USNO circular no. 163, pA3-6.
-*
-*  P.T.Wallace   Starlink   September 1987
-*/
-sla_nutc (date, dpsi, deps, eps0)
-double date,*dpsi,*deps,*eps0;
-{
-double t,el,el2,el3;
-double elp,elp2;
-double f,f2,f4;
-double d,d2,d4;
-double om,om2;
-double dp,de;
-double a;
-
-/*  Turns to arc seconds */
-static double t2as=1296000.0;
-/*  Arc seconds to radians */
-static double as2r=0.4848136811095359949e-05;
-/*  Units of 0.0001 arcsec to radians */
-static double u2r=0.4848136811095359949e-05/1.0e4;
-
-/*  Interval between basic epoch J2000.0 and current epoch (JC) */
-      t=(date-51544.5)/36525.0;
-
-/*
-*  FUNDAMENTAL ARGUMENTS in the FK5 reference system
-*/
-
-/*  Mean longitude of the moon minus mean longitude of the moon's perigee */
-      el=as2r*(485866.733+(1325*t2as+715922.633
-              +(31.310+0.064*t)*t)*t);
-
-/*  Mean longitude of the sun minus mean longitude of the sun's perigee */
-      elp=as2r*(1287099.804+(99.0*t2as+1292581.224 +(-0.577-0.012*t)*t)*t);
-
-/*  Mean longitude of the moon minus mean longitude of the moon's node */
-      f=as2r*(335778.877+(1342*t2as+295263.137 +(-13.257+0.011*t)*t)*t);
-
-/*  Mean elongation of the moon from the sun */
-      d=as2r*(1072261.307+(1236*t2as+1105601.328 +(-6.891+0.019*t)*t)*t);
-
-/*  Longitude of the mean ascending node of the lunar orbit on the */
-/*   ecliptic, measured from the mean equinox of date */
-      om=as2r*(450160.280+(-5.0*t2as-482890.539 +(7.455+0.008*t)*t)*t);
-
-/*  Multiples of arguments */
-      el2=el+el;
-      el3=el2+el;
-      elp2=elp+elp;
-      f2=f+f;
-      f4=f2+f2;
-      d2=d+d;
-      d4=d2+d2;
-      om2=om+om;
-
-
-/*
-*  SERIES FOR THE NUTATION
-*/
-      dp=0.0;
-      de=0.0;
-
-/*  106 */
-      dp=dp+sin(elp+d);
-/*  105*/
-      dp=dp-sin(f2+d4+om2);
-/*  104*/
-      dp=dp+sin(el2+d2);
-/*  103*/
-      dp=dp-sin(el-f2+d2);
-/*  102*/
-      dp=dp-sin(el+elp-d2+om);
-/*  101*/
-      dp=dp-sin(-elp+f2+om);
-/*  100*/
-      dp=dp-sin(el-f2-d2);
-/*  99*/
-      dp=dp-sin(elp+d2);
-/*  98*/
-      dp=dp-sin(f2-d+om2);
-/*  97*/
-      dp=dp-sin(-f2+om);
-/*  96*/
-      dp=dp+sin(-el-elp+d2+om);
-/*  95*/
-      dp=dp+sin(elp+f2+om);
-/*  94*/
-      dp=dp-sin(el+f2-d2);
-/*  93*/
-      dp=dp+sin(el3+f2-d2+om2);
-/*  92*/
-      dp=dp+sin(f4-d2+om2);
-/*  91*/
-      dp=dp-sin(el+d2+om);
-/*  90*/
-      dp=dp-sin(el2+f2+d2+om2);
-/*  89*/
-      a=el2+f2-d2+om;
-      dp=dp+sin(a);
-      de=de-cos(a);
-/*  88*/
-      dp=dp+sin(el-elp-d2);
-/*  87*/
-      dp=dp+sin(-el+f4+om2);
-/*  86*/
-      a=-el2+f2+d4+om2;
-      dp=dp-sin(a);
-      de=de+cos(a);
-/*  85*/
-      a=el+f2+d2+om;
-      dp=dp-sin(a);
-      de=de+cos(a);
-/*  84*/
-      a=el+elp+f2-d2+om2;
-      dp=dp+sin(a);
-      de=de-cos(a);
-/*  83*/
-      dp=dp-sin(el2-d4);
-/*  82*/
-      a=-el+f2+d4+om2;
-      dp=dp-2.0*sin(a);
-      de=de+cos(a);
-/*  81*/
-      a=-el2+f2+d2+om2;
-      dp=dp+sin(a);
-      de=de-cos(a);
-/*  80*/
-      dp=dp-sin(el-d4);
-/*  79*/
-      a=-el+om2;
-      dp=dp+sin(a);
-      de=de-cos(a);
-/*  78*/
-      a=f2+d+om2;
-      dp=dp+2.0*sin(a);
-      de=de-cos(a);
-/*  77*/
-      dp=dp+2.0*sin(el3);
-/*  76*/
-      a=el+om2;
-      dp=dp-2.0*sin(a);
-      de=de+cos(a);
-/*  75*/
-      a=el2+om;
-      dp=dp+2.0*sin(a);
-      de=de-cos(a);
-/*  74*/
-      a=-el+f2-d2+om;
-      dp=dp-2.0*sin(a);
-      de=de+cos(a);
-/*  73*/
-      a=el+elp+f2+om2;
-      dp=dp+2.0*sin(a);
-      de=de-cos(a);
-/*  72*/
-      a=-elp+f2+d2+om2;
-      dp=dp-3.0*sin(a);
-      de=de+cos(a);
-/*  71*/
-      a=el3+f2+om2;
-      dp=dp-3.0*sin(a);
-      de=de+cos(a);
-/*  70*/
-      a=-el2+om;
-      dp=dp-2.0*sin(a);
-      de=de+cos(a);
-/*  69*/
-      a=-el-elp+f2+d2+om2;
-      dp=dp-3.0*sin(a);
-      de=de+cos(a);
-/*  68*/
-      a=el-elp+f2+om2;
-      dp=dp-3.0*sin(a);
-      de=de+cos(a);
-/*  67*/
-      dp=dp+3.0*sin(el+f2);
-/*  66*/
-      dp=dp-3.0*sin(el+elp);
-/*  65*/
-      dp=dp-4.0*sin(d);
-/*  64*/
-      dp=dp+4.0*sin(el-f2);
-/*  63*/
-      dp=dp-4.0*sin(elp-d2);
-/*  62*/
-      a=el2+f2+om;
-      dp=dp-5.0*sin(a);
-      de=de+3.0*cos(a);
-/*  61*/
-      dp=dp+5.0*sin(el-elp);
-/*  60*/
-      a=-d2+om;
-      dp=dp-5.0*sin(a);
-      de=de+3.0*cos(a);
-/*  59*/
-      a=el+f2-d2+om;
-      dp=dp+6.0*sin(a);
-      de=de-3.0*cos(a);
-/*  58*/
-      a=f2+d2+om;
-      dp=dp-7.0*sin(a);
-      de=de+3.0*cos(a);
-/*  57*/
-      a=d2+om;
-      dp=dp-6.0*sin(a);
-      de=de+3.0*cos(a);
-/*  56*/
-      a=el2+f2-d2+om2;
-      dp=dp+6.0*sin(a);
-      de=de-3.0*cos(a);
-/*  55*/
-      dp=dp+6.0*sin(el+d2);
-/*  54;*/
-      a=el+f2+d2+om2;
-      dp=dp-8.0*sin(a);
-      de=de+3.0*cos(a);
-/*  53*/
-      a=-elp+f2+om2;
-      dp=dp-7.0*sin(a);
-      de=de+3.0*cos(a);
-/*  52*/
-      a=elp+f2+om2;
-      dp=dp+7.0*sin(a);
-      de=de-3.0*cos(a);
-/*  51*/
-      dp=dp-7.0*sin(el+elp-d2);
-/*  50*/
-      a=-el+f2+d2+om;
-      dp=dp-10.0*sin(a);
-      de=de+5.0*cos(a);
-/*  49*/
-      a=el-d2+om;
-      dp=dp-13.0*sin(a);
-      de=de+7.0*cos(a);
-/*  48*/
-      a=-el+d2+om;
-      dp=dp+16.0*sin(a);
-      de=de-8.0*cos(a);
-/*  47*/
-      a=-el+f2+om;
-      dp=dp+21.0*sin(a);
-      de=de-10.0*cos(a);
-/*  46*/
-      dp=dp+26.0*sin(f2);
-      de=de-cos(f2);
-/*  45*/
-      a=el2+f2+om2;
-      dp=dp-31.0*sin(a);
-      de=de+13.0*cos(a);
-/*  44*/
-      a=el+f2-d2+om2;
-      dp=dp+29.0*sin(a);
-      de=de-12.0*cos(a);
-/*  43*/
-      dp=dp+29.0*sin(el2);
-      de=de-cos(el2);
-/*  42*/
-      a=f2+d2+om2;
-      dp=dp-38.0*sin(a);
-      de=de+16.0*cos(a);
-/*  41*/
-      a=el+f2+om;
-      dp=dp-51.0*sin(a);
-      de=de+27.0*cos(a);
-/*  40*/
-      a=-el+f2+d2+om2;
-      dp=dp-59.0*sin(a);
-      de=de+26.0*cos(a);
-/*  39*/
-      a=-el+om;
-      dp=dp+(-58.0-0.1*t)*sin(a);
-      de=de+32.0*cos(a);
-/*  38*/
-      a=el+om;
-      dp=dp+(63.0+0.1*t)*sin(a);
-      de=de-33.0*cos(a);
-/*  37*/
-      dp=dp+63.0*sin(d2);
-      de=de-2.0*cos(d2);
-/*  36*/
-      a=-el+f2+om2;
-      dp=dp+123.0*sin(a);
-      de=de-53.0*cos(a);
-/*  35*/
-      a=el-d2;
-      dp=dp-158.0*sin(a);
-      de=de-cos(a);
-/*  34*/
-      a=el+f2+om2;
-      dp=dp-301.0*sin(a);
-      de=de+(129.0-0.1*t)*cos(a);
-/*  33*/
-      a=f2+om;
-      dp=dp+(-386.0-0.4*t)*sin(a);
-      de=de+200.0*cos(a);
-/*  32*/
-      dp=dp+(712.0+0.1*t)*sin(el);
-      de=de-7.0*cos(el);
-/*  31*/
-      a=f2+om2;
-      dp=dp+(-2274.0-0.2*t)*sin(a);
-      de=de+(977.0-0.5*t)*cos(a);
-/*  30*/
-      dp=dp-sin(elp+f2-d2);
-/*  29*/
-      dp=dp+sin(-el+d+om);
-/*  28*/
-      dp=dp+sin(elp+om2);
-/*  27*/
-      dp=dp-sin(elp-f2+d2);
-/*  26*/
-      dp=dp+sin(-f2+d2+om);
-/*  25*/
-      dp=dp+sin(el2+elp-d2);
-/*  24*/
-      dp=dp-4.0*sin(el-d);
-/*  23*/
-      a=elp+f2-d2+om;
-      dp=dp+4.0*sin(a);
-      de=de-2.0*cos(a);
-/*  22*/
-      a=el2-d2+om;
-      dp=dp+4.0*sin(a);
-      de=de-2.0*cos(a);
-/*  21*/
-      a=-elp+f2-d2+om;
-      dp=dp-5.0*sin(a);
-      de=de+3.0*cos(a);
-/*  20*/
-      a=-el2+d2+om;
-      dp=dp-6.0*sin(a);
-      de=de+3.0*cos(a);
-/*  19*/
-      a=-elp+om;
-      dp=dp-12.0*sin(a);
-      de=de+6.0*cos(a);
-/*  18*/
-      a=elp2+f2-d2+om2;
-      dp=dp+(-16.0+0.1*t)*sin(a);
-      de=de+7.0*cos(a);
-/*  17*/
-      a=elp+om;
-      dp=dp-15.0*sin(a);
-      de=de+9.0*cos(a);
-/*  16*/
-      dp=dp+(17.0-0.1*t)*sin(elp2);
-/*  15*/
-      dp=dp-22.0*sin(f2-d2);
-/*  14*/
-      a=el2-d2;
-      dp=dp+48.0*sin(a);
-      de=de+cos(a);
-/*  13*/
-      a=f2-d2+om;
-      dp=dp+(129.0+0.1*t)*sin(a);
-      de=de-70.0*cos(a);
-/*  12*/
-      a=-elp+f2-d2+om2;
-      dp=dp+(217.0-0.5*t)*sin(a);
-      de=de+(-95.0+0.3*t)*cos(a);
-/*  11*/
-      a=elp+f2-d2+om2;
-      dp=dp+(-517.0+1.2*t)*sin(a);
-      de=de+(224.0-0.6*t)*cos(a);
-/*  10*/
-      dp=dp+(1426.0-3.4*t)*sin(elp);
-      de=de+(54.0-0.1*t)*cos(elp);
-/*  9*/
-      a=f2-d2+om2;
-      dp=dp+(-13187.0-1.6*t)*sin(a);
-      de=de+(5736.0-3.1*t)*cos(a);
-/*  8*/
-      dp=dp+sin(el2-f2+om);
-/*  7*/
-      a=-elp2+f2-d2+om;
-      dp=dp-2.0*sin(a);
-      de=de+1.0*cos(a);
-/*  6*/
-      dp=dp-3.0*sin(el-elp-d);
-/*  5*/
-      a=-el2+f2+om2;
-      dp=dp-3.0*sin(a);
-      de=de+1.0*cos(a);
-/*  4*/
-      dp=dp+11.0*sin(el2-f2);
-/*  3*/
-      a=-el2+f2+om;
-      dp=dp+46.0*sin(a);
-      de=de-24.0*cos(a);
-/*  2*/
-      dp=dp+(2062.0+0.2*t)*sin(om2);
-      de=de+(-895.0+0.5*t)*cos(om2);
-/*  1*/
-      dp=dp+(-171996.0-174.2*t)*sin(om);
-      de=de+(92025.0+8.9*t)*cos(om);
-
-/*  Convert results to radians*/
-      *dpsi=dp*u2r;
-      *deps=de*u2r;
-
-/*  Mean obliquity*/
-      *eps0=as2r*(84381.448+ (-46.8150+ (-0.00059+ 0.001813*t)*t)*t);
-      eqeq = *dpsi * cos(*eps0 + *deps) * 13750.987; 
-}
-
-/*
-*     - - - - -
-*      P R E C
-*     - - - - -
-*
-*  Form the matrix of precession between two epochs (IAU 1976, FK5)
-*  (double precision)
-*
-*  Given:
-*     EP0    dp         beginning epoch
-*     EP1    dp         ending epoch
-*
-*  Returned:
-*     RMATP  dp(3,3)    precession matrix
-*
-*  Notes:
-*
-*     1)  The epochs are TDB (loosely ET) Julian epochs.
-*
-*     2)  The matrix is in the sense   V(EP1)  =  RMATP * V(EP0)
-*
-*  References:
-*     Lieske,J.H., 1979. Astron.Astrophys.,73,282.
-*      equations (6) & (7), p283.
-*     Kaplan,G.H., 1981. USNO circular no. 163, pA2.
-*
-*  Called:  sla_DEULER
-*
-*  P.T.Wallace   Starlink   12 April 1990
-*/
-sla_prec (ep0, ep1, rmatp)
-double ep0,ep1,rmatp[3][3];
-{
-
-/*  Arc seconds to radians*/
-static double as2r=0.4848136811095359949e-05;
-
-double t0,t,tas2r,w,zeta,z,theta;
-
-
-
-/*  Interval between basic epoch J2000.0 and beginning epoch (JC)*/
-      t0 = (ep0-2000.0)/100.0;
-
-/*  Interval over which precession required (JC)*/
-      t = (ep1-ep0)/100.0;
-
-/*  Euler angles*/
-      tas2r = t*as2r;
-      w = 2306.2181+(1.39656-0.000139*t0)*t0;
-
-      z = (w+((1.09468+0.000066*t0)+0.018203*t)*t)*tas2r;
-
-      zeta = (w+((0.30188-0.000344*t0)+0.017998*t)*t)*tas2r;
-
-      theta = (2004.3109+(-0.85330-0.000217*t0)*t0);
-      theta = (theta +((-0.42665-0.000217*t0)-0.041833*t)*t);
-      theta = theta*tas2r;
-
-/*
-      theta = ((2004.3109+(-0.85330-0.000217*t0)*t0)
-             +((-0.42665-0.000217*t0)-0.041833*t)*t)*tas2r;
-
-      printf("theta %f\n", theta );
-*/
-
-/*  Rotation matrix*/
-      sla_deuler("zyz",-zeta,theta,-z,rmatp);
-}
-
-/*
-*     - - - - - - -
-*      P R E N U T
-*     - - - - - - -
-*
-*  Form the matrix of precession and nutation (IAU1976/FK5)
-*  (double precision)
-*
-*  Given:
-*     EPOCH   dp         Julian Epoch for mean coordinates
-*     DATE    dp         Modified Julian Date (JD-2400000.5)
-*                        for true coordinates
-*
-*  Returned:
-*     RMATPN  dp(3,3)    combined precession/nutation matrix
-*
-*  Called:  sla_PREC, sla_EPJ, sla_NUT, sla_DMXM
-*
-*  Notes:
-*
-*  1)  The epoch and date are TDB (loosely ET).
-*
-*  2)  The matrix is in the sense   V(true)  =  RMATPN * V(mean)
-*
-*  P.T.Wallace   Starlink   April 1987
-*/
-sla_prenut (epoch, date, rmatpn)
-double epoch,date,rmatpn[3][3];
-{
-
-double rmatp[3][3],rmatn[3][3],sla_epj();
-
-
-
-/*  Precession*/
-      sla_prec(epoch,sla_epj(date),rmatp);
-
-/*  Nutation*/
-      sla_nut(date,rmatn);
-
-/*  Combine the matrices:  PN = N x P*/
-      sla_dmxm(rmatn,rmatp,rmatpn);
-}
-
-/*
-*     - - - - - - 
-*      P R E B N
-*     - - - - - -
-*
-*  Generate the matrix of precession between two epochs,
-*  using the old, pre IAU 1976, Bessel-Newcomb model, in
-*  Andoyer's formulation (double precision)
-*
-*  Given:
-*     BEP0    dp         beginning Besselian epoch
-*     BEP1    dp         ending Besselian epoch
-*
-*  Returned:
-*     RMATP  dp(3,3)    precession matrix
-*
-*  The matrix is in the sense   V(BEP1)  =  RMATP * V(BEP0) .
-*
-*  Reference:
-*     Smith et al 1989, Astron. J., 97, 1 p269.
-*
-*  Called:  sla_DEULER
-*
-*  P.T.Wallace   Starlink   12 April 1990
-*/
-sla_prebn (bep0, bep1, rmatp)
-double bep0,bep1,rmatp[3][3];
-{
-
-/*  Arc seconds to radians*/
-static double as2r=0.4848136811095359949e-05;
-
-double bigt,t,tas2r,w,zeta,z,theta;
-
-
-
-/*  Interval between basic epoch B1850.0 and beginning epoch in TC*/
-      bigt = (bep0-1850.0)/100.0;
-
-/*  Interval over which precession required, in tropical centuries*/
-      t = (bep1-bep0)/100.0;
-
-/*  Euler angles*/
-      tas2r = t*as2r;
-      w = 2303.5545+(1.39720+0.000060*bigt)*bigt;
-
-      zeta = (w+(0.30240-0.000270*bigt+0.017995*t)*t)*tas2r;
-      z = (w+(1.09480+0.000390*bigt+0.018325*t)*t)*tas2r;
-      theta = (2005.112+(-0.8529-0.00037*bigt)*bigt+
-             (-0.4265-0.00037*bigt-0.04180*t)*t)*tas2r;
-
-/*  Rotation matrix*/
-      sla_deuler("zyz",-zeta,theta,-z,rmatp);
-}
-
-
-/*
-*     - - - - - - -
-*      D R A N R M
-*     - - - - - - -
-*
-*  Normalise angle into range 0-2 pi  (double precision)
-*
-*  Given:
-*     ANGLE     dp      the angle in radians
-*
-*  The result is ANGLE expressed in the range 0-2 pi (double
-*  precision).
-*
-*  P.T.Wallace   Starlink   December 1984
-*/
-double sla_dranrm(angle)
-double angle;
-{
-  double ret, fmod();
-  static double d2pi=6.283185307179586476925287;
-
-  ret =fmod(angle,d2pi);
-  if(ret < 0.0 )
-     ret=ret+d2pi;
-  return(ret);
-}
-
-/*
-*     - - - - - -
-*      D C S 2 C
-*     - - - - - -
-*
-*  Spherical coordinates to direction cosines (double precision)
-*
-*  Given:
-*     A,B       dp      spherical coordinates in radians
-*                        (RA,Dec), (Long,Lat) etc
-*
-*  Returned:
-*     V         dp(3)   x,y,z unit vector
-*
-*  The spherical coordinates are longitude (+ve anticlockwise
-*  looking from the +ve latitude pole) and latitude.  The
-*  Cartesian coordinates are right handed, with the x axis
-*  at zero longitude and latitude, and the z axis at the
-*  +ve latitude pole.
-*
-*  P.T.Wallace   Starlink   October 1984
-*/
-sla_dcs2c (a, b, v)
-double a,b,v[3];
-{
-  double cosb;
-
-  cosb=cos(b);
-
-  v[0]=cos(a)*cosb;
-  v[1]=sin(a)*cosb;
-  v[2]=sin(b);
-}
-
-/*
-*     - - - -
-*      E P J
-*     - - - -
-*
-*  Conversion of Modified Julian Date to Julian Epoch (double precision)
-*
-*  Given:
-*     DATE     dp       Modified Julian Date (JD - 2400000.5)
-*
-*  The result is the Julian Epoch.
-*
-*  Reference:
-*     Lieske,J.H., 1979. Astron.Astrophys.,73,282.
-*
-*  P.T.Wallace   Starlink   February 1984
-*/
-double sla_epj(date)
-double date;
-{
-      return( 2000.0 + (date-51544.5)/365.25 );
-}
-
-/*
-*     - - - - - 
-*      D M X M
-*     - - - - -
-* 
-*  Product of two 3x3 matrices:
-*
-*      matrix C  =  matrix A  x  matrix B
-*
-*  (double precision)
-*
-*  Given:
-*      A      dp(3,3)        matrix
-*      B      dp(3,3)        matrix
-*
-*  Returned:
-*      C      dp(3,3)        matrix result
-*
-*  To comply with the ANSI Fortran 77 standard, A, B and C must
-*  be different arrays.  However, the routine is coded so as to
-*  work properly on the VAX and many other systems even if this
-*  rule is violated.
-*
-*  P.T.Wallace   Starlink   5 April 1990
-*/
-sla_dmxm (a, b, c)
-double a[3][3],b[3][3],c[3][3];
-{
-      int i,j,k;
-      double w,wm[3][3];
-
-/*  Multiply into scratch matrix */
-      for(i=0; i< 3; i++ ) {
-        for(j=0; j< 3; j++ ) {
-            w=0.0;
-            for( k=0; k<3; k++ ) 
-               w=w+a[k][i]*b[j][k];
-            wm[j][i]=w;
-         }
-      }
-
-/*  Return the result */
-      for(j=0; j< 3; j++ )
-        for(i=0; i< 3; i++ )
-            c[j][i]=wm[j][i];
-}
-
-/*
-*     - - - - - - -
-*      D E U L E R
-*     - - - - - - -
-*
-*  Form a rotation matrix from the Euler angles - three successive
-*  rotations about specified Cartesian axes (double precision)
-*
-*  Given:
-*    ORDER  c*(*)    specifies about which axes the rotations occur
-*    PHI    dp       1st rotation (radians)
-*    THETA  dp       2nd rotation (   "   )
-*    PSI    dp       3rd rotation (   "   )
-*
-*  Returned:
-*    RMAT   dp(3,3)  rotation matrix
-*
-*  A rotation is positive when the reference frame rotates
-*  anticlockwise as seen looking towards the origin from the
-*  positive region of the specified axis.
-*
-*  The characters of ORDER define which axes the three successive
-*  rotations are about.  A typical value is 'ZXZ', indicating that
-*  RMAT is to become the direction cosine matrix corresponding to
-*  rotations of the reference frame through PHI radians about the
-*  old Z-axis, followed by THETA radians about the resulting X-axis,
-*  then PSI radians about the resulting Z-axis.
-*
-*  The axis names can be any of the following, in any order or
-*  combination:  X, Y, Z, uppercase or lowercase, 1, 2, 3.  Normal
-*  axis labelling/numbering conventions apply;  the xyz (=123)
-*  triad is right-handed.  Thus, the 'ZXZ' example given above
-*  could be written 'zxz' or '313' (or even 'ZxZ' or '3xZ').  ORDER
-*  is terminated by length or by the first unrecognised character.
-*
-*  Fewer than three rotations are acceptable, in which case the later
-*  angle arguments are ignored.  Zero rotations produces a unit RMAT.
-*
-*  P.T.Wallace   Starlink   November 1988
-*/
-sla_deuler (order, phi, theta, psi, rmat)
-char *order;
-double phi,theta,psi,rmat[3][3];
-{
-
-      int j,i,l,n,k;
-      double result[3][3],rotn[3][3],angle,s,c,w,wm[3][3];
-      char axis;
-
-/*  Initialise result matrix */
-      for(j=0; j<3; j++ ) {
-        for(i=0; i<3; i++ ) {
-            if(i != j)
-               result[j][i] = 0.0;
-            else
-               result[j][i] = 1.0;
-         }
-      }
-
-/*  Establish length of axis string */
-      l = strlen(order) -1;
-
-/*  Look at each character of axis string until finished */
-      for(n=0; n<3; n++ ) {
-         if(n<=l) {
-
-/*        Initialise rotation matrix for the current rotation */
-            for(j=0; j<3; j++ ) {
-               for(i=0; i<3; i++ ) {
-                  if (i!=j)
-                     rotn[j][i] = 0.0;
-                  else
-                     rotn[j][i] = 1.0;
-               }
-            }
-
-/*        Pick up the appropriate Euler angle and take sine & cosine */
-            if (n==0)
-               angle = phi;
-            else if (n==1)
-               angle = theta;
-            else
-               angle = psi;
-            s = sin(angle);
-            c = cos(angle);
-
-/*        Identify the axis */
-            axis = order[n];
-            if(axis=='X'|| axis == 'x' || axis=='1') {
-
-/*           Matrix for x-rotation */
-               rotn[1][1] = c;
-               rotn[2][1] = s;
-               rotn[1][2] = -s;
-               rotn[2][2] = c;
-
-            } else if (axis=='Y'|| axis=='y'|| axis=='2') {
-
-/*           Matrix for y-rotation */
-               rotn[0][0] = c;
-               rotn[2][0] = -s;
-               rotn[0][2] = s;
-               rotn[2][2] = c;
-
-            } else if(axis=='Z'|| axis=='z'||axis=='3') {
-
-/*           Matrix for z-rotation */
-               rotn[0][0] = c;
-               rotn[1][0] = s;
-               rotn[0][1] = -s;
-               rotn[1][1] = c;
-            } else {
-
-/*           Unrecognised character - fake end of string */
-               l = 0;
-
-            }
-
-/*        Apply the current rotation (matrix ROTN x matrix RESULT) */
-            for(i=0; i<3; i++ ) {
-              for(j=0; j<3; j++ ) {
-                  w = 0.0;
-                  for(k=0; k<3; k++ )
-                     w = w+rotn[k][i]*result[j][k];
-                  wm[j][i] = w;
-               } 
-            }
-            for(j=0; j<3; j++ )
-              for(i=0; i<3; i++ )
-                  result[j][i] = wm[j][i];
-         }
-      }
-
-/*  Copy the result */
-      for(j=0; j<3; j++ )
-        for(i=0; i<3; i++ )
-            rmat[j][i] = result[j][i];
-}
-
-/*
-*     - - - - - -
-*      D C C 2 S
-*     - - - - - -
-*
-*  Direction cosines to spherical coordinates (double precision)
-*
-*  Given:
-*     V     d(3)   x,y,z vector
-*
-*  Returned:
-*     A,B   d      spherical coordinates in radians
-*
-*  The spherical coordinates are longitude (+ve anticlockwise
-*  looking from the +ve latitude pole) and latitude.  The
-*  Cartesian coordinates are right handed, with the x axis
-*  at zero longitude and latitude, and the z axis at the
-*  +ve latitude pole.
-*
-*  If V is null, zero A and B are returned.
-*  At either pole, zero A is returned.
-*
-*  P.T.Wallace   Starlink   July 1989
-*/
-sla_dcc2s (v, a, b)
-double v[3], *a,*b;
-{
-  double x,y,z,r;
-
-      x = v[0];
-      y = v[1];
-      z = v[2];
-      r = sqrt(x*x+y*y);
-
-      if (r == 0.0)
-        *a = 0.0;
-      else
-        *a = atan2(y,x);
-
-      if(z == 0.0)
-         *b = 0.0;
-      else
-         *b = atan2(z,r);
-}
-
-/*
-*     - - - - - 
-*      D M X V
-*     - - - - -
-*
-*  Performs the 3-D forward unitary transformation:
-*
-*     vector VB = matrix DM * vector VA
-*
-*  (double precision)
-*
-*  Given:
-*     DM       dp(3,3)    matrix
-*     VA       dp(3)      vector
-*
-*  Returned:
-*     VB       dp(3)      result vector
-*
-*  P.T.Wallace   Starlink   March 1986
-*/
-sla_dmxv (dm, va, vb)
-double dm[3][3],va[3],vb[3];
-{
-      int i,j;
-      double w,vw[3];
-
-
-/*  Matrix DM * vector VA -> vector VW */
-      for(j=0; j<3; j++ ) {
-         w=0.0;
-         for(i=0; i<3; i++ ) 
-            w=w+dm[i][j]*va[i];
-         vw[j]=w;
-      }
-
-/*  Vector VW -> vector VB */
-      for(j=0; j<3; j++ )
-         vb[j]=vw[j];
-}
-
-
-/*+
-*     - - - - - -
-*      A D D E T
-*     - - - - - -
-*
-*  Add the E-terms (elliptic component of annual aberration)
-*  to a pre IAU 1976 mean place to conform to the old
-*  catalogue convention (double precision)
-*
-*  Given:
-*     RM,DM     dp     RA,Dec (radians) without E-terms
-*     EQ        dp     Besselian epoch of mean equator and equinox
-*
-*  Returned:
-*     RC,DC     dp     RA,Dec (radians) with E-terms included
-*
-*  Called:
-*     sla_ETRMS, sla_DCS2C, sla_DCC2S, sla_DRANRM, sla_DRANGE
-*
-*  Explanation:
-*     Most star positions from pre-1984 optical catalogues (or
-*     derived from astrometry using such stars) embody the
-*     E-terms.  If it is necessary to convert a formal mean
-*     place (for example a pulsar timing position) to one
-*     consistent with such a star catalogue, then the RA,Dec
-*     should be adjusted using this routine.
-*
-*  Reference:
-*     Explanatory Supplement to the Astronomical Ephemeris,
-*     section 2D, page 48.
-*
-*  P.T.Wallace   Starlink   July 1986
-*/
-sla_addet (rm, dm, eq, rc, dc)
-double rm,dm,eq, *rc, *dc;
-{
-      double a[3],v[3];
-      int i;
-
-/*  E-terms vector */
-      sla_etrms(eq,a);
-
-/*  Spherical to Cartesian */
-      sla_dcs2c(rm,dm,v);
-
-/*  Include the E-terms */
-      for(i=0; i<3; i++ )
-         v[i]=v[i]+a[i];
-
-/*  Cartesian to spherical */
-      sla_dcc2s(v,rc,dc);
-
-/*  Bring RA into conventional range */
-      *rc=sla_dranrm(*rc);
-}
-
-/*
-*     - - - - - -
-*      E T R M S
-*     - - - - - -
-*
-*  Compute the E-terms (elliptic component of annual aberration)
-*  vector (double precision)
-*
-*  Given:
-*     EP      dp      Besselian epoch
-*
-*  Returned:
-*     EV      dp(3)   E-terms as (dx,dy,dz)
-*
-*  Note the use of the J2000 aberration constant (20.49552 arcsec).
-*  This is a reflection of the fact that the E-terms embodied in
-*  existing star catalogues were computed from a variety of
-*  aberration constants.  Rather than adopting one of the old
-*  constants the latest value is used here.
-*
-*  References:
-*     1  Smith, C.A. et al., 1989.  Astr.J. 97, 265.
-*     2  Yallop, B.D. et al., 1989.  Astr.J. 97, 274.
-*
-*  P.T.Wallace   Starlink   10 April 1990
-*/
-sla_etrms (ep, ev)
-double ep,ev[3];
-{
-
-/*  Arcseconds to radians */
-static double as2r=0.4848136811095359949e-5;
-
-double t,e,e0,p,ek,cp;
-
-/*  Julian centuries since B1950 */
-      t=(ep-1950.0)*1.00002135903e-2;
-
-/*  Eccentricity */
-      e=0.01673011-(0.00004193+0.000000126*t)*t;
-
-/*  Mean obliquity */
-      e0=(84404.836-(46.8495+(0.00319+0.00181*t)*t)*t)*as2r;
-
-/*  Mean longitude of perihelion */
-      p=(1015489.951+(6190.67+(1.65+0.012*t)*t)*t)*as2r;
-
-/*  E-terms */
-      ek=e*20.49552*as2r;
-      cp=cos(p);
-      ev[0]= ek*sin(p);
-      ev[1]=-ek*cp*cos(e0);
-      ev[2]=-ek*cp*sin(e0);
-}
-/*
-*     - - - - - -
-*      F K 4 5 Z
-*     - - - - - -
-*
-*  Convert B1950.0 FK4 star data to J2000.0 FK5 assuming zero
-*  proper motion in an inertial frame (double precision)
-*
-*  This routine converts stars from the old, Bessel-Newcomb, FK4
-*  system to the new, IAU 1976, FK5, Fricke system, in such a
-*  way that the FK5 proper motion is zero.  Because such a star
-*  has, in general, a non-zero proper motion in the FK4 system,
-*  the routine requires the epoch at which the position in the
-*  FK4 system was determined.
-*
-*  The method is from Appendix 2 of ref 1, but using the constants
-*  of ref 2.
-*
-*  Given:
-*     R1950,D1950     dp    B1950.0 FK4 RA,Dec at epoch (rad)
-*     BEPOCH          dp    Besselian epoch (e.g. 1979.3D0)
-*
-*  Returned:
-*     R2000,D2000     dp    J2000.0 FK5 RA,Dec (rad)
-*
-*  Notes:
-*
-*  1)  The epoch BEPOCH is strictly speaking Besselian, but
-*      if a Julian epoch is supplied the result will be
-*      affected only to a negligible extent.
-*
-*  2)  Conversion from Besselian epoch 1950.0 to Julian epoch
-*      2000.0 only is provided for.  Conversions involving other
-*      epochs will require use of the appropriate precession,
-*      proper motion, and E-terms routines before and/or
-*      after FK425 is called.
-*
-*  3)  In the FK4 catalogue the proper motions of stars within
-*      10 degrees of the poles do not embody the differential
-*      E-term effect and should, strictly speaking, be handled
-*      in a different manner from stars outside these regions.
-*      However, given the general lack of homogeneity of the star
-*      data available for routine astrometry, the difficulties of
-*      handling positions that may have been determined from
-*      astrometric fields spanning the polar and non-polar regions,
-*      the likelihood that the differential E-terms effect was not
-*      taken into account when allowing for proper motion in past
-*      astrometry, and the undesirability of a discontinuity in
-*      the algorithm, the decision has been made in this routine to
-*      include the effect of differential E-terms on the proper
-*      motions for all stars, whether polar or not.  At epoch 2000,
-*      and measuring on the sky rather than in terms of dRA, the
-*      errors resulting from this simplification are less than
-*      1 milliarcsecond in position and 1 milliarcsecond per
-*      century in proper motion.
-*
-*  References:
-*
-*     1  Aoki,S., et al, 1983.  Astron.Astrophys., 128, 263.
-*
-*     2  Smith, C.A. et al, 1989.  "The transformation of astrometric
-*        catalog systems to the equinox J2000.0".  Astron.J. 97, 265.
-*
-*     3  Yallop, B.D. etal, 1989.  "Transformation of mean star places
-*        from FK4 B1950.0 to FK5 J2000.0 using matrices in 6-space".
-*        Astron.J. 97, 274.
-*
-*  Called:  sla_DCS2C, sla_EPJ, sla_EPB2D, sla_DCC2S, sla_DRANRM
-*
-*  P.T.Wallace   Starlink   10 April 1990
-*/
-
-sla_fk45z (r1950,d1950,bepoch,r2000,d2000)
-double r1950,d1950,bepoch, *r2000,*d2000;
-{
-      static double d2pi=6.283185307179586476925287;
-      double w;
-      int i,j;
-
-/*  Position and position+velocity vectors */
-      double r0[3],a1[3],v1[3],v2[6];
-
-/*  Radians per year to arcsec per century */
-      static double pmf=100.0*60.0*60.0*360.0/6.283185307179586476925287;
-
-/*  Functions */
-      double sla_epj(),sla_epb2d(),sla_dranrm();
-
-/* */
-/*  CANONICAL CONSTANTS  (see references) */
-/* */
-
-/*  Vectors A and Adt, and matrix M (only half of which is needed here) */
-     static double  a[3] = { -1.62557e-6,  -0.31919e-6, -0.13843e-6 };
-     static double ad[3] = { +1.245e-3,    -1.580e-3,   -0.659e-3   };
-
-     static double em[3][6] = {
-                         { +0.999925678186902,
-                            +0.011182059571766,
-                            +0.004857946721186,
-                            -0.000541652366951,
-                            +0.237917612131583,
-                            -0.436111276039270 
-                         },{
-                            -0.011182059642247,
-                             +0.999937478448132,
-                             -0.000027147426498,
-                             -0.237968129744288,
-                             -0.002660763319071,
-                             +0.012259092261564 
-                         } , {
-                            -0.004857946558960,
-                             -0.000027176441185,
-                             +0.999988199738770,
-                             +0.436227555856097,
-                             -0.008537771074048,
-                             +0.002119110818172 
-                          }
-                        };
-
-/*  Spherical to Cartesian */
-      sla_dcs2c(r1950,d1950,r0);
-
-/*  Adjust vector A to give zero proper motion in FK5 */
-      w=(bepoch-1950.0)/pmf;
-      for(i=0; i<3; i++ )
-         a1[i]=a[i]+w*ad[i];
-
-/*  Remove e-terms */
-      w=r0[0]*a1[0]+r0[1]*a1[1]+r0[2]*a1[2];
-      for(i=0; i<3; i++ )
-         v1[i]=r0[i]-a1[i]+w*r0[i];
-
-/*  Convert position vector to Fricke system */
-      for(i=0; i<6; i++ ) {
-         w=0.0;
-         for(j=0; j<3; j++ )
-            w=w+em[j][i]*v1[j];
-         v2[i]=w;
-      }
-
-/*  Allow for fictitious proper motion in FK4 */
-      w=(sla_epj(sla_epb2d(bepoch))-2000.0)/pmf;
-      for(i=0; i<3; i++ )
-         v2[i]=v2[i]+w*v2[i+3];
-
-/*  Revert to spherical coordinates */
-      sla_dcc2s(v2,&w,d2000);
-      *r2000=sla_dranrm(w);
-}
-
-/*
-*     - - - -
-*      M A P
-*     - - - -
-*
-*  Transform star RA,Dec from mean place to geocentric apparent
-*
-*  The reference frames and timescales used are post IAU 1976.
-*
-*  References:
-*     1984 Astronomical Almanac, pp B39-B41.
-*     (also Lederle & Schwan, Astron. Astrophys. 134,
-*      1-6, 1984)
-*
-*  Given:
-*     RM,DM    dp     mean RA,Dec (rad)
-*     PR,PD    dp     proper motions:  RA,Dec changes per Julian year
-*     PX       dp     parallax (arcsec)
-*     RV       dp     radial velocity (km/sec, +ve if receding)
-*     EQ       dp     epoch and equinox of star data (Julian)
-*     DATE     dp     TDB for apparent place (JD-2400000.5)
-*
-*  Returned:
-*     RA,DA    dp     apparent RA,Dec (rad)
-*
-*  Called:
-*     sla_MAPPA       star-independent parameters
-*     sla_MAPQK       quick mean to apparent
-*
-*  Notes:
-*
-*  1)  EQ is the Julian epoch specifying both the reference
-*      frame and the epoch of the position - usually 2000.
-*      For positions where the epoch and equinox are
-*      different, use the routine sla_PM to apply proper
-*      motion corrections before using this routine.
-*
-*  2)  The distinction between the required TDB and TDT is
-*      always negligible.  Moreover, for all but the most
-*      critical applications UTC is adequate.
-*
-*  3)  The proper motions in RA are dRA/dt rather than
-*      cos(Dec)*dRA/dt.
-*
-*  4)  This routine may be wasteful for some applications
-*      because it recomputes the Earth position/velocity and
-*      the precession/nutation matrix each time, and because
-*      it allows for parallax and proper motion.  Where
-*      multiple transformations are to be carried out for one
-*      epoch, a faster method is to call the sla_MAPPA routine
-*      once and then either the sla_MAPQK routine (which includes
-*      parallax and proper motion) or sla_MAPQKZ (which assumes
-*      zero parallax and proper motion).
-*
-*  P.T.Wallace   Starlink   11 April 1990
-*/
-sla_map (rm, dm, pr, pd, px, rv, eq, date, ra, da)
-double rm,dm,pr,pd,px,rv,eq,date, *ra, *da;
-{
-  double amprms[21];
-
-/*  Star-independent parameters */
-  sla_mappa(eq,date,amprms);
-
-/*  Mean to apparent */
-      sla_mapqk(rm,dm,pr,pd,px,rv,amprms,ra,da);
-}
-
-/*
-*     - - - - - -
-*      M A P P A
-*     - - - - - -
-*
-*  Compute star-independent parameters in preparation for
-*  conversions between mean place and geocentric apparent place.
-*
-*  The parameters produced by this routine are required in the
-*  parallax, light deflection, aberration, and precession/nutation
-*  parts of the mean/apparent transformations.
-*
-*  The reference frames and timescales used are post IAU 1976.
-*
-*  Given:
-*     EQ       d      epoch of mean equinox to be used (Julian)
-*     DATE     d      TDB (JD-2400000.5)
-*
-*  Returned:
-*     AMPRMS   d(21)  star-independent mean-to-apparent parameters:
-*             
-*       (1)      time interval for proper motion (Julian years)
-*       (2-4)    barycentric position of the Earth (AU)
-*       (5-7)    heliocentric direction of the Earth (unit vector)
-*       (8)      (grav rad Sun)*2/(Sun-Earth distance)
-*       (9-11)   ABV: barycentric Earth velocity in units of c
-*       (12)     sqrt(1-v**2) where v=modulus(ABV)
-*       (13-21)  precession/nutation (3,3) matrix
-*
-*  References:
-*     1984 Astronomical Almanac, pp B39-B41.
-*     (also Lederle & Schwan, Astron. Astrophys. 134,
-*      1-6, 1984)
-*
-*  Notes:
-*
-*  1)  For DATE, the distinction between the required TDB and TDT
-*      is always negligible.  Moreover, for all but the most
-*      critical applications UTC is adequate.
-*
-*  2)  The accuracy of the routines using the parameters AMPRMS is
-*      limited by the routine sla_EVP, used here to compute the
-*      Earth position and velocity by the methods of Stumpff.
-*      The maximum error in the resulting aberration corrections is
-*      about 0.3 milliarcsecond.
-*
-*  3)  The vectors AMPRMS(2-4) and AMPRMS(5-7) are referred to
-*      the mean equinox and equator of epoch EQ.
-*
-*  4)  The parameters AMPRMS produced by this routine are used by
-*      sla_MAPQK and sla_MAPQKZ.
-*
-*  5)  This routine replaces earlier routine sla_MAPP, which has
-*      been withdrawn.
-*
-*  Called:
-*     sla_EPJ         MDJ to Julian epoch
-*     sla_EVP         earth position & velocity
-*     sla_DVN         normalise vector
-*     sla_PRENUT      precession/nutation matrix
-*
-*  P.T.Wallace   Starlink   11 April 1990
-*/
-sla_mappa (eq, date, amprms)
-double eq,date,amprms[21];
-{
-
-/*  Light time for 1 AU (sec) */
-      double cr = 499.004782;
-
-/*  Gravitational radius of the sun x 2 (2*mu/c**2, AU) */
-      double gr2 = 2.0*9.87063e-9;
-      int i;
-
-      double ebd[3],ehd[3],eh[3],e,vn[3],vm;
-
-/*  Time interval for proper motion correction */
-      amprms[0] = sla_epj(date)-eq;
-
-/*  Get Earth barycentric and heliocentric position and velocity */
-      sla_evp(date,eq,ebd,&amprms[1],ehd,eh);
-
-/*  Heliocentric direction of earth (normalised) and modulus */
-      sla_dvn(eh,&amprms[4],&e);
-
-/*  Light deflection parameter */
-      amprms[7] = gr2/e;
-
-/*  Aberration parameters */
-      for(i=0; i<3; i++ )
-         amprms[i+8] = ebd[i]*cr;
-
-      sla_dvn(&amprms[8],vn,&vm);
-      amprms[11] = sqrt(1.0-vm*vm);
-
-/*  Precession/nutation matrix */
-      sla_prenut(eq,date,(void *)&amprms[12]);
-}
-
-/*
-*     - - - -
-*      E V P 
-*     - - - -
-*
-*  Barycentric and heliocentric velocity and position of the Earth
-*
-*  All arguments are double precision
-*
-*  Given:
-*
-*     DATE          TDB (loosely ET) as a Modified Julian Date
-*                                         (JD-2400000.5)
-*
-*     DEQX          Julian Epoch (e.g. 2000.0D0) of mean equator and
-*                   equinox of the vectors returned.  If DEQX .LE. 0D0,
-*                   all vectors are referred to the mean equator and
-*                   equinox (FK5) of date DATE.
-*
-*  Returned (all 3D Cartesian vectors):
-*
-*     DVB,DPB       barycentric velocity, position
-*
-*     DVH,DPH       heliocentric velocity, position
-*
-*  (Units are au/s for velocity and au for position)
-*
-*  Called:  sla_EPJ, sla_PREC
-*
-*  Accuracy:
-*
-*     The maximum deviations from the JPL DE96 ephemeris are as
-*     follows:
-*
-*     barycentric velocity                  42  cm/s
-*     barycentric position           0.000 046  au
-*
-*     heliocentric velocity                 42  cm/s
-*     heliocentric position          0.000 011  au
-*
-*  This routine is adapted from the BARVEL and BARCOR
-*  subroutines of P.Stumpff, which are described in
-*  Astron. Astrophys. Suppl. Ser. 41, 1-8 (1980).  Most of the
-*  changes are merely cosmetic and do not affect the results at
-*  all.  However, some adjustments have been made so as to give
-*  results that refer to the new (IAU 1976 'FK5') equinox
-*  and precession, although the differences these changes make
-*  relative to the results from Stumpff's original 'FK4' version
-*  are smaller than the inherent accuracy of the algorithm.  One
-*  minor shortcoming in the original routines that has NOT been
-*  corrected is that better numerical accuracy could be achieved
-*  if the various polynomial evaluations were nested.  Note also
-*  that one of Stumpff's precession constants differs by 0.001 arcsec
-*  from the value given in the Explanatory Supplement to the A.E.
-*
-*  P.T.Wallace   Starlink   27 November 1991
-*/
-
-sla_evp (date, deqx, dvb, dpb, dvh, dph)
-double date,deqx,dvb[3],dpb[3],dvh[3],dph[3];
-{
-      int ideq,i,j,k;
-      double t,tsq,a,pertl,
-           pertld,pertr,pertrd,cosa,sina,esq,param,twoe,twog,
-           phi,f,sinf,cosf,phid,psid,pertp,pertpd,tl,sinlm,coslm,
-           sigma,b,plon,pomg,pecc,flatm,flat;
-
-      double dt,dtsq,dlocal,dml,
-                       deps,dparam,dpsi,d1pdro,drd,drld,dtl,dsinls,
-                       dcosls,dxhd,dyhd,dzhd,dxbd,dybd,dzbd,dcosep,
-                       dsinep,dyahd,dzahd,dyabd,dzabd,dr,
-                       dxh,dyh,dzh,dxb,dyb,dzb,dyah,dzah,dyab,
-                       dzab,depj,deqcor;
-
-      double sn[4], forbel[7],sorbel[17],sinlp[4],coslp[4];
-      /* EQUIVALENCE (SORBEL(1),E),(FORBEL(1),G) */
-
-      double  dprema[3][3],w,vw[3];
-
-      static double  dc2pi=6.2831853071796,cc2pi=6.283185;
-      static double  ds2r=0.7272205216643e-04;
-
-/* */
-/*   Constants DCFEL(I,K) of fast changing elements */
-/*                     I=1                I=2              I=3 */
-     static double dcfel[8][3] = {
-                  { 1.7400353e+00, 6.2833195099091e+02, 5.2796e-06 },
-                  { 6.2565836e+00, 6.2830194572674e+02,-2.6180e-06 },
-                  { 4.7199666e+00, 8.3997091449254e+03,-1.9780e-05 },
-                  { 1.9636505e-01, 8.4334662911720e+03,-5.6044e-05 },
-                  { 4.1547339e+00, 5.2993466764997e+01, 5.8845e-06 },
-                  { 4.6524223e+00, 2.1354275911213e+01, 5.6797e-06 },
-                  { 4.2620486e+00, 7.5025342197656e+00, 5.5317e-06 },
-                  { 1.4740694e+00, 3.8377331909193e+00, 5.6093e-06 }
-               };
-
-/*
-*   Constants DCEPS and CCSEL(I,K) of slowly changing elements
-*                      I=1           I=2           I=3
-*/
-      static double dceps[3] = {  4.093198e-01,-2.271110e-04,-2.860401e-08 };
-      static double ccsel[17][3] = {
-                   { 1.675104E-02,-4.179579E-05,-1.260516E-07 },
-                   { 2.220221E-01, 2.809917E-02, 1.852532E-05 },
-                   { 1.589963E+00, 3.418075E-02, 1.430200E-05 },
-                   { 2.994089E+00, 2.590824E-02, 4.155840E-06 },
-                   { 8.155457E-01, 2.486352E-02, 6.836840E-06 },
-                   { 1.735614E+00, 1.763719E-02, 6.370440E-06 },
-                   { 1.968564E+00, 1.524020E-02,-2.517152E-06 },
-                   { 1.282417E+00, 8.703393E-03, 2.289292E-05 },
-                   { 2.280820E+00, 1.918010E-02, 4.484520E-06 },
-                   { 4.833473E-02, 1.641773E-04,-4.654200E-07 },
-                   { 5.589232E-02,-3.455092E-04,-7.388560E-07 },
-                   { 4.634443E-02,-2.658234E-05, 7.757000E-08 },
-                   { 8.997041E-03, 6.329728E-06,-1.939256E-09 },
-                   { 2.284178E-02,-9.941590E-05, 6.787400E-08 },
-                   { 4.350267E-02,-6.839749E-05,-2.714956E-07 },
-                   { 1.348204E-02, 1.091504E-05, 6.903760E-07 },
-                   { 3.106570E-02,-1.665665E-04,-1.590188E-07 }
-                };
-/* */
-/*   Constants of the arguments of the short-period perturbations */
-/*   by the planets:   DCARGS(I,K) */
-/*                       I=1               I=2 */
-      static double dcargs[15][2] = {
-                   { 5.0974222e+00,-7.8604195454652e+02 },
-                   { 3.9584962e+00,-5.7533848094674e+02 },
-                   { 1.6338070e+00,-1.1506769618935e+03 },
-                   { 2.5487111e+00,-3.9302097727326e+02 },
-                   { 4.9255514e+00,-5.8849265665348e+02 },
-                   { 1.3363463e+00,-5.5076098609303e+02 },
-                   { 1.6072053e+00,-5.2237501616674e+02 },
-                   { 1.3629480e+00,-1.1790629318198e+03 },
-                   { 5.5657014e+00,-1.0977134971135e+03 },
-                   { 5.0708205e+00,-1.5774000881978e+02 },
-                   { 3.9318944e+00, 5.2963464780000e+01 },
-                   { 4.8989497e+00, 3.9809289073258e+01 },
-                   { 1.3097446e+00, 7.7540959633708e+01 },
-                   { 3.5147141e+00, 7.9618578146517e+01 },
-                   { 3.5413158e+00,-5.4868336758022e+02 }
-               };
-
-/* */
-/*   Amplitudes CCAMPS(N,K) of the short-period perturbations */
-/*           N=1          N=2          N=3          N=4          N=5 */
-      static double ccamps[15][5] = {
-       { -2.279594E-5, 1.407414E-5, 8.273188E-6, 1.340565E-5,-2.490817E-7 },
-       { -3.494537E-5, 2.860401E-7, 1.289448E-7, 1.627237E-5,-1.823138E-7 },
-       {  6.593466E-7, 1.322572E-5, 9.258695E-6,-4.674248E-7,-3.646275E-7 },
-       {  1.140767E-5,-2.049792E-5,-4.747930E-6,-2.638763E-6,-1.245408E-7 },
-       {  9.516893E-6,-2.748894E-6,-1.319381E-6,-4.549908E-6,-1.864821E-7 },
-       {  7.310990E-6,-1.924710E-6,-8.772849E-7,-3.334143E-6,-1.745256E-7 },
-       { -2.603449E-6, 7.359472E-6, 3.168357E-6, 1.119056E-6,-1.655307E-7 },
-       { -3.228859E-6, 1.308997E-7, 1.013137E-7, 2.403899E-6,-3.736225E-7 },
-       {  3.442177E-7, 2.671323E-6, 1.832858E-6,-2.394688E-7,-3.478444E-7 },
-       {  8.702406E-6,-8.421214E-6,-1.372341E-6,-1.455234E-6,-4.998479E-8 },
-       { -1.488378E-6,-1.251789E-5, 5.226868E-7,-2.049301E-7, 0.0E0 },
-       { -8.043059E-6,-2.991300E-6, 1.473654E-7,-3.154542E-7, 0.0E0 },
-       {  3.699128E-6,-3.316126E-6, 2.901257E-7, 3.407826E-7, 0.0E0 },
-       {  2.550120E-6,-1.241123E-6, 9.901116E-8, 2.210482E-7, 0.0E0 },
-       { -6.351059E-7, 2.341650E-6, 1.061492E-6, 2.878231E-7, 0.0E0 }
-       };
-
-/* */
-/*   Constants of the secular perturbations in longitude */
-/*   CCSEC3 and CCSEC(N,K) */
-/*                      N=1           N=2           N=3 */
-     static double ccsec3 = -7.757020E-08;
-     static double ccsec[4][3]  = {
-                  { 1.289600E-06, 5.550147E-01, 2.076942E+00 },
-                  { 3.102810E-05, 4.035027E+00, 3.525565E-01 },
-                  { 9.124190E-06, 9.990265E-01, 2.622706E+00 },
-                  { 9.793240E-07, 5.508259E+00, 1.559103E+01 }
-               };
-
-/*   Sidereal rate DCSLD in longitude, rate CCSGD in mean anomaly */
-      static double dcsld = 1.990987e-07;
-      static double ccsgd = 1.990969E-07;
-
-/*   Some constants used in the calculation of the lunar contribution */
-      static double cckm = 3.122140E-05;
-      static double ccmld = 2.661699E-06;
-      static double ccfdi = 2.399485E-07;
-
-/* */
-/*   Constants DCARGM(I,K) of the arguments of the perturbations */
-/*   of the motion of the Moon */
-/*                       I=1               I=2 */
-      static double dcargm[3][2] =  {
-                    { 5.1679830e+00, 8.3286911095275e+03 },
-                    { 5.4913150e+00,-7.2140632838100e+03 },
-                    { 5.9598530e+00, 1.5542754389685e+04 }
-              };
-
-/* */
-/*   Amplitudes CCAMPM(N,K) of the perturbations of the Moon */
-/*            N=1          N=2           N=3           N=4 */
-      static double ccampm[3][4] = {
-         {  1.097594E-01, 2.896773E-07, 5.450474E-02, 1.438491E-07 },
-         { -2.223581E-02, 5.083103E-08, 1.002548E-02,-2.291823E-08 },
-         {  1.148966E-02, 5.658888E-08, 8.249439E-03, 4.063015E-08 }
-      };
-
-/* */
-/*   CCPAMV(K)=A*M*DL/DT (planets), DC1MME=1-MASS(Earth+Moon) */
-      static double ccpamv[4] = { 8.326827E-11,1.843484E-11,1.988712E-12,1.881276E-12};
-      static double dc1mme = 0.99999696;
-
-/*   CCPAM(K)=A*M(planets), CCIM=INCLINATION(Moon) */
-      static double ccpam[4] = {4.960906E-3,2.727436E-3,8.392311E-4,1.556861E-3};
-      static double ccim = 8.978749E-2;
-
-/* */
-/*   EXECUTION */
-/*   --------- */
-
-/*   Control parameter IDEQ, and time arguments */
-      ideq = 0;
-      if (deqx > 0.0) ideq=1;
-      dt = (date-15019.5)/36525.0;
-      t = dt;
-      dtsq = dt*dt;
-      tsq = dtsq;
-
-/*   Values of all elements for the instant DATE */
-      for( k=0; k<8; k++) {
-         dlocal = fmod(dcfel[k][0]+dt*dcfel[k][1]+dtsq*dcfel[k][2], dc2pi);
-         if (k == 0)
-            dml = dlocal;
-         else
-            forbel[k-1] = dlocal;
-      }
-      deps = fmod(dceps[0]+dt*dceps[1]+dtsq*dceps[2], dc2pi);
-      for( k=0; k<17; k++) {
-         sorbel[k] = fmod(ccsel[k][0]+t*ccsel[k][1]+tsq*ccsel[k][2], cc2pi);
-      }
-
-/*   Secular perturbations in longitude */
-      for( k=0; k<4; k++) {
-         a = fmod(ccsec[k][1]+t*ccsec[k][2], cc2pi);
-         sn[k] = sin(a);
-      }
-
-/*   Periodic perturbations of the EMB (Earth-Moon barycentre) */
-      pertl =  ccsec[0][0]          *sn[0] +ccsec[1][0]*sn[1]+
-              (ccsec[2][0]+t*ccsec3)*sn[2] +ccsec[3][0]*sn[3];
-      pertld = 0.0;
-      pertr = 0.0;
-      pertrd = 0.0;
-      for( k=0; k<15; k++) {
-         a = fmod(dcargs[k][0]+dt*dcargs[k][1], dc2pi);
-         cosa = cos(a);
-         sina = sin(a);
-         pertl = pertl + ccamps[k][0]*cosa+ccamps[k][1]*sina;
-         pertr = pertr + ccamps[k][2]*cosa+ccamps[k][3]*sina;
-         if(k<10) {
-            pertld = pertld+
-                     (ccamps[k][1]*cosa-ccamps[k][0]*sina)*ccamps[k][4];
-            pertrd = pertrd+
-                     (ccamps[k][3]*cosa-ccamps[k][2]*sina)*ccamps[k][4];
-         }
-      }
-
-/*   Elliptic part of the motion of the EMB */
-      /* EQUIVALENCE (SORBEL(1),E),(FORBEL(1),G) */
-      esq = sorbel[0]*sorbel[0];
-      dparam = 1.0-esq;
-      param = dparam;
-      twoe = sorbel[0]+sorbel[0];
-      twog = forbel[0]+forbel[0];
-      phi = twoe*((1.0-esq*0.125)*sin(forbel[0])+sorbel[0]*0.625*sin(twog)
-                +esq*0.5416667*sin(forbel[0]+twog) );
-      f = forbel[0]+phi;
-      sinf = sin(f);
-      cosf = cos(f);
-      dpsi = dparam/(1.0+sorbel[0]*cosf);
-      phid = twoe*ccsgd*((1.0+esq*1.5)*cosf+sorbel[0]*(1.25-sinf*sinf*0.5));
-      psid = ccsgd*sorbel[0]*sinf/sqrt(param);
-
-/*   Perturbed heliocentric motion of the EMB */
-      d1pdro = 1.0+pertr;
-      drd = d1pdro*(psid+dpsi*pertrd);
-      drld = d1pdro*dpsi*(dcsld+phid+pertld);
-      dtl = fmod(dml+phi+pertl, dc2pi);
-      dsinls = sin(dtl);
-      dcosls = cos(dtl);
-      dxhd = drd*dcosls-drld*dsinls;
-      dyhd = drd*dsinls+drld*dcosls;
-
-/*   Influence of eccentricity, evection and variation on the */
-/*   geocentric motion of the Moon */
-      pertl = 0.0;
-      pertld = 0.0;
-      pertp = 0.0;
-      pertpd = 0.0;
-      for( k=0; k<3; k++) {
-         a = fmod(dcargm[k][0]+dt*dcargm[k][1], dc2pi);
-         sina = sin(a);
-         cosa = cos(a);
-         pertl = pertl +ccampm[k][0]*sina;
-         pertld = pertld+ccampm[k][1]*cosa;
-         pertp = pertp +ccampm[k][2]*cosa;
-         pertpd = pertpd-ccampm[k][3]*sina;
-      }
-
-/*   Heliocentric motion of the Earth */
-      tl = forbel[1]+pertl;
-      sinlm = sin(tl);
-      coslm = cos(tl);
-      sigma = cckm/(1.0+pertp);
-      a = sigma*(ccmld+pertld);
-      b = sigma*pertpd;
-      dxhd = dxhd+(a*sinlm)+(b*coslm);
-      dyhd = dyhd-(a*coslm)+(b*sinlm);
-      dzhd =     -(sigma*ccfdi*cos(forbel[2]));
-
-/*   Barycentric motion of the Earth */
-      dxbd = dxhd*dc1mme;
-      dybd = dyhd*dc1mme;
-      dzbd = dzhd*dc1mme;
-      for( k=0; k<4; k++) {
-         plon = forbel[k+3];
-         pomg = sorbel[k+1];
-         pecc = sorbel[k+9];
-         tl = fmod(plon+2.0*pecc*sin(plon-pomg), cc2pi);
-         sinlp[k] = sin(tl);
-         coslp[k] = cos(tl);
-         dxbd = dxbd+(ccpamv[k]*(sinlp[k]+pecc*sin(pomg)));
-         dybd = dybd-(ccpamv[k]*(coslp[k]+pecc*cos(pomg)));
-         dzbd = dzbd-(ccpamv[k]*sorbel[k+13]*cos(plon-sorbel[k+5]));
-      }
-
-/*   Transition to mean equator of date */
-      dcosep = cos(deps);
-      dsinep = sin(deps);
-      dyahd = dcosep*dyhd-dsinep*dzhd;
-      dzahd = dsinep*dyhd+dcosep*dzhd;
-      dyabd = dcosep*dybd-dsinep*dzbd;
-      dzabd = dsinep*dybd+dcosep*dzbd;
-
-/*   Heliocentric coordinates of the Earth */
-      dr = dpsi*d1pdro;
-      flatm = ccim*sin(forbel[2]);
-      a = sigma*cos(flatm);
-      dxh = dr*dcosls-(a*coslm);
-      dyh = dr*dsinls-(a*sinlm);
-      dzh =          -(sigma*sin(flatm));
-
-/*   Barycentric coordinates of the Earth */
-      dxb = dxh*dc1mme;
-      dyb = dyh*dc1mme;
-      dzb = dzh*dc1mme;
-      for( k=0; k<4; k++) {
-         flat = sorbel[k+13]*sin(forbel[k+3]-sorbel[k+5]);
-         a = ccpam[k]*(1.0-sorbel[k+9]*cos(forbel[k+3]-sorbel[k+1]));
-         b = a*cos(flat);
-         dxb = dxb-(b*coslp[k]);
-         dyb = dyb-(b*sinlp[k]);
-         dzb = dzb-(a*sin(flat));
-      }
-
-/*   Transition to mean equator of date */
-      dyah = dcosep*dyh-dsinep*dzh;
-      dzah = dsinep*dyh+dcosep*dzh;
-      dyab = dcosep*dyb-dsinep*dzb;
-      dzab = dsinep*dyb+dcosep*dzb;
-
-/*   Copy result components into vectors, correcting for FK4 equinox */
-      depj=sla_epj(date);
-      deqcor = ds2r*(0.035+0.00085*(depj-1950.0));
-      dvh[0] = dxhd-deqcor*dyahd;
-      dvh[1] = dyahd+deqcor*dxhd;
-      dvh[2] = dzahd;
-      dvb[0] = dxbd-deqcor*dyabd;
-      dvb[1] = dyabd+deqcor*dxbd;
-      dvb[2] = dzabd;
-      dph[0] = dxh-deqcor*dyah;
-      dph[1] = dyah+deqcor*dxh;
-      dph[2] = dzah;
-      dpb[0] = dxb-deqcor*dyab;
-      dpb[1] = dyab+deqcor*dxb;
-      dpb[2] = dzab;
-
-/*   Was precession to another equinox requested? */
-      if (ideq!=0) {
-
-/*     Yes: compute precession matrix from MJD DATE to Julian epoch DEQX */
-         sla_prec(depj,deqx,dprema);
-
-/*     Rotate DVH */
-         for(j=0; j<3; j++ ) {
-            w=0.0;
-            for(i=0; i<3; i++ ) {
-               w=w+dprema[i][j]*dvh[i];
-            }
-            vw[j]=w;
-         }
-         for(j=0; j<3; j++ ) {
-            dvh[j]=vw[j];
-         }
-
-/*     Rotate DVB */
-         for(j=0; j<3; j++ ) {
-            w=0.0;
-            for(i=0; i<3; i++ ) {
-               w=w+dprema[i][j]*dvb[i];
-            }
-            vw[j]=w;
-         }
-         for(j=0; j<3; j++ ) {
-            dvb[j]=vw[j];
-         }
-
-/*     Rotate DPH */
-         for(j=0; j<3; j++ ) {
-            w=0.0;
-            for(i=0; i<3; i++ ) {
-               w=w+dprema[i][j]*dph[i];
-            }
-            vw[j]=w;
-         }
-         for(j=0; j<3; j++ ) {
-            dph[j]=vw[j];
-         }
-
-/*     Rotate DPB */
-         for(j=0; j<3; j++ ) {
-            w=0.0;
-            for(i=0; i<3; i++ ) {
-               w=w+dprema[i][j]*dpb[i];
-            }
-            vw[j]=w;
-         }
-         for(j=0; j<3; j++ ) {
-            dpb[j]=vw[j];
-         }
-      }
-}
-
-/*
-*     - - - - 
-*      D V N
-*     - - - -
-*
-*  Normalises a 3-vector also giving the modulus (double precision)
-*
-*  Given:
-*     V       dp(3)      vector
-*
-*  Returned:
-*     UV      dp(3)      unit vector in direction of V
-*     VM      dp         modulus of V
-*
-*  If the modulus of V is zero, UV is set to zero as well
-*
-*  P.T.Wallace   Starlink   November 1984
-*/
-sla_dvn (v, uv, vm)
-double v[3],uv[3], *vm;
-{
-  int i;
-  double w1,w2;
-
-/*  Modulus */
-      w1=0.0;
-      for(i=0; i<3; i++ ) {
-         w2=v[i];
-         w1=w1+w2*w2;
-      }
-      w1=sqrt(w1);
-      *vm=w1;
-
-/*  Normalise the vector */
-      if(w1 <= 0.0)
-         w1=1.0;
-      for(i=0; i<3; i++ )
-         uv[i]=v[i]/w1;
-}
-
-/*
-*     - - - - - -
-*      M A P Q K
-*     - - - - - -
-*
-*  Quick mean to apparent place:  transform a star RA,Dec from
-*  mean place to geocentric apparent place, given the
-*  star-independent parameters.
-*
-*  Use of this routine is appropriate when efficiency is important
-*  and where many star positions, all referred to the same equator
-*  and equinox, are to be transformed for one epoch.  The
-*  star-independent parameters can be obtained by calling the
-*  sla_MAPPA routine.
-*
-*  If the parallax and proper motions are zero the sla_MAPQKZ
-*  routine can be used instead.
-*
-*  The reference frames and timescales used are post IAU 1976.
-*
-*  Given:
-*     RM,DM    d      mean RA,Dec (rad)
-*     PR,PD    d      proper motions:  RA,Dec changes per Julian year
-*     PX       d      parallax (arcsec)
-*     RV       d      radial velocity (km/sec, +ve if receding)
-*
-*     AMPRMS   d(21)  star-independent mean-to-apparent parameters:
-*             
-*       (1)      time interval for proper motion (Julian years)
-*       (2-4)    barycentric position of the Earth (AU)
-*       (5-7)    heliocentric direction of the Earth (unit vector)
-*       (8)      (grav rad Sun)*2/(Sun-Earth distance)
-*       (9-11)   barycentric Earth velocity in units of c
-*       (12)     sqrt(1-v**2) where v=modulus(ABV)
-*       (13-21)  precession/nutation (3,3) matrix
-*
-*  Returned:
-*     RA,DA    d      apparent RA,Dec (rad)
-*
-*  References:
-*     1984 Astronomical Almanac, pp B39-B41.
-*     (also Lederle & Schwan, Astron. Astrophys. 134,
-*      1-6, 1984)
-*
-*  Notes:
-*
-*  1)  The vectors AMPRMS(2-4) and AMPRMS(5-7) are referred to
-*      the mean equinox and equator of epoch EQ.
-*
-*  2)  Within about 300 arcsec of the centre of the Sun the
-*      gravitational deflection term is set to zero to avoid
-*      overflow.  Otherwise no account is taken of the
-*      impossibility of observing stars which lie behind
-*      the Sun.
-*
-*  3)  This routine replaces earlier routine sla_MAPQ, which is
-*      to be withdrawn.
-*
-*  Called:
-*     sla_DCS2C       spherical to Cartesian
-*     sla_DVDV        dot product
-*     sla_DMXV        matrix x vector
-*     sla_DCC2S       Cartesian to spherical
-*     sla_DRANRM      normalise angle 0-2Pi
-*
-*  P.T.Wallace   Starlink   November 1988
-*/
-sla_mapqk (rm, dm, pr, pd, px, rv, amprms, ra, da)
-double rm,dm,pr,pd,px,rv,amprms[21],*ra,*da;
-{
-
-/*  Arc seconds to radians */
-      static double as2r=0.4848136811095359949e-5;
-
-/*  Km/s to AU/year */
-      double vf = 0.21094502;
-
-      int i;
-
-      double pmt,gr2e,ab1,eb[3],ehn[3],abv[3],
-             q[3],pxr,w,em[3],p[3],pn[3],pde,pdep1,
-             p1[3],p1dv,p1dvp1,p2[3],p3[3];
-
-      double sla_dvdv(),sla_dranrm();
-
-/*  Unpack scalar and vector parameters */
-      pmt = amprms[0];
-      gr2e = amprms[7];
-      ab1 = amprms[11];
-      for(i=0; i<3; i++ ) {
-         eb[i] = amprms[i+1];
-         ehn[i] = amprms[i+4];
-         abv[i] = amprms[i+8];
-      }
-
-/*  Spherical to x,y,z */
-      sla_dcs2c(rm,dm,q);
-
-/*  Space motion (radians per year) */
-      pxr = px*as2r;
-      w = vf*rv*pxr;
-      em[0] = -pr*q[1]-pd*cos(rm)*sin(dm)+w*q[0];
-      em[1] =  pr*q[0]-pd*sin(rm)*sin(dm)+w*q[1];
-      em[2] =          pd*cos(dm)        +w*q[2];
-
-/*  Geocentric direction of star (normalised) */
-      for(i=0; i<3; i++ )
-         p[i] = q[i]+pmt*em[i]-pxr*eb[i];
-      sla_dvn(p,pn,&w);
-
-/*  Light deflection */
-      pde = sla_dvdv(pn,ehn);
-      pdep1 = 1.0+pde;
-      w = gr2e/max(pdep1,1e-6);
-      for(i=0; i<3; i++ )
-         p1[i] = pn[i]+w*(ehn[i]-pde*pn[i]);
-
-/*  Aberration */
-      p1dv = sla_dvdv(p1,abv);
-      p1dvp1 = p1dv+1.0;
-      w = 1.0+p1dv/(ab1+1.0);
-      for(i=0; i<3; i++ )
-         p2[i] = (ab1*p1[i]+w*abv[i])/p1dvp1;
-
-/*  Precession and nutation */
-      sla_dmxv((void *)&amprms[12],p2,p3);
-
-/*  Geocentric apparent RA,Dec */
-      sla_dcc2s(p3,ra,da);
-      *ra = sla_dranrm(*ra);
-}
-
-/*
-*     - - - - -
-*      E P C O
-*     - - - - -
-*
-*  Convert an epoch into the appropriate form - 'B' or 'J'
-*
-*  Given:
-*     K0    char    form of result:  'B'=Besselian, 'J'=Julian
-*     K     char    form of given epoch:  'B' or 'J'
-*     E     dp      epoch
-*
-*  Called:  sla_EPB, sla_EPJ2D, sla_EPJ, sla_EPB2D
-*
-*  Notes:
-*
-*     1) The result is always either equal to or very close to
-*        the given epoch E.  The routine is required only in
-*        applications where punctilious treatment of heterogeneous
-*        mixtures of star positions is necessary.
-*
-*     2) K0 and K are not validated.  They are interpreted as follows:
-*
-*        o  If K0 and K are the same the result is E.
-*        o  If K0 is 'B' and K isn't, the conversion is J to B.
-*        o  In all other cases, the conversion is B to J.
-*
-*  P.T.Wallace   Starlink   8 April 1990
-*/
-double sla_epco (k0, k, e)
-char *k0,*k;
-double e;
-{
-  double ret, sla_epb(),sla_epj2d(),sla_epj(),sla_epb2d();
-
-      if (strcmp(k,k0)==0)
-         ret = e;
-      else if (strcmp(k0, "B")==0 )
-         ret=sla_epb(sla_epj2d(e));
-      else
-         ret=sla_epj(sla_epb2d(e));
-      return(ret);
-}
-
-/*
-*     - - - - - -
-*      E P J 2 D
-*     - - - - - -
-*
-*  Conversion of Julian Epoch to Modified Julian Date (double precision)
-*
-*  Given:
-*     EPJ      dp       Julian Epoch
-*
-*  The result is the Modified Julian Date (JD - 2400000.5).
-*
-*  Reference:
-*     Lieske,J.H., 1979. Astron.Astrophys.,73,282.
-*
-*  P.T.Wallace   Starlink   February 1984
-*/
-double sla_epj2d (epj)
-double epj;
-{
-      return( 51544.5 + (epj-2000.0)*365.25);
-}
-
-/*
-*     - - - - - -
-*      E P B 2 D
-*     - - - - - -
-*
-*  Conversion of Besselian Epoch to Modified Julian Date
-*  (double precision)
-*
-*  Given:
-*     EPB      dp       Besselian Epoch
-*
-*  The result is the Modified Julian Date (JD - 2400000.5).
-*
-*  Reference:
-*     Lieske,J.H., 1979. Astron.Astrophys.,73,282.
-*
-*  P.T.Wallace   Starlink   February 1984
-*/
-double sla_epb2d(epb)
-double epb;
-{
-      return( 15019.81352 + (epb-1900.0)*365.242198781 );
-}
-
-/*
-*     - - - -
-*      E P B
-*     - - - -
-*
-*  Conversion of Modified Julian Date to Besselian Epoch
-*  (double precision)
-*
-*  Given:
-*     DATE     dp       Modified Julian Date (JD - 2400000.5)
-*
-*  The result is the Besselian Epoch.
-*
-*  Reference:
-*     Lieske,J.H., 1979. Astron.Astrophys.,73,282.
-*
-*  P.T.Wallace   Starlink   February 1984
-*/
-double sla_epb(date)
-double date;
-{
-      return( 1900.0 + (date-15019.81352)/365.242198781 );
-}
-
-/*
-*     - - - - -
-*      D V D V
-*     - - - - -
-* 
-*  Scalar product of two 3-vectors  (double precision)
-*
-*  Given:
-*      VA      dp(3)     first vector
-*      VB      dp(3)     second vector
-*
-*  The result is the scalar product VA.VB (double precision)
-*
-*  P.T.Wallace   Starlink   November 1984
-*/
-double sla_dvdv(va, vb)
-double va[3],vb[3];
-{
-      return(va[0]*vb[0]+va[1]*vb[1]+va[2]*vb[2]);
-}
-
-double current_time()
-{
-  struct tm *gmt, *gmtime();
-  time_t t;
-  double dys, year, frac;
-
-  time(&t);
-  gmt = gmtime(&t);
-
-  dys = (double)dysize(gmt->tm_year);
-  year = 1900.0 + (double)gmt->tm_year;  
-  frac = ((double)gmt->tm_yday + ((double)gmt->tm_hour +
-         ((double)gmt->tm_min + (double)gmt->tm_sec/60.0)/60.0)/24.0)/dys;
-  
-  return( year + frac);
-}
-
-
-/*  gall -> B1950 
-
-h_slaGe50(ret,p)
-struct NODE *ret;
-struct NODE *p[];
-{
-  ret->type = typ_int;
-  if( p[0]->type != typ_double ||
-      p[1]->type != typ_double ||
-      p[2]->type != typ_double ||
-      p[3]->type != typ_double ) {
-    ret->value.ival = 1;
-    return;
-  } else
-    ret->value.ival = 0;
-
-  slaGe50(p[0]->value.fval, p[1]->value.fval, &p[2]->value.fval, &p[3]->value.fval );
-}
-*/
-
-/*  gall -> J2000 
-
-h_slaGaleq(ret,p)
-struct NODE *ret;
-struct NODE *p[];
-{
-  ret->type = typ_int;
-  if( p[0]->type != typ_double ||
-      p[1]->type != typ_double ||
-      p[2]->type != typ_double ||
-      p[3]->type != typ_double ) {
-    ret->value.ival = 1;
-    return;
-  } else
-    ret->value.ival = 0;
-
-  slaGaleq(p[0]->value.fval, p[1]->value.fval, &p[2]->value.fval, &p[3]->value.fval );
-}
-*/
-
-/*  J2000 -> gal 
-
-h_slaEqgal(ret,p)
-struct NODE *ret;
-struct NODE *p[];
-{
-  ret->type = typ_int;
-  if( p[0]->type != typ_double ||
-      p[1]->type != typ_double ||
-      p[2]->type != typ_double ||
-      p[3]->type != typ_double ) {
-    ret->value.ival = 1;
-    return;
-  } else
-    ret->value.ival = 0;
-
-  slaEqgal(p[0]->value.fval, p[1]->value.fval, &p[2]->value.fval, &p[3]->value.fval );
-}
-*/
-
-/*  B1950 ->gall 
-
-h_slaEg50(ret,p)
-struct NODE *ret;
-struct NODE *p[];
-{
-  ret->type = typ_int;
-  if( p[0]->type != typ_double ||
-      p[1]->type != typ_double ||
-      p[2]->type != typ_double ||
-      p[3]->type != typ_double ) {
-    ret->value.ival = 1;
-    return;
-  } else
-    ret->value.ival = 0;
-
-  slaEg50(p[0]->value.fval, p[1]->value.fval, &p[2]->value.fval, &p[3]->value.fval );
-}
-*/
-
-
-int isleap(year)
-int year;
-{
-  return((year % 4 == 0 && year % 100 != 0) || year % 400 == 0);
-}
-
-int dysize(yr)
-{
-  return( isleap( yr ) ? 366 : 365 );
-}
-
-
-
-/*
- Calculates Parallactic angle (degrees) from
-  TLST (Sidereal time, Hours)
-  RA   (Hours)
-  DEC  (Degrees)
-  ALAT (Latitude of observatory, degrees)
-
-    Written by D. T. Emerson.
-*/
-
-double para(tlst, ra, dec, alat )
-double  tlst, ra, dec, alat;
-{
-  double  ha, har, rar, decr, alatr, tanp1, tanp2, angle;
-  double sin(), cos(), atan2();
-      
-/* Calculate Hour Angle HA (hours)  */
-
-  ha = tlst - ra;
-
-/* Convert to consistent units (here radians)  */  
-
-  har   = ha*PI/12.0;
-  rar   = ra*PI/12.0;
-  decr  = dec*PI/180.0;
-  alatr = alat*PI/180.0;
-
-/* Calculate TANP, i.e. TAN(Parallactic angle) using ATAN2  */
-
-  tanp1 = cos(alatr)*sin(har);
-  tanp2 = (sin(alatr)*cos(decr) - cos(alatr)*sin(decr)*cos(har));
-
-/* Catch indeterminate case, where numerator and denominator = 0  */
-
-  if(tanp1 == 0.0 && tanp2 == 0.0)
-    angle = 0.0;
-
-/* Use ATAN2 instead of ATAN, to allow for denominator possibly being zero,
-   and to get signs of all 4 quadrants correct.  */
-
-   else
-     angle = atan2(tanp1,tanp2)*180.0/PI;
-
-  return(angle);
-}
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <time.h>
-#include <string.h>
-#include <sys/time.h>
-
-#define CTD (360.0/(PI*2.0))
-#define CTR (PI*2.0/360.0)
-#define AOLAT   18.353806         /* degrees north */
-
-double  deg_sin(double);
-double  deg_cos(double);
-double  deg_tan(double);
-double  deg_asin(double);
-double  deg_acos(double);
-double  deg_atan(double);
-double  sin(), cos(), tan();
-
-/* returns the azimuth and za for a source at apparent ra, dec and lst
-   ra (hours)
-   dec (degrees)
-   lst (hours)
-*/
-
-int compute_azza( ra, dec, lst, paz, pza  ) 
-double ra, dec, lst, *paz, *pza;
-{
-  double ha, az, el, sindec, cosdec, sinlat, coslat,
-                cosha, sinel, cosel, cosazel, cosaz;
-
-
-/* Calculate hour angle and convert to degrees (use convention
-   that hour angle ranges between +/- 12 hours)    */
-
-  ha = lst - ra;
-  if( ha > 12.0 )
-    ha = ha - 24.0;
-  else if( ha < -12.0 )
-    ha = ha + 24.0;
-  ha = ha * 15.0;
-
-/* Compute trig quantities needed; make angle calculations double
-   precision to cut down on round-off-induced overflows near the
-   zenith and the meridian.    */
-
-  sindec = sin(dec*CTR);
-  cosdec = cos(dec*CTR);
-  sinlat = sin(AOLAT*CTR);
-  coslat = cos(AOLAT*CTR);
-  cosha  = cos(ha*CTR);
-
-/* Compute elevation (trap for blow-ups near the zenith):  */
-
-  sinel = sindec * sinlat + cosdec * cosha * coslat;
-
-  if (sinel >= -1.0 && sinel <= 1.0)
-    el = asin(sinel)*CTD;
-  else
-    printf("elevation too high");
-
-/* Compute azimuth (trap for blow-ups near HA = 0):    */
-
-  cosel = cos(el*CTR);
-  cosazel = sindec * coslat - cosdec * cosha * sinlat;
-  cosaz = (1.0/cosel) * cosazel;
-  if (cosaz >= -1.0 && cosaz <= 1.0)
-    az = acos(cosaz)*CTD;
-  else {
-    if (dec <= AOLAT)
-      az = 180.0;
-    else
-      az = 0.0;
-  }
-
-/* Resolve quadrant ambiguity of azimuth:    */
-
-  if (ha > 0.0)
-    az = 360.0 - az;
-
-  *pza = 90.0 - el;
-
-  az += 180.0; /* arecibo az is 180 away from azel dish */
-  if ( az > 360.0 )
-    az -= 360.0;
-
-  *paz = az;
-  /* printf("az %f dec %f ha %f\n", az, dec, ha ); */
-  return 0;
-}
-
-/* 
-  thanks to Avinash Deshspande, he computed these mixed up 
-  equations
-*/
-
-compute_zaha( az, dec, pza, pha )
-double az;
-double dec;
-double *pza;
-double *pha;
-{
-  double sinaz, cosaz, sindec, cosdec, sinlat, coslat;
-  double sinelp, sinelm, sinel, cosel, sinha;
-  double el, ha, za, sq, zam, zap;
-
-  sinaz  = sin(az*CTR);
-  cosaz  = cos(az*CTR);
-  sindec = sin(dec*CTR);
-  cosdec = cos(dec*CTR);
-  sinlat = sin(AOLAT*CTR);
-  coslat = cos(AOLAT*CTR);
-
-  sq = cosdec*cosdec - coslat*coslat*sinaz*sinaz;
-  if( sq < 0.0 )
-    return;
-  sinelp = (sinlat*sindec + coslat * cosaz * 
-    sqrt( sq ) ) /
-    ( 1.0 - coslat*coslat * sinaz*sinaz );
-
-  sinelm = (sinlat*sindec - coslat * cosaz * 
-    sqrt( sq ) ) /
-    ( 1.0 - coslat*coslat * sinaz*sinaz );
-
-  zam = 90.0 - deg_asin( sinelm );
-  zap = 90.0 - deg_asin( sinelp );
-
-/* find a za in the right range */
-
-  if( zam > 0.0 && zam < 20.0 ) {
-    sinel = sinelm;
-    za = zam;
-  } else {
-    sinel = sinelp;
-    za = zap;
-  }
-    
-  cosel = (sindec - sinel * sinlat ) / coslat / cosaz ;
-
-  sinha =  -1.0 * cosel * sinaz / cosdec;
-  ha = deg_asin( sinha );
-  ha /= 15;
-
-  *pza = za;
-  *pha = ha;
-}
-
-/* compute radec offsets from az/za offsets and positions */
-
-int off_hadec( daz, dza, az, za, ha, dec, pdha, pddec )
-double daz;
-double dza; 
-double az; 
-double za; 
-double ha; 
-double dec; 
-double *pdha;
-double *pddec;
-{
-  double cosza, coslat, cosaz, cosdec;
-  double sinza, sinlat, sinaz;
-  double cosha, sinha, ddec, hacd;
-
-   daz = CTR*daz;
-   dza = CTR*dza;
-   az = CTR*az;
-   za = CTR*za;
-   ha =  ha*PI/12.0;
-   dec = CTR*dec;
-  
-   cosza = cos(za);
-   coslat = cos(AOLAT);
-   cosaz = cos(az);
-   sinza = sin(za);
-   sinlat = sin(AOLAT);
-   sinaz = sin(az);
-   cosdec = cos(dec);
-   cosha = cos(ha);
-   cosdec = cos(dec);
-
-   ddec = (dza * ( cosza *coslat * cosaz - sinza * sinlat ) - 
-          daz * ( coslat * sinaz ) ) / cosdec; 
-
-   *pddec = CTD*ddec;
-
-   hacd = -1.0 * (cosha * cosaz + sinha * sinaz *sinlat ) * daz -
-                 (cosha * sinaz * cosza - 
-                   sinha * ( sinza * coslat + cosza * sinlat * cosaz )) * dza;
-
-   *pdha = hacd / cosdec;
-}
-
-
-#include <stdlib.h>
-#include <math.h>
-/*
-   compute apparent ra, dec from az, el, lst
-   Zombeck 1982 p. 71
-
-   az, el, ra, dec in degrees
-   lst in hours
-
-*/
-
-double  deg_sin(double);
-double  deg_cos(double);
-double  deg_tan(double);
-double  deg_asin(double);
-double  deg_acos(double);
-double  deg_atan(double);
-double  sin(), cos(), tan();
-
-#define AOLAT   18.353806         /* degrees north */
-
-/* az za in degrees lst in hours */
-
-compute_radec( az, za, lst, pra, pdec )
-double az, za, lst;
-double *pra, *pdec;
-{
-  double sindec, sinaz, sinel, cosaz, cosel;
-  double cosdec, dec, ha, cosha, sinlat, coslat;
-  double el;
-
-  az += 180.0;
-  if( az > 360.0 )
-   az -= 360.0;
-  el = 90.0 - za;
-  sinel = deg_sin(el);
-  cosel = deg_cos(el);
-  sinaz = deg_sin(az);
-  cosaz = deg_cos(az);
-  sinlat = deg_sin(AOLAT);
-  coslat = deg_cos(AOLAT);
-
-  sindec = sinel * sinlat + cosel * coslat * cosaz;
-
-  if( sindec >= -1.0 && sindec <= 1.0 )
-    dec = deg_asin( sindec );
-  else
-    dec = 90.0;
-
-  cosdec = deg_cos( dec );
-  cosha = ( sinel * coslat - cosel * cosaz * sinlat)/cosdec ;
-
-  if( cosha >= -1.0 && cosha <= 1.0 )
-    ha = deg_acos( cosha )/15.0;
-  else
-    ha = 0.0;
-
-/* Resolve quadrant ambiguity */
-
-  if( az < 180.0 )
-    ha = -ha;
-
-  *pra =  fmod(lst - ha, 24.0);
-  if( *pra < 0.0 )
-    *pra += 24.0;
-
-  *pdec = dec;
-}
-
-struct ALFAOFF {
-  double az;
-  double za;
-};
-
-static struct ALFAOFF *alfaoff = NULL;
-
-double roty( double, double, double);
-double rotx( double, double, double);
-int find_alfarot(double, int, double *, double * );
-double find_alfaoff(int, int);
-double  deg_sin(double);
-double  deg_cos(double);
-double  deg_tan(double);
-double  deg_asin(double);
-double  deg_acos(double);
-double  deg_atan(double);
-double  sin(), cos(), tan();
-
-double find_alfaoff(beam, isza)
-int beam;
-int isza;
-{
-  int count;
-  char *s;
-  char *delim = " \t\n";
-  FILE *fd;
-  char line[80];
-
-  if( !alfaoff ) {
-    alfaoff = (struct ALFAOFF *)malloc( sizeof(struct ALFAOFF)*7);
-    bzero( alfaoff, sizeof(struct ALFAOFF)*7);
-
-    alfaoff[0].az=0.0;
-    alfaoff[0].za=0.0;
-    alfaoff[1].az=-164.529999999/3600.0;
-    alfaoff[1].za=332.558085181/3600.0;
-    alfaoff[2].az=-329.06/3600.0;
-    alfaoff[2].za=0.0;
-    alfaoff[3].az=-164.529999999/3600.0; 
-    alfaoff[3].za=-332.558085181/3600.0;
-    alfaoff[4].az=164.529999999/3600.0;
-    alfaoff[4].za=-332.558085181/3600.0;
-    alfaoff[5].az=329.06/3600.0;
-    alfaoff[5].za=0.0;
-    alfaoff[6].az=164.529999999/3600.0;
-    alfaoff[6].za=332.558085181/3600.0;
-
-  }
-
-  if ( beam < 0 || beam > 6 )
-    return 0.0;
-  else if( isza )
-    return alfaoff[beam].za;
-  else
-    return alfaoff[beam].az;
-}
-
-find_alfarot(angle, beam, paz, pza )
-double angle;
-int beam;
-double *paz;
-double *pza;
-{
-  double az, za;
-
-  az  = find_alfaoff(beam, 0);
-  za  = find_alfaoff(beam, 1);
-
- *paz = rotx( az, za, angle );
- *pza = roty( az, za, angle );
-}
-
-#define ALFARATIO (329.06/384.005)
-
-/* negative angle associated with clockwize rotation */
-
-double rotx( offx, offy, ang )
-double offx, offy, ang;
-{
-  double ret, h, a1;
-
-  offy *= ALFARATIO;
-
-  h = sqrt( offx*offx + offy*offy );
-  a1 = atan2( offy, offx);
-  ret = h * cos( a1 - ang/180.0*PI );
-
-
-  return ret;
-}
-
-/* adjust for the ellipse */
-/* negative angle associated with clockwize rotation */
-
-double roty( offx, offy, ang )
-double offx, offy, ang;
-{
-  double ret, h, a1;
-
-  offy *= ALFARATIO;
-  h = sqrt( offx*offx + offy*offy );
-  a1 = atan2( offy, offx);
-  ret = h * sin( a1 - ang/180.0*PI );
-  ret /= ALFARATIO;
-  return ret;
-}
-
-/* given 
-  J2000 ra/dec in hh.hhh ddd.ddd
-  lst time in hours from midnight
-  current epoch as in 2004.56789
-  rotation angle
-  alfa beam
-
-  compute new ra/dec based on alfa beam offsets
-
-*/
-
-alfa_position( ra, dec, lst, epoch, angle, off1, off2, beam, pra, pdec )
-double ra;
-double dec;
-double lst;
-double epoch;
-double angle;
-double off1;
-double off2;
-int beam;
-double *pra;
-double *pdec;
-{
-  double rra, rdec, nra, ndec, bra, bdec, offaz, offza;
-  double saz, sza, nsaz, nsza;
-
-  rra = ra*PI*2.0/24.0;
-  rdec = dec*PI*2.0/360.0;
-  sla_preces("FK5",2000.0,epoch, &rra, &rdec );
-  nra = rra * 24.0 / 2.0 / PI;
-  ndec = rdec * 180.0 / PI;
-
-  compute_azza( nra, ndec, lst, &saz, &sza );
-
-  find_alfarot(angle, beam, &offaz, &offza );
-
-  saz = saz - (offaz - off1)/deg_sin(sza);
-  sza = sza - (offza - off2);
-  compute_radec( saz, sza, lst, &bra, &bdec );
-
-  rra = bra*2.0*PI/24.0;
-  rdec = bdec*PI/180.0;
-  sla_preces("FK5",epoch, 2000.0, &rra, &rdec );
-  bra = rra * 24.0 / 2.0 / PI;
-  bdec = rdec * 180.0 / PI;
-  *pra = bra;
-  *pdec = bdec;
-
-  /* printf("%d     %13.9f     %13.9f\n", beam, bra, bdec );*/
-}
-/* given 
-  J2000 ra/dec in hh.hhh ddd.ddd
-  lst time in hours from midnight
-  current epoch as in 2004.56789
-  rotation angle (deg)
-  alfa beam (0-6)
-
-  compute new ra/dec based on alfa beam offsets
-
-main(int argc, char **argv){
-double ra;
-double dec;
-double lst;
-double epoch;
-double angle;
-double off1;
-double off2;
-int beam;
-double pra;
-double pdec;
-ra=atof(argv[1]);
-dec=atof(argv[2]);
-lst=atof(argv[3]);
-epoch=atof(argv[4]);
-angle=atof(argv[5]);
-off1=0.0;
-off2=0.0;
-beam=atoi(argv[6]);
-printf("%f %f %f %f %f %f %f %d\n",ra, dec, lst, epoch, angle, off1, off2,beam);
-alfa_position( ra, dec, lst, epoch, angle, off1, off2, beam, &pra, &pdec );
-printf("%f %f\n",pra,pdec);
-}
-*/
diff --git a/filterbank-gmrt/aliases.c b/filterbank-gmrt/aliases.c
deleted file mode 100644
index b7ccc08..0000000
--- a/filterbank-gmrt/aliases.c
+++ /dev/null
@@ -1,145 +0,0 @@
-#include <string.h>
-
-/* returns the correct TEMPO site code given SIGPROC's telescope_id */
-char tempo_site(int telescope_id) /*includefile*/
-{
-  switch (telescope_id) {
-  case 0:
-    return('3');
-    break;
-  case 1:
-    return('3'); /*AO*/
-    break;
-  case 3:
-    return('f'); /*Nancay*/
-    break;
-  case 4:
-    return('7'); /*Parkes*/
-    break;
-  case 5:
-    return('8'); /*Jodrell*/
-    break;
-  case 6:
-    return('1'); /*GBT*/
-    break;
-  case 8:
-    return('g'); /*Effelsberg*/
-    break;
-  default:
-    return('?'); /*unknown*/
-    /*error_message("tempo_site: unknown telescope!");*/
-    break;
-  }
-}
-
-char *telescope_name (int telescope_id) /*includefile*/
-{
-  char *telescope,string[80];
-  switch (telescope_id) {
-  case 0: 
-    strcpy(string,"Fake");
-    break;
-  case 1: 
-    strcpy(string,"Arecibo");
-    break;
-  case 2: 
-    strcpy(string,"Ooty");
-    break;
-  case 3: 
-    strcpy(string,"Nancay");
-    break;
-  case 4: 
-    strcpy(string,"Parkes");
-    break;
-  case 5: 
-    strcpy(string,"Jodrell");
-    break;
-  case 6: 
-    strcpy(string,"GBT");
-    break;
-  case 7: 
-    strcpy(string,"GMRT");
-    break;
-  case 8: 
-    strcpy(string,"Effelsberg");
-    break;
-  default: 
-    strcpy(string,"???????"); 
-    break;
-  }
-  telescope=(char *) malloc(strlen(string));
-  strcpy(telescope,string);
-  return(telescope);
-}
-char *backend_name (int machine_id) /*includefile*/
-{
-  char *backend, string[80];
-  switch (machine_id) {
-  case 0:
-    strcpy(string,"FAKE");
-    break;
-  case 1:
-    strcpy(string,"PSPM");
-    break;
-  case 2:
-    strcpy(string,"WAPP");
-    break;
-  case 3:
-    strcpy(string,"AOFTM");
-    break;
-  case 4:
-    strcpy(string,"BPP");
-    break;
-  case 5:
-    strcpy(string,"OOTY");
-    break;
-  case 6:
-    strcpy(string,"SCAMP");
-    break;
-  case 7:
-    strcpy(string,"GMRTGSB");
-    break;
-  case 8:
-    strcpy(string,"GMRTGWB");
-    break;
-  default:
-    strcpy(string,"????");
-    break;
-  }
-  backend=(char *) malloc(strlen(string));
-  strcpy(backend,string);
-  return(backend);
-}
-char *data_category (int data_type) /*includefile*/
-{
-  char *datatype, string[80];
-  switch (data_type) {
-  case 0:
-    strcpy(string,"raw data");
-    break;
-  case 1:
-    strcpy(string,"filterbank");
-    break;
-  case 2:
-    strcpy(string,"time series");
-    break;
-  case 3:
-    strcpy(string,"pulse profiles");
-    break;
-  case 4:
-    strcpy(string,"amplitude spectrum");
-    break;
-  case 5:
-    strcpy(string,"complex spectrum");
-    break;
-  case 6:
-    strcpy(string,"dedispersed subbands");
-    break;
-  default:
-    strcpy(string,"unknown!");
-    break;
-  }
-  datatype=(char *) malloc(strlen(string));
-  strcpy(datatype,string);
-  return(datatype);
-}
diff --git a/filterbank-gmrt/angle_split.c b/filterbank-gmrt/angle_split.c
deleted file mode 100644
index 744c3e8..0000000
--- a/filterbank-gmrt/angle_split.c
+++ /dev/null
@@ -1,16 +0,0 @@
-void angle_split(double angle, int *dd, int *mm, double *ss) /*includefile*/
-{
-  int negative;
-  if (angle<0.0) {
-    angle*=-1.0;
-    negative=1;
-  } else {
-    negative=0;
-  }
-  *dd=(int) (angle/10000.0);
-  angle-=(double) (*dd)*10000.0;
-  *mm=(int) (angle/100.0);
-  *ss=angle-100.0*(*mm);
-  if (negative) *dd = *dd * -1;
-}
-
diff --git a/filterbank-gmrt/aoftm.c b/filterbank-gmrt/aoftm.c
deleted file mode 100644
index d645e3d..0000000
--- a/filterbank-gmrt/aoftm.c
+++ /dev/null
@@ -1,333 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include "filterbank.h"
-
-#define HEADERRECS 36
-#define HEADERSIZE HEADERRECS*80 		/* FITS 2880-byte block */
-#define AOFTMBLEN 524288	/* buffer size in bytes */
-#define CHANSPERQ 256		/* n chans per freq quadrant */
-
-/* data management variables */
-unsigned short buffer[AOFTMBLEN/2];
-unsigned short BRO[256], BRO2[256], FOLD[256], FOLD2[256];
-unsigned short aoftm_data[1024];
-double quadif[4];
-int quadsign[4];
-int nfft, nbufs, nbits, nchans, twobit; 
-
-char aoftm_header[HEADERRECS][80]; 
-double aoftm_if[4];
-int aoftm_sgn[4], aoftm_pol[16];
-
-char *headername (char *filename) /*includefile*/
-{
-  char *string, *hdrnam;
-  string=(char *)malloc(strlen(filename));
-  hdrnam=(char *)malloc(strlen(filename));
-  string=strtok(filename,".");
-  while (string != NULL) {
-    if (strcmp(string,"dat")) {
-      strcat(hdrnam,string);
-      strcat(hdrnam,".");
-    } else {
-      strcat(hdrnam,"hdr");
-    }
-    string=strtok(NULL,".");
-  }
-  free(string);
-  return(hdrnam);
-}
-
-int aoftm_read_header(char *filename) /*includefile*/
-{
-  FILE *out_hdr, *board_config, *instream;
-  char outfile[100];
-
-  /* header info variables */
-  char aoftm_polcfg[33], aoftm_chord[9];
-  double freq, bw, dt, dt_max, int_time;
-  char utc_start[8];
-  char caltype[6], tick, dest, source[9];
-  char hdrfname[80], runtype[6], receiver[9], projid[9];
-  int rah, ram, decd, decm, day, month, year, hr, min, sec;
-  float ras, decs;
-  double glon, glat;
-  int iboard, iquad, icount, nchan_max, boardno, test_vec;
-  int seek, equinox;
-  
-  double fmjd, az, za;
-  int j, mjd;
-  int nscan;
-
-  strcpy(hdrfname,"");
-  strncat(hdrfname,filename,strlen(filename)-4);
-  strcat(hdrfname,".hdr");
-
-  if ((instream = fopen(hdrfname, "r")) == NULL) {
-    /*fprintf(stderr,"Couldn't open pipe for header read!\n");*/
-    return(0);
-  }
-  if (fread(aoftm_header, 1, HEADERSIZE, instream) != HEADERSIZE) {
-    fprintf(stderr, "Unable to read header!\n");
-    return(0);
-  }
-  close(instream);
-  az=za=0.0;
-  for (j=0; j<HEADERRECS; j++) {
-    if (strstr(aoftm_header[j], "MJD-OBS") != NULL) 
-      sscanf(aoftm_header[j], "MJD-OBS = %lf", &fmjd);
-    if (strstr(aoftm_header[j], "AZ-OBS") != NULL)
-      sscanf(aoftm_header[j], "AZ-OBS = %lf", &az);
-    if (strstr(aoftm_header[j], "EL-OBS") != NULL)
-      sscanf(aoftm_header[j], "EL-OBS = %lf", &za);
-    if (strstr(aoftm_header[j], "EQUINOX") != NULL)
-      sscanf(aoftm_header[j], "EQUINIX = %d", &equinox);
-    if (strstr(aoftm_header[j], "SOURCE") != NULL)
-      sscanf(aoftm_header[j], "SOURCE  = '%9c'",&source);
-    if (strstr(aoftm_header[j], "AZ-OBS") != NULL)
-      sscanf(aoftm_header[j], "AZ-OBS = '%lf'",&az);
-    if (strstr(aoftm_header[j], "EL-OBS") != NULL)
-      sscanf(aoftm_header[j], "EL-OBS = '%lf'",&za);
-    if (strstr(aoftm_header[j], "DATE-OBS") != NULL)
-      sscanf(aoftm_header[j], "DATE-OBS= ' %2d/%2d/%2d", &day,&month,&year);
-    if (strstr(aoftm_header[j], "TIME-OBS") != NULL)
-      sscanf(aoftm_header[j], "TIME-OBS= ' %2d:%2d:%2d", &hr,&min,&sec);
-    if (strstr(aoftm_header[j], "RA-OBS") != NULL)
-      sscanf(aoftm_header[j], "RA-OBS  = ' %2d:%2d:%.1f",&rah,&ram,&ras);
-    if (strstr(aoftm_header[j], "DEC-OBS") != NULL)
-      sscanf(aoftm_header[j], "DEC-OBS = ' %3d:%2d:%.0f",&decd,&decm,&decs);
-    if (strstr(aoftm_header[j], "NFFT") != NULL)
-      sscanf(aoftm_header[j], "NFFT = %d", &nfft);
-    if (strstr(aoftm_header[j], "NINT") != NULL)
-      sscanf(aoftm_header[j], "NINT = %d", &icount);
-    if (strstr(aoftm_header[j], "BOARD") != NULL)
-      sscanf(aoftm_header[j], "BOARD = %d", &boardno);
-    if (strstr(aoftm_header[j], "T-VECTOR") != NULL)
-      sscanf(aoftm_header[j], "T-VECTOR = %d", &test_vec);
-    if (strstr(aoftm_header[j], "BUFFERS") != NULL)
-      sscanf(aoftm_header[j], "BUFFERS = %d", &nbufs);
-    if (strstr(aoftm_header[j], "NBITS") != NULL)
-      sscanf(aoftm_header[j], "NBITS = %d", &nbits);
-    if (strstr(aoftm_header[j], "DELTA-T") != NULL)
-      sscanf(aoftm_header[j], "DELTA-T = %lf", &dt);
-    if (strstr(aoftm_header[j], "TOTAL-T") != NULL)
-      sscanf(aoftm_header[j], "TOTAL-T = %lf", &int_time);
-    if (strstr(aoftm_header[j], "FREQ") != NULL)
-      sscanf(aoftm_header[j], "FREQ = %lf", &freq);
-    if (strstr(aoftm_header[j], "BW") != NULL)
-      sscanf(aoftm_header[j], "BW = %lf", &bw);
-    if (strstr(aoftm_header[j], "RECEIVER") != NULL)
-      sscanf(aoftm_header[j], "RECEIVER='%9c'",&receiver);
-    if (strstr(aoftm_header[j], "PROJECT") != NULL)
-      sscanf(aoftm_header[j], "PROJECT ='%9c'",&projid);
-    if (strstr(aoftm_header[j], "POL_CFG") != NULL)
-      sscanf(aoftm_header[j],"POL_CFG = '%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d'",&aoftm_pol[0],&aoftm_pol[1],&aoftm_pol[2],&aoftm_pol[3],&aoftm_pol[4],&aoftm_pol[5],&aoftm_pol[6],&aoftm_pol[7],&aoftm_pol[8],&aoftm_pol[9],&aoftm_pol[10],&aoftm_pol[11],&aoftm_pol[12],&aoftm_pol[13],&aoftm_pol[14],&aoftm_pol[15]);
-    if (strstr(aoftm_header[j], "IF_CFG") != NULL)
-      sscanf(aoftm_header[j],"IF_CFG = '%lf %lf %lf %lf",&aoftm_if[0], 
-	     &aoftm_if[1], &aoftm_if[2], &aoftm_if[3]);
-    if (strstr(aoftm_header[j], "CHN_ORDR") != NULL)
-      sscanf(aoftm_header[j],"CHN_ORDR = '%d %d %d %d'",&aoftm_sgn[0],&aoftm_sgn[1],&aoftm_sgn[2],&aoftm_sgn[3]);
-    if (strstr(aoftm_header[j], "10-SEC") != NULL)
-      sscanf(aoftm_header[j], "10-SEC = %c", &tick);
-    if (strstr(aoftm_header[j], "CAL-TYPE") != NULL)
-      sscanf(aoftm_header[j], "CAL-TYPE = '%6s'", caltype);
-    if (strstr(aoftm_header[j], "SCAN-NO") != NULL)
-      sscanf(aoftm_header[j], "SCAN-NO = %d", &nscan);
-    if (strstr(aoftm_header[j], "SEEK-BGN") != NULL)
-      sscanf(aoftm_header[j], "SEEK-BGN = %d", &seek);
-    if (strstr(aoftm_header[j], "DESTINAT") != NULL)
-      sscanf(aoftm_header[j], "DESTINAT = ' %c", &dest);
-  }
-
-  mjd = (int) fmjd;
-  twobit = (nbits == 2) ? 1 : 0;
-  nchans = (twobit) ? 4*nfft : nfft;
-  strcpy(source_name,"");
-  strncat(source_name,source,9);
-  if (ras<0.0) ras=0.0;
-  if (decs<0.0) decs=0.0;
-  src_raj=(double)rah*10000.0+(double)ram*100.0+(double)ras;
-  src_dej=abs(decd)*10000.0+decm*100.0+decs;
-  if (decd<0.0) src_dej*=-1.0;
-  cel2gal(rah,ram,ras,decd,decm,decs,&glon,&glat);
-  az_start=az;
-  za_start=za;
-  tsamp=dt*1.0e-6;
-  tstart=fmjd;
-  fch1=freq+5115.0/1024.0; /* to get to the top of the band */
-  foff=bw/(double)nchans;
-  return(1);
-}
-void create_bro(int nfft) /*includefile*/
-{
-  int i,j,k;
- 
-  k = rint( log((double)nfft)/log(2.0) ); 
-  for (i=0; i<nfft; i++) {
-    BRO[i] = 0;
-    for (j=0; j<k; j++)
-      BRO[i] += ((i >> j) & 1) << (k-j-1);
-    if (i < nfft/2)
-      FOLD[nfft/2 - i - 1] = BRO[i];
-    else
-      FOLD[3*nfft/2 - i - 1] = BRO[i];
-  }
- 
-  if (nfft < 256) {
-    for (i=0; i<nfft; i++) {
-      FOLD[i] += 1;
-      if (FOLD[i] > (unsigned short)(nfft - 1)) FOLD[i] = 0;
-    }
-  }
- 
-  for (i=0; i<nfft; i++) {
-    FOLD2[FOLD[i]] = i;
-    BRO2[BRO[i]] = i;
-  }
-
-}
-void two_bit_reorder(unsigned short *spectrum, int nfft) /*includefile*/
-{
-  int i;
- 
-  for(i=0; i<nfft; i += 2){         
-    aoftm_data[FOLD2[i]]          = ((*(spectrum + i/2) >> 6) & 0x0003);
-    aoftm_data[FOLD2[i+1]]        = ((*(spectrum + i/2) >> 14) & 0x0003);
-
-    aoftm_data[FOLD2[i]+nfft]     = ((*(spectrum + i/2) >> 4) & 0x0003);
-    aoftm_data[FOLD2[i+1]+nfft]   = ((*(spectrum + i/2) >> 12) & 0x0003);
-
-    aoftm_data[FOLD2[i]+nfft*2]   = ((*(spectrum + i/2) >> 2) & 0x0003);
-    aoftm_data[FOLD2[i+1]+nfft*2] = ((*(spectrum + i/2) >> 10) & 0x0003);
-
-    aoftm_data[FOLD2[i]+nfft*3]   = ((*(spectrum + i/2) >> 0) & 0x0003);
-    aoftm_data[FOLD2[i+1]+nfft*3] = ((*(spectrum + i/2) >> 8) & 0x0003);
-  }
-
-
-
-}
-void eight_bit_reorder(unsigned short *spectrum, int nfft) /*includefile*/
-{
-  int i;
- 
-  for (i=0; i<nfft; i += 2){
-    aoftm_data[FOLD2[i]]   = (*(spectrum + i/2) & 0x00ff);
-    aoftm_data[FOLD2[i+1]] = (*(spectrum + i/2) >> 8);
-  }
-}
-void aoftm2fb(char *filename, FILE *output) /*includefile*/
-{ 
-  unsigned char data_out[1024],flip_out[1024];
-  unsigned short *p, *p0;
-  int isam,ibuf,index,rr,i,j,doit;
-  unsigned long idx[4*CHANSPERQ];
-  FILE *instream;
-  float chanif[4*CHANSPERQ], quadbw, df, realtime;
-  int nskip,iquad, ichan, iboard, swap_bytes, samples_per_buffer;
-  char message[80];
-
-  samples_per_buffer=4194304/nchans/nbits;
-
-  nskip=0;
-  twobit = (nbits == 2) ? 1 : 0;
-  nchans = (twobit) ? 4*nfft : nfft;
-
-/* rr is the number of AOFTMBLEN buffers of data to be read and stored on disk 
-(un-bit-reversed but packed); */
-
-  rr = (int) nbufs;     /* or buffer numbers */
-  rr = (nbufs < rr) ? nbufs : rr;
-
-  /* open up logfile */
-  open_log("filterbank.monitor");
-
-  create_bro(nfft);   
-  swap_bytes=little_endian();
-
-  instream=open_file(filename,"rb");
-
-  quadif[0]=50.0;quadif[1]=52.5;quadif[2]=55.0;quadif[3]=57.5;
-  quadsign[0]=quadsign[1]=quadsign[2]=quadsign[3]=-1;
-
-  if (twobit) {
-    quadbw = quadif[0]-quadif[1];
-    if (quadbw < 0.0) quadbw = -quadbw;
-    df = quadbw/(double)CHANSPERQ;
-    for (iquad=0;iquad<4;iquad++) {
-      for (j=0;j<CHANSPERQ;j++) {
-	ichan = j + iquad*CHANSPERQ;
-	chanif[ichan] = quadif[iquad]
-	  + quadsign[iquad]*((double)j*df - (quadbw-df)/2.);
-      }
-    }
-    indexx(1024,&(chanif[-1]),&(idx[-1]));
-    for (ichan=0;ichan<nchans;ichan++) idx[ichan]--;
-    
-  }
-  else {
-    for (ichan=0;ichan<CHANSPERQ;ichan++) {
-      if (quadsign[1] < 0.) 
-	idx[ichan] = nchans-ichan-1; 
-      else 
-	idx[ichan] = ichan;
-    }
-  }
-  
-  /* loop over rr buffers, un-bit-reversing one sample at a time, and 
-     writing packed data to disk */
-
-  for (ibuf=0; ibuf<rr; ibuf++) {
-    realtime=(float)tsamp*(float)samples_per_buffer*(float)ibuf;
-    if ( (doit=process(realtime,start_time,final_time)) == -1) break;
-      if (fread(buffer, 2, AOFTMBLEN/2, instream) != AOFTMBLEN/2) {
-	/*fprintf(stderr, "End of data at buffer %d\nbuf", ibuf+1);*/
-	rr = ibuf + 1;
-	break;          /* buffers are 2 byte values */
-      }
-    if (doit) {
-      sprintf(message,"time:%.1fs",realtime);
-      update_log(message);
-      if (swap_bytes) 
-	for (isam=0;isam<AOFTMBLEN/2;isam++) swap_short(&buffer[isam]);
-      
-      for (isam = 0; isam<AOFTMBLEN/nfft; isam++) {
-	p = &(buffer[isam*nfft/2]);
-	if (twobit) {
-	  two_bit_reorder(p,nfft);
-	  for (ichan=0; ichan<nchans; ichan++) {
-	    index = idx[ichan];
-	    if (aoftm_data[index] == 1) 
-	      aoftm_data[index] = 3;
-	    else if (aoftm_data[index] == 0) 
-	      aoftm_data[index] = 2;
-	    else if (aoftm_data[index] == 3) 
-	      aoftm_data[index] = 1;
-	    else 
-	      aoftm_data[index] = 0;
-	    data_out[ichan] = (unsigned char) aoftm_data[index];
-	  }
-	} else {
-	  eight_bit_reorder(p,nfft); 
-	  for (ichan=0; ichan<nchans; ichan++) {
-	    index = idx[ichan];
-	    data_out[ichan] = (unsigned char) aoftm_data[index];
-	  }
-	}
-	j=nchans;
-	for (i=0;i<nchans;i++) flip_out[i]=data_out[--j]; 
-	if (fwrite(flip_out, 1, nchans, output) != nchans) {
-	  fprintf(stderr,"Couldn't write AOFTM data!\n");
-	  close(instream);
-	  exit(-1);
-	}
-      }
-    }
-  }
-  close(instream);
-}
-
-
-
diff --git a/filterbank-gmrt/bacspin.h b/filterbank-gmrt/bacspin.h
deleted file mode 100644
index 56f5843..0000000
--- a/filterbank-gmrt/bacspin.h
+++ /dev/null
@@ -1,233 +0,0 @@
-/*
- * PSPM timing header definition.
- * 
- * Be VERY careful about making changes to this file as it may 
- * compromise your ability to read existing data headers from
- * old data.
- *
- * To maintain portability it is explicitly assumed that:
- * double = 8Bytes,
- * long = 4Bytes,
- * and that doubles start on an even word boundary.
- *
- *
- * For the paranoid, add the following code fragment to the beginning
- * of your programs:
- *
- * if ( sizeof(PSPM_TIMING_HEADER) != PSPM_HEADER_SIZE )
- *      some error message;
- *
- *
- * $Log: pspm_timing_header.h,v $
- * Revision 1.5  1999/01/17 01:02:14  sba
- * added initial_phase_offset and stctime to BPP section
- *
- * Revision 1.4  1998/08/04 01:07:42  cadwell
- * fixed header size for BPPs by adding 8 to the filler array
- *
- * Revision 1.3  1998/08/03 20:10:08  cadwell
- * added new BPP entries tick_offset and startup_latency
- * NUM_LO_BOARDS -> MAX_NUM_LO_BOARDS
- * NUM_MF_BOARDS -> MAX_NUM_MF_BOARDS
- *
- * Revision 1.2  1998/07/17 00:04:12  sba
- * Switched to using rcsid.h macros to put RCS Id strings in executables
- *
- * Revision 1.1  1998/02/25 01:09:39  sba
- * Initial revision
- *
- *
- */
-
-#ifndef _PSPM_TIMING_HEADER_H
-#define _PSPM_TIMING_HEADER_H
-
-#ifndef PSPM_TIMING_HEADER_SIZE
-#define PSPM_TIMING_HEADER_SIZE	(1<<15)
-#endif
-
-#define MAXNUMCB 6
-#define MAXNUMDFB (2*MAXNUMCB)
-#define MAX_NUM_LO_BOARDS MAXNUMCB
-#define MAX_NUM_MF_BOARDS (2*MAX_NUM_LO_BOARDS)
-#define FB_CHAN_PER_BRD                   8
-#define MAX_HARRIS_TAPS                 256
-
-#define	TIMING_TYPE		1	/* 2d array of unsigned longs	*/
-#define	TIMING_LONG_TYPE	1	/* 2d array of unsigned longs	*/
-#define	TIMING_FLOAT_TYPE	3	/* 2d array of floats		*/
-
-
-
-typedef struct {
-  
-    /* In this part, double=8bytes, long=4bytes, if not, fix it! */
-
-    char head[16]; /* Holds "NBPPTIME\0" */
-
-    long header_version;	/* Version number which is different for each backend */
-
-    long scan_num;		/* Scan number e.g. 31096001 = Obs 1 on day 310 of 1996 */
-    
-
-    double psr_period;
-    double samp_rate;		/* Sample rate in (us). Note, in the case    */
-				/* of oversampling this is the integrated    */
-				/* sample rate not the hardware rate.	     */
-    double psr_dm;
-    double length_of_integration; /* An estimate that does NOT take into     */
-				/* account the doppler corrections to	     */
-				/* samp_rate.  For true integration time,    */
-				/* the polyco.dat entry appended on the end  */
-				/* of the scan must be consulted.	     */
-    char psr_name[16];
-
-    long scan_file_number;	/* Which file number of the scan?	     */
-    long stc;			/* Unused, use stctime instead.		     */
-    long num_phase_bins;
-    long num_periods;		/* exact number of pulse periods integrated  */
-    long sizeof_polyco;
-    long oversample;		/* How many hardware samples are integrated  */
-				/* before accumulating in the pulse profile  */
-				/* (note, a 0 should be interpreted as a 1). */
-
-
-    /* These doubles are all aligned on 8-byte boundaries */
-    double ra_1950;		/* Radians */
-    double dec_1950;		/* Radians */
-    double tele_x;		/* Carriage X position in m */
-    double tele_y;		/* Carriage Y position in m */
-    double tele_z;		/* Carriage Z position in m */
-    double tele_inc;		/* Mirror inclination in deg */
-    double Fclk;		/* Fast clock speed (Hz) */
-    double Har_Clk;		/* Harris clock (H_deci_factor*bandwidth) */
-    double bandwidth;		/* DSB channel bandwidth (== Sclk) */
-    double dfb_gain[MAXNUMDFB];	/* Gain that was applied to generate Harris coeffs */
-
-    /*
-     * AIB Configuration
-     */
-    double aib_los[MAX_NUM_LO_BOARDS];
-    double mf_filt_width[MAX_NUM_MF_BOARDS];
-    double mf_atten[MAX_NUM_MF_BOARDS];
-    double rf_lo;		/* LO frequency used in the receiver to generate the IF */
-
-    long bit_mode;		/* 4 = 4-bit power, -4 = 4-bit voltage in direct mode */
-    long num_chans;		/* Calculated number of 4-bit channels in each sample */
-    int lmst;			/* LMST time in seconds since 0h */
-    char target_name[32];	/* Space for pulsar name or map name for survey */
-    char date[16];		/* UT date which will match the scan number */
-    char start_time[16];	/* UT time of the 1pps tick which started the obs*/
-    long file_size;		/* Size of this file */
-    long tape_num;		/* Tape number */
-    long tape_file_number;	/* File number on this tape */
-    char obs_group[16];		/* Who did the observation (mainly for future) */
-
-    int enabled_CBs;		/* Bitmap of enabled CBs */
-    int mb_start_address;	/* Real base (8-bit) address of first CB reg read */
-    int mb_end_address;		/* Read end (8-bit) address of last CB reg read */
-    int mb_start_board;		/* First board ID read */
-    int mb_end_board;		/* last board ID read (MB can only read seq. boards) */
-    int mb_vme_mid_address;	/* Value stored in VME_MID register (usu. 00) */
-    int mb_ack_enabled;		/* Boolean, did we use ACK protocol? */
-    int start_from_ste;		/* Boolean, am I starting with the STE counter? */
-
-    /*
-     * CB Registers
-     */
-    int cb_sum_polarizations;	/* Boolean, did the CBs sum pols on-board? */
-    int cb_direct_mode;		/* Boolean, did we read the CBs in direct-mode? */
-    int cb_eprom_mode[MAXNUMCB]; /* Which EPROM table? (MAXNUMCB=6) */
-    int cb_accum_length;	/* Contents of CB accum len regs (all CBs IDENTICAL) */
-				/* cb_accum_length is TOTAL accum length, not accum_len-1 */
-
-    /**
-     * TB Registers
-     */
-    int tb_outs_reg;	/* OUTS_REG, turns on/off analog supply and PLLs */
-    int tb_ste;		/* Value stored in STE counter */
-    int tb_stc;		/* This need to be read AFTER an integration!!! */
-    int  H_deci_factor;	/* Decimation factor */
-    int GenStat0, GenStat1, Ack_Reg; /* HW registers, for debugging */
-
-    /*
-     * DFB Registers
-     */
-    /* These first three are the "logical" state of the DFBs */
-    int dfb_sram_length;	/* Same for every board??? */
-    int ASYMMETRIC;		/* Currently the same for all boards */
-    float dfb_sram_freqs[FB_CHAN_PER_BRD]; /* Filled in by setmixer_board (8) */
-
-    /* These three are for HW debugging, not to be used by analysis software */
-    int dfb_mixer_reg[MAXNUMDFB]; /* Set by set_dfb_mixer (MAXNUMDFB=12) */
-    int dfb_conf_reg[MAXNUMDFB];  /* Set by set_dfb_conf */
-    int dfb_sram_addr_msb[MAXNUMDFB]; /* Set by set_dfb_conf */
-
-    /* These are the ACTUAL Harris taps loaded into the DFBs */
-    int i_hcoef[MAX_HARRIS_TAPS]; /* MAX_HARRIS_TAPS=256 */
-    int q_hcoef[MAX_HARRIS_TAPS];
-
-
-    /*
-     * Hardware configuration
-     */
-    int tb_id;
-    int cb_id[MAXNUMCB];
-    int dfb_id[MAXNUMDFB];
-
-    int aib_if_switch;	/* Which IF input are we using? (Same for both Pols) */
-
-    /* matt add new stuff here */
-    /* Additional Hardware information, 97apr25 MRD */
-    int	mb_rev, mb_serial;
-    int	tb_rev, tb_serial;
-    int	cb_rev[MAXNUMCB], cb_serial[MAXNUMCB];
-    int	dfb_rev[MAXNUMDFB], dfb_serial[MAXNUMDFB];
-    int	mb_xtal_freq;
-    int	mf_serial[MAX_NUM_MF_BOARDS], mf_rev[MAX_NUM_MF_BOARDS];
-    int	lo_serial[MAX_NUM_LO_BOARDS], lo_rev[MAX_NUM_LO_BOARDS];
-
-    int	mb_long_ds0;		/* lengthen DS0 on vme reads with ack enabled */
-    int	dfb_sun_program[MAXNUMDFB];	/* Set by set_dfb_mode */
-    int	dfb_eprom[MAXNUMDFB];		/* Set by set_dfb_mode */
-    int	dfb_sram_addr[MAXNUMDFB];       /* rev 4 Set by set_dfb_conf */
-    int	dfb_har_addr[MAXNUMDFB];        /* rev 4 Set by set_dfb_conf */
-    int	dfb_clip_adc_neg8[MAXNUMDFB];	/* for use in DFB mixer table */
-    int	dfb_shften_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_fwd_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_rvrs_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_asymmetric[MAXNUMDFB];	/* what kind of taps to load ? */
-    double dfb_i_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double dfb_q_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double max_dfb_freq;                /* used in picking decimations */
-
-    int aib_serial;
-    int aib_rev;
-
-    double tick_offset;		        /* delay from 1sec tick to start time (usec) */
-    double startup_latency;	        /* estimated (by Matt?) time delay through */
-                                        /* system (usec) */
-    double initial_phase_offset;	/* Time offset to correct start time */
-					/* from first sample at an arbitrary */
-					/* phase to the start time of the    */
-					/* first folded phase bin (sec).     */
-    double stctime;			/* STC counter converted to sec.     */
-
-    char filler[28746];
-    long BACKEND_TYPE;
-    long UPDATE_DONE;
-    long HEADER_TYPE;
-
-} PSPM_TIMING_HEADER;
-
-
-/*
- * Prototypes.
- */
-int update_timing_header( int polysize, PSPM_TIMING_HEADER *t_h );
-int update_params( PSPM_TIMING_HEADER *t_h );
-
-#endif /* _PSPM_TIMING_HEADER_H */
-
-
-
diff --git a/filterbank-gmrt/bandfactors.c b/filterbank-gmrt/bandfactors.c
deleted file mode 100644
index e0bd2f4..0000000
--- a/filterbank-gmrt/bandfactors.c
+++ /dev/null
@@ -1,20 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-double *bandfactors(int nchans) /*includefile*/
-{
-  FILE *file;
-  double *corrfactor,dtmp;
-  int j;
-  float temp;
-
-  corrfactor = (double *) malloc(nchans * sizeof(double));
-  /* read in bandpass correction factors from file "file" */
-  file=open_file("bandfactors","r");
-  for (j=0; j<nchans; j++) {
-    fscanf(file,"%f %lf",&temp,&dtmp);
-    corrfactor[j]=dtmp;
-  }
-  close(file);
-
-  return(corrfactor);
-}
diff --git a/filterbank-gmrt/bandpass.c b/filterbank-gmrt/bandpass.c
deleted file mode 100644
index 42d10e8..0000000
--- a/filterbank-gmrt/bandpass.c
+++ /dev/null
@@ -1,128 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include "sigproc.h"
-#include "header.h"
-FILE *input;
-main(int argc, char *argv[])
-{
-  char string[80];
-  int increment=0,i,j,k,l,ndumps,ic,x,y,cube,dumpcount;
-  double elapsed_time;
-  unsigned char c;
-  unsigned short s;
-  float *f,*g,temp,fchan;
-  double secsperdump;
-
-  /* default is to read from standard input and to sum all dumps */
-  input=stdin;
-  ndumps=cube=dumpcount=0;
-  secsperdump=elapsed_time=0.0;
-
-  /* check command-line parameters */ 
-  i=1;
-  while (i<argc) {
-    print_version(argv[0],argv[1]);
-    if (strings_equal(argv[i],"-d")) {
-      i++;
-      ndumps=atoi(argv[i]);
-    } else if (strings_equal(argv[i],"-t")) {
-      i++;
-      secsperdump=atof(argv[i]);
-    } else if (help_required(argv[i])) {
-      bandpass_help();
-      exit(0);
-    } else if (strings_equal(argv[i],"-cube")) {
-      cube=1;
-    } else if (file_exists(argv[i])) {
-      input=open_file(argv[i],"rb");
-    } else {
-      bandpass_help();
-      sprintf(string,"unknown argument (%s) passed to bandpass",argv[i]);
-      error_message(string);
-    }
-    i++;
-  }
-
-  if (!read_header(input)) 
-    error_message("could not read filterbank header...");
-
-  /* set number of dumps to average over if user has supplied seconds */
-  if (secsperdump > 0.0) 
-    ndumps = (int) rint(secsperdump/tsamp);
-
-  /* initialize buffer for storing bandpass */
-  ic=nchans*nifs;
-  f = (float *) malloc(sizeof(float)*ic);
-  g = (float *) malloc(sizeof(float)*ic);
-  for (i=0; i<ic; i++) f[i]=g[i]=0.0;
-  k=l=0;
-  while (!feof(input)) {
-    switch (nbits) {
-    case 4:
-      fread(&c,1,1,input);
-      char2ints(c,&x,&y);
-      f[l]=(float) x;
-      l++;
-      f[l]=(float) y;
-      break;
-    case 8:
-      fread(&c,nbits/8,1,input);
-      f[l]=(float) c;
-      break;
-    case 16:
-      fread(&s,nbits/8,1,input);
-      f[l]=(float) s;
-      break;
-    case 32:
-      fread(&temp,nbits/8,1,input);
-      f[l]=temp;
-      break;
-    default:
-      sprintf(string,"cannot read %d bits per sample...\n",nbits);
-      error_message(string);
-      break;
-    }
-    l++;
-    if (l==ic) {
-      for (i=0;i<ic;i++) g[i]+=f[i];
-      k++;
-      if (k==ndumps) {
-	dumpcount++;
-	if (!cube) puts("#START");
-	for (i=0; i<nchans; i++) {
-	  fchan=fch1+(foff*(double) i);
-	  if (cube) printf("%f ",elapsed_time);
-	  printf("%f ",fchan);
-	  for (j=0; j<nifs; j++) {
-	    l=j*nchans+i;
-	    printf("%f ",g[l]/(float)ndumps);
-	    g[l]=f[l]=0.0;
-	  }
-	  printf("\n");
-	}
-	if (!cube) puts("#STOP");
-	k=0;
-      }
-      l=0;
-      if (cube) {
-	elapsed_time+=tsamp;
-	if (dumpcount==nchans) exit(0);
-      }
-    }
-  }
-
-  /* write out final dump if necessary */
-  if (!ndumps) {
-    ndumps=k;
-    for (i=0; i<nchans; i++) {
-      fchan=fch1+(foff*(double) i);
-      printf("%f ",fchan);
-      for (j=0; j<nifs; j++) {
-	l=j*nchans+i;
-	printf("%f ",g[l]/(float)ndumps);
-      }
-      printf("\n");
-    }
-  }
-}
diff --git a/filterbank-gmrt/barycentre.c b/filterbank-gmrt/barycentre.c
deleted file mode 100644
index 8d3c9da..0000000
--- a/filterbank-gmrt/barycentre.c
+++ /dev/null
@@ -1,239 +0,0 @@
-/* 
-   barycentre.c - refer a filterbank/timeseries file to the rest
-   frame of the solar system barycentre by computing an appropriate
-   set of polynomial coefficients for the data sampling interval,
-   then keeping track of the difference between elapsed time (topo)
-   versus the time computed from the coefficients (barycentric) and
-   adding or removing time samples so that the two timescales stay
-   fixed. Added samples are set to zero.
-*/
-#include "dedisperse.h"
-char polyco_filename[80];
-double fcent;
-/* subroutine to call TEMPO to calculate a polyco.bar file for barycentering */
-char *make_polycofile(char ra[],char dec[],char topo[], char site,
-			    double mjdtopo, double tsamp)
-{
-  FILE *resid2,*parfile, *tzfile;
-  float junk;
-  double mjdbary;
-  char *polycofilename;
-  polycofilename=(char *) malloc(80);
-
-  parfile=fopen("tssb.par","w");
-  fprintf(parfile,"PSR 0000+00\n");
-  fprintf(parfile,"RAJ %s\n",ra);
-  fprintf(parfile,"DECJ %s\n",dec);
-  fprintf(parfile,"F0 1.0\n");
-  fprintf(parfile,"DM 0.0\n");
-  fprintf(parfile,"PEPOCH %s\n",topo);
-  fclose(parfile);
-  tzfile=fopen("tz.in","w");
-  fprintf(tzfile,"%c    2  30  9 %.0lf\n",site,fcent);
-  fprintf(tzfile,"\n \n");
-  fprintf(tzfile,"0000+00 60 9 12 %.0lf\n",fcent);
-  fclose(tzfile);
-  tzfile=fopen("runtempo.csh","w");
-  fprintf(tzfile,"#!/bin/csh\n",site);
-  fprintf(tzfile,"tempo -z -f tssb.par << EOD\n");
-  fprintf(tzfile,"%f %f\n",mjdtopo-1.0,mjdtopo+1.0);
-  fprintf(tzfile,"EOD");
-  fclose(tzfile);
-  system("csh runtempo.csh > /dev/null");
-  system("mv polyco.dat polyco.bar");
-  system("rm -f tssb.par tz.in tz.tmp");
-  system("rm -f fort.22 tempo.lis runtempo.csh ");
-  strcpy(polycofilename,"polyco.bar");
-  return(polycofilename);
-}
-
-/* subroutine to call TEMPO to calculate the barycentric MJD */
-double barycentric_time(char ra[],char dec[],char topo[], char site,
-			    double mjdtopo)
-{
-  FILE *resid2,*parfile, *timfile;
-  float junk;
-  double mjdbary;
-  parfile=fopen("tssb.par","w");
-  fprintf(parfile,"PSR 0000+00\n");
-  fprintf(parfile,"RAJ %s\n",ra);
-  fprintf(parfile,"DECJ %s\n",dec);
-  fprintf(parfile,"F0 1.0\n");
-  fprintf(parfile,"DM 0.0\n");
-  fprintf(parfile,"PEPOCH %s\n",topo);
-  fclose(parfile);
-  timfile=fopen("tssb.tim","w");
-  fprintf(timfile,"%c    0  0000+00 %.3lf %.13f     1.00\n",site,fcent,mjdtopo);
-  fprintf(timfile,"%c    0  0000+00 %.3lf %.13f     1.00\n",site,fcent,mjdtopo);
-  fprintf(timfile,"%c    0  0000+00 %.3lf %.13f     1.00\n",site,fcent,mjdtopo);
-  fclose(timfile);
-  system("tempo tssb.tim > /dev/null");
-  resid2=fopen("resid2.tmp","r");
-  fread(&junk,4,1,resid2);
-  fread(&mjdbary,8,1,resid2);
-  fclose(resid2);
-  system("rm -f tssb.tim tssb.par 0000+00.par");
-  system("rm -f matrix.tmp tempo.lis resid2.tmp ");
-  return(mjdbary);
-}
-
-char inpfile[80], outfile[80];
-main (int argc, char *argv[]) 
-{
-  int drop,add,i,j,n,ntim,headersize,rah,ram,ded,dem;
-  int ndropped=0,nadded=0,nbytes_per_sample,verbose=0,mypolyco=0;
-  unsigned char *rawdata, *dummy;
-  double mjd, elapsed_time, barycentre_time;
-  double ras,des,mjdbary;
-  char ra[80], dec[80], topo[80], sra[6], sde[6], site;
-  char message[80];
-  struct POLYCO polyco;
-  FILE *polycofile;
-
-  if (argc<2 || help_required(argv[1])) {
-    barycentre_help();
-    exit(0);
-  }
-  print_version(argv[0],argv[1]);
-  if (!file_exists(argv[1]))
-    error_message("input file does not exist!");
-
-  strcpy(inpfile,argv[1]);
-  input=open_file(inpfile,"r");
-  strcpy(outfile,"stdout");
-  output=stdout;
-
-  i=2;
-  while (i<argc) {
-    if (strings_equal(argv[i],"-verbose")) 
-      verbose=1;
-    if (strings_equal(argv[i],"-mypolyco")) 
-      mypolyco=1;
-    i++;
-  }
-
-  if ((headersize=read_header(input))) {
-
-    /* calculate centre frequency for use in TEMPO files */
-    fcent=fch1+(double)(nchans/2)*foff;
-    /* parse the header parameters for RA */
-    angle_split(src_raj,&rah,&ram,&ras);
-    if (ras<10.0) {
-      sprintf(sra,"0%.1f",ras);
-    } else {
-      sprintf(sra,"%.1f",ras);
-    }
-    sprintf(ra,"%02d:%02d:%s",rah,ram,sra);
-    /* parse the header parameters for DEC */
-    angle_split(src_dej,&ded,&dem,&des);
-    if (des<10.0) {
-      sprintf(sde,"0%.1f",des);
-    } else {
-      sprintf(sde,"%.1f",des);
-    }
-    sprintf(dec,"%02d:%02d:%s",ded,dem,sde);
-    /* now call TEMPO to calculate the barycentric MJD */
-    sprintf(topo,"%.12f",tstart);
-    site=tempo_site(telescope_id);
-    if (verbose) 
-      fprintf(stderr,"Telescope: %s TEMPO site code: %c\n",
-	      telescope_name(telescope_id),site);
-    if (mypolyco) {
-      strcpy(polyco_filename,"polyco.bar");
-      if (verbose)
-      fprintf(stderr,"Using barycentric polyco file: %s\n",polyco_filename);
-    } else {
-      strcpy(polyco_filename,make_polycofile(ra,dec,topo,site,tstart,tsamp));
-      if (verbose)
-      fprintf(stderr,"Created barycentric polyco file: %s\n",polyco_filename);
-    }
-      
-    barycentric=1;
-    mjdbary=barycentric_time(ra,dec,topo,site,tstart);
-    if (verbose) {
-      fprintf(stderr,"Topocentric MJD %.12f\n",tstart);
-      fprintf(stderr,"Barycentric MJD %.12f\n",mjdbary);
-    }
-    /* write out header with barycentric MJD if required */
-    send_string("HEADER_START");
-    send_int("telescope_id",telescope_id); 
-    send_int("machine_id",machine_id);
-    send_coords(src_raj,src_dej,az_start,za_start);
-    send_int("data_type",data_type);
-    send_int("barycentric",1);
-    send_int("pulsarcentric",0);
-    if (nchans==1) send_double("refdm",refdm);
-    if (fch1 == 0.0) 
-      send_double("fch1",frequency_table[0]);
-    else
-      send_double("fch1",fch1);
-    send_int("nchans",nchans);
-    if (nchans>1) send_double("foff",foff);
-    send_int("nbits",nbits);  
-    send_int("nifs",nifs);  
-    send_double ("tstart",mjdbary); 
-    send_double("tsamp",tsamp);
-    send_string("HEADER_END");
-    open_log("barycentre.monitor");
-
-    ntim=nsamples(inpfile,headersize,nbits,nifs,nchans);
-    mjd=tstart;
-    polycofile=open_file(polyco_filename,"r");
-    if (!read_polycoset(polycofile,&polyco)) {
-      error_message("depolyco: error reading polyco file");
-    } else {
-      get_nearest_polyco(polyco_filename,mjd,&polyco);
-    }
-
-    i=n=drop=add=0;
-    nbytes_per_sample=nchans*nbits*nifs/8;
-    dummy=(char *) malloc(nbytes_per_sample);
-    for (j=0;j<nbytes_per_sample;j++) dummy[j]=0;
-    elapsed_time=barycentre_time=0.0;
-    while (i<ntim) {
-      n++;
-      elapsed_time+=tsamp;
-      barycentre_time+=tsamp*polyco_period(mjd,polyco);
-      if (elapsed_time-barycentre_time>tsamp) {
-	add=1;
-	elapsed_time-=tsamp;
-      } else if (barycentre_time-elapsed_time>tsamp) {
-	drop=1;
-	elapsed_time+=tsamp;
-      }
-      if (drop || add) {
-	rawdata=(char *) malloc(n*nbytes_per_sample);
-	fread(rawdata,1,n*nbytes_per_sample,input);
-	if (drop) {
-	  ndropped++;
-	  fwrite(rawdata,1,(n-1)*nbytes_per_sample,output);
-	} else {
-	  nadded++;
-	  fwrite(rawdata,1,n*nbytes_per_sample,output);
-	  fwrite(dummy,1,nbytes_per_sample,output);
-	}
-	n=0;
-	free(rawdata);
-	drop=add=0;
-        sprintf(message,"time:%.1fs",elapsed_time);
-        update_log(message);
-      }
-      mjd+=tsamp/86400.0;
-      get_nearest_polyco(polyco_filename,mjd,&polyco);
-      i++;
-    }
-    if (n) {
-      rawdata=(char *) malloc(n*nbytes_per_sample);
-      fread(rawdata,1,n*nbytes_per_sample,input);
-      fwrite(rawdata,1,n*nbytes_per_sample,output);
-      free(rawdata);
-    }
-    free(dummy);
-    update_log("finished");
-    close_log("barycentre.monitor");
-    if (verbose && nadded)
-      fprintf(stderr,"added %d samples\n",nadded);
-    if (verbose && ndropped)
-      fprintf(stderr,"dropped %d samples\n",ndropped);
-  }
-}
diff --git a/filterbank-gmrt/baseline.f b/filterbank-gmrt/baseline.f
deleted file mode 100644
index 6959676..0000000
--- a/filterbank-gmrt/baseline.f
+++ /dev/null
@@ -1,62 +0,0 @@
-c==============================================================================
-	subroutine baseline(llog)
-c==============================================================================
-c
-c       Subtracts a SLOPING baseline from the time series contained in the
-c       array series(ntim). Writes out the mean which is then subtracted
-c       The time series is then normalized so that the rms is unity.
-c
-c	22/03/98 (dunc@mpifr-bonn.mpg.de)
-c
-c==============================================================================
-	implicit none
-        include 'time.inc'
-	integer llog,i,j,nrun,nrav
-	parameter(nrav=32)
-	real mean,sums,sumd,rssq(nrav),rsum(nrav),var,mea,msq,rms
-	real x(nrav),y(nrav),z(nrav),e(nrav),slope,inter,eslo,eint
-	
-	sumd=0.0
-	do i=1,nrav
-	   rsum(i)=0.0
-	   rssq(i)=0.0
-	enddo
-	nrun=ntim/nrav
-	
-	do i=1,ntim
-	  j=min(nrav,i/nrun+1)
-	  rsum(j)=rsum(j)+series(i)
-	  rssq(j)=rssq(j)+series(i)*series(i)
-	  sumd=sumd+series(i)
-        enddo
-	mean=sumd/real(ntim)
-
-	do i=1,nrav
-	   mea=rsum(i)/real(nrun)
-	   msq=rssq(i)/real(nrun)
-	   var=sqrt(msq-mea*mea)
-	   j=nrun/2+(i-1)*nrun
-	   x(i)=i
-	   y(i)=mea
-	   e(i)=var/sqrt(real(nrun))
-	enddo
-	call slfit(x,y,z,nrav,e,.false.,inter,slope,eint,eslo)
-	write(llog,*) 'Subtracting mean from function:',inter,slope
-
-	do i=1,ntim
-	  mean=inter+slope*real(i)*real(nrav)/real(ntim)
-	  series(i)=series(i)-mean
-	enddo
-	
-	sums=0.0
-	do i=1,ntim
-	  sums=sums+series(i)*series(i)
-        enddo
-	rms=sqrt(sums/real(ntim))
-
-	do i=1,ntim
-          series(i)=series(i)/rms
-        enddo
-
-        write(llog,*) 'Time series now has zero mean and unit rms...'
-	end
diff --git a/filterbank-gmrt/best.f b/filterbank-gmrt/best.f
deleted file mode 100644
index a9f120e..0000000
--- a/filterbank-gmrt/best.f
+++ /dev/null
@@ -1,965 +0,0 @@
-c==============================================================================
-      program best
-c==============================================================================
-c
-c     Looks through the .prd files to find the best candidates
-c     from the analysis... (dunc@mpifr-bonn.mpg.de - November 1997)
-c
-c     Modification history:
-c
-c     98/02/02 -> dunc@mpifr-bonn.mpg.de - Acceleration options added
-c     98/06/12 -> dlorimer@naic.edu      - code overhauled and commented
-c                                        - harmonic zapping simplified
-c                                        - -p option implemented
-c     98/07/01 -> dunc@mpifr-bonn.mpg.de - -z option implemented
-c                                        - directory etc listed on plot      
-c     98/07/11 -> dunc@mpifr-bonn.mpg.de - -L and -H options implemented
-c     98/07/15 -> dunc@mpifr-bonn.mpg.de - -a option no longer necessary
-c                                        - adot read in and 2-D plot
-c     98/07/17 -> dunc@mpifr-bonn.mpg.de - ".fld" file with folding commands
-c     98/09/26 -> dunc@mpifr-bonn.mpg.de - assumes DM search if only one list
-c     98/11/24 -> dunc@naic.edu          - corrected DM/ACIDX output feature
-c     99/04/21 -> dunc@naic.edu          - added -F and -C options to calculate
-c                                        - whether a candidate gets DM smeared
-c     02/10/22 -> drl@jb.man.ac.uk       - -z option done by default -i inverts
-c                                        - harmonic checking only for <16*P
-c                                        - -t option allows tracing candidates
-c      
-c==============================================================================
-c
-      implicit none
-
-      include 'vers.inc'
-      
-      character*80 filename,option,title*160,susfile,cline,prf,ps
-      character*70 string(10),period,acceln,accdot,dmidx*4,dmval*8
-
-      integer fold,nc,mc,nt,mt,lst,lun2,lun3,lsum,length,mg,ngx,ngy
-      integer ngz,ndmi,ndmm
-      parameter(mt=5000,mc=mt*512,mg=256)
-
-      real*8 par(mc),ratio, ratio2
-      
-      real snr(mc), dm(mt), ac(mt), ad(mt), x(mt), y(mt), ymin,
-     &     dmdsp, dd(mt), snrmax, snrmin, prdmin, prdmax, ymax,
-     &     parmin(3), parmax(3), grid(mg,mg), tr(6), xmin, xmax,
-     &     xval(mg), yval(mg), gridmin, gridmax, deltax, deltay,
-     &     xx, yy, fcentre, chbandw,zval(mg)
-
-      integer trid(mc),cidx(mc),i,j,k,l,sidx(mc),nids(mc),ndm
-      integer narg,iargc,fld(mc),nsus,nf,mode,ix,iy,gidx,iz,bb
-
-      logical lview, prd, frq, plotit, autop, harm, test, hzap,
-     &        ok, lac, ldm, lad, consider, laccn, smeared, trace,
-     &     lmode5
-c
-c==============================================================================
-c
-c     un-comment these lines if floating point exceptions
-c     occur (heaven forbid!)
-c
-c      external myhandler
-c      integer ieee_handler
-c
-c  TRAP DIVISION BY ZERO ERRORS and NaN
-c      i=ieee_handler("set","common",myhandler)
-c==============================================================================
-c
-c     If no command line input given - tell user what to do...
-c
-      lmode5 = .false.
-      narg=iargc()
-      call getarg(1,option)
-      if (option.eq.'version'.or.option.eq.'-version') then
-         write(*,'(a,a)') 'PROGRAM: best ',version
-         stop
-      endif
-      if (narg.lt.1.or.option.eq.'-help'.or.option.eq.'help') call help
-c
-c     Get filename and initialise some flags and variables
-c
-      call getarg(1,filename)
-      lst=length(filename)-4
-      cline='best '//filename(1:length(filename))
-      l=length(cline)
-      prd=index(filename,'.prd').gt.0.or.index(filename,'.top').gt.0
-      frq=.not.prd
-      fold=0
-      autop=.false.
-      snrmin=8.0
-      prdmin=0.0
-      prdmax=1.0e32
-      lview=.false.
-      hzap=.true.
-      trace=.false.
-      do i=1,2
-         parmin(i)=-1.0e32
-         parmax(i)=+1.0e32
-      enddo
-      chbandw=0.0
-      fcentre=1.0
-c
-c     Sort out command-line arguments
-c
-      if (narg.gt.1) then
-        do i=2,narg
-          call getarg(i,option)
-          cline=cline(1:l)//' '//option(1:length(option))
-          l=length(cline)
-          if (index(option,'-f').gt.0) read(option(3:),*) fold
-          if (index(option,'-s').gt.0) read(option(3:),*) snrmin
-          if (index(option,'-l').gt.0) read(option(3:),*) prdmin
-          if (index(option,'-h').gt.0) read(option(3:),*) prdmax 
-          if (index(option,'-L').gt.0) read(option(3:),*) parmin(1)
-          if (index(option,'-H').gt.0) read(option(3:),*) parmax(1) 
-          if (index(option,'-F').gt.0) read(option(3:),*) fcentre
-          if (index(option,'-C').gt.0) read(option(3:),*) chbandw
-          if (index(option,'-v').gt.0) lview=.true.
-          if (index(option,'-p').gt.0) autop=.true.
-          if (index(option,'-z').gt.0) hzap=.true.
-          if (index(option,'-i').gt.0) hzap=.false.
-          if (index(option,'-t').gt.0) trace=.true.
-        enddo
-      endif
-c
-c     Write out the command line inputs to a filename.bst file
-c     so that the action can be repeated at a later date......
-c      
-      call glun(lun2)
-      open(unit=lun2,file=filename(1:lst)//'.bst',status='unknown')
-      write(lun2,'(a)') cline(1:length(cline))
-      close(unit=lun2)
-c
-c     Read in the candidates from the ".prd" or ".frq" file...
-c
-      write(*,'('' File: '',a)') filename(1:index(filename,' ')-1)
-      nc=0
-      nt=0
-      if (fold.eq.0) then
-         write(*,*) 'Folds: 1-5'
-         do fold=1,5
-            call readsus(filename, fold, mc, nc, mt, nt,
-     &                   par, snr, trid, fld, dm, ac, ad)
-         enddo
-	 nf=5
-      else
-            write(*,*) 'Fold:',fold
-            call readsus(filename, fold, mc, nc, mt, nt,
-     &                   par, snr, trid, fld, dm, ac, ad)
-	 nf=1
-      endif
-c
-c     Look at dm,ac+ad arrays to establish parameter space of search
-c
-      ldm=.false.
-      lac=.false.
-      lad=.false.
-      mode=0
-      if (nt.eq.5.and.nf.eq.5) then
-         ldm=.true. ! assume DM search if only one list
-         mode=1
-      else
-         do i=1,nt
-            if (i.gt.1.and.dm(i).ne.dm(i-1)) ldm=.true.
-            if (ac(i).ne.0.0) lac=.true.
-            if (ad(i).ne.0.0) lad=.true.
-         enddo
-      endif
-      if (ldm.and.(.not.lac).and.(.not.lad)) then
-         write(*,*) '1-D DM search...'
-         mode=1
-      else if ((.not.ldm).and.(lac.or.lad)) then
-         if (lac.and.(.not.lad)) then
-            write(*,*) '1-D AC search...'
-            mode=2
-         else if (lad.and.(.not.lac)) then
-            write(*,*) '1-D AD search...'
-            mode=3
-         else if (lad.and.lac) then
-            write(*,*) '2-D AC+AD search...'
-            mode=4
-         endif
-
-      else if(ldm.and.(lac.and.lad)) then
-         write(*,*) '3-D DM+AC+AD search...'
-         mode=5
-      endif
-      
-      if (mode.eq.0) stop 'Unrecognizable parameter space! HELP!'
-c
-c     Go through list, leaving out candidates that do not fall in
-c     selected ranges.
-c
-      j=0
-      k=0
-      do i=1,nc
-         consider=(par(i).ge.prdmin.and.par(i).le.prdmax)
-         k=trid(i)
-         if (mode.eq.1.and.(dm(k).lt.parmin(1).or.dm(k).gt.parmax(1)))
-     &   consider=.false.         
-         if (mode.eq.1.and.smeared(real(par(i)),dm(k),fcentre,chbandw))
-     &   consider=.false.         
-         if (mode.eq.2.and.(ac(k).lt.parmin(1).or.ac(k).gt.parmax(1)))
-     &   consider=.false.         
-         if (mode.eq.3.and.(ad(k).lt.parmin(1).or.ad(k).gt.parmax(1)))
-     &   consider=.false.
-         if (consider) then
-            j=j+1
-            par(j)=par(i)
-            snr(j)=snr(i)
-            trid(j)=trid(i)
-            fld(j)=fld(i)
-         endif
-      enddo
-      nc=j
-c      
-c     Initialise arrays ready for cross-correlation analysis
-c
-      do i=1,nc
-         cidx(i)=0
-         sidx(i)=0
-         nids(i)=0
-      enddo
-c
-c     Establish ranges of DMs (or ACs) searched
-c
-      do i=1,2
-         parmin(i)=0.0
-         parmax(i)=0.0
-      enddo
-      dmdsp=dm(1)
-      do i=1,nt
-         if (mode.eq.1) then
-            dd(i)=dm(i)
-         else if (mode.eq.2) then
-            dd(i)=ac(i)
-         else if (mode.eq.3) then
-            dd(i)=ad(i)
-         endif
-         parmin(1)=min(parmin(1),dd(i))
-         parmax(1)=max(parmax(1),dd(i))
-      enddo
-c
-c     Display info concerning number of candidates read in
-c
-      if (mode.eq.1) then
-        write(*,*) nt/nf,' DM group(s). ',nc,' candidates'
-        write(*,*) 'DM range:',parmin(1),parmax(1),' pc/cc'
-      else if (mode.eq.2) then
-        write(*,*) nt/nf,' AC group(s). ',nc,' candidates'
-        write(*,*) 'AC range:',parmin(1),parmax(1),' m/s/s'
-      else if (mode.eq.3) then
-        write(*,*) nt/nf,' AD group(s). ',nc,' candidates'
-        write(*,*) 'AD range:',parmin(1),parmax(1),' cm/s/s/s'
-      else if (mode.eq.4) then
-        write(*,*) nt/nf,' AD/AC group(s). ',nc,' candidates'
-        call gdim(ac,nt,ngx,parmin(1),parmax(1),xval)
-        call gdim(ad,nt,ngy,parmin(2),parmax(2),yval)
-        write(*,*) 'AC x AD grid dimensions:',ngx,' x',ngy
-        write(*,*) 'AC range:',parmin(1),parmax(1),' m/s/s'
-        write(*,*) 'AD range:',parmin(2),parmax(2),' cm/s/s/s'
-      else if (mode.eq.5) then
-         
-
-
-
-         write(*,*) nt/nf,' DM/AD/AC group(s). ',nc,' candidates'
-         call gdim(dm,nt,ngz,parmin(1),parmax(1),zval)
-         call gdim(ac,nt,ngx,parmin(2),parmax(2),xval)
-         call gdim(ad,nt,ngy,parmin(3),parmax(3),yval)
-         
-         write(*,*) 'DM range:',parmin(1),parmax(1),' pc/cc'
-         write(*,*) 'AC x AD grid dimensions:',ngx,' x',ngy
-         write(*,*) 'AC range:',parmin(2),parmax(2),' m/s/s'
-         write(*,*) 'AD range:',parmin(3),parmax(3),' cm/s/s/s'
-      endif
-
-      
-c     
-c     Sort signals in terms of their signal-to-noise ratios
-c
-      call indexxf77(nc,snr,sidx)
-c
-c     Cross-correlate signals for integer and non-integer harmonics
-c     when found, these are then flagged out using the array cidx() 
-c
-      if (hzap) then
-         write(*,*)'Zapping integer+non-integer harmonics...'
-      else
-         write(*,*)'Zapping only the integer harmonics...'
-      endif
-c
-c     This loop is not as horrendous as it looks... (well ok, it is!)
-c      
-      do i=nc,1,-1
-         k=sidx(i)  ! index of outer loop in terms of descending SNR
-         if (cidx(k).eq.0) then ! has this signal already been seen?
-            do j=1,nc
-               test=par(j).ne.0.0.and.par(k).ne.0.0.and.cidx(j).eq.0
-               if (test) then 
-                  ratio=par(k)/par(j)                    
-                  if (ratio.lt.1.0) ratio=1.0/ratio      
-                  ratio2=ratio
-                  ratio=ratio-int(ratio)
-                  harm=(ratio.gt.0.999.or.ratio.lt.0.001)
-                  if (hzap) then ! non-integer harmonics clobbered here
-                   harm=harm.or.(ratio.gt.0.24999.and.ratio.lt.0.25001)
-                   harm=harm.or.(ratio.gt.0.33332.and.ratio.lt.0.33334)
-                   harm=harm.or.(ratio.gt.0.49999.and.ratio.lt.0.50001)
-                   harm=harm.or.(ratio.gt.0.66665.and.ratio.lt.0.66667)
-                   harm=harm.or.(ratio.gt.0.74999.and.ratio.lt.0.75001)
-c                     harm=harm.or.(ratio.gt.0.249.and.ratio.lt.0.251)
-c                     harm=harm.or.(ratio.gt.0.332.and.ratio.lt.0.334)
-c                     harm=harm.or.(ratio.gt.0.499.and.ratio.lt.0.501)
-c                     harm=harm.or.(ratio.gt.0.599.and.ratio.lt.0.601)
-c                     harm=harm.or.(ratio.gt.0.665.and.ratio.lt.0.667)
-c                     harm=harm.or.(ratio.gt.0.749.and.ratio.lt.0.751)
-                  endif
-c
-c     check to see if candidate is harmonically related out to 16th
-c
-                  if (harm.and.ratio2.lt.16.0) then
-                     cidx(j)=k
-                     if (snr(k).ge.snrmin.and.snr(j).ge.snrmin)
-     &                    nids(k)=nids(k)+1
-                     if (j.ne.k) then
-                       cidx(j)=-1*cidx(j)
-                       if (trace) 
-     &                 write(*,*) par(j),' related to',par(k),ratio2
-                    endif
-                  endif
-               endif
-            enddo
-         endif
-      enddo
-c
-c     Column headers for screen output...
-c
-      write( *, * ) mode
-      write(string(1),'(a,a)')'   P (ms)      SNR    AC   ACID NIDs f',
-     &                     '    P/Ptop    Ptop/P'
-      write(string(2),'(a,a)')'   f (Hz)      SNR    AC   ACID NIDs f',
-     &                     '    f/ftop    ftop/f'
-      write(string(3),'(a,a)')'   P (ms)      SNR    DM   DMID NIDs f',
-     &                     '    P/Ptop    Ptop/P'
-      write(string(4),'(a,a)')'   f (Hz)      SNR    DN   DMID NIDs f',
-     &                     '    f/ftop    ftop/f'
-      write(string(5),'(a,a)')'   P (ms)      SNR    AD   ACID NIDs f',
-     &                     '    P/Ptop    Ptop/P'
-      write(string(6),'(a,a)')'   f (Hz)      SNR    AD   ACID NIDs f',
-     &                     '    f/Ptop    ftop/f'
-      write(string(7),'(a,a)')'   P (ms)      SNR    AC     AD   ACID',
-     &                     ' NIDs f    P/Ptop    Ptop/P'
-      write(string(8),'(a,a)')'   f (HZ)      SNR    AC     AD   ACID',
-     &                     ' NIDs f    f/ftop    ftop/f'
-      write(string(9),'(a,a)')'   P (ms)      SNR    DM   AC  AD ACID',
-     &                     'NIDs f    P/Ptop    Ptop/P'
-      write(string(10),'(a,a)')'  f (HZ)      SNR    DM   AC  AD ACID',
-     &                     'NIDs f    f/ftop    ftop/f'
-
-      if (mode.eq.1) then
-        if (prd) write(*,*) string(3)
-        if (frq) write(*,*) string(4)
-        laccn=.false.
-      else if (mode.eq.2) then
-        if (prd) write(*,*) string(1)
-        if (frq) write(*,*) string(2)
-        laccn=.true.
-      else if (mode.eq.3) then
-        if (prd) write(*,*) string(5)
-        if (frq) write(*,*) string(6)
-        laccn=.true.
-      else if (mode.eq.4) then
-        if (prd) write(*,*) string(7)
-        if (frq) write(*,*) string(8)
-        laccn=.true.
-      else if (mode.eq.5) then
-        if (prd) write(*,*) string(9)
-        if (frq) write(*,*) string(10)
-        laccn=.true.
-      endif
-c
-c     Print out results of cross correlation analysis.... ie list
-c     only the signals that have not been flagged in the cidx()
-c     array as being related to something else (i.e. cidx(i)=0.0)
-c     this output goes out to a "*.lis" file as well as to the sceen.
-c
-      call glun(lun2)
-      open(unit=lun2,file=filename(1:index(filename,' ')-5)//'.lis',
-     &     status='unknown')
-      call glun(lun3)
-      open(unit=lun3,file=filename(1:index(filename,' ')-5)//'.fld',
-     &     status='unknown')
-      nsus=0
-      do i=nc,1,-1
-         j=sidx(i)
-         if (cidx(j).gt.0.and.snr(j).ge.snrmin.and.
-     &       par(j).le.prdmax.and.par(j).ge.prdmin) then
-            ratio=par(j)/par(sidx(nc))
-            if (mode.lt.4) then
-            nsus=nsus+1
-            write(*,1) par(j),snr(j),dd(trid(j)),trid(j),nids(j),
-     &                 fld(j),ratio,1.0/ratio
-            write(lun2,1) par(j),snr(j),dd(trid(j)),trid(j),nids(j),
-     &                 fld(j),ratio,1.0/ratio,
-     &                 filename(1:index(filename,' ')-5),nsus
-            call wstr8(par(j),period)
-            call wstr4(dd(trid(j)),acceln)
-            write(dmidx,'(i4.4)') trid(j)
-            write(dmval,'(f8.2)') dm(trid(j))
-            write(prf,'(a,i3,a)') '_sus',nsus,'.prf'
-            if (nsus.lt.100) write(prf,'(a,i2,a)') 'sus',nsus,'.prf'
-            if (nsus.lt.10) write(prf,'(a,i1,a)') 'sus',nsus,'.prf'
-            write(ps,'(a,i3,a)') '_sus',nsus,'.ps/ps'
-            if (nsus.lt.100) write(ps,'(a,i2,a)') '_sus',nsus,'.ps/ps'
-            if (nsus.lt.10) write(ps,'(a,i1,a)') '_sus',nsus,'.ps/ps'
-            if (mode.eq.1) then
-               write(lun3,'(a)')    'filterbank '//
-     &              filename(1:index(filename,' ')-5)//'.dat'//
-     &              '| dedisperse -d '//dmval//'| fold -p '//
-     &              period(1:length(period))//' -n 128 > '//
-     &              filename(1:index(filename,' ')-5)//prf//
-     &              '; plot prof '//         
-     &              filename(1:index(filename,' ')-5)//prf//
-     &              '-nobox -centre -T"P: '//period(1:length(period))//
-     &              ' ms DM: '//dmval//' cm-3 pc"'//
-     &              ' -d'//filename(1:index(filename,' ')-5)//ps
-            else
-               write(lun3,'(a)') 'fold '//
-     &              filename(1:index(filename,' ')-5)//'.tim'//
-     &                        ' -p '//period(1:length(period))//
-     &                        ' -a '//acceln(1:length(acceln))//
-     &           ' > '//prf
-            endif
-            else if(mode.eq.4) then
-            write(*,2) par(j),snr(j),ac(trid(j)),ad(trid(j)),trid(j),
-     &                 nids(j),fld(j),ratio,1.0/ratio,
-     &                 filename(1:index(filename,' ')-5)
-            write(lun2,2) par(j),snr(j),ac(trid(j)),ad(trid(j)),trid(j),
-     &                 nids(j),fld(j),ratio,1.0/ratio,
-     &                 filename(1:index(filename,' ')-5)
-            call wstr8(par(j),period)
-            call wstr4(ac(trid(j)),acceln)
-            call wstr4(ad(trid(j)),accdot)
-            write(lun3,'(a)') 'fold '//
-     &              filename(1:index(filename,' ')-5)//'.ser'//
-     &                        ' -p'//period(1:length(period))//
-     &                        ' -a'//acceln(1:length(acceln))//
-     &                        ' -d'//accdot(1:length(accdot))//
-     &                        ' -s8; grey'
-         else if(mode.eq.5) then
-            write(*,12) par(j),snr(j),dm(trid(j)),ac(trid(j)),
-     &           ad(trid(j)),trid(j),
-     &           nids(j),fld(j),ratio,1.0/ratio,
-     &           filename(1:index(filename,' ')-5)
-            write(lun2,2) par(j),snr(j),ac(trid(j)),ad(trid(j)),trid(j),
-     &           nids(j),fld(j),ratio,1.0/ratio,
-     &           filename(1:index(filename,' ')-5)
-            call wstr8(par(j),period)
-            call wstr4(ac(trid(j)),acceln)
-            call wstr4(ad(trid(j)),accdot)
-            write(lun3,'(a)') 'fold '//
-     &           filename(1:index(filename,' ')-5)//'.ser'//
-     &           ' -p'//period(1:length(period))//
-     &           ' -a'//acceln(1:length(acceln))//
-     &           ' -d'//accdot(1:length(accdot))//
-     &           ' -s8; grey'
-         endif
-      endif
-      enddo
-      close(unit=lun3)
-      close(unit=lun2)
-c
-c     Stop here if nothing else to be done (default mode)
-c
-      if ((.not.autop).and.(.not.lview)) stop
-c
-c     Carry on either in interactive (view) mode where the
-c     postscript files are saved on demand, or in automatic
-c     mode (-p) which writes all the postscript output
-c
-      if (lview) write(*,*) 'Cycling through the list...'
-      nsus=0
-      do i=nc,1,-1
-         j=sidx(i)
-         if (cidx(j).gt.0.and.snr(j).ge.snrmin.and.
-     &       par(j).le.prdmax.and.par(j).ge.prdmin) then
-            if (mode.eq.2.and.lview.and.(.not.autop)) then
-               if (prd) write(*,*) string(1)(1:24)
-               if (frq) write(*,*) string(2)(1:24)
-            else if (mode.eq.3.and.lview.and.(.not.autop)) then
-               if (prd) write(*,*) string(5)(1:24)
-               if (frq) write(*,*) string(6)(1:24)
-            else if (mode.eq.4.and.lview.and.(.not.autop)) then
-               if (prd) write(*,*) string(7)(1:32)
-               if (frq) write(*,*) string(8)(1:32)
-            else if (mode.eq.5.and.lview.and.(.not.autop)) then
-               if (prd) write(*,*) string(9)(1:40)
-               if (frq) write(*,*) string(10)(1:40)
-            else if (.not.autop) then
-               if (prd) write(*,*) string(3)
-               if (frq) write(*,*) string(4)
-c               stop 'HELP!'
-            endif
-            if (lview) then
-               if (mode.lt.4) then
-                  write(*,5) par(j),snr(j),dd(trid(j))
-               else if(mode.eq.4) then
-                  write(*,6) par(j),snr(j),ac(trid(j)),
-     &                 ad(trid(j))
-               else if(mode.eq.5) then
-                  write(*,13) par(j),snr(j),dm(trid(j)),ac(trid(j)),
-     &                 ad(trid(j))
-               endif
-            endif
-            nsus=nsus+1
-c
-c           Clear the grid if in 2-D mode
-c      
-            if (mode.eq.4.or.mode.eq.5) then
-               gridmin=+1.0e32
-               gridmax=-1.0e32
-               do k=1,mg
-                  do l=1,mg
-                     grid(k,l)=0.0
-                  enddo
-               enddo
-            endif
-c
-c           Open a summary file (list of signal-to-noise versus DM/AC
-c           for reading by other programs... only done in auto mode
-c
-            call glun(lsum)
-            if (nsus.lt.10) then
-               write(susfile,'(a,i1,a)')'sus00',nsus,'.sum'
-            else if (nsus.lt.100) then
-               write(susfile,'(a,i2,a)')'sus0',nsus,'.sum'
-            else
-               write(susfile,'(a,i3,a)')'sus',nsus,'.sum'
-            endif
-            open(unit=lsum,file=susfile,status='unknown')
-c	MK 2006: Added the name of the dedispersed
-c		file. This is for 'tune' used with MMB  
-		
-            write(dmval,'(f8.2)') dd(trid(j))
-
-		bb=index(dmval,' ')
-               do while (bb.eq.1)
-                  dmval=dmval(2:8)
-                  bb=index(dmval,' ')
-               enddo			
-		write(lsum,*)filename(1:index(filename,' ')-5)//
-     &              '_dice_dm'//dmval(1:bb-1)//'.tim'
-
-            if (mode.eq.4) then
-               write(lsum,*) par(j),snr(j),ac(trid(j)),ad(trid(j))
-               xx=ac(trid(j))
-               yy=ad(trid(j))
-            else if(mode.eq.5) then
-               write(lsum,*) par(j),snr(j),dm(trid(j)),ac(trid(j)),
-     &              ad(trid(j))
-               xx=ac(trid(j))
-               yy=ad(trid(j))
-            else
-               write(lsum,*) par(j),snr(j),dd(trid(j)),fld(j)
-            endif
-            
-
-c     We need to reset the x and y arrays for mode 5
-            if(mode.eq.5) then
-               do ndmi = 0,5000
-                  x(ndmi) = 0
-                  y(ndmi) = 0
-               enddo
-            endif
-
-
-            ndm=0
-            ndmi = 0
-            ndmm = 1
-            snrmax=0.0
-
-            do k=1,nc
-               if (abs(cidx(k)).eq.j.and.fld(k).eq.fld(j))then
-                  ok=.true.
-                  if (mode.eq.4) then
-                     l=trid(k)
-                     ix=gidx(xval,ngx,ac(l))
-                     iy=gidx(yval,ngy,ad(l))
-                     grid(ix,iy)=snr(k)
-                     write(lsum,*) ix,iy,tr(1)+real(ix)*tr(2),
-     &               tr(4)+real(iy)*tr(6),grid(ix,iy)
-                     gridmin=min(gridmin,grid(ix,iy))
-                     gridmax=max(gridmax,grid(ix,iy))
-                     deltax=(parmax(1)-parmin(1))/real(ngx)
-                     deltay=(parmax(2)-parmin(2))/real(ngy)
-                     tr(1)=parmin(1)-0.5*deltax
-                     tr(2)=deltax
-                     tr(3)=0.0
-                     tr(4)=parmin(2)-0.5*deltay
-                     tr(5)=0.0
-                     tr(6)=deltay
-                  else if(mode.eq.5) then
-c                     if (ndm.gt.0) ok=dd(trid(k)).ne.x(ndm)
-c                     if (ok) then   
-c                        ndm=ndm+1
-c                        x(ndm)=dd(trid(k))
-c                        y(ndm)=snr(k)
-c                        write(lsum,*) ndm,x(ndm),y(ndm)
-c                        snrmax=max(snrmax,snr(k))
-c                     endif
-
-
-                     l=trid(k)
-                     iz=gidx(zval,ngz,dm(l))
-                     ix=gidx(xval,ngx,ac(l))
-                     iy=gidx(yval,ngy,ad(l))
-                     if(grid(ix,iy).lt.snr(k)) grid(ix,iy)=snr(k)
-                     ndm = ndmm
-                     ndmi = 1
-c     A fake 'while' loop
- 100                 continue
-                     if(ndmi.lt.ndmm.or.ndmi.eq.ndmm) then
-c                        write(*,*)ndmi,x(ndmi),dm(trid(k))
-                        if(x(ndmi).eq.dm(trid(k))) then
-                           ndm = ndmi
-c     if we already have the dm then use the old value
-                        else
-                           ndmi = ndmi + 1
-                           goto 100
-                        endif
-                     endif
-c     increment the max ndmval
-                     
-                     if(ndm.eq.ndmm) then
-                        x(ndm) = dm(trid(k))
-                        ndmm = ndmm + 1
-                     endif
-
-                     if(y(ndm).lt.snr(k)) y(ndm) = snr(k)
-c                    write(lsum,*) ix,iy,iz,tr(1)+real(ix)*tr(2),
-c     &              tr(4)+real(iy)*tr(6),grid(ix,iy)
-                     write(lsum,*) ix, dm(trid(k)),iy, ac(trid(k)),iz
-     &                    ,ad(trid(k)),snr(k)
-
-                     snrmax=max(snrmax,snr(k))
-c                     write(*,*)ndm,ndmm,x(ndm),y(ndm),snrmax
-                     
-                     
-                     gridmin=min(gridmin,grid(ix,iy))
-                     gridmax=max(gridmax,grid(ix,iy))
-                     deltax=(parmax(2)-parmin(2))/real(ngx)
-                     deltay=(parmax(3)-parmin(3))/real(ngy)
-                     tr(1)=parmin(2)-0.5*deltax
-                     tr(2)=deltax
-                     tr(3)=0.0
-                     tr(4)=parmin(3)-0.5*deltay
-                     tr(5)=0.0
-                     tr(6)=deltay
-
-                  else
-                     if (ndm.gt.0) ok=dd(trid(k)).ne.x(ndm)
-                     if (ok) then   
-                        ndm=ndm+1
-                        x(ndm)=dd(trid(k))
-                        y(ndm)=snr(k)
-                        write(lsum,*) ndm,x(ndm),y(ndm)
-                        snrmax=max(snrmax,snr(k))
-                     endif
-                  endif
-               endif
-            enddo
-            close(lsum)
-
-c     test
-
-          
-
-c
-c           For the main plot, write out a title
-c
-            write(title,3) par(j),snr(j),dd(trid(j))
-            if (laccn) write(title,4) par(j),snr(j),dd(trid(j)),dmdsp
-            if (mode.eq.4) write(title,7) par(j),snr(j),xx,yy
-            if (mode.eq.5) write(title,8) par(j),snr(j),ac(trid(j)),
-     &           ad(trid(j)),dm(trid(j))
-c
-c           Sort out whether this plot will get displayed...
-c           always the case in auto mode, on demand otherwise
-c    
-c
- 
-
-	    plotit=.true.
-            option=' '
-            if (lview) then
-               write(*,'('' View this one [y] ''$)')
-               read(*,'(a)')option
-               if (option(1:1).ne.'n'.and.option(1:1).ne.'N') then 
-                  call pgbegin(0,'/xs',1,1)
-               else
-                  plotit=.false.
-               endif
-            else if (autop) then
-               call pgbegin(0,
-     &         susfile(1:index(susfile,'.sum')-1)//'.ps/ps',1,1)
-               plotit=.true.
-            else
-               plotit=.false.
-            endif
-c
-c           Plot it
-c
-
-            lmode5 = .false.
-
-	    if (plotit) then
- 200           if(lmode5) then
-                  mode = 1
-                  call pgvport(0.12,0.85,0.50,0.85)
-                  call pgsch(1.0)
-                  call pgscf(2)
-                  
-               else if(mode.eq.5) then
-                  call pgvport(0.12,0.40,0.12,0.40)
-                  call pgsch(1.0)
-                  call pgscf(2)
-                  mode = 4
-                  lmode5 = .true.
-                
-               else
-                  call pgvport(0.15,0.85,0.15,0.85)
-                  call pgsch(1.3)
-                  call pgscf(2)
-               endif
-               if (mode.eq.4) then
-                  xmin=tr(1)+tr(2)*0.5
-                  xmax=tr(1)+tr(2)*(real(ngx)+0.5)
-                  ymin=tr(4)+tr(6)*0.5
-                  ymax=tr(4)+tr(6)*(real(ngy)+0.5)
-               else
-c                  xmin=parmin(1)
-                  xmin=dd(1)
-                  xmax=parmax(1)
-                  ymin=0.0
-                  ymax=snrmax*1.1
-               endif
-               call pgwindow(xmin,xmax,ymin,ymax)
-               call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-               if (mode.eq.1) then
-                  call pglabel('Trial DM (cm\\u-3\\d pc)',
-     &                'Signal-to-Noise Ratio',' ')
-               else if (mode.eq.2) then
-                  call pglabel('Trial Acceleration (m s\\u-2\\d)',
-     &                'Signal-to-Noise Ratio',' ')
-               else if (mode.eq.3) then
-                  call pglabel('Trial Adot (cm s\\u-3\\d)',
-     &                'Signal-to-Noise Ratio',' ')
-               else if (mode.eq.4) then
-                  call pglabel('Trial Acceleration (m s\\u-2\\d)',
-     &                'Trial Adot (cm s\\u-3\\d)',' ')
-               endif
-               if (mode.eq.2.or.mode.eq.3) then
-                  call pgsls(2)
-                  call pgmove(parmin(1),snrmin)
-                  call pgdraw(parmax(1),snrmin)
-               endif
-               if (mode.lt.4) then
-                  call pgsls(4)
-                  call pgmove(0.0,0.0)
-                  call pgdraw(0.0,snrmax*1.1)
-                  call pgsls(1)
-                  call pgline(ndm,x,y)
-                  call pgpoint(ndm,x,y,17)
-               else if (mode.eq.4.or.mode.eq.5) then
-                  call pggray(grid,mg,mg,1,ngx,1,ngy,gridmax,gridmin,tr)
-                  call pgpoint(1,xx,yy,27)
-                  call pgsls(4)
-                  call pgmove(xmin,0.0)
-                  call pgdraw(xmax,0.0)
-                  call pgmove(0.0,ymin)
-                  call pgdraw(0.0,ymax)
-                  call pgsls(1)
-               endif
-              
-              
-
-               if(lmode5.and.mode.eq.4) then
-                  goto 200
-               else if(lmode5.and.mode.eq.1) then
-                  mode = 5
-                  lmode5 = .false.
-                  
-               endif
-               call pgsch(1.0)
-               call pgwindow(0.0,1.0,0.0,1.0)
-               call pgtext(-0.05,1.25,title)
-               call getenv('PWD',title)
-               title='Directory: '//title(1:index(title,' ')-1)
-     &              //' File: '//filename(1:lst)
-               call pgtext(-0.05,1.35,title)
-               
-               call pgiden
-               call pgend
-            endif
-         endif
-      enddo
-c
-c     Formats for various screen/plot outputs
-c      
- 1    format(f13.8,1x,f6.1,1x,f7.1,1x,2(i4.4,1x),
-     &   i1,2(1x,f9.4),1x,a,1x,i4)
- 2    format(f13.8,1x,f6.1,1x,2(f7.1,1x),2(i4.4,1x),i1,2(1x,f9.4),1x,a)
- 3    format('P =',f9.4,' ms SNR = ',f6.1,' DM = ',f7.2,
-     &' cm\\u-3\\d pc')
- 4    format('P =',f9.4,' ms SNR = ',f6.1,' AC = ',f7.1,
-     &' m s\\u-2\\d (DM = ',f7.2,')')
- 5    format(f13.8,1x,f6.1,1x,f6.1,1x)
- 6    format(f13.8,1x,f6.1,1x,2(f6.1,1x))
- 7    format('P =',f9.4,' ms SNR = ',f6.1,' AC = ',f7.1,
-     &' m s\\u-2\\d AD = ',f7.2,' cm s\\u-3\\d')
- 8    format('P =',f9.4,' ms SNR = ',f6.1,' AC = ',f7.1,
-     &' m s\\u-2\\d AD = ',f7.2,' cm s\\u-3\\d DM = ',f7.2,
-     &' cm\\u-3\\d pc')
-
- 12   format(f13.8,1x,f6.1,f6.1,1x,2(f7.1,1x),2(i4.4,1x),i1,2(1x,f9.4),
-     &     1x,a)
- 13   format(f13.8,1x,f6.1,1x,3(f6.1,1x))
-
-      end
-c==============================================================================
-      subroutine help
-      write(*,*)
-      write(*,1) 'best - displays the best suspects from SEEK'
-      write(*,*)
-      write(*,1) 'usage: best <INFILE> -{options}'
-      write(*,*)
-      write(*,1)
-     & 'The input file may be of the ".prd", ".top" or ".frq" variety.'
-      write(*,*)
-      write(*,1)'options:'
-      write(*,*)
-      write(*,1)'-v: view output selectively'
-      write(*,1)'-p: produce postscript file output automatically'
-      write(*,1)'-i: zap integer harmonics only'
-      write(*,1)'-t: trace mode... show all harmonic relationships'
-      write(*,*)
-      write(*,1)'-f[fold]: read a specific harmonic fold (1-5;def=all)'
-      write(*,1)'-s[smin]: set signal-to-noise threshold smin (def=8)'
-      write(*,1)'-l[mini]: set minimum prd/frq to consider (ms;def=0)'
-      write(*,1)'-h[maxi]: set maximum prd/frq to consider (ms;def=inf)'
-      write(*,1)'-L[mini]: set minimum ac/dm to consider'
-      write(*,1)'-H[maxi]: set maximum ac/dm to consider'
-      write(*,1)'-F[fMHz]: set centre freq for DMsmear test (optional)'
-      write(*,1)'-C[fMHz]: set channel band for DMsmear test (optional)'
-      write(*,*)
- 1    format(a)
-      stop
-      end
-c==============================================================================
-c      integer function myhandler(sig,code,context)
-c==============================================================================
-c      integer sig, code, context(5)
-c      write(*,*)'ieee exception'
-c      call abort()
-c      end
-c==============================================================================
-      subroutine gdim(x,nt,ng,xmin,xmax,xval)
-c==============================================================================
-c
-c     Gets the dimensions of a 1-D slice of parameter space
-c
-c     x(nt) - r4 - array containing signal-to-noise ratios --- passed
-c     nt    - i4 - integer nunber of elements in the slice --- passed
-c     ng    - i4 - number of distinct grid elements        --- return
-c     xmin  - r4 - lowest grid element                     --- return
-c     xmax  - r4 - highest grid element                    --- return
-c     xval  - r4 - array containing valiues of ng elements --- return
-c
-c     Created: 98/07/15 (dunc@mpifr-bonn.mpg.de)
-c      
-c==============================================================================
-c
-      implicit none
-      integer nt,ng
-      real x(nt),xmin,xmax,xval(*)
-      
-      integer i,j
-      logical newpnt
-
-      ng=0
-      xmax=-1.0e32
-      xmin=+1.0e32
-
-      do i=1,nt
-         xmin=min(xmin,x(i))
-         xmax=max(xmax,x(i))
-         newpnt=.true.
-         if (ng.gt.0) then
-            do j=1,ng
-               if (x(i).eq.xval(j)) newpnt=.false.
-            enddo
-         endif
-         if (newpnt) then
-            ng=ng+1
-            xval(ng)=x(i)
-         endif
-      enddo
-
-      end
-c==============================================================================
-      integer function gidx(xval,nx,x)
-c==============================================================================
-c
-c     Returns the index "gidx" in the array xval(nx) of the value 'x'
-c
-c     xval(*) - r4 - array containing values of ng elements  --- passed
-c     nx      - i4 - number of used elements in xval         --- passed
-c     x       - r4 - value whose index in xval is required   --- passed
-c
-c     Created: 98/07/15 (dunc@mpifr-bonn.mpg.de)
-c      
-c==============================================================================
-c
-      implicit none
-      integer nx
-      real xval(*),x
-      integer i
-      gidx=0
-      do i=1,nx
-         if (xval(i).eq.x) then
-            gidx=i
-            return
-         endif
-      enddo
-      stop 'HELP! Grid value not found! - see GIDX for more info...'
-      end
-c==============================================================================
-      subroutine wstr4(param4,cstring)
-      implicit none
-      real*4 param4
-      real*8 param8
-      character*(*) cstring
-      integer i,length,j
-      write(cstring,*) param4
-      goto 1
-      entry wstr8(param8,cstring)
-      write(cstring,*) param8
- 1    j=0
-      do i=1,length(cstring)
-         if (cstring(i:i).ne.' '.and.j.eq.0) j=i
-      enddo
-      cstring=cstring(j:)
-      end
-c==============================================================================
-      logical function smeared(period,dm,f0,chbw)
-c
-c     Returns true if smearing across a single filterbank channel
-c     of width chbw (MHz) for a centre frequency f0 (MHz) is larger
-c     than the period of the signal... ie if it's dispersion smeared
-c
-      implicit none
-      real period,dm,f0,chbw
-      smeared=(8.3e6*dm*chbw/f0/f0/f0).gt.period
-      end
-c==============================================================================
diff --git a/filterbank-gmrt/birdies.inc b/filterbank-gmrt/birdies.inc
deleted file mode 100644
index 042c814..0000000
--- a/filterbank-gmrt/birdies.inc
+++ /dev/null
@@ -1,9 +0,0 @@
-C @(#)birdies.inc	3.1 12/17/92
-
-      integer nbrd, nba, nbb, irange_a, irange_b, nhbrd, zapped
-      real bfa, bfb, tot, bffa, bffb, perzapped
-      logical beambirdie
-
-      common/birdie/nbrd,bfa(20),bfb(20),nba(20),nbb(20),tot,
-     +    irange_a(20),irange_b(20),nhbrd(20),bffa(20), bffb(20)
-     +    ,beambirdie(20),zapped,perzapped
diff --git a/filterbank-gmrt/bit.c b/filterbank-gmrt/bit.c
deleted file mode 100644
index c42276a..0000000
--- a/filterbank-gmrt/bit.c
+++ /dev/null
@@ -1,12 +0,0 @@
-#include <math.h>
-int bit(int bitindex, unsigned char byte) /*includefile*/
-{
-  unsigned char mask;
-  mask=(unsigned char) pow(2,bitindex-1);
-  
-  if (mask & byte) {
-    return (0);
-  } else {
-    return (1);
-  }
-}
diff --git a/filterbank-gmrt/blanker.c b/filterbank-gmrt/blanker.c
deleted file mode 100644
index 2a588d1..0000000
--- a/filterbank-gmrt/blanker.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/* blanker - a program to blank out pulses from a time series */
-
-#include "dedisperse.h"
-char polyco_filename[80];
-char inpfile[80], outfile[80];
-main (int argc, char *argv[]) 
-{
-  int i,ntim,headersize,noff=0,gulp;
-  float *time_series,sum=0.0,sumsq=0.0,mean,meansq,sigma;
-  double phase_start=0.0,phase_finish=0.0,phase,turn=0.0,last=0.0,period,mjd;
-  long seed=0;
-  struct POLYCO polyco;
-  FILE *polycofile;
-  if (argc<2 || help_required(argv[1])) {
-    blanker_help();
-    exit(0);
-  }
-  print_version(argv[0],argv[1]);
-  if (!file_exists(argv[1]))
-    error_message("input file does not exist!");
-
-  strcpy(inpfile,argv[1]);
-  input=open_file(inpfile,"r");
-  strcpy(outfile,"stdout");
-  output=stdout;
-  strcpy(polyco_filename,"polyco.dat");
-
-  i=2;
-  while (i<argc) {
-    if (strings_equal(argv[i],"-p"))       strcpy(polyco_filename,argv[++i]);
-    if (strings_equal(argv[i],"-s"))       phase_start=atof(argv[++i]);
-    if (strings_equal(argv[i],"-f"))       phase_finish=atof(argv[++i]);
-    i++;
-  }
-  if (phase_start==phase_finish)
-    error_message("start and end phases must be different");
-  if (phase_start>phase_finish)
-    error_message("start phases must be less than end phase");
-
-  if ((headersize=read_header(input))) {
-    if (nbits!=32) 
-      error_message("blanker currently only works for 32-bit data");
-
-    send_string("HEADER_START");
-
-    if (!strings_equal(source_name,"")) {
-      send_string("source_name");
-      send_string(source_name);
-    }
-    send_int("telescope_id",telescope_id); 
-    send_int("machine_id",machine_id);
-    send_coords(src_raj,src_dej,az_start,za_start);
-    send_int("data_type",2);
-    send_double("fch1",fch1);
-    send_double("refdm",refdm);
-    send_int("barycentric",barycentric);
-    send_int("nchans",1);
-    send_int("nbits",nbits);  
-    send_double ("tstart",tstart); 
-    send_double("tsamp",tsamp);
-    send_int("nifs",nifs);
-    send_string("HEADER_END");
-
-    gulp=8192;
-    ntim=nsamples(inpfile,headersize,nbits,nifs,nchans);
-    if (gulp>ntim) gulp=ntim;
-
-    polycofile=open_file(polyco_filename,"r");
-    if (!read_polycoset(polycofile,&polyco)) {
-      error_message("blanker: error reading polyco file");
-    } else {
-      get_nearest_polyco(polyco_filename,tstart,&polyco);
-      period=polyco_period(tstart,polyco);
-    }
-
-    time_series=(float *) malloc(gulp*sizeof(float));
-    fread(time_series,sizeof(float),gulp,input);
-
-    /* calculate the off-pulse mean and rms from first 1k points */
-    i=0;
-    mjd=tstart;
-    while (noff<1024) {
-      turn += tsamp/period;
-      if ((turn-last)>=1.0) {
-	get_nearest_polyco(polyco_filename,tstart,&polyco);
-	period=polyco_period(tstart,polyco);
-	last=turn;
-      }
-      phase = turn-floor(turn);
-      if ((phase<phase_start)||(phase>phase_finish)) {
-	sum+=time_series[i];
-	sumsq+=time_series[i]*time_series[i];
-	noff++;
-      }
-      tstart += tsamp/86400.0;
-      i++;
-    }
-    mean=sum/(float)gulp;
-    meansq=sumsq/(float)gulp;
-    sigma=sqrt(meansq-mean*mean);
-
-    /* now run through the file blanking with gaussian noise */
-    turn=0.0;
-    last=0.0;
-    tstart=mjd;
-    i=0;
-    while (!feof(input)) {
-      turn += tsamp/period;
-      if ((turn-last)>=1.0) {
-	get_nearest_polyco(polyco_filename,tstart,&polyco);
-	period=polyco_period(tstart,polyco);
-	last=turn;
-      }
-      phase = turn-floor(turn);
-      if ((phase>=phase_start)&&(phase<=phase_finish)) 
-	time_series[i]=gasdev(&seed)*sigma+mean;
-      tstart += tsamp/86400.0;
-      i++;
-      if (i==gulp) {
-	fwrite(time_series,sizeof(float),gulp,output);
-	gulp=fread(time_series,sizeof(float),gulp,input);
-	i=0;
-      }
-    }
-
-  }
-}
diff --git a/filterbank-gmrt/bpp.c b/filterbank-gmrt/bpp.c
deleted file mode 100644
index 146b0bd..0000000
--- a/filterbank-gmrt/bpp.c
+++ /dev/null
@@ -1,1211 +0,0 @@
-#include "presto.h"
-#include "mask.h"
-#include "bpp.h"
-
-/* All of the following have an _st to indicate static */
-static long long numpts_st[MAXPATCHFILES], padpts_st[MAXPATCHFILES], N_st;
-static long long filedatalen_st[MAXPATCHFILES];
-static int numblks_st[MAXPATCHFILES];
-static int bytesperpt_st, bytesperblk_st;
-static int numchan_st, numifs_st, ptsperblk_st=PTSPERBLOCK;
-static double times_st[MAXPATCHFILES], mjds_st[MAXPATCHFILES];
-static double elapsed_st[MAXPATCHFILES], T_st, dt_st;
-static double startblk_st[MAXPATCHFILES], endblk_st[MAXPATCHFILES];
-static infodata idata_st[MAXPATCHFILES];
-static unsigned char databuffer[2*MAXDATLEN], padval=4;
-static int currentfile, currentblock, both_IFs_present=0;
-static int bufferpts=0, padnum=0, shiftbuffer=1;
-static double mid_freq_st, ch1_freq_st, delta_freq_st;
-static double chan_freqs[2*MAXNUMCHAN];
-static int chan_index[2*MAXNUMCHAN], chan_mapping[2*MAXNUMCHAN];
-#if 0
-static double chan_freqs2[2*MAXNUMCHAN];
-static int chan_index2[2*MAXNUMCHAN];
-#endif
-static int dfb_chan_lookup[MAXREGS][NIBPERREG] = {
-  {4, 0, 4, 0},
-  {5, 1, 5, 1},
-  {6, 2, 6, 2},
-  {7, 3, 7, 3},
-  {4, 0, 4, 0},
-  {5, 1, 5, 1},
-  {6, 2, 6, 2},
-  {7, 3, 7, 3}
-};
-/* This takes care of byte swap in outreg_b */
-static float sideband_lookup[MAXREGS][NIBPERREG] = {
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0}
-};
-
-typedef struct findex{
-  double freq; 
-  int index;
-} findex;
-
-typedef struct mapindex{
-  int mapping;
-  int index;
-} mapindex;
-
-double slaCldj(int iy, int im, int id, int *j);
-void convert_BPP_one_IF(unsigned char *rawdata, unsigned char *bytes,
-			BPP_ifs ifs);
-void convert_BPP_sum_IFs(unsigned char *rawdata, unsigned char *bytes);
-void convert_BPP_point(unsigned char *rawdata, unsigned char *bytes);
-
-
-int compare_findex(const void *ca, const void *cb)
-/* qsort comparison function for findex */
-{
-  findex *a, *b;
- 
-  a = (findex *) ca;
-  b = (findex *) cb;
-  if ((b->freq - a->freq) < 0.0)
-    return 1;
-  if ((b->freq - a->freq) > 0.0)
-    return -1;
-  /* This keeps IF0 freqs before IF1 freqs*/
-  /*
-  if ((b->index - a->index) < 0)
-    return 1;
-  if ((b->index - a->index) > 0)
-    return -1;
-  */
-  return 0;
-}
-
-
-int compare_mapindex(const void *ca, const void *cb)
-/* qsort comparison function for findex */
-{
-  mapindex *a, *b;
- 
-  a = (mapindex *) ca;
-  b = (mapindex *) cb;
-  if ((b->index - a->index) < 0)
-    return 1;
-  if ((b->index - a->index) > 0)
-    return -1;
-  return 0;
-}
-
-
-static double UT_strings_to_MJD(char *date, char *start_time, 
-				int *mjd_day, double *mjd_fracday)
-{
-  int mtab[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
-  int julday, year, month=1, day, hour, min, sec, err;
-
-  sscanf(date, "%3d:%4d", &julday, &year);
-  julday++;  /* UT date starts from 0, I believe */
-  /* Allow for leap years */
-  if (year % 4 == 0)
-    mtab[1] = 29;
-  if (year % 100 == 0 && year % 400 != 0)
-    mtab[1] = 28;
-  /* Convert Julian day to day and month */
-  while (julday - mtab[month-1] > 0){
-    julday -= mtab[month-1];
-    month++;
-  }
-  day = julday;
-  sscanf(start_time, "%2d:%2d:%2d", &hour, &min, &sec);
-  *mjd_fracday = (hour + (min + (sec / 60.0)) / 60.0) / 24.0;
-  *mjd_day = slaCldj(year, month, day, &err);
-  return *mjd_day + *mjd_fracday;
-}
-
-
-static void swapendian_BPP_header(BPP_SEARCH_HEADER *hdr)
-/* This is required since it is a binary header */
-{
-  int ii;
-
-  hdr->header_version = swap_int(hdr->header_version);
-  hdr->bit_mode = swap_int(hdr->bit_mode);
-  hdr->num_chans = swap_int(hdr->num_chans);
-  hdr->lmst = swap_int(hdr->lmst);
-  hdr->scan_file_number = swap_int(hdr->scan_file_number);
-  hdr->file_size = swap_int(hdr->file_size);
-  hdr->tape_num = swap_int(hdr->tape_num);
-  hdr->tape_file_number = swap_int(hdr->tape_file_number);
-  hdr->enabled_CBs = swap_int(hdr->enabled_CBs);
-  hdr->mb_start_address = swap_int(hdr->mb_start_address);
-  hdr->mb_end_address = swap_int(hdr->mb_end_address);
-  hdr->mb_start_board = swap_int(hdr->mb_start_board);
-  hdr->mb_end_board = swap_int(hdr->mb_end_board);
-  hdr->mb_vme_mid_address = swap_int(hdr->mb_vme_mid_address);
-  hdr->mb_ack_enabled = swap_int(hdr->mb_ack_enabled);
-  hdr->start_from_ste = swap_int(hdr->start_from_ste);
-  hdr->cb_sum_polarizations = swap_int(hdr->cb_sum_polarizations);
-  hdr->cb_direct_mode = swap_int(hdr->cb_direct_mode);
-  hdr->cb_accum_length = swap_int(hdr->cb_accum_length);
-  hdr->tb_outs_reg = swap_int(hdr->tb_outs_reg);
-  hdr->tb_ste = swap_int(hdr->tb_ste);
-  hdr->tb_stc = swap_int(hdr->tb_stc);
-  hdr->H_deci_factor = swap_int(hdr->H_deci_factor);
-  hdr->GenStat0 = swap_int(hdr->GenStat0);
-  hdr->GenStat1 = swap_int(hdr->GenStat1);
-  hdr->Ack_Reg = swap_int(hdr->Ack_Reg);
-  hdr->dfb_sram_length = swap_int(hdr->dfb_sram_length);
-  hdr->ASYMMETRIC = swap_int(hdr->ASYMMETRIC);
-  hdr->mb_long_ds0 = swap_int(hdr->mb_long_ds0);
-  hdr->aib_serial = swap_int(hdr->aib_serial);
-  hdr->aib_rev = swap_int(hdr->aib_rev);
-  hdr->BACKEND_TYPE = swap_int(hdr->BACKEND_TYPE);
-  hdr->UPDATE_DONE = swap_int(hdr->UPDATE_DONE);
-  hdr->HEADER_TYPE = swap_int(hdr->HEADER_TYPE);
-  hdr->tb_id = swap_int(hdr->tb_id);
-  hdr->aib_if_switch = swap_int(hdr->aib_if_switch);
-  hdr->mb_rev = swap_int(hdr->mb_rev);
-  hdr->mb_serial = swap_int(hdr->mb_serial);
-  hdr->tb_rev = swap_int(hdr->tb_rev);
-  hdr->tb_serial = swap_int(hdr->tb_serial);
-  hdr->mb_xtal_freq = swap_int(hdr->mb_xtal_freq);
-  hdr->scan_num = swap_uint(hdr->scan_num);
-  hdr->ll_file_offset = swap_longlong(hdr->ll_file_offset);
-  hdr->ll_file_size = swap_longlong(hdr->ll_file_size);
-  hdr->length_of_integration = swap_double(hdr->length_of_integration);
-  hdr->samp_rate = swap_double(hdr->samp_rate);
-  hdr->ra_2000 = swap_double(hdr->ra_2000);
-  hdr->dec_2000 = swap_double(hdr->dec_2000);
-  hdr->tele_x = swap_double(hdr->tele_x);
-  hdr->tele_y = swap_double(hdr->tele_y);
-  hdr->tele_z = swap_double(hdr->tele_z);
-  hdr->tele_inc = swap_double(hdr->tele_inc);
-  hdr->Fclk = swap_double(hdr->Fclk);
-  hdr->Har_Clk = swap_double(hdr->Har_Clk);
-  hdr->bandwidth = swap_double(hdr->bandwidth);
-  hdr->rf_lo = swap_double(hdr->rf_lo);
-  hdr->max_dfb_freq = swap_double(hdr->max_dfb_freq);
-  hdr->mjd_start = swap_longdouble(hdr->mjd_start);
-  for (ii=0; ii<FB_CHAN_PER_BRD; ii++){
-    hdr->dfb_sram_freqs[ii] = swap_float(hdr->dfb_sram_freqs[ii]);
-  }
-  for (ii=0; ii<MAX_HARRIS_TAPS; ii++){
-    hdr->i_hcoef[ii] = swap_int(hdr->i_hcoef[ii]);
-    hdr->q_hcoef[ii] = swap_int(hdr->q_hcoef[ii]);
-  }
-  for (ii=0; ii<MAXNUMCB; ii++){
-    hdr->cb_id[ii] = swap_int(hdr->cb_id[ii]);
-    hdr->cb_rev[ii] = swap_int(hdr->cb_rev[ii]);
-    hdr->cb_serial[ii] = swap_int(hdr->cb_serial[ii]);
-    hdr->cb_eprom_mode[ii] = swap_int(hdr->cb_eprom_mode[ii]);
-  }
-  for (ii=0; ii<MAX_NUM_MF_BOARDS; ii++){
-    hdr->mf_rev[ii] = swap_int(hdr->mf_rev[ii]);
-    hdr->mf_serial[ii] = swap_int(hdr->mf_serial[ii]);
-    hdr->mf_filt_width[ii] = swap_double(hdr->mf_filt_width[ii]);
-    hdr->mf_atten[ii] = swap_double(hdr->mf_atten[ii]);
-  }
-  for (ii=0; ii<MAX_NUM_LO_BOARDS; ii++){
-    hdr->lo_rev[ii] = swap_int(hdr->lo_rev[ii]);
-    hdr->lo_serial[ii] = swap_int(hdr->lo_serial[ii]);
-    hdr->aib_los[ii] = swap_double(hdr->aib_los[ii]);
-  }
-  for (ii=0; ii<MAXNUMDFB; ii++){
-    hdr->dfb_mixer_reg[ii] = swap_int(hdr->dfb_mixer_reg[ii]);
-    hdr->dfb_conf_reg[ii] = swap_int(hdr->dfb_conf_reg[ii]);
-    hdr->dfb_sram_addr_msb[ii] = swap_int(hdr->dfb_sram_addr_msb[ii]);
-    hdr->dfb_id[ii] = swap_int(hdr->dfb_id[ii]);
-    hdr->dfb_rev[ii] = swap_int(hdr->dfb_rev[ii]);
-    hdr->dfb_serial[ii] = swap_int(hdr->dfb_serial[ii]);
-    hdr->dfb_sun_program[ii] = swap_int(hdr->dfb_sun_program[ii]);
-    hdr->dfb_eprom[ii] = swap_int(hdr->dfb_eprom[ii]);
-    hdr->dfb_sram_addr[ii] = swap_int(hdr->dfb_sram_addr[ii]);
-    hdr->dfb_har_addr[ii] = swap_int(hdr->dfb_har_addr[ii]);
-    hdr->dfb_clip_adc_neg8[ii] = swap_int(hdr->dfb_clip_adc_neg8[ii]);
-    hdr->dfb_shften_[ii] = swap_int(hdr->dfb_shften_[ii]);
-    hdr->dfb_fwd_[ii] = swap_int(hdr->dfb_fwd_[ii]);
-    hdr->dfb_rvrs_[ii] = swap_int(hdr->dfb_rvrs_[ii]);
-    hdr->dfb_asymmetric[ii] = swap_int(hdr->dfb_asymmetric[ii]);
-    hdr->dfb_i_dc[ii] = swap_double(hdr->dfb_i_dc[ii]);
-    hdr->dfb_q_dc[ii] = swap_double(hdr->dfb_q_dc[ii]);
-    hdr->dfb_gain[ii] = swap_double(hdr->dfb_gain[ii]);
-  }
-}
-
-
-void calc_BPP_chans(BPP_SEARCH_HEADER *hdr)
-/* Calculates freqs and ordering index table for BPP channels */
-{
-  int ii, n=0, dfb_chan, logical_board, regid, bid, nibble, nchans;
-  double  f_aib, u_or_l, f_sram, fc;
-  findex *findexarr;
-  mapindex *mapindexarr;
-
-  /* The following is probably a bad way to see if */
-  /* we need to swap the endianess of the header.  */
-  if (hdr->num_chans < 0 || hdr->num_chans > 2*MAXNUMCHAN){
-    swapendian_BPP_header(hdr);
-  }
-  nchans = (hdr->mb_end_address / 2 - hdr->mb_start_address / 2 + 1) * \
-    (hdr->mb_end_board - hdr->mb_start_board + 1) * 4;
-  if (nchans > 2*MAXNUMCHAN){
-    printf("Error:  nchans (%d) > 2*MAXNUMCHAN (%d) in bpp_calc_chans()\n\n",
-	   nchans, 2*MAXNUMCHAN);
-    exit(1);
-  } else if (nchans == 2*MAXNUMCHAN){
-    both_IFs_present = 1;
-  }
-  /* Loop over (16-bit) regs per board. divide by 2's are to make them   */
-  /* word addresses instead of byte addresses so we can index with them. */
-  /* Normal modes will be regid = 0..3, 0..7, or 4..7                    */
-  for (regid=hdr->mb_start_address/2; regid<=hdr->mb_end_address/2; regid++){
-    /* Loop over each board */
-    for (bid=hdr->mb_start_board; bid<=hdr->mb_end_board; bid++){
-      /* Now find which LOGICAL CB we are reading */
-      logical_board = -1;
-      for (ii=0; ii<MAXNUMCB; ii++){
-        if (bid==hdr->cb_id[ii]){
-          logical_board = ii;
-          break;
-        }
-      }
-      if (logical_board==-1){
-	printf("calc_BPP_chans() - logical_board not found");
-	exit(1);
-      }
-      /* Assumes cabling so that LO0 feeds MF0,1 which feeds leftmost CB! */
-      f_aib = hdr->aib_los[logical_board];
-      /* Loop over 4 nibbles per reg */
-      for (nibble=0; nibble<4; nibble++){
-        dfb_chan = dfb_chan_lookup[regid][nibble];
-        u_or_l = sideband_lookup[regid][nibble];
-        f_sram = hdr->dfb_sram_freqs[dfb_chan];
-	fc = f_aib + f_sram + u_or_l * hdr->bandwidth/4.0;
-        /* chan_freqs[n] = (hdr->rf_lo + fc) / 1000000.0; */
-
-	/* 1 Sept 2001:  I'm not sure what should be here or not... SMR */
-	/* obs below 10 GHz are LSB; above 10 GHz are USB */
-	if (hdr->rf_lo > 1.0e6)
-	  hdr->rf_lo /= 1.0e6;
-
-	if (hdr->rf_lo < 1.e10)
-	  chan_freqs[n++] = hdr->rf_lo + 800 - fc/1.0e6;
-	else
-	  chan_freqs[n++] = hdr->rf_lo + fc/1.0e6;
-      }
-    }
-  }
-
-  /* Make a lookup table which gives chans in order of increasing freq */
-  
-  numchan_st = MAXNUMCHAN;
-  findexarr = (findex *)malloc(sizeof(findex) * nchans);
-  mapindexarr = (mapindex *)malloc(sizeof(mapindex) * nchans);
-  for (ii=0; ii<nchans; ii++){
-    findexarr[ii].freq = chan_freqs[ii];
-    findexarr[ii].index = ii;    
-  }
-  /* Sort IF1 or summed IFs according to freq */
-  qsort(findexarr, MAXNUMCHAN, 
-	sizeof(findex), compare_findex);
-  for (ii=0; ii<MAXNUMCHAN; ii++){
-    chan_index[ii] = findexarr[ii].index;
-    mapindexarr[ii].index = findexarr[ii].index;
-    mapindexarr[ii].mapping = ii;
-  }
-  /* Sort IF1 or summed IFs according to index */
-  qsort(mapindexarr, MAXNUMCHAN, 
-	sizeof(mapindex), compare_mapindex);
-
-  if (both_IFs_present){
-    /* Sort IF2 according to freq */
-    qsort(findexarr+MAXNUMCHAN, MAXNUMCHAN, 
-	  sizeof(findex), compare_findex);
-    for (ii=MAXNUMCHAN; ii<2*MAXNUMCHAN; ii++){
-      chan_index[ii] = findexarr[ii].index;
-      mapindexarr[ii].index = findexarr[ii].index;
-      mapindexarr[ii].mapping = ii-MAXNUMCHAN;
-    }
-    /* Sort IF2 according to index */
-    qsort(mapindexarr+MAXNUMCHAN, MAXNUMCHAN, 
-	  sizeof(mapindex), compare_mapindex);
-  }
-  free(findexarr);
-  for (ii=0; ii<nchans; ii++)
-    chan_mapping[ii] = mapindexarr[ii].mapping;
-  free(mapindexarr);
-
-  /* Set the static variables */
-
-  n = nchans / 2;
-  mid_freq_st = 0.5 * (chan_freqs[chan_index[n]] + 
-		       chan_freqs[chan_index[n-1]]);
-  ch1_freq_st = chan_freqs[chan_index[0]];
-  delta_freq_st = chan_freqs[chan_index[1]] - chan_freqs[chan_index[0]];
-}
-
-
-void BPP_hdr_to_inf(BPP_SEARCH_HEADER *hdr, infodata *idata)
-/* Convert BPP header into an infodata structure */
-{
-  double MJD;
-  char ctmp[80];
-
-  strncpy(idata->object, hdr->target_name, 32);
-  idata->ra_h = (int) floor(hdr->ra_2000 / 10000.0);
-  idata->ra_m = (int) floor((hdr->ra_2000 - 
-			     idata->ra_h * 10000) / 100.0);
-  idata->ra_s = hdr->ra_2000 - idata->ra_h * 10000 - 
-    idata->ra_m * 100;
-  idata->dec_d = (int) floor(fabs(hdr->dec_2000) / 10000.0);
-  idata->dec_m = (int) floor((fabs(hdr->dec_2000) - 
-			      idata->dec_d * 10000) / 100.0);
-  idata->dec_s = fabs(hdr->dec_2000) - idata->dec_d * 10000 - 
-    idata->dec_m * 100;
-  if (hdr->dec_2000 < 0.0)
-    idata->dec_d = -idata->dec_d;
-  strcpy(idata->telescope, "GBT");
-  strcpy(idata->instrument, "BCPM1");
-  idata->num_chan = numchan_st;
-  idata->dt = hdr->samp_rate / 1000000.0;
-  idata->N = hdr->length_of_integration / idata->dt;
-  idata->chan_wid = fabs(delta_freq_st);
-  idata->freqband = idata->num_chan * idata->chan_wid;
-  idata->freq = ch1_freq_st;
-  idata->fov = 1.2 * SOL * 3600.0 / (1000000.0 * idata->freq * 64 * DEGTORAD);
-  MJD = UT_strings_to_MJD(hdr->date, hdr->start_time, 
-			  &(idata->mjd_i), &(idata->mjd_f));
-  idata->bary = 0;
-  idata->numonoff = 0;
-  strcpy(idata->band, "Radio");
-  strcpy(idata->analyzer, "Scott Ransom");
-  strcpy(idata->observer, "--");
-  if (hdr->cb_sum_polarizations)
-    sprintf(ctmp, "Polarizations were summed in hardware.");
-  else
-    sprintf(ctmp, "Polarizations were not summed in hardware.");
-  sprintf(idata->notes, "Scan number %010u from tape %d, file %d.\n    Topo UTC Date (DDD:YYYY) & Time at file start = %s, %s\n    %s\n", 
-	  hdr->scan_num, hdr->tape_num, hdr->tape_file_number, 
-	  hdr->date, hdr->start_time, ctmp);
-}
-
-
-void get_BPP_file_info(FILE *files[], int numfiles, long long *N, 
-		       int *ptsperblock, int *numchan, double *dt, 
-		       double *T, infodata *idata, int output)
-/* Read basic information into static variables and make padding      */
-/* calculations for a set of BPP rawfiles that you want to patch      */
-/* together.  N, numchan, dt, and T are return values and include all */
-/* the files with the required padding.  If output is true, prints    */
-/* a table showing a summary of the values.                           */
-{
-  int ii;
-  char rawhdr[BPP_HEADER_SIZE];
-  BPP_SEARCH_HEADER *header;
-
-  if (numfiles > MAXPATCHFILES){
-    printf("\nThe number of input files (%d) is greater than \n", numfiles);
-    printf("   MAXPATCHFILES=%d.  Exiting.\n\n", MAXPATCHFILES);
-    exit(0);
-  }
-  chkfread(rawhdr, BPP_HEADER_SIZE, 1, files[0]);
-  header = (BPP_SEARCH_HEADER *)rawhdr;
-  calc_BPP_chans(header);
-  BPP_hdr_to_inf(header, &idata_st[0]);
-  BPP_hdr_to_inf(header, idata);
-  *numchan = numchan_st = idata_st[0].num_chan;
-  *ptsperblock = ptsperblk_st;
-  if (both_IFs_present){
-    printf("  (Note:  Both IFs are present.)\n");
-    numifs_st = 2;
-  } else
-    numifs_st = 1;
-  bytesperpt_st = (numchan_st * numifs_st * 4) / 8;
-  bytesperblk_st = ptsperblk_st * bytesperpt_st;
-  filedatalen_st[0] = chkfilelen(files[0], 1) - BPP_HEADER_SIZE;
-  numblks_st[0] = filedatalen_st[0] / bytesperblk_st;
-  numpts_st[0] = numblks_st[0] * ptsperblk_st;
-  N_st = numpts_st[0];
-  dt_st = *dt = idata_st[0].dt;
-  times_st[0] = numpts_st[0] * dt_st;
-  mjds_st[0] = idata_st[0].mjd_i + idata_st[0].mjd_f;
-  elapsed_st[0] = 0.0;
-  startblk_st[0] = 1;
-  endblk_st[0] = (double) numpts_st[0] / ptsperblk_st;
-  padpts_st[0] = padpts_st[numfiles-1] = 0;
-  for (ii=1; ii<numfiles; ii++){
-    chkfread(rawhdr, BPP_HEADER_SIZE, 1, files[ii]);
-    header = (BPP_SEARCH_HEADER *)rawhdr;
-    calc_BPP_chans(header);
-    BPP_hdr_to_inf(header, &idata_st[ii]);
-    if (idata_st[ii].num_chan != numchan_st){
-      printf("Number of channels (file %d) is not the same!\n\n", ii+1);
-    }
-    if (idata_st[ii].dt != dt_st){
-      printf("Sample time (file %d) is not the same!\n\n", ii+1);
-    }
-    filedatalen_st[ii] = chkfilelen(files[ii], 1) - BPP_HEADER_SIZE;
-    numblks_st[ii] = filedatalen_st[ii] / bytesperblk_st;
-    numpts_st[ii] = numblks_st[ii] * ptsperblk_st;
-    times_st[ii] = numpts_st[ii] * dt_st;
-    /* If the MJDs are equal, then this is a continuation */
-    /* file.  In that case, calculate the _real_ time     */
-    /* length of the previous file and add it to the      */
-    /* previous files MJD to get the current MJD.         */
-    mjds_st[ii] = idata_st[ii].mjd_i + idata_st[ii].mjd_f;
-    if (fabs(mjds_st[ii]-mjds_st[0]) < 1.0e-6 / SECPERDAY){
-      elapsed_st[ii] = (filedatalen_st[ii-1] / bytesperpt_st) * dt_st;
-      idata_st[ii].mjd_f = idata_st[ii-1].mjd_f + elapsed_st[ii] / SECPERDAY;
-      idata_st[ii].mjd_i = idata_st[ii-1].mjd_i;
-      if (idata_st[ii].mjd_f >= 1.0){
-	idata_st[ii].mjd_f -= 1.0;
-	idata_st[ii].mjd_i++;
-      }
-      mjds_st[ii] = idata_st[ii].mjd_i + idata_st[ii].mjd_f;
-    } else {
-      elapsed_st[ii] = mjd_sec_diff(idata_st[ii].mjd_i, idata_st[ii].mjd_f,
-				    idata_st[ii-1].mjd_i, idata_st[ii-1].mjd_f);
-    }
-    padpts_st[ii-1] = (long long)((elapsed_st[ii]-times_st[ii-1]) / 
-				  dt_st + 0.5);
-    elapsed_st[ii] += elapsed_st[ii-1];
-    N_st += numpts_st[ii] + padpts_st[ii-1];
-    startblk_st[ii] = (double) (N_st - numpts_st[ii]) /
-      ptsperblk_st + 1;
-    endblk_st[ii] = (double) (N_st) / ptsperblk_st;
-  }
-  padpts_st[numfiles-1] = ((long long) ceil(endblk_st[numfiles-1]) *
-                           ptsperblk_st - N_st);
-  N_st += padpts_st[numfiles-1];
-  *N = N_st;
-  *T = T_st = N_st * dt_st;
-  currentfile = currentblock = 0;
-#if 0
-  {
-    double *freq;
-    int *nibble;
-
-    for (ii=0; ii<96; ii++){
-      gen_channel_mapping(header, &nibble, &freq, NULL);
-      chan_index2[ii] = nibble[ii];
-      chan_freqs2[ii] = freq[ii]/1000000.0;
-    }
-    for (ii=0; ii<numchan_st; ii++){
-      printf("%3d  %3d  %3d  %10.3f  %3d  %10.3f\n", ii, 
-	     chan_mapping[ii], chan_index[ii], chan_freqs[chan_index[ii]],
-	     chan_index2[ii], chan_freqs2[ii]);
-    }
-  }
-#endif
-  if (output){
-    printf("  Number of files = %d\n", numfiles);
-    printf("     Points/block = %d\n", ptsperblk_st);
-    printf("  Num of channels = %d\n", numchan_st);
-    printf(" Total points (N) = %lld\n", N_st);
-    printf(" Sample time (dt) = %-14.14g\n", dt_st);
-    printf("   Total time (s) = %-14.14g\n\n", T_st);
-    printf("File  Start Block    Last Block     Points      Elapsed (s)      Time (s)            MJD           Padding\n");
-    printf("----  ------------  ------------  ----------  --------------  --------------  ------------------  ----------\n");
-    for (ii=0; ii<numfiles; ii++)
-      printf("%2d    %12.11g  %12.11g  %10lld  %14.13g  %14.13g  %17.12f  %10lld\n",
-             ii+1, startblk_st[ii], endblk_st[ii], numpts_st[ii],
-             elapsed_st[ii], times_st[ii], mjds_st[ii], padpts_st[ii]);
-    printf("\n");
-  }
-}
-
-
-void BPP_update_infodata(int numfiles, infodata *idata)
-/* Update the onoff bins section in case we used multiple files */
-{
-  
-  int ii, index=2;
-
-  idata->N = N_st;
-  if (numfiles==1 && padpts_st[0]==0){
-    idata->numonoff = 0;
-    return;
-  }
-  /* Determine the topocentric onoff bins */
-  idata->numonoff = 1;
-  idata->onoff[0] = 0.0;
-  idata->onoff[1] = numpts_st[0] - 1.0;
-  for (ii=1; ii<numfiles; ii++){
-    if (padpts_st[ii-1]){
-      idata->onoff[index] = idata->onoff[index-1] + padpts_st[ii-1];
-      idata->onoff[index+1] = idata->onoff[index] + numpts_st[ii];
-      idata->numonoff++;
-      index += 2;
-    } else {
-      idata->onoff[index-1] += numpts_st[ii];
-    }
-  }
-  if (padpts_st[numfiles-1]){
-    idata->onoff[index] = idata->onoff[index-1] + padpts_st[numfiles-1];
-    idata->onoff[index+1] = idata->onoff[index];
-    idata->numonoff++;
-  }
-}
-
-
-int skip_to_BPP_rec(FILE *infiles[], int numfiles, int rec)
-/* This routine skips to the record 'rec' in the input files   */
-/* *infiles.  *infiles contains 4 bit digitized data from the  */
-/* BCPM1 backend at the GBT.  Returns the record skipped to.   */
-{
-  double floor_blk;
-  int filenum=0;
- 
-  if (rec < startblk_st[0])
-    rec += (startblk_st[0] - 1);
-  if (rec > 0 && rec < endblk_st[numfiles-1]){
- 
-    /* Find which file we need */
-    while (rec > endblk_st[filenum])
-      filenum++;
- 
-    currentblock = rec - 1;
-    shiftbuffer = 1;
-    floor_blk = floor(startblk_st[filenum]);
- 
-    /* Set the data buffer to all padding just in case */
-    memset(databuffer, padval, 2*MAXDATLEN);
- 
-    /* Warning:  I'm not sure if the following is correct. */
-    /*   If really needs accurate testing to see if my     */
-    /*   offsets are correct.  Bottom line, don't trust    */
-    /*   a TOA determined using the following!             */
- 
-    if (rec < startblk_st[filenum]){  /* Padding region */
-      currentfile = filenum-1;
-      chkfileseek(infiles[currentfile], 0, 1, SEEK_END);
-      bufferpts = padpts_st[currentfile] % ptsperblk_st;
-      padnum = ptsperblk_st * (rec - endblk_st[currentfile] - 1);
-      /*
-      printf("Padding:  currentfile = %d  bufferpts = %d  padnum = %d\n",
-             currentfile, bufferpts, padnum);
-      */
-    } else {  /* Data region */
-      currentfile = filenum;
-      chkfileseek(infiles[currentfile], rec - startblk_st[filenum],
-                  bytesperblk_st, SEEK_CUR);
-      bufferpts = (int)((startblk_st[filenum] - floor_blk) * ptsperblk_st + 0.5);
-      padnum = 0;
-      /*
-      printf("Data:  currentfile = %d  bufferpts = %d  padnum = %d\n",
-             currentfile, bufferpts, padnum);
-      */
-    }
- 
-  } else {
-    printf("\n rec = %d out of range in skip_to_BPP_rec()\n", rec);
-    exit(1);
-  }
-  return rec;
-}
-
-
-void print_BPP_hdr(BPP_SEARCH_HEADER *hdr)
-/* Output a BPP header in human readable form */
-{
-  int mjd_i;
-  double mjd_d;
-
-  calc_BPP_chans(hdr);
-  printf("\n'%s' (version %d)\n", hdr->head, hdr->header_version);
-  printf("                     Target = %s\n", hdr->target_name);
-  if (strlen(hdr->obs_group))
-    printf("                Observed by = %s\n", hdr->obs_group);
-  printf("   Scan number (DDDYYYY###) = %010u\n", hdr->scan_num);
-  printf("           Scan file number = %d\n", hdr->scan_file_number);
-  /*
-  printf("          File size (bytes) = %d\n", hdr->file_size);
-  */
-  printf("                Tape number = %d\n", hdr->tape_num);
-  printf("           Tape file number = %d\n", hdr->tape_file_number);
-  printf("       LMST in sec since 0h = %d\n", hdr->lmst);
-  printf("        UTC date (DDD:YYYY) = %s\n", hdr->date);
-  printf("        UTC time (HH:MM:SS) = %s\n", hdr->start_time);
-  printf("             MJD start time = %.11f\n", 
-	 UT_strings_to_MJD(hdr->date, hdr->start_time, &mjd_i, &mjd_d));
-  printf("    RA (J2000, HHMMSS.SSSS) = %.4f\n", hdr->ra_2000);
-  printf("   DEC (J2000, DDMMSS.SSSS) = %.4f\n", hdr->dec_2000);
-  printf("     Integration length (s) = %.17g\n", hdr->length_of_integration);
-  printf("           Sample time (us) = %.17g\n", hdr->samp_rate);
-  if (hdr->bit_mode==4)
-    printf("               Channel mode = Powers\n");
-  else if (hdr->bit_mode==-4)
-    printf("               Channel mode = Direct voltages\n");
-  else
-    printf("        UNKNOWN CHANNEL MODE!!\n");
-  if (hdr->cb_sum_polarizations){
-    printf("      Polarizations summed? = Yes\n");
-    printf("         Number of channels = %d\n", hdr->num_chans);
-    printf("    Overall bandwidth (MHz) = %.17g\n", 
-	   hdr->num_chans * delta_freq_st);
-  } else {
-    printf("      Polarizations summed? = No\n");
-    printf("         Number of channels = %d x 2 IFs\n", hdr->num_chans/2);
-    printf("    Overall bandwidth (MHz) = %.17g\n", 
-	   0.5 * hdr->num_chans * delta_freq_st);
-  }
-  printf("    Channel bandwidth (MHz) = %.17g\n", delta_freq_st);
-  printf("  Lowest channel freq (MHz) = %.17g\n", ch1_freq_st);
-  printf("          Middle freq (MHz) = %.17g\n", mid_freq_st);
-  printf("  LO freq used for IF (MHz) = %.17g\n", hdr->rf_lo);
-  printf("\n");
-}
-
-
-int read_BPP_rawblock(FILE *infiles[], int numfiles, 
-		      unsigned char *data, int *padding)
-/* This routine reads a single record from the          */
-/* input files *infiles which contain 4 bit digitized   */
-/* data from the BCPM1 pulsar backend at the GBT.       */
-/* A BPP record is ptsperblk_st*numchan_st*4 bits long. */
-/* *data must be bytesperblk_st bytes long.  If padding */
-/* is returned as 1, then padding was added and         */
-/* statistics should not be calculated.                 */
-{
-  int offset=0, numtopad=0;
-  unsigned char *dataptr;
-
-  /* If our buffer array is offset from last time */
-  /* copy the second part into the first.         */
-
-  if (bufferpts && shiftbuffer){
-    offset = bufferpts * bytesperpt_st;
-    memcpy(databuffer, databuffer + bytesperblk_st, offset);
-    dataptr = databuffer + offset;
-  } else {
-    dataptr = data;
-  }
-  shiftbuffer=1;
-
-  /* Make sure our current file number is valid */
-
-  if (currentfile >= numfiles)
-    return 0;
-
-  /* First, attempt to read data from the current file */
-  
-  if (fread(dataptr, bytesperblk_st, 1, infiles[currentfile])){ /* Got Data */
-    *padding = 0;
-    /* Put the new data into the databuffer if needed */
-    if (bufferpts){
-      memcpy(data, dataptr, bytesperblk_st);
-    }
-    currentblock++;
-    return 1;
-  } else { /* Didn't get data */
-    if (feof(infiles[currentfile])){  /* End of file? */
-      numtopad = padpts_st[currentfile] - padnum;
-      if (numtopad){  /* Pad the data? */
-	*padding = 1;
-	if (numtopad >= ptsperblk_st - bufferpts){  /* Lots of padding */
-	  if (bufferpts){  /* Buffer the padding? */
-	    /* Add the amount of padding we need to */
-	    /* make our buffer offset = 0           */
-	    numtopad = ptsperblk_st - bufferpts;
-	    memset(dataptr, padval, numtopad * bytesperpt_st);
-	    /* Copy the new data/padding into the output array */
-	    memcpy(data, databuffer, bytesperblk_st);
-	    bufferpts = 0;
-	  } else {  /* Add a full record of padding */
-	    numtopad = ptsperblk_st;
-	    memset(data, padval, bytesperblk_st);
-	  }
-	  padnum += numtopad;
-	  currentblock++;
-	  /* If done with padding reset padding variables */
-	  if (padnum==padpts_st[currentfile]){
-	    padnum = 0;
-	    currentfile++;
-	  }
-	  return 1;
-	} else {  /* Need < 1 block (or remaining block) of padding */
-	  int pad;
-	  /* Add the remainder of the padding and */
-	  /* then get a block from the next file. */
-          memset(databuffer + bufferpts * bytesperpt_st, 
-		 padval, numtopad * bytesperpt_st);
-	  padnum = 0;
-	  currentfile++;
-	  shiftbuffer = 0;
-	  bufferpts += numtopad;
-	  return read_BPP_rawblock(infiles, numfiles, data, &pad);
-	}
-      } else {  /* No padding needed.  Try reading the next file */
-	currentfile++;
-	shiftbuffer = 0;
-	return read_BPP_rawblock(infiles, numfiles, data, padding);
-      }
-    } else {
-      printf("\nProblem reading record from BPP data file:\n");
-      printf("   currentfile = %d, currentblock = %d.  Exiting.\n",
-	     currentfile, currentblock);
-      exit(1);
-    }
-  }
-}
-
-
-int read_BPP_rawblocks(FILE *infiles[], int numfiles, 
-		       unsigned char rawdata[], int numblocks,
-		       int *padding)
-     /* This routine reads numblocks BPP records from the input  */
-/* files *infiles.  The 4-bit data is returned in rawdata   */
-/* which must have a size of numblocks * bytesperblk_st.    */
-/* The number  of blocks read is returned.                  */
-/* If padding is returned as 1, then padding was added      */
-/* and statistics should not be calculated                  */
-{
-  int ii, retval=0, pad, numpad=0;
-  
-  *padding = 0;
-  for (ii=0; ii<numblocks; ii++){
-    retval += read_BPP_rawblock(infiles, numfiles, 
-				rawdata + ii * bytesperblk_st, &pad);
-    if (pad)
-      numpad++;
-  }
-  /* Return padding 'true' if more than */
-  /* half of the blocks are padding.    */
-  /* 
-     if (numpad > numblocks / 2)
-        *padding = 1;
-  */
-  /* Return padding 'true' if any block was padding */
-  if (numpad) 
-    *padding = 1;
-  return retval;
-}
-
-
-int read_BPP(FILE *infiles[], int numfiles, float *data, 
-	     int numpts, double *dispdelays, int *padding, 
-	     int *maskchans, int *nummasked, mask *obsmask, 
-	     BPP_ifs ifs)
-/* This routine reads numpts from the BPP raw input    */
-/* files *infiles.  These files contain 4-bit data     */
-/* from the BCPM1 backend at the GBT.  Time delays     */
-/* and a mask are applied to each channel.  It returns */
-/* the # of points read if successful, 0 otherwise.    */
-/* If padding is returned as 1, then padding was       */
-/* added and statistics should not be calculated.      */
-/* maskchans is an array of length numchans contains   */
-/* a list of the number of channels that were masked.  */
-/* ifs is which ifs to return (assuming both IFs have  */
-/* been recorded. Legal values are IF0, IF1, SUMIFS.   */
-/* The # of channels masked is returned in nummasked.  */
-/* obsmask is the mask structure to use for masking.   */
-{
-  int ii, jj, numread=0, offset, sampperblk;
-  double starttime=0.0;
-  static unsigned char *tempzz, *raw, *rawdata1, *rawdata2; 
-  static unsigned char *currentdata, *lastdata, bytepadval;
-  static int firsttime=1, numblocks=1, allocd=0, mask=0;
-  static double duration=0.0, timeperblk=0.0;
-
-  /* The x2 comes from 4-bits/pt */
-  sampperblk = bytesperblk_st * 2;
-  *nummasked = 0;
-  if (firsttime) {
-    if (numpts % ptsperblk_st){
-      printf("numpts must be a multiple of %d in read_BPP()!\n",
-	     ptsperblk_st);
-      exit(1);
-    } else
-      numblocks = numpts / ptsperblk_st;
-    
-    if (obsmask->numchan) mask = 1;
-    raw  = gen_bvect(numblocks * bytesperblk_st);
-    rawdata1 = gen_bvect(numblocks * sampperblk);
-    rawdata2 = gen_bvect(numblocks * sampperblk);
-    /* Put padval in the low and high nibbles */
-    bytepadval = (padval << 4) | padval;
-    allocd = 1;
-    timeperblk = ptsperblk_st * dt_st;
-    duration = numblocks * timeperblk;
-    
-    numread = read_BPP_rawblocks(infiles, numfiles, raw, 
-				 numblocks, padding);
-    if (numread != numblocks && allocd){
-      printf("Problem reading the raw BPP data file.\n\n");
-      free(raw);
-      free(rawdata1);
-      free(rawdata2);
-      allocd = 0;
-      return 0;
-    }
-    
-    currentdata = rawdata1;
-    lastdata = rawdata2;
-
-    if (mask){
-      starttime = currentblock * timeperblk;
-      *nummasked = check_mask(starttime, duration, obsmask, maskchans);
-      if (*nummasked==-1) /* If all channels are masked */
-	memset(raw, bytepadval, numblocks * sampperblk);
-    }
-
-    if (numifs_st==2){
-      /* Choosing a single IF */
-      if (ifs==IF0 || ifs==IF1)
-	for (ii=0; ii<numpts; ii++)
-	  convert_BPP_one_IF(raw + ii * bytesperpt_st, 
-			     currentdata + ii * numchan_st, ifs);
-      /* Sum the IFs */
-      else
-	for (ii=0; ii<numpts; ii++)
-	  convert_BPP_sum_IFs(raw + ii * bytesperpt_st, 
-			      currentdata + ii * numchan_st);
-    } else {
-      /* Select the already summed IFs */
-      for (ii=0; ii<numpts; ii++)
-	convert_BPP_point(raw + ii * bytesperpt_st, 
-			  currentdata + ii * numchan_st);
-    }
-
-    if (*nummasked > 0){ /* Only some of the channels are masked */
-      for (ii=0; ii<numpts; ii++){
-	offset = ii * numchan_st;
-	for (jj=0; jj<*nummasked; jj++)
-	  currentdata[offset+maskchans[jj]] = padval;
-      }
-    }
-
-    SWAP(currentdata, lastdata);
-    firsttime=0;
-  }
-  
-  /* Read, convert and de-disperse */
-  
-  if (allocd){
-    numread = read_BPP_rawblocks(infiles, numfiles, raw, 
-				 numblocks, padding);
-
-    if (mask){
-      starttime = currentblock * timeperblk;
-      *nummasked = check_mask(starttime, duration, obsmask, maskchans);
-      if (*nummasked==-1) /* If all channels are masked */
-	memset(raw, bytepadval, numblocks * sampperblk);
-    }
-
-    if (numifs_st==2){
-      /* Choosing a single IF */
-      if (ifs==IF0 || ifs==IF1)
-	for (ii=0; ii<numpts; ii++)
-	  convert_BPP_one_IF(raw + ii * bytesperpt_st, 
-			     currentdata + ii * numchan_st, ifs);
-      /* Sum the IFs */
-      else
-	for (ii=0; ii<numpts; ii++)
-	  convert_BPP_sum_IFs(raw + ii * bytesperpt_st, 
-			      currentdata + ii * numchan_st);
-    } else {
-      /* Select the already summed IFs */
-      for (ii=0; ii<numpts; ii++)
-	convert_BPP_point(raw + ii * bytesperpt_st, 
-			  currentdata + ii * numchan_st);
-    }
-
-    if (*nummasked > 0){ /* Only some of the channels are masked */
-      for (ii=0; ii<numpts; ii++){
-	offset = ii * numchan_st;
-	for (jj=0; jj<*nummasked; jj++)
-	  currentdata[offset+maskchans[jj]] = padval;
-      }
-    }
-
-    dedisp(currentdata, lastdata, numpts, numchan_st, dispdelays, data);
-    SWAP(currentdata, lastdata);
-
-    if (numread != numblocks){
-      free(raw);
-      free(rawdata1);
-      free(rawdata2);
-      allocd = 0;
-    }
-    return numread * ptsperblk_st;
-  } else {
-    return 0;
-  }
-}
-
-void get_BPP_channel(int channum, float chandat[], 
-		     unsigned char rawdata[], int numblocks,
-		     BPP_ifs ifs)
-/* Return the values for channel 'channum' of a block of       */
-/* 'numblocks' raw BPP data stored in 'rawdata' in 'chandat'.  */
-/* 'rawdata' should have been initialized using                */
-/* read_BPP_rawblocks(), and 'chandat' must have at least      */
-/* 'numblocks' * 'ptsperblk_st' spaces.                        */
-/* Channel 0 is assumed to be the lowest freq channel.         */
-/* The different IFs are handled as standard channel numbers.  */
-/* with 'channum' = 0-numchan_st-1 as per normal.              */
-{
-  unsigned char *rawdataptr;
-  int ii, nibble;
-
-  if (channum > numchan_st*numifs_st || channum < 0){
-    printf("\nchannum = %d is out of range in get_BPP_channel()!\n\n",
-	   channum);
-    exit(1);
-  }
-  if (numifs_st==2){
-    /* Choosing a single IF */
-    if (ifs==IF0 || ifs==IF1){
-      if (ifs==IF0){
-	rawdataptr = rawdata + chan_index[channum] / 2;
-	nibble = chan_index[channum] % 2;
-      } else {
-	rawdataptr = rawdata + chan_index[channum+numchan_st] / 2;
-	nibble = chan_index[channum+numchan_st] % 2;
-      }
-      if (nibble) /* Use last 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] = (*rawdataptr & 0x0F);
-	  rawdataptr += bytesperpt_st;
-	}
-      else /* Use first 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] = (*rawdataptr >> 0x04);
-	  rawdataptr += bytesperpt_st;
-	}
-    /* Sum the IFs */
-    } else {
-      rawdataptr = rawdata + chan_index[channum] / 2;
-      nibble = chan_index[channum] % 2;
-      if (nibble) /* Use last 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] = (*rawdataptr & 0x0F);
-	  rawdataptr += bytesperpt_st;
-	}
-      else /* Use first 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] = (*rawdataptr >> 0x04);
-	  rawdataptr += bytesperpt_st;
-	}
-      rawdataptr = rawdata + chan_index[channum+numchan_st] / 2;
-      nibble = chan_index[channum+numchan_st] % 2;
-      if (nibble) /* Use last 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] += (*rawdataptr & 0x0F);
-	  rawdataptr += bytesperpt_st;
-	}
-      else /* Use first 4 bits in the byte */
-	for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	  chandat[ii] += (*rawdataptr >> 0x04);
-	  rawdataptr += bytesperpt_st;
-	}
-    }
-  } else {
-    /* Select the already summed IFs */
-    rawdataptr = rawdata + chan_index[channum] / 2;
-    nibble = chan_index[channum] % 2;
-    if (nibble) /* Use last 4 bits in the byte */
-      for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	chandat[ii] = (*rawdataptr & 0x0F);
-	rawdataptr += bytesperpt_st;
-      }
-    else /* Use first 4 bits in the byte */
-      for (ii=0; ii<numblocks*ptsperblk_st; ii++){
-	chandat[ii] = (*rawdataptr >> 0x04);
-	rawdataptr += bytesperpt_st;
-      }
-  }
-}
-
-
-int read_BPP_subbands(FILE *infiles[], int numfiles, float *data, 
-		      double *dispdelays, int numsubbands, 
-		      int transpose, int *padding, 
-		      int *maskchans, int *nummasked, mask *obsmask,
-		      BPP_ifs ifs)
-/* This routine reads a record from the input files *infiles[]   */
-/* which contain data from the BPP system.  The routine uses    */
-/* dispersion delays in 'dispdelays' to de-disperse the data     */
-/* into 'numsubbands' subbands.  It stores the resulting data    */
-/* in vector 'data' of length 'numsubbands' * 'ptsperblk_st'.    */
-/* The low freq subband is stored first, then the next highest   */
-/* subband etc, with 'ptsperblk_st' floating points per subband. */
-/* It returns the # of points read if succesful, 0 otherwise.    */
-/* If padding is returned as 1, then padding was added and       */
-/* statistics should not be calculated.  'maskchans' is an array */
-/* of length numchans which contains a list of the number of     */
-/* channels that were masked.  The # of channels masked is       */
-/* returned in 'nummasked'.  'obsmask' is the mask structure     */
-/* to use for masking.  If 'transpose'==0, the data will be kept */
-/* in time order instead of arranged by subband as above.        */
-/* ifs is which ifs to return (assuming both IFs have been       */
-/* recorded. Legal values are IF0, IF1, SUMIFS.                  */
-{
-  int ii, jj, numread, trtn, offset;
-  double starttime=0.0;
-  static unsigned char *raw, *tempzz, bytepadval;
-  static unsigned char rawdata1[MAXDATLEN], rawdata2[MAXDATLEN]; 
-  static unsigned char *currentdata, *lastdata, *move;
-  static int firsttime=1, move_size=0, mask=0;
-  static double timeperblk=0.0;
-  
-  *nummasked = 0;
-  if (firsttime) {
-    if (obsmask->numchan) mask = 1;
-    move_size = (ptsperblk_st + numsubbands) / 2;
-    move = gen_bvect(move_size);
-    raw = gen_bvect(bytesperblk_st);
-    currentdata = rawdata1;
-    lastdata = rawdata2;
-    timeperblk = ptsperblk_st * dt_st;
-    if (!read_BPP_rawblock(infiles, numfiles, raw, padding)){
-      printf("Problem reading the raw BPP data file.\n\n");
-      return 0;
-    }
-    /* Put padval in the low and high nibbles */
-    bytepadval = (padval << 4) | padval;
-    if (mask){
-      starttime = currentblock * timeperblk;
-      *nummasked = check_mask(starttime, timeperblk, obsmask, maskchans);
-      if (*nummasked==-1) /* If all channels are masked */
-	memset(raw, bytepadval, bytesperblk_st);
-    }
-    if (numifs_st==2){
-      /* Choosing a single IF */
-      if (ifs==IF0 || ifs==IF1)
-	for (ii=0; ii<ptsperblk_st; ii++)
-	  convert_BPP_one_IF(raw + ii * bytesperpt_st, 
-			     currentdata + ii * numchan_st, ifs);
-      /* Sum the IFs */
-      else
-	for (ii=0; ii<ptsperblk_st; ii++)
-	  convert_BPP_sum_IFs(raw + ii * bytesperpt_st, 
-			      currentdata + ii * numchan_st);
-    } else {
-      /* Select the already summed IFs */
-      for (ii=0; ii<ptsperblk_st; ii++)
-	convert_BPP_point(raw + ii * bytesperpt_st, 
-			  currentdata + ii * numchan_st);
-    }
-    if (*nummasked > 0){ /* Only some of the channels are masked */
-      for (ii=0; ii<ptsperblk_st; ii++){
-	offset = ii * numchan_st;
-	for (jj=0; jj<*nummasked; jj++)
-	  currentdata[offset+maskchans[jj]] = padval;
-      }
-    }
-    SWAP(currentdata, lastdata);
-    firsttime=0;
-  }
-
-  /* Read, convert and de-disperse */
-
-  numread = read_BPP_rawblock(infiles, numfiles, raw, padding);
-  if (mask){
-    starttime = currentblock * timeperblk;
-    *nummasked = check_mask(starttime, timeperblk, obsmask, maskchans);
-    if (*nummasked==-1) /* If all channels are masked */
-      memset(raw, bytepadval, bytesperblk_st);
-  }
-  if (numifs_st==2){
-    /* Choosing a single IF */
-    if (ifs==IF0 || ifs==IF1)
-      for (ii=0; ii<ptsperblk_st; ii++)
-	convert_BPP_one_IF(raw + ii * bytesperpt_st, 
-			   currentdata + ii * numchan_st, ifs);
-    /* Sum the IFs */
-    else
-      for (ii=0; ii<ptsperblk_st; ii++)
-	convert_BPP_sum_IFs(raw + ii * bytesperpt_st, 
-			    currentdata + ii * numchan_st);
-  } else {
-    /* Select the already summed IFs */
-    for (ii=0; ii<ptsperblk_st; ii++)
-      convert_BPP_point(raw + ii * bytesperpt_st, 
-			currentdata + ii * numchan_st);
-  }
-  if (*nummasked > 0){ /* Only some of the channels are masked */
-    for (ii=0; ii<ptsperblk_st; ii++){
-      offset = ii * numchan_st;
-      for (jj=0; jj<*nummasked; jj++)
-	currentdata[offset+maskchans[jj]] = padval;
-    }
-  }
-  dedisp_subbands(currentdata, lastdata, ptsperblk_st, numchan_st, 
-		  dispdelays, numsubbands, data);
-  SWAP(currentdata, lastdata);
-
-  /* Transpose the data into vectors in the result array */
-
-  if (transpose){
-    if ((trtn = transpose_float(data, ptsperblk_st, numsubbands,
-				move, move_size))<0)
-      printf("Error %d in transpose_float().\n", trtn);
-  }
-  if (numread)
-    return ptsperblk_st;
-  else
-    return 0;
-}
-
-void convert_BPP_one_IF(unsigned char *rawdata, unsigned char *bytes,
-			BPP_ifs ifs)
-/* This routine converts a single IF from 4-bit digitized */
-/* data of two IFs into an array of 'numchan' bytes.      */
-{
-  int ii, *indexptr;
-  unsigned char *rawdataptr;
-
-  if (ifs==IF0){
-    rawdataptr = rawdata;
-    indexptr = chan_mapping;
-  } else {
-    rawdataptr = rawdata+MAXNUMCHAN/2;
-    indexptr = chan_mapping+MAXNUMCHAN;
-  }
-  for (ii=0; ii<numchan_st/2; ii++, rawdataptr++){
-    bytes[*indexptr++] = (*rawdataptr >> 0x04);
-    bytes[*indexptr++] = (*rawdataptr & 0x0F);
-  }
-}
-
-
-void convert_BPP_sum_IFs(unsigned char *rawdata, unsigned char *bytes)
-/* This routine converts 4-bit digitized data for 2 IFs */
-/* into a summed IF array of 'numchan' bytes.           */
-{
-  int ii, *indexptr_if1, *indexptr_if2;
-  unsigned char *rawdataptr_if1, *rawdataptr_if2;
-
-  rawdataptr_if1 = rawdata;
-  rawdataptr_if2 = rawdata+MAXNUMCHAN/2;
-  indexptr_if1 = chan_mapping;
-  indexptr_if2 = chan_mapping+MAXNUMCHAN;
-  for (ii=0; ii<numchan_st; ii++) bytes[ii] = 0;
-  for (ii=0; ii<numchan_st/2; ii++){
-    bytes[*indexptr_if1++] += (*rawdataptr_if1 >> 0x04);
-    bytes[*indexptr_if1++] += (*rawdataptr_if1 & 0x0F);
-    bytes[*indexptr_if2++] += (*rawdataptr_if2 >> 0x04);
-    bytes[*indexptr_if2++] += (*rawdataptr_if2 & 0x0F);
-    rawdataptr_if1++;
-    rawdataptr_if2++;
-  }
-}
-
-
-void convert_BPP_point(unsigned char *rawdata, unsigned char *bytes)
-/* This routine converts 4-bit digitized power data */
-/* into an array of 'numchan' bytes.                */
-{
-  int ii, *indexptr;
-  unsigned char *rawdataptr;
-
-  rawdataptr = rawdata;
-  indexptr = chan_mapping;
-  for (ii=0; ii<numchan_st/2; ii++, rawdataptr++){
-    bytes[*indexptr++] = (*rawdataptr >> 0x04);
-    bytes[*indexptr++] = (*rawdataptr & 0x0F);
-  }
-}
-
diff --git a/filterbank-gmrt/bpp.h b/filterbank-gmrt/bpp.h
deleted file mode 100644
index ca2e087..0000000
--- a/filterbank-gmrt/bpp.h
+++ /dev/null
@@ -1,199 +0,0 @@
-#ifndef BPP_HEADER_SIZE
-#define BPP_HEADER_SIZE	32768
-#endif
-
-#define MAXNUMCB 6
-#define MAXNUMDFB (2*MAXNUMCB)
-#define MAX_NUM_LO_BOARDS MAXNUMCB
-#define MAX_NUM_MF_BOARDS (2*MAX_NUM_LO_BOARDS)
-#define FB_CHAN_PER_BRD 8
-#define MAX_HARRIS_TAPS 256
-#define MAXREGS 8
-#define NIBPERREG 4
-#define MAXNUMCHAN (MAXNUMDFB*FB_CHAN_PER_BRD)
-#define PTSPERBLOCK 1000
-#define MAXDATLEN (MAXNUMCHAN*PTSPERBLOCK)
-/* The following were taken from various header files */
-#define NBOARDS         16      /* number of boards in the PSPM             */
-#define NCHANPERBOARD   8       /* number of channels per board             */
-#define NCHAN   (NBOARDS*NCHANPERBOARD) /* maximum total number of channels */
-#define CB_VME_OUT_REG  16      /* Number of bits per output CB reg         */
-#define NBITS           4       /* number of bits per channel               */
-#define BITSPERBYTE     8
-#ifndef TRUE
-#define TRUE 1
-#endif
-#ifndef FALSE
-#define FALSE 0
-#endif
-#define	DATA_WORD	8		/* number of bits in a single word  */
-#define	DATA_TYPE	u_char		/* type of a single data word	    */
-#define	MAXSTATES	(1<<DATA_WORD)	/* maximum number of states in a    */
-					/* single word.			    */
-#define	MAXPACK		(DATA_WORD/2)	/* maximum number of samples in a   */
-					/* single data word, i.e. for 2-bit */
-					/* samples.			    */
-
-typedef enum {
-  IF0, IF1, SUMIFS
-} BPP_ifs;
-
-typedef struct BPP_SEARCH_HEADER{
-  char head[16];	/* Holds "NBPPSEARCH\0" */
-  int header_version;	/* Version number which is different for each backend */
-  unsigned int scan_num;/* Scan number e.g. 31096001 = Obs 1 on day 310 of 1996 */
-			/* Changed to DDDYYYYSSS in Jan 2000 */
-  /* These doubles are all aligned on 8-byte boundaries */
-  double length_of_integration; /* if known in advance */
-  double samp_rate;     /* Calculated from nbpp_sw (in us despite name) */
-  double ra_2000;	/* HHMMSS.SSSS */
-  double dec_2000;	/* DDMMSS.SSSS */
-  double tele_x;	/* Carriage X position in m */
-  double tele_y;	/* Carriage Y position in m */
-  double tele_z;	/* Carriage Z position in m */
-  double tele_inc;	/* Mirror inclination in deg */
-  double Fclk;		/* Fast clock speed (Hz) */
-  double Har_Clk;	/* Harris clock (H_deci_factor*bandwidth) */
-  double bandwidth;	/* DSB channel bandwidth (== Sclk) */
-  double dfb_gain[MAXNUMDFB]; /* Gain that was applied to generate Harris coeffs */
-  /*
-   * AIB Configuration
-   */
-  double aib_los[MAX_NUM_LO_BOARDS];
-  double mf_filt_width[MAX_NUM_MF_BOARDS];
-  double mf_atten[MAX_NUM_MF_BOARDS];
-  double rf_lo;		  /* LO frequency used in the receiver to generate the IF */
-  int bit_mode;		  /* 4 = 4-bit power, -4 = 4-bit voltage in direct mode */
-  int num_chans;	  /* Calculated number of 4-bit channels in each sample */
-  int lmst;		  /* LMST time in seconds since 0h */
-  char target_name[32];	  /* Space for pulsar name or map name for survey */
-  char date[16];	  /* UT date which will match the scan number */
-  char start_time[16];	  /* UT time of the 1pps tick which started the obs*/
-  int scan_file_number;	  /* Which file number of the scan? */
-  int file_size;	  /* Size of this file */
-  int tape_num;		  /* Tape number */
-  int tape_file_number;	  /* File number on this tape */
-  char obs_group[16];	  /* Who did the observation (mainly for future) */
-  int enabled_CBs;	  /* Bitmap of enabled CBs */
-  int mb_start_address;	  /* Real base (8-bit) address of first CB reg read */
-  int mb_end_address;	  /* Read end (8-bit) address of last CB reg read */
-  int mb_start_board;	  /* First board ID read */
-  int mb_end_board;	  /* last board ID read (MB can only read seq. boards) */
-  int mb_vme_mid_address; /* Value stored in VME_MID register (usu. 00) */
-  int mb_ack_enabled;	  /* Boolean, did we use ACK protocol? */
-  int start_from_ste;	  /* Boolean, am I starting with the STE counter? */
-  /*
-   * CB Registers
-   */
-  int cb_sum_polarizations;    /* Boolean, did the CBs sum pols on-board? */
-  int cb_direct_mode;	       /* Boolean, did we read the CBs in direct-mode? */
-  int cb_eprom_mode[MAXNUMCB]; /* Which EPROM table? (MAXNUMCB=6) */
-  int cb_accum_length;	/* Contents of CB accum len regs (all CBs IDENTICAL) */
-                        /* cb_accum_length is TOTAL accum length, not accum_len-1 */
-  /**
-   * TB Registers
-   */
-  int tb_outs_reg;	/* OUTS_REG, turns on/off analog supply and PLLs */
-  int tb_ste;		/* Value stored in STE counter */
-  int tb_stc;		/* This need to be read AFTER an integration!!! */
-  int H_deci_factor;	/* Decimation factor */
-  int GenStat0, GenStat1, Ack_Reg; /* HW registers, for debugging */
-  /*
-   * DFB Registers
-   */
-  /* These first three are the "logical" state of the DFBs */
-  int dfb_sram_length;	/* Same for every board??? */
-  int ASYMMETRIC;	/* Currently the same for all boards */
-  float dfb_sram_freqs[FB_CHAN_PER_BRD]; /* Filled in by setmixer_board (8) */
-  /* These three are for HW debugging, not to be used by analysis software */
-  int dfb_mixer_reg[MAXNUMDFB];     /* Set by set_dfb_mixer (MAXNUMDFB=12) */
-  int dfb_conf_reg[MAXNUMDFB];      /* Set by set_dfb_conf */
-  int dfb_sram_addr_msb[MAXNUMDFB]; /* Set by set_dfb_conf */
-  /* These are the ACTUAL Harris taps loaded into the DFBs */
-  int i_hcoef[MAX_HARRIS_TAPS];     /* MAX_HARRIS_TAPS=256 */
-  int q_hcoef[MAX_HARRIS_TAPS];
-  /*
-   * Hardware configuration
-   */
-  int tb_id;
-  int cb_id[MAXNUMCB];
-  int dfb_id[MAXNUMDFB];
-  int aib_if_switch;	/* Which IF input are we using? (Same for both Pols) */
-  /* Additional Hardware information, 97apr25 MRD */
-  int mb_rev, mb_serial;
-  int tb_rev, tb_serial;
-  int cb_rev[MAXNUMCB], cb_serial[MAXNUMCB];
-  int dfb_rev[MAXNUMDFB], dfb_serial[MAXNUMDFB];
-  int mb_xtal_freq;
-  int mf_serial[MAX_NUM_MF_BOARDS], mf_rev[MAX_NUM_MF_BOARDS];
-  int lo_serial[MAX_NUM_LO_BOARDS], lo_rev[MAX_NUM_LO_BOARDS];
-  int mb_long_ds0;		    /* lengthen DS0 on vme reads with ack enabled */
-  int dfb_sun_program[MAXNUMDFB];   /* Set by set_dfb_mode */
-  int dfb_eprom[MAXNUMDFB];	    /* Set by set_dfb_mode */
-  int dfb_sram_addr[MAXNUMDFB];     /* rev 4 Set by set_dfb_conf */
-  int dfb_har_addr[MAXNUMDFB];      /* rev 4 Set by set_dfb_conf */
-  int dfb_clip_adc_neg8[MAXNUMDFB]; /* for use in DFB mixer table */
-  int dfb_shften_[MAXNUMDFB];	    /* for low level Harris mode */
-  int dfb_fwd_[MAXNUMDFB];	    /* for low level Harris mode */
-  int dfb_rvrs_[MAXNUMDFB];	    /* for low level Harris mode */
-  int dfb_asymmetric[MAXNUMDFB];    /* what kind of taps to load ? */
-  double dfb_i_dc[MAXNUMDFB];	    /* set when programming the Mixer SRAM*/
-  double dfb_q_dc[MAXNUMDFB];	    /* set when programming the Mixer SRAM*/
-  double max_dfb_freq;              /* used in picking decimations */
-  /* 
-   * pre 97apr25 was 29780
-   * pre 97oct29 was 28844
-   * pre 98jan20 was 28836
-   */
-  int aib_serial;
-  int aib_rev;
-  /*
-   * (long long) file_size and offset where added August 1999 to the
-   * source tree. Prior to this time, or when the production binaries
-   * where updated for a particular backend, these values will hold 0
-   * and you should use the (long) file_size above. Note, there was
-   * no equivalent offset number prior to ll_file_offset.
-   */
-  long long ll_file_offset;	/* Cummulative size of all of the previous  */
-				/* files in this scan (Bytes) which can,    */
-				/* e.g. be used to calculate the start time */
-				/* of this file.			    */
-  long long ll_file_size;	/* Size of this particular file (Bytes).    */
-  char quad_word_boundary_filler[8];
-  long double mjd_start;	/* Start time (MJD)			    */
-  char filler[28788];
-  int BACKEND_TYPE;
-  int UPDATE_DONE;
-  int HEADER_TYPE;
-} BPP_SEARCH_HEADER;
-
-
-/* bpp.c */
-int compare_findex(const void *ca, const void *cb);
-void calc_BPP_chans(BPP_SEARCH_HEADER *hdr);
-void BPP_hdr_to_inf(BPP_SEARCH_HEADER *hdr, infodata *idata);
-void get_BPP_file_info(FILE *files[], int numfiles, long long *N, 
-		       int *ptsperblock, int *numchan, double *dt, 
-		       double *T, infodata *idata, int output);
-void BPP_update_infodata(int numfiles, infodata *idata);
-int skip_to_BPP_rec(FILE *infiles[], int numfiles, int rec);
-void print_BPP_hdr(BPP_SEARCH_HEADER *hdr);
-int read_BPP_rawblock(FILE *infiles[], int numfiles, unsigned char *data, 
-		      int *padding);
-int read_BPP_rawblocks(FILE *infiles[], int numfiles, unsigned char rawdata[], 
-		       int numblocks, int *padding);
-int read_BPP(FILE *infiles[], int numfiles, float *data, int numpts, 
-	     double *dispdelays, int *padding, int *maskchans, 
-	     int *nummasked, mask *obsmask, BPP_ifs ifs);
-void convert_BPP_one_IF(unsigned char *rawdata, unsigned char *bytes, 
-			BPP_ifs ifs);
-void convert_BPP_sum_IFs(unsigned char *rawdata, unsigned char *bytes);
-void convert_BPP_point(unsigned char *rawdata, unsigned char *bytes);
-int read_BPP_subbands(FILE *infiles[], int numfiles, float *data, 
-		      double *dispdelays, int numsubbands, 
-		      int transpose, int *padding, 
-		      int *maskchans, int *nummasked, mask *obsmask,
-		      BPP_ifs ifs);
-void get_BPP_channel(int channum, float chandat[], 
-		     unsigned char rawdata[], int numblocks,
-		     BPP_ifs ifs);
diff --git a/filterbank-gmrt/bpp2fb.c b/filterbank-gmrt/bpp2fb.c
deleted file mode 100644
index 39d9c7c..0000000
--- a/filterbank-gmrt/bpp2fb.c
+++ /dev/null
@@ -1,232 +0,0 @@
-/*
-  bpp2fb - converts BPP search-mode data into "filterbank" data 
-
-  BPP search-mode data is read as unsigned chars each consisting of
-  two 4-bit words. Reading the data in this way means that no byte
-  swapping is required. Data are read in as blocks of BLOCKSIZE samples
-  so that BLOCKSIZE/2 unsigned chars are read in each time. 
-*/
-
-#include "filterbank.h"
-#include "bpphdr.h" 
-BPP_SEARCH_HEADER bpp_search; 
-void bpp2fb(FILE *input, FILE *output) /* includefile */
-{
-  FILE *fpou;
-  int np,ns,nc,i,c,b,s,nchars,idump,doit,opened,nsblk,i1,i2,*chtab,blocksize;
-  float *tempblock, *datablock,realtime=0.0;
-  unsigned char *charblock,sample;
-  static unsigned char *charcarry;
-  unsigned short *shortblock;
-  char string[80];
-  int nshift[8] = {28,24,20,16,12,8,4,0};
-  static int ncarryover;
-  static int first = 1;
-  static int fileidx_start=1,file_count=1;
-  static double end_time;
-  double scantime,sample_start,sample_final;
-  int sample_skip,bytestart;
-  int bytefinal,fileidx_final,sample_diff,byte_diff=0;
-  int bpp_headersize = 32768;
-  int rd_jnq=0;
-  double sample_end,byte_end;
-
-  np=idump=opened=0;
-  ns=512;
-  blocksize=ns*nchans;
-  nc=nchans;
-
-  if(first) {
-    charcarry  = (unsigned char *) malloc(sizeof(unsigned char)*blocksize);
-    ncarryover = 0;
-    first = 0;
-    scantime = (double)((double)bpp_search.file_size)/((double)(nchans/2))*bpp_search.samp_rate*1.e-6;
-
-    if(start_time){
-      fileidx_start = ceil(start_time/scantime);
-      file_count = fileidx_start;
-      sample_skip = floor(start_time/tsamp);
-      sample_start = sample_skip - (double)((fileidx_start-1)*(scantime/(double)tsamp));
-      bytestart = (sample_start*(double)nchans)/2.;
-
-      if(bytestart<blocksize/2){
-	bytestart+=(double)bpp_search.file_size-blocksize/2;
-	fileidx_start-=1;
-	file_count -=1;
-	sample_skip -= ns;
-	sample_start = sample_skip - (double)((fileidx_start-1)*(scantime/(double)tsamp));
-      }
-
-      realtime += sample_skip*(double)tsamp - scantime*(fileidx_start-1);
-
-      if((rd_jnq =fseek(input,bytestart,SEEK_CUR)< 0)) 	fprintf(stderr,"Error seeking to data byte %d in file\n",bytestart);
-    }
-    
-    if(final_time){
-      sample_end = ceil(final_time/(double)tsamp);
-      fileidx_final = ceil(final_time/scantime);
-      sample_final = sample_end-(double)((fileidx_final-1)*scantime/tsamp);
-      byte_end = ceil(final_time/(double)tsamp)*(double)nchans/2;
-      bytefinal = (double)sample_final*(double)nchans/2;
-      end_time = (double)(byte_end/((double)nchans/2)*(double)tsamp);
-
-      
-      fprintf(stderr,"Ending Time:   \n");
-      fprintf(stderr,"          End File #                %2d\n",fileidx_final);
-      fprintf(stderr,"          End Sample #    %12.3f\n",sample_final);
-      fprintf(stderr,"          End Time (s)    %12.5f     (w.r.t. File # 1)\n",end_time);
-
-      if(start_time) {
-	end_time -= (double)((fileidx_start-1)*scantime);
-	fprintf(stderr,"          End Time (s)    %12.5f     (w.r.t. File # %d)\n",end_time,fileidx_start);
-      }
-
-    }
-    if (!final_time)    end_time = 1000*scantime;
-  }
-
-  tempblock  = (float *) malloc(sizeof(float)*blocksize);
-  datablock  = (float *) malloc(sizeof(float)*blocksize);
-  charblock  = (unsigned char *) malloc(sizeof(unsigned char)*blocksize);
-  shortblock = (unsigned short *) malloc(sizeof(unsigned short)*blocksize);
-
-  if (headerfile) {
-    /* write output ASCII header file */
-    fpou=open_file("head","w");  
-    fprintf(fpou,"Original BPP file: %s\n",inpfile);
-    fprintf(fpou,"Sample time (us): %f\n",tsamp*1.0e6);
-    fprintf(fpou,"Number of samples/record: %d\n",ns);
-    fprintf(fpou,"Center freq (MHz): %f\n",fch1+(float)nchans*foff/2.0);
-    fprintf(fpou,"Channel band (kHz): %f\n",fabs(foff)*1000.0);
-    fprintf(fpou,"Number of channels/record: %d\n",nc);
-    fprintf(fpou,"Time stamp (MJD): %18.12f\n",tstart);
-    fprintf(fpou,"AZ at start: %f\n",az_start);
-    fprintf(fpou,"ZA at start: %f\n",za_start);
-    fprintf(fpou,"RA (J2000): %f\n",src_raj);
-    fprintf(fpou,"DEC (J2000):  %f\n",src_dej);
-    fclose(fpou);
-  }
-
-  chtab=bpp_chans(bpp_search.bandwidth,bpp_search.mb_start_address,
-		  bpp_search.mb_end_address,bpp_search.mb_start_board,
-		  bpp_search.mb_end_board,bpp_search.cb_id,
-		  bpp_search.aib_los,bpp_search.dfb_sram_freqs,
-		  bpp_search.rf_lo);
-
-
-  /************************************************/
-  /* main loop over each record of input data file*/
-  /************************************************/
-  while (!feof(input)&& realtime<=end_time) {
-    /* read in a record */
-
-    if(!ncarryover)  /* No data left from previous file */
-      nchars=fread(charblock,sizeof(unsigned char),blocksize/2,input);
-
-    if(ncarryover>0) { /* Add to partial block left from previous file */
-      nchars=fread(charblock,sizeof(unsigned char),(blocksize/2-ncarryover),input);
-      for(c=0;c<nchars;c++) 
-	charblock[c+ncarryover] = charblock[c];
-      for(c=0;c<ncarryover;c++) 
-	charblock[c] = charcarry[c];
-      ncarryover = 0;
-      nchars = blocksize/2;
-      fprintf(stderr,"          Starting at beginning of File # %d\n",file_count);
-    }
-    if(!ncarryover && nchars<blocksize/2) { /* Don't process, just keep */
-      ncarryover = nchars;
-      for(c=0;c<nchars;c++) 
-	charcarry[c] = charblock[c];
-      file_count++;
-      if(final_time)      end_time = end_time - (double)tsamp*(int)(scantime/(double)tsamp);
-      fprintf(stderr,"Advancing to file # %d\n",file_count);
-      /*      if(final_time)   fprintf(stderr,"            End time =  %f     (w.r.t. file # %d)\n",end_time,file_count);*/
-      /*      fprintf(stderr,"          Realtime is           %f\n",realtime);*/
-    }
-    else {
-      /* decide whether to process it */
-      if ( (doit=process(realtime,sample_skip*(double)tsamp,end_time)) == -1) {
-	fprintf(stderr,"realtime at time of break = %f (s)\n ",realtime);
-	break; 
-      }
-      doit = 1;
-      if (doit) {
-	/* about to process this record, update log */
-	np++;
-	if (np%10 == 0) {
-	  if (!opened) {
-	    open_log("filterbank.monitor");
-	    opened=1;
-	  }
-	  sprintf(string,"time:%.1fs",realtime);
-	  update_log(string);
-	}
-	
-	/* unscramble the 4-bit data into the float tempblock */
-	
-	nsblk=0;
-	for (c=0;c<nchars;c++) {
-	  char2ints(charblock[c],&i1,&i2);
-	  tempblock[nsblk++] = (float) i2;
-	  tempblock[nsblk++] = (float) i1;
-	}
-	
-	/* update wallclock time */
-	realtime+=(float) (nsblk/nchans/nifs) * (float) tsamp; 
-	
-	if (sumifs) for (s=0;s<nsblk;s++) datablock[s]=0.0;
-	s=i1=i2=0;
-	/* loop over all samples, summing IFs 1+2 -> total power if neccessary */
-	while (s<nsblk) {
-	  for (i=0;i<nifs;i++) {
-	    for (c=0;c<nchans;c++) {
-	      if (sumifs) {
-		if (i<2) datablock[i1+c]+=tempblock[i2+chtab[i*nchans+c]];
-	      } else {
-		datablock[i1+i*nchans+c]=tempblock[i2+chtab[i*nchans+c]];
-	      }
-	      s++;
-	    }
-	  }
-	  
-	  /* update internal counters */
-	  i2+=nifs*nchans;
-	  if (sumifs) {
-	    i1+=nchans;
-	  } else {
-	    i1+=nifs*nchans;
-	  }
-	}
-	/* divide by 2 to in sumif mode to allow for 4-bit packing */
-	if (sumifs) {
-	  nsblk/=nifs;
-	  for (s=0;s<nsblk;s++) datablock[s]/=2.0;
-	}
-	/* decide on how to write out data */
-	if (obits==32) {
-	  /* user has requested floating point numbers in binary file */
-	  if (swapout) for (s=0;s<nsblk;s++) swap_float(&datablock[s]);
-	  fwrite(datablock,sizeof(float),nsblk,output);
-	} else if (obits==16) {
-	  /* user has requested unsigned shorts in binary file */
-	  float2short(datablock,nsblk,0.0,15.0,shortblock);
-	  if (swapout) for (s=0;s<nsblk;s++) swap_short(&shortblock[s]);
-	  fwrite(shortblock,sizeof(unsigned short),nsblk,output);
-	} else if (obits==8) {
-	  /* user has requested unsigned chars in binary file */
-	  float2char(datablock,nsblk,0.0,15.0,charblock);
-	  fwrite(charblock,sizeof(unsigned char),nsblk,output);
-	} else if (obits==4) {
-	  /* default is to  write data out packed into character format */
-	  float2four(datablock,nsblk,0.0,15.0,charblock);
-	  fwrite(charblock,sizeof(unsigned char),nsblk/2,output);
-	} 
-	else { 
-	  error_message("unknown bit format for writing");
-	}
-      }
-      /* update dumps read/processed */
-      idump+=ns;
-    }
-  }
-}
diff --git a/filterbank-gmrt/bpphdr.h b/filterbank-gmrt/bpphdr.h
deleted file mode 100644
index 302bc19..0000000
--- a/filterbank-gmrt/bpphdr.h
+++ /dev/null
@@ -1,332 +0,0 @@
-#ifndef BPP_HEADER_SIZE
-#define BPP_HEADER_SIZE	(1<<15)
-#endif
-
-#define MAXNUMCB 6
-#define MAXREGS 8
-#define NIBPERREG 4
-#define MAXNUMDFB (2*MAXNUMCB)
-#define MAX_NUM_LO_BOARDS MAXNUMCB
-#define MAX_NUM_MF_BOARDS (2*MAX_NUM_LO_BOARDS)
-#define FB_CHAN_PER_BRD                   8
-#define MAX_HARRIS_TAPS                 256
-#define MAXNUMCHAN (MAXNUMDFB*FB_CHAN_PER_BRD)
-
-typedef struct {
-
-    /*
-     * Here are BPP header items
-     */
-    char head[16];		/* Holds "NBPPSEARCH\0" */
-    long header_version;	/* Version number which is different for each backend */
-    unsigned long scan_num;	/* Scan number e.g. 31096001 = Obs 1 on day 310 of 1996 */
-				/* Changed to DDDYYYYSSS in Jan 2000 */
-
-    /* These doubles are all aligned on 8-byte boundaries */
-    double length_of_integration; /* if known in advance */
-    double samp_rate;	/* Calculated from nbpp_sw ( in us despite name ) */
-    double ra_1950;		/* Radians */
-    double dec_1950;		/* Radians */
-    double tele_x;		/* Carriage X position in m */
-    double tele_y;		/* Carriage Y position in m */
-    double tele_z;		/* Carriage Z position in m */
-    double tele_inc;		/* Mirror inclination in deg */
-    double Fclk;		/* Fast clock speed (Hz) */
-    double Har_Clk;		/* Harris clock (H_deci_factor*bandwidth) */
-    double bandwidth;		/* DSB channel bandwidth (== Sclk) */
-    double dfb_gain[MAXNUMDFB];	/* Gain that was applied to generate Harris coeffs */
-
-    /*
-     * AIB Configuration
-     */
-    double aib_los[MAX_NUM_LO_BOARDS];
-    double mf_filt_width[MAX_NUM_MF_BOARDS];
-    double mf_atten[MAX_NUM_MF_BOARDS];
-    double rf_lo;		/* LO frequency used in the receiver to generate the IF */
-
-    long bit_mode;		/* 4 = 4-bit power, -4 = 4-bit voltage in direct mode */
-    long num_chans;		/* Calculated number of 4-bit channels in each sample */
-    int lmst;			/* LMST time in seconds since 0h */
-    char target_name[32];	/* Space for pulsar name or map name for survey */
-    char date[16];		/* UT date which will match the scan number */
-    char start_time[16];	/* UT time of the 1pps tick which started the obs*/
-    long scan_file_number;	/* Which file number of the scan? */
-    long file_size;		/* Size of this file */
-    long tape_num;		/* Tape number */
-    long tape_file_number;	/* File number on this tape */
-    char obs_group[16];		/* Who did the observation (mainly for future) */
-
-    int enabled_CBs;		/* Bitmap of enabled CBs */
-    int mb_start_address;	/* Real base (8-bit) address of first CB reg read */
-    int mb_end_address;		/* Read end (8-bit) address of last CB reg read */
-    int mb_start_board;		/* First board ID read */
-    int mb_end_board;		/* last board ID read (MB can only read seq. boards) */
-    int mb_vme_mid_address;	/* Value stored in VME_MID register (usu. 00) */
-    int mb_ack_enabled;		/* Boolean, did we use ACK protocol? */
-    int start_from_ste;		/* Boolean, am I starting with the STE counter? */
-
-    /*
-     * CB Registers
-     */
-    int cb_sum_polarizations;	/* Boolean, did the CBs sum pols on-board? */
-    int cb_direct_mode;		/* Boolean, did we read the CBs in direct-mode? */
-    int cb_eprom_mode[MAXNUMCB]; /* Which EPROM table? (MAXNUMCB=6) */
-    int cb_accum_length;	/* Contents of CB accum len regs (all CBs IDENTICAL) */
-				/* cb_accum_length is TOTAL accum length, not accum_len-1 */
-
-    /**
-     * TB Registers
-     */
-    int tb_outs_reg;	/* OUTS_REG, turns on/off analog supply and PLLs */
-    int tb_ste;		/* Value stored in STE counter */
-    int tb_stc;		/* This need to be read AFTER an integration!!! */
-    int  H_deci_factor;	/* Decimation factor */
-    int GenStat0, GenStat1, Ack_Reg; /* HW registers, for debugging */
-
-    /*
-     * DFB Registers
-     */
-    /* These first three are the "logical" state of the DFBs */
-    int dfb_sram_length;	/* Same for every board??? */
-    int ASYMMETRIC;		/* Currently the same for all boards */
-    float dfb_sram_freqs[FB_CHAN_PER_BRD]; /* Filled in by setmixer_board (8) */
-
-    /* These three are for HW debugging, not to be used by analysis software */
-    int dfb_mixer_reg[MAXNUMDFB]; /* Set by set_dfb_mixer (MAXNUMDFB=12) */
-    int dfb_conf_reg[MAXNUMDFB];  /* Set by set_dfb_conf */
-    int dfb_sram_addr_msb[MAXNUMDFB]; /* Set by set_dfb_conf */
-
-    /* These are the ACTUAL Harris taps loaded into the DFBs */
-    int i_hcoef[MAX_HARRIS_TAPS]; /* MAX_HARRIS_TAPS=256 */
-    int q_hcoef[MAX_HARRIS_TAPS];
-
-
-    /*
-     * Hardware configuration
-     */
-    int tb_id;
-    int cb_id[MAXNUMCB];
-    int dfb_id[MAXNUMDFB];
-
-    int aib_if_switch;	/* Which IF input are we using? (Same for both Pols) */
-
-    /* matt add new stuff here */
-    /* Additional Hardware information, 97apr25 MRD */
-    int	mb_rev, mb_serial;
-    int	tb_rev, tb_serial;
-    int	cb_rev[MAXNUMCB], cb_serial[MAXNUMCB];
-    int	dfb_rev[MAXNUMDFB], dfb_serial[MAXNUMDFB];
-    int	mb_xtal_freq;
-    int	mf_serial[MAX_NUM_MF_BOARDS], mf_rev[MAX_NUM_MF_BOARDS];
-    int	lo_serial[MAX_NUM_LO_BOARDS], lo_rev[MAX_NUM_LO_BOARDS];
-
-    int	mb_long_ds0;		/* lengthen DS0 on vme reads with ack enabled */
-    int	dfb_sun_program[MAXNUMDFB];	/* Set by set_dfb_mode */
-    int	dfb_eprom[MAXNUMDFB];		/* Set by set_dfb_mode */
-    int	dfb_sram_addr[MAXNUMDFB];       /* rev 4 Set by set_dfb_conf */
-    int	dfb_har_addr[MAXNUMDFB];        /* rev 4 Set by set_dfb_conf */
-    int	dfb_clip_adc_neg8[MAXNUMDFB];	/* for use in DFB mixer table */
-    int	dfb_shften_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_fwd_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_rvrs_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_asymmetric[MAXNUMDFB];	/* what kind of taps to load ? */
-    double dfb_i_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double dfb_q_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double max_dfb_freq;                /* used in picking decimations */
-
-    /* 
-     * pre 97apr25 was 29780
-     * pre 97oct29 was 28844
-     * pre 98jan20 was 28836
-     */
-    int aib_serial;
-    int aib_rev;
-    /*
-     * (long long) file_size and offset where added August 1999 to the
-     * source tree. Prior to this time, or when the production binaries
-     * where updated for a particular backend, these values will hold 0
-     * and you should use the (long) file_size above. Note, there was
-     * no equivalent offset number prior to ll_file_offset.
-     */
-    long long ll_file_offset;	/* Cummulative size of all of the previous  */
-				/* files in this scan (Bytes) which can,    */
-				/* e.g. be used to calculate the start time */
-				/* of this file.			    */
-    long long ll_file_size;	/* Size of this particular file (Bytes).    */
-    char quad_word_boundary_filler[8];
-    long double mjd_start;	/* Start time (MJD)			    */
-    char filler[28788];
-
-    long BACKEND_TYPE;
-    long UPDATE_DONE;
-    long HEADER_TYPE;
-
-} BPP_SEARCH_HEADER;
-
-
-#define	TIMING_TYPE		1	/* 2d array of unsigned longs	*/
-#define	TIMING_LONG_TYPE	1	/* 2d array of unsigned longs	*/
-#define	TIMING_FLOAT_TYPE	3	/* 2d array of floats		*/
-
-typedef struct {
-  
-    /* In this part, double=8bytes, long=4bytes, if not, fix it! */
-
-    char head[16]; /* Holds "NBPPTIME\0" */
-
-    long header_version;	/* Version number which is different for each backend */
-
-    long scan_num;		/* Scan number e.g. 31096001 = Obs 1 on day 310 of 1996 */
-    
-
-    double psr_period;
-    double samp_rate;		/* Sample rate in (us). Note, in the case    */
-				/* of oversampling this is the integrated    */
-				/* sample rate not the hardware rate.	     */
-    double psr_dm;
-    double length_of_integration; /* An estimate that does NOT take into     */
-				/* account the doppler corrections to	     */
-				/* samp_rate.  For true integration time,    */
-				/* the polyco.dat entry appended on the end  */
-				/* of the scan must be consulted.	     */
-    char psr_name[16];
-
-    long scan_file_number;	/* Which file number of the scan?	     */
-    long stc;			/* Unused, use stctime instead.		     */
-    long num_phase_bins;
-    long num_periods;		/* exact number of pulse periods integrated  */
-    long sizeof_polyco;
-    long oversample;		/* How many hardware samples are integrated  */
-				/* before accumulating in the pulse profile  */
-				/* (note, a 0 should be interpreted as a 1). */
-
-
-    /* These doubles are all aligned on 8-byte boundaries */
-    double ra_1950;		/* Radians */
-    double dec_1950;		/* Radians */
-    double tele_x;		/* Carriage X position in m */
-    double tele_y;		/* Carriage Y position in m */
-    double tele_z;		/* Carriage Z position in m */
-    double tele_inc;		/* Mirror inclination in deg */
-    double Fclk;		/* Fast clock speed (Hz) */
-    double Har_Clk;		/* Harris clock (H_deci_factor*bandwidth) */
-    double bandwidth;		/* DSB channel bandwidth (== Sclk) */
-    double dfb_gain[MAXNUMDFB];	/* Gain that was applied to generate Harris coeffs */
-
-    /*
-     * AIB Configuration
-     */
-    double aib_los[MAX_NUM_LO_BOARDS];
-    double mf_filt_width[MAX_NUM_MF_BOARDS];
-    double mf_atten[MAX_NUM_MF_BOARDS];
-    double rf_lo;		/* LO frequency used in the receiver to generate the IF */
-
-    long bit_mode;		/* 4 = 4-bit power, -4 = 4-bit voltage in direct mode */
-    long num_chans;		/* Calculated number of 4-bit channels in each sample */
-    int lmst;			/* LMST time in seconds since 0h */
-    char target_name[32];	/* Space for pulsar name or map name for survey */
-    char date[16];		/* UT date which will match the scan number */
-    char start_time[16];	/* UT time of the 1pps tick which started the obs*/
-    long file_size;		/* Size of this file */
-    long tape_num;		/* Tape number */
-    long tape_file_number;	/* File number on this tape */
-    char obs_group[16];		/* Who did the observation (mainly for future) */
-
-    int enabled_CBs;		/* Bitmap of enabled CBs */
-    int mb_start_address;	/* Real base (8-bit) address of first CB reg read */
-    int mb_end_address;		/* Read end (8-bit) address of last CB reg read */
-    int mb_start_board;		/* First board ID read */
-    int mb_end_board;		/* last board ID read (MB can only read seq. boards) */
-    int mb_vme_mid_address;	/* Value stored in VME_MID register (usu. 00) */
-    int mb_ack_enabled;		/* Boolean, did we use ACK protocol? */
-    int start_from_ste;		/* Boolean, am I starting with the STE counter? */
-
-    /*
-     * CB Registers
-     */
-    int cb_sum_polarizations;	/* Boolean, did the CBs sum pols on-board? */
-    int cb_direct_mode;		/* Boolean, did we read the CBs in direct-mode? */
-    int cb_eprom_mode[MAXNUMCB]; /* Which EPROM table? (MAXNUMCB=6) */
-    int cb_accum_length;	/* Contents of CB accum len regs (all CBs IDENTICAL) */
-				/* cb_accum_length is TOTAL accum length, not accum_len-1 */
-
-    /**
-     * TB Registers
-     */
-    int tb_outs_reg;	/* OUTS_REG, turns on/off analog supply and PLLs */
-    int tb_ste;		/* Value stored in STE counter */
-    int tb_stc;		/* This need to be read AFTER an integration!!! */
-    int  H_deci_factor;	/* Decimation factor */
-    int GenStat0, GenStat1, Ack_Reg; /* HW registers, for debugging */
-
-    /*
-     * DFB Registers
-     */
-    /* These first three are the "logical" state of the DFBs */
-    int dfb_sram_length;	/* Same for every board??? */
-    int ASYMMETRIC;		/* Currently the same for all boards */
-    float dfb_sram_freqs[FB_CHAN_PER_BRD]; /* Filled in by setmixer_board (8) */
-
-    /* These three are for HW debugging, not to be used by analysis software */
-    int dfb_mixer_reg[MAXNUMDFB]; /* Set by set_dfb_mixer (MAXNUMDFB=12) */
-    int dfb_conf_reg[MAXNUMDFB];  /* Set by set_dfb_conf */
-    int dfb_sram_addr_msb[MAXNUMDFB]; /* Set by set_dfb_conf */
-
-    /* These are the ACTUAL Harris taps loaded into the DFBs */
-    int i_hcoef[MAX_HARRIS_TAPS]; /* MAX_HARRIS_TAPS=256 */
-    int q_hcoef[MAX_HARRIS_TAPS];
-
-
-    /*
-     * Hardware configuration
-     */
-    int tb_id;
-    int cb_id[MAXNUMCB];
-    int dfb_id[MAXNUMDFB];
-
-    int aib_if_switch;	/* Which IF input are we using? (Same for both Pols) */
-
-    /* matt add new stuff here */
-    /* Additional Hardware information, 97apr25 MRD */
-    int	mb_rev, mb_serial;
-    int	tb_rev, tb_serial;
-    int	cb_rev[MAXNUMCB], cb_serial[MAXNUMCB];
-    int	dfb_rev[MAXNUMDFB], dfb_serial[MAXNUMDFB];
-    int	mb_xtal_freq;
-    int	mf_serial[MAX_NUM_MF_BOARDS], mf_rev[MAX_NUM_MF_BOARDS];
-    int	lo_serial[MAX_NUM_LO_BOARDS], lo_rev[MAX_NUM_LO_BOARDS];
-
-    int	mb_long_ds0;		/* lengthen DS0 on vme reads with ack enabled */
-    int	dfb_sun_program[MAXNUMDFB];	/* Set by set_dfb_mode */
-    int	dfb_eprom[MAXNUMDFB];		/* Set by set_dfb_mode */
-    int	dfb_sram_addr[MAXNUMDFB];       /* rev 4 Set by set_dfb_conf */
-    int	dfb_har_addr[MAXNUMDFB];        /* rev 4 Set by set_dfb_conf */
-    int	dfb_clip_adc_neg8[MAXNUMDFB];	/* for use in DFB mixer table */
-    int	dfb_shften_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_fwd_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_rvrs_[MAXNUMDFB];		/* for low level Harris mode */
-    int	dfb_asymmetric[MAXNUMDFB];	/* what kind of taps to load ? */
-    double dfb_i_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double dfb_q_dc[MAXNUMDFB];		/* set when programming the Mixer SRAM*/
-    double max_dfb_freq;                /* used in picking decimations */
-
-    int aib_serial;
-    int aib_rev;
-
-    double tick_offset;		        /* delay from 1sec tick to start time (usec) */
-    double startup_latency;	        /* estimated (by Matt?) time delay through */
-                                        /* system (usec) */
-    double initial_phase_offset;	/* Time offset to correct start time */
-					/* from first sample at an arbitrary */
-					/* phase to the start time of the    */
-					/* first folded phase bin (sec).     */
-    double stctime;			/* STC counter converted to sec.     */
-
-    char filler[28746];
-    long BACKEND_TYPE;
-    long UPDATE_DONE;
-    long HEADER_TYPE;
-
-} BPP_TIMING_HEADER;
-
-
diff --git a/filterbank-gmrt/cel2gal.c b/filterbank-gmrt/cel2gal.c
deleted file mode 100644
index b17e8c3..0000000
--- a/filterbank-gmrt/cel2gal.c
+++ /dev/null
@@ -1,38 +0,0 @@
-#include <math.h>
-/* J2000 coordinates of galactic north pole and x-axis */
-#define N_GAL_POLE_RA    (12 + (51 + (26.2754/60))/60)*15
-#define N_GAL_POLE_DEC   (27 + (07 + (41.705/60))/60)
-#define GAL_CENTER_DEC  -(28 + (56 + (10.219/60))/60)
-
-void cel2gal(int rah, int ram, double ras,int decd,int decm,double decs,double *glon,double *glat) /*includefile*/
-{
-double ra, dec, gl, gb;
-int isign=1;
-double twopi, raddeg, spdec, cpdec, glong_off, ra_off;
-double sra, cra, sdec, cdec;
-
-    ra = (rah + (ram + (ras/60))/60)*15;
-    if (decd != 0) isign = decd/abs(decd);
-    dec = decd + isign*(decm + (decs/60))/60;
-
-  twopi = 4*acos(0.0);
-  raddeg = twopi/360.0;
-
-  spdec = sin((90 - N_GAL_POLE_DEC)*raddeg);
-  cpdec = cos((90 - N_GAL_POLE_DEC)*raddeg);
-  glong_off = -asin(sin(GAL_CENTER_DEC*raddeg)/spdec)/raddeg;
-  ra_off = 90 + N_GAL_POLE_RA;
-
-  sra = sin((ra - ra_off)*raddeg);
-  cra = cos((ra - ra_off)*raddeg);
-  sdec = sin(dec*raddeg);
-  cdec = cos(dec*raddeg);
-
-  *glon = glong_off;
-  *glon = glong_off + atan2((cdec*sra*cpdec + sdec*spdec), cdec*cra)/raddeg;
-  if (*glon < 0)
-    *glon = *glon + 360;
-  *glat = asin(sdec*cpdec - cdec*sra*spdec)/raddeg;
-
-}
-  
diff --git a/filterbank-gmrt/cfits_subs.c b/filterbank-gmrt/cfits_subs.c
deleted file mode 100644
index 0b4b409..0000000
--- a/filterbank-gmrt/cfits_subs.c
+++ /dev/null
@@ -1,1192 +0,0 @@
-
-/* FITS FILE INTERACTION ROUTINES */
-
-/* $Id: cfits_subs.c,v 1.8 2004/06/10 04:13:48 wwilson Exp $ */
-
-/* This version for CFITSIO */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "cor_common.h"
-#include "product_types.h"
-#include "obs_types.h"
-#include "scan_header.h"
-#include "supplhdr.h"
-#include "newcycle.h"
-#include "oldcycle.h"
-
-#include "cordat.h"
-
-/* cfitsio include file */
-#include "fitsio.h"
-
-#define WBSAM_FIXED 0x2
-
-/* Define CFITS file pointer - global- defined in fitsio.h */
-fitsfile *cfitsptr;
-
-int new_file = 0;
-
-/* hdu numbers */
-int dig_stats_hdu;
-int bpass_hdu;
-int last_scanhdr_hdu;
-int subint_hdu;
-
-int bat_to_ut_secs( double *ut_secs, long long bat );
-int bat_to_ut_str( char *str, int len, long long bat );
-int bat_to_mjd( double *mjd, long long bat );
-long long BAT( void );
-void rads_to_str( char *str, int str_len, double rads, int mode );
-
-
-/* BEGIN */
-
-int CDfits_open_file( char *filename )
-{
-  int status;
-  int bitpix   =  8;
-  int naxis   =  0;
-  long *naxes;
-  
-  status = 0;
-  /* Open file */
-  fits_create_file( &cfitsptr, filename, &status );
-  /* Write primary header */
-  bitpix = 8;
-  naxis = 0;
-  fits_create_img( cfitsptr, bitpix, naxis, naxes, &status );
-
-  /* Add first keywords */
-  fits_update_key( cfitsptr, TSTRING, "HDRVER", "1.19", "Header version", &status);
-  fits_write_date( cfitsptr, &status);
-
-  new_file = 1;
-  
-  
-  return( status );
-  
-}
-
-
-int CDfits_write_scanhdr( void )
-{
-  int status;
-  int i, j, k, m, n;
-  short int sj;
-  
-  double dx, dy, dz;
-  
-  long lk;
-    
-  int nrows, ncols;
-  long naxes[3];
-
-  char *ttype[4], *tform[4], *tunit[4];
-
-  char str[16], Istr[16], *qch, *rch, *sch, *tch;
-
-  int chan_inc, first_normal_group, npols, pol;
-      
-  float x;
-
-#undef POINT_PAR
-#ifdef POINT_PAR
-
-  float xa[12];
-
-#endif
-  
-  FILE *fp;
-  char filename[80];
-  
-#define GSTR_LEN 88
-  char gstr[GSTR_LEN];
-  char astr[80];
-  
-  void *pv;
-
-  char date_time[24];
-
-#define MAX_BLKS 20
-  char *pch[MAX_BLKS];
-  char site[MAX_BLKS][2];
-  short int nspan[MAX_BLKS];
-  short int ncoeff[MAX_BLKS];
-  double rfreq[MAX_BLKS];
-  double rmjd[MAX_BLKS];
-  double rphase[MAX_BLKS];
-  double lgfiterr[MAX_BLKS];
-  double f0[MAX_BLKS];
-#define MAX_COEFF 15
-  double coeff[MAX_BLKS][MAX_COEFF];
-
-
-  /* For Pulsar History BINTABLE */
- 
-  static char *PHtype[18] = {
-    "DATE_PRO","PROC_CMD","POL_TYPE","NPOL    ","NBIN    ","NBIN_PRD","TBIN    ","CTR_FREQ",
-    "NCHAN   ","CHAN_BW ","PAR_CORR","RM_CORR ","DEDISP  ","DDS_MTHD","SC_MTHD ","CAL_MTHD",
-    "CAL_FILE","RFI_MTHD"
-  };
-  
-  static char *PHform[18] = {
-    "24A     ","80A     ","8A      ","1I      ","1I      ","1I      ","1D      ","1D      ",
-    "1I      ","1D      ","1I      ","1I      ","1I      ","32A     ","32A     ","32A     ",
-    "32A     ","32A     "
-  };
-  
-  static char *PHunit[18] = {
-    "        ","        ","        ","        ","        ","        ","s       ","MHz     ",
-    "        ","MHz     ","        ","        ","        ","        ","        ","        ",
-    "        ","        "
-  };
-
-
-  /* For Pulsar Epmemeris BINTABLE */
-
-  static char *PEtype[56] = {
-    "DATE_PRO", "PROC_CMD", "EPHVER", "PSR_NAME", "RAJ", "DECJ", "PMRA", "PMDEC", 
-    "PX", "POSEPOCH", "IF0", "FF0", "F1", "F2", "F3", "PEPOCH",
-    "DM", "DM1", "RM", "BINARY", "T0", "PB", "A1", "OM", 
-    "OMDOT", "ECC", "PBDOT", "GAMMA", "SINI", "M2", "T0_2", "PB_2",
-    "A1_2", "OM_2", "ECC_2", "DTHETA", "XDOT", "EDOT", "TASC", "EPS1",
-    "EPS2", "START", "FINISH", "TRES", "NTOA", "CLK", "EPHEM", "TZRIMJD",
-    "TZRFMJD", "TZRFRQ", "TZRSITE", "GLEP_1", "GLPH_1", "GLF0_1", "GLF1_1", "GLF0D_1"
-  };
-  
-  static char *PEform[56] = {
-    "24A     ", "80A     ", "16A     ", "16A     ", "24A     ", "24A     ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1J      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "8A      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1I      ", "12A     ", "12A     ", "1J      ",
-    "1D      ", "1D      ", "1A      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      "
-  };
-  
-  /* For Pulsar Polyco BINTABLE */
-
-  static char *PPtype[13] = {
-    "DATE_PRO", "POLYVER ", "NSPAN   ", "NCOEF   ", "NPBLK   ", "NSITE   ", "REF_FREQ", "PRED_PHS",
-    "REF_MJD ", "REF_PHS ", "REF_F0  ", "LGFITERR", "COEFF   "
-  };
-    
-  static char *PPform[13] = {
-    "24A     ", "16A     ", "1I      ", "1I      ", "1I      ", "1A      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "15D     ",
-  };
-
-  /* BEGIN */
-
-  status = 0;
-
-  /* Get DateTime string - required in various BINTABLEs */
-  fits_get_system_time( date_time, &n, &status );
-  
-  if( new_file ) {
-
-    /* Add required keywords to primary header */
-
-    /* fits_update_key( cfitsptr, TSTRING, "ORIGIN", "RNM", 
-       "Output class", &status); */
-
-    fits_update_key( cfitsptr, TSTRING, "OBSERVER", header.observer, 
-		     "Observer name(s)", &status);
-    fits_update_key( cfitsptr, TSTRING, "PROJID", supplhdr.project, 
-		     "Project name", &status);
-    fits_update_key( cfitsptr, TSTRING, "TELESCOP", supplhdr.site_name,
-		     "Telescope name", &status);
-    fits_update_key( cfitsptr, TDOUBLE, "ANT_X", &header.antenna[0].x,
-		     "[m] Antenna ITRF X-coordinate (D)", &status);
-    fits_update_key( cfitsptr, TDOUBLE, "ANT_Y", &header.antenna[0].y,
-		     "[m] Antenna ITRF Y-coordinate (D)", &status);
-    fits_update_key( cfitsptr, TDOUBLE, "ANT_Z", &header.antenna[0].z,
-		     "[m] Antenna ITRF Z-coordinate (D)", &status);
-    fits_update_key( cfitsptr, TSTRING, "FRONTEND", supplhdr.frontend, 
-		     "Rx and feed ID", &status);
-
-    fits_update_key( cfitsptr, TSTRING, "FD_POLN", supplhdr.polzn,
-		     "LIN or CIRC", &status);
-    x = 0.0;
-    fits_update_key( cfitsptr, TFLOAT, "XPOL_ANG", &x,
-		     "[deg] Angle of X-probe wrt platform zero (E)", &status);
-
-    fits_update_key( cfitsptr, TSTRING, "BACKEND", supplhdr.backend, 
-		     "Backend ID", &status);
-    fits_update_key( cfitsptr, TSTRING, "BECONFIG", (*c_c).config_menu_name,
-		     "Backend configuration file name", &status);
-
-    /* Basic cycle time for integration */
-    dx = (*c_c).integ_time / 1.0E06;
-    fits_update_key( cfitsptr, TDOUBLE, "TCYCLE", &dx,
-		     "[s] Correlator cycle time (D)", &status);
-
-    /* Find the first normal group in band */
-    first_normal_group = -1;
-    i = (*c_c).band[0].first_group;
-    k = i + (*c_c).band[0].num_group - 1;
-    while( ( i <= k ) && ( first_normal_group < 0 ) ) {
-      if( (*c_c).product[ (*c_c).prod_group[i].first_prod ].type < POL_CAL_OFF ) {
-	first_normal_group = i;
-      }
-      i++;
-    }
-    if( first_normal_group < 0 ) first_normal_group = 0;
-
-    npols = (*c_c).prod_group[first_normal_group].num_prod;
-
-    /* Receiver channels - best guess */
-    if( npols == 1 ) nrcvr = 1;
-    else nrcvr = 2;
-    
-    fits_update_key( cfitsptr, TINT, "NRCVR", &nrcvr,
-		     "Number of receiver channels (I)", &status);
-    fits_update_key( cfitsptr, TSTRING, "OBS_MODE", supplhdr.obsmode,
-		     "(PSR, CAL, SEARCH)", &status);
-    /* fits_update_key( cfitsptr, TSTRING, "DATATYPE", "FOLD",
-                     "FOLD or DUMP", &status);  */
-    fits_update_key( cfitsptr, TSTRING, "SRC_NAME", header.source,
-		     "Source or scan ID", &status);
-    fits_update_key( cfitsptr, TSTRING, "COORD_MD", header.epoch,
-		     "Coordinate mode (J2000, Gal, Ecliptic, etc.)", &status);
-
-    /* J2000 or B1950 */
-    if( header.epoch[0] == 'J' || header.epoch[0] == 'B') j = 0;
-    /* All others */
-    else j = 2;
-
-    rads_to_str( gstr, 16, supplhdr.start_long, j );
-
-    /*
-    gstr[17] = '\0';
-    printf("\n rads_to_str(mode0) on %f = '%s'", supplhdr.start_long, gstr );
-    */
-
-    fits_update_key( cfitsptr, TSTRING, "STT_CRD1", gstr,
-		     "Start coord 1 (hh:mm:ss.sss or ddd.ddd)", &status);
-
-    rads_to_str( gstr, 16, supplhdr.start_lat, j+1 );
-    fits_update_key( cfitsptr, TSTRING, "STT_CRD2", gstr,
-		     "Start coord 2 (-dd:mm:ss.sss or -dd.ddd)", &status);
-   
-    fits_update_key( cfitsptr, TSTRING, "TRK_MODE", supplhdr.trackmode,
-		     "Track mode (TRACK, SCANGC, SCANLAT)", &status);
-
-    rads_to_str( gstr, 16, supplhdr.stop_long, j );
-    fits_update_key( cfitsptr, TSTRING, "STP_CRD1", gstr,
-		     "Stop coord 1 (hh:mm:ss.sss or ddd.ddd)", &status);
-
-    rads_to_str( gstr, 16, supplhdr.stop_lat, j+1 );
-    fits_update_key( cfitsptr, TSTRING, "STP_CRD2", gstr,
-		     "Stop coord 2 (-dd:mm:ss.sss or -dd.ddd)", &status);
-   
-    x = supplhdr.scan_cycles * ( (*c_c).integ_time / 1.0E06 );
-    fits_update_key( cfitsptr, TFLOAT, "SCANLEN ", &x,
-		     "[s] Requested scan length (E)", &status);
-    
-    fits_update_key( cfitsptr, TSTRING, "FD_MODE", supplhdr.fdmode,
-		     "Feed track mode - Const FA, CPA, GPA", &status);
-
-    fits_update_key( cfitsptr, TFLOAT, "FA_REQ", &supplhdr.xpolang,
-		     "[deg] Feed/Posn angle requested (E)", &status);
-
-    fits_update_key( cfitsptr, TFLOAT, "ATTEN_A", &supplhdr.atten_a,
-		     "[db] Attenuator, Poln A (E)", &status);
-
-    fits_update_key( cfitsptr, TFLOAT, "ATTEN_B", &supplhdr.atten_b,
-		     "[db] Attenuator, Poln B (E)", &status);
-
-    fits_update_key( cfitsptr, TSTRING, "CAL_MODE", supplhdr.calmode,
-		     "Cal mode (OFF, SYNC, EXT1, EXT2)", &status);
-
-    x = (float) (*c_c).pulsar_ncal_sig_frequency;
-    fits_update_key( cfitsptr, TFLOAT, "CAL_FREQ", &x,
-		     "[Hz] Cal modulation frequency (E)", &status);
-
-    x = (float) (*c_c).pulsar_ncal_sig_duty_cycle;
-    fits_update_key( cfitsptr, TFLOAT, "CAL_DCYC", &x,
-		     "Cal duty cycle (E)", &status);
-
-    x = (float) (*c_c).pulsar_ncal_sig_start_phase;
-    fits_update_key( cfitsptr, TFLOAT, "CAL_PHS ", &x,
-		     "Cal phase (wrt start time) (E)", &status);
-    
-
-    new_file = 0;
-
-  }
-
-#ifdef POINT_PAR
-
-  /* Add Pointing Parameters BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 1; /* tfields */
-  ttype[0] = "PPAR    ";
-  tform[0] = "12E     ";
-
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, NULL, "POINTPAR", &status);
-
-  /* Pointing parameters */
-  for( n=0; n<11; n++ ) xa[n] = (float) supplhdr.pointing_parameter[n];
-  xa[11] = 0.0;
-  fits_write_col( cfitsptr, TFLOAT, 1, 1, 1, 12, xa, &status );
-
-#endif
-
-  /* Add Processing History BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 18; /* tfields */
-   
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   PHtype, PHform, PHunit, "HISTORY", &status);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  pch[0] = date_time;
-  fits_write_col( cfitsptr, TSTRING, 1, 1, 1, 1, pch, &status );
-  /* Processing program and command */
-  pch[0] = "WBCOR";
-  fits_write_col( cfitsptr, TSTRING, 2, 1, 1, 1, pch, &status );
-  /* Polarisation identifier */
-  if( npols < 4 ) {
-    str[0] = '\0';
-    k = (*c_c).prod_group[first_normal_group].first_prod;
-    m = 0;
-    for( j=0; j<npols; j++ ) {
-      pol = (*c_c).product[k].polarisation;
-      if( pol == 1 ) strcat( str, "XX" );
-      else if( pol == 2 ) {
-	/* An XY product will be written out as two pols, real and imag */
-	strcat( str, "CRCI" );
-	m++;
-      }
-      else if( pol == 3 ) {
-	/* A YX product will be written out as two pols, real and imag */
-	strcat( str, "CRCI" );
-	m++;
-      }
-      else if( pol == 4 ) strcat( str, "YY" );
-      else strcat( str, "??" );
-      k++;
-    }
-  }
-  else {
-    strcpy( str, "XXYYXYYX" );
-  }
-  pch[0] = str;
-  fits_write_col( cfitsptr, TSTRING, 3, 1, 1, 1, pch, &status );
-
-  /* Nr of pols  - i.e. actually written out */
-  sj = npols + m;
-  fits_write_col( cfitsptr, TSHORT, 4, 1, 1, 1, &sj, &status );
-
-  /* Nr of bins per product (0 for SEARCH mode) */
-  sj = (*c_c).band[0].num_bins;
-  fits_write_col( cfitsptr, TSHORT, 5, 1, 1, 1, &sj, &status );
-
-  /* Nr of bins per period */
-  fits_write_col( cfitsptr, TSHORT, 6, 1, 1, 1, &sj, &status );
-
-  /* Bin time */
-  dx =  (*c_c).pulsar_period / sj;
-  fits_write_col( cfitsptr, TDOUBLE, 7, 1, 1, 1, &dx, &status );
-
-  /* Centre freq. */
-  dx = header.band[0].frequency;  
-  fits_write_col( cfitsptr, TDOUBLE, 8, 1, 1, 1, &dx, &status );
-
-  /* Number of channels */
-  chan_inc = header.band[0].channel_increment;
-  if( chan_inc <= 0 ) chan_inc = 1;
-  n = ( ( header.band[0].last_channel - 
-		   header.band[0].first_channel ) 
-		 / chan_inc ) + 1;
-
-  /* Don't include DC channel */  
-  if( header.band[0].first_channel == 1 ) n--;
-  
-  sj = n;
-  fits_write_col( cfitsptr, TSHORT, 9, 1, 1, 1, &sj, &status );
-
-  /* Channel bandwidth */
-  dy = header.band[0].bandwidth / (double) ( (*c_c).band[0].nfft / 2 );
-  if( header.band[0].spectrum_inverted < 0 ) dy = -dy;
-
-  /* Channel incr. width - signed */
-  dx = (double) chan_inc * dy;
-  fits_write_col( cfitsptr, TDOUBLE, 10, 1, 1, 1, &dx, &status );
-
-  /* Create frequency array for later */
-  /* Get freq. of first channel */
-  if( ( k = header.band[0].first_channel ) == 1 ) k = 2;
-  
-  j = ( (*c_c).band[0].nfft / 4 ) + 1 - k;
-  dz = header.band[0].frequency - ( j * dy );
-
-  for(i=0; i<n; i++ ) {
-    binned_freq[i] = (float) dz;
-    dz += dx;
-  }    
-
-
-  sj = 0;
-  /* Parallactic angle correction applied */
-  fits_write_col( cfitsptr, TSHORT, 11, 1, 1, 1, &sj, &status );
-  /* RM correction applied */
-  fits_write_col( cfitsptr, TSHORT, 12, 1, 1, 1, &sj, &status );
-  /* Data dedispersed */
-  fits_write_col( cfitsptr, TSHORT, 13, 1, 1, 1, &sj, &status );
-  /* Dedispersion method */
-  pch[0] = "NONE";
-  fits_write_col( cfitsptr, TSTRING, 14, 1, 1, 1, pch, &status );
-  /* Scattered power correction method */
-  pch[0] = supplhdr.scpwr;
-  fits_write_col( cfitsptr, TSTRING, 15, 1, 1, 1, pch, &status );
-  /* Calibration method */
-  pch[0] = "NONE";
-  fits_write_col( cfitsptr, TSTRING, 16, 1, 1, 1, pch, &status );
-  /* Name of calibration file */
-  pch[0] = "NONE";
-  fits_write_col( cfitsptr, TSTRING, 17, 1, 1, 1, pch, &status );
-  /* RFI excision method */
-  pch[0] = supplhdr.rfiex;
-  fits_write_col( cfitsptr, TSTRING, 18, 1, 1, 1, pch, &status );
-
-
-  /* Add Original BANDPASS BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 3;  /* tfields */
-
-  nchan_orig = ( (*c_c).band[0].nfft / 2 ) + 1;
-
-  naxes[0] = nchan_orig;
-  naxes[1] = nrcvr;
-
-  sprintf( str, "%ldE", naxes[1] );
-
-  ttype[0] = "DAT_OFFS";
-  tform[0] = str;
-  tunit[0] = "";
-
-  ttype[1] = "DAT_SCL ";
-  tform[1] = str;
-  tunit[1] = "";
-
-  sprintf( Istr, "%ldI", ( naxes[0] * naxes[1] ) );
-  ttype[2] = "DATA    ";
-  tform[2] = Istr;
-  tunit[2] = "Jy      ";
-
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, tunit, "BANDPASS", &status);
-
-  /* Add dimensions of column 3 = BANDPASS Data */  
-  fits_write_tdim( cfitsptr, 3, 2, naxes, &status );
-
-  /* Add keywords */
-  fits_update_key( cfitsptr, TINT, "NCH_ORIG", &nchan_orig,
-		     "Number of channels in original bandpass (I)", &status);
-  fits_update_key( cfitsptr, TINT, "BP_NPOL ", &nrcvr,
-		     "Number of polarizations in bandpass (I)", &status);
-
-  /* Store hdu number */
-  fits_get_hdu_num( cfitsptr, &bpass_hdu );
-
-
-  /* Add Pulsar Ephemeris BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 56; /* tfields */
-
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   PEtype, PEform, NULL, "PSREPHEM", &status);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  pch[0] = date_time;
-  fits_write_col( cfitsptr, TSTRING, 1, 1, 1, 1, pch, &status );
-  /* Processing program and command */
-  pch[0] = "WBCOR";
-  fits_write_col( cfitsptr, TSTRING, 2, 1, 1, 1, pch, &status );
-  /* Ephemeris version */
-  pch[0] = "PSRINFO:1.4";
-  fits_write_col( cfitsptr, TSTRING, 3, 1, 1, 1, pch, &status );
-
-  /* Open ephemeris file */
-  /* Construct filename  */
-  if( ( qch = getenv( "cor_pulsar" ) ) == NULL ) return(-11);
-
-  strcpy( filename, qch );
-  if( filename[ strlen(filename) - 1 ] != '/' )
-    strcat( filename, "/" );
-  strcat( filename, "online.eph" );
- 
-  if( ( fp = fopen( filename, "r" ) ) == NULL ) return(-12);
-
-  while( fgets( gstr, GSTR_LEN, fp ) != NULL ) {
-
-    if( ( qch = strtok( gstr, " " ) ) != NULL ) {
-
-      /* Following gets a name change - From PSRJ to PSR_NAME */
-      if( strcmp( qch, "PSRJ" ) == 0 ) i = 3;
-      /* Following two get split into integer and fractional parts */
-      else if( strcmp( qch, "F" ) == 0 ) i = 10;
-      else if( strcmp( qch, "F0" ) == 0 ) i = 10; /* Possible alternative to just F */
-      else if( strcmp( qch, "TZRMJD" ) == 0 ) i = 47;
-      else {
-	for( i=0; i<ncols; i++ ) {
-	  if( strcmp( qch, PEtype[i] ) == 0 ) break;
-	}
-      }
-
-      if( i < ncols ) {
-	/* Get next parameter */
-	if( ( rch = strtok( NULL, " " ) ) == NULL ) return(-13);
-
-	if( i == 10 || i == 47 || ( qch = strchr( PEform[i], 'D' ) ) != NULL ) {
-	  /* Change any D exponent to E */
-	  if( ( sch = strrchr( rch, 'D' ) ) != NULL ) *sch = 'E';
-	  tch = sch;
-	
-	  if( i == 10 || i == 47 ) {
-	    /* Convert to integer + fractional part AND
-	       if i == 10 convert from Hz to mHz i.e. multiply by 1000 */
-	    /* Get exponent */
-	    if( sch != NULL ) {
-	      if( sscanf( ++sch, "%d", &j ) != 1 )  return(-91);
-	    }
-	    else j = 0;
-	  
-	    /* get position of decimal point */
-	    if( ( sch = strrchr( rch, '.' ) ) == NULL ) {
-	      /* Integer part only */
-	      if( sscanf( rch, "%ld", &lk ) != 1 ) return(-92);
-	      dx = 0.0;
-	    }
-	    else {
-	      /* Decimal point present */
-	      if( i == 10 ) j += 3;  /* multiply by 1000 - sec. to ms. */
-
-	      if( j >= 0 ) {
-		k = (int) ( sch - rch );
-		if( k > 0 ) {
-		  strncpy( astr, rch, k );
-		  astr[k] = '\0';
-		}
-		else strcpy( astr, "0" );
-	      
-		if( j > 0 ) { /* multiply by 10**j, i.e. move decimal point */
-		  strncat( astr, (sch+1), j );
-		  *(sch += j) = '.';
-		  *--sch = '0';
-		}
-		/* Now astr contains integer part, sch points to fractional part */
-		if( sscanf( astr, "%ld", &lk ) != 1 ) return(-93);
-		/* Don't want exponent - reduced to fraction */
-		if( tch != NULL ) *tch = '\0';
-		if( sscanf( sch, "%lf", &dx ) != 1 ) return(-94);
-	      }
-	      else {
-		/* Fractional part only */
-		lk = 0;
-		if( sscanf( sch, "%lf", &dx ) != 1 ) return(-94);
-		if( i == 10 ) dx *= 1000.0;
-	      }
-	    	    
-	    }
-	  
-	    pv = &lk;
-	    j = TLONG;
-
-	  }
-	  else {
-
-	    if( sscanf( rch, "%lf", &dx ) != 1 ) return(-14);
-
-	    j = TDOUBLE;
-	    pv = &dx;
-
-	  }	
-	}
-	else if( ( qch = strchr( PEform[i], 'A' ) ) != NULL ) {
-	  j = TSTRING;
-	  /* Strip off any trailing newline */
-	  if( ( sch = strrchr( rch, '\n' ) ) != NULL ) *sch = '\0';
-	  pch[0] = rch;
-	  pv = pch;
-	}
-	else if( ( qch = strchr( PEform[i], 'I' ) ) != NULL ) {
-	  j = TSHORT;
-	  if( sscanf( rch, "%d", &k ) != 1 ) return(-15);
-	  sj = k;
-	  pv = &sj;
-	}
-	else if( ( qch = strchr( PEform[i], 'J' ) ) != NULL ) {
-	  j = TINT;
-	  if( sscanf( rch, "%d", &k ) != 1 ) return(-16);
-	  pv = &k;
-	}
-	else return(-17);
-            
-	fits_write_col( cfitsptr, j, i+1, 1, 1, 1, pv, &status );
-
-	/* Write fractional part */
-	if( i == 10 || i == 47 ) {
-	  j = TDOUBLE;
-	  pv = &dx;
-	  fits_write_col( cfitsptr, j, i+2, 1, 1, 1, pv, &status );
-	  
-	  printf( "\n In Ephemeris BINTABLE: %s = %ld %e", PEtype[i], lk, dx );
-	}
-      }
-    }
-  }
-  fclose( fp );
-  
-  /* Add Digitiser Statistics BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 1; /* tfields */
-
-  wbsam_levs = 2;
-  num_wbsams = nrcvr;
-
-  naxes[0] = wbsam_levs;
-  naxes[1] = num_wbsams;
-  if( ( n = header.cycles_to_avg ) <= 0 ) n = 1;
-  naxes[2] = n;
-
-  sprintf( str, "%ldE", ( naxes[0] * naxes[1] * naxes[2] ) );
-  ttype[0] = "DATA    ";
-  tform[0] = str;
-
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, NULL, "DIG_STAT", &status);
-
-  /* Add dimensions of column 1 = Data */  
-  fits_write_tdim( cfitsptr, 1, 3, naxes, &status );
-
-  /* Add keywords */
-  fits_update_key( cfitsptr, TSTRING, "DIG_MODE", "2-bit,3-level",
-		     "Digitiser mode", &status);
-  fits_update_key( cfitsptr, TINT, "NDIGR", &num_wbsams,
-		     "Number of digitised channels (I)", &status);
-  fits_update_key( cfitsptr, TINT, "NLEV", &wbsam_levs,
-		     "Number of digitiser levels (I)", &status);
-  fits_update_key( cfitsptr, TINT, "NCYCSUB", &n,
-		     "Number of correlator cycles per subint (I)", &status);
-
-  /* Store current hdu number */
-  fits_get_hdu_num( cfitsptr, &dig_stats_hdu );
-
-
-  
-  /* Add Polyco History BINTABLE */
-
-  /* Read in polyco file */
-  /* Construct filename from .eph name  */
-
-  qch = strstr( filename, ".eph" );
-  *qch = '\0';
-  strcat( filename, ".polyco" );
-  if( ( fp = fopen( filename, "r" ) ) == NULL ) return(-18);
-
-  k = 0;
-  while( ( k < MAX_BLKS ) && 
-	 ( ( n = fscanf( fp, "%s %s%lf%lf%lf%lf%lf%lf%lf %s%hd%hd%lf%16c", 
-			 gstr, gstr, &dx, &rmjd[k], &dx, &dx, &lgfiterr[k], &rphase[k], &f0[k],
-			 site[k], &nspan[k], &ncoeff[k], &rfreq[k], gstr ) ) != EOF ) ) {
-    if( n != 14 ) return(-20);
-    if( ncoeff[k] > MAX_COEFF ) return(-21);
-    
-    for( i=0; i<ncoeff[k]; i++ ) {
-      if( fscanf( fp, "%s", gstr  ) != 1 ) return(-22);
-      /* Translate exponent D to E */
-      if( ( qch = strchr( gstr, (int) 'D' ) ) != NULL ) *qch = 'E';
-      if( sscanf( gstr, "%lE", &coeff[k][i] ) != 1 ) return(-23);
-    }
-    for( i=ncoeff[k]; i<MAX_COEFF; i++ ) coeff[k][i] = 0.0;
-    k++;
-  }
-  if( k >= MAX_BLKS ) return(-24);
-  
-  fclose( fp );
-
-  printf("\nCFITS_SUBS:  Polyco - Site[0,1](hex) = %x %x", site[0][0], site[0][1] );
-  
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 13; /* tfields */
-  
-
-  fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		   PPtype, PPform, NULL, "POLYCO  ", &status);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  for( i=0; i<k; i++ ) pch[i] = date_time;
-  fits_write_col( cfitsptr, TSTRING, 1, 1, 1, k, pch, &status );
-  /* Polyco version */
-  for( i=0; i<k; i++ ) pch[i] = "TEMPO:11.0";
-  fits_write_col( cfitsptr, TSTRING, 2, 1, 1, k, pch, &status );
-  /* Span of polyco in min */
-  fits_write_col( cfitsptr, TSHORT, 3, 1, 1, k, nspan, &status );
-  /* Nr of coefficients - per block */
-  fits_write_col( cfitsptr, TSHORT, 4, 1, 1, k, ncoeff, &status );
-  /* Nr of polyco blocks (of NCOEF coefficients) -reuse nspan array */
-  for( i=0; i<k; i++ ) nspan[i] = k;
-  fits_write_col( cfitsptr, TSHORT, 5, 1, 1, k, nspan, &status );
-  /* TEMPO site code - 1 character */
-  for( i=0; i<k; i++ ) pch[i] = &site[i][0];
-  fits_write_col( cfitsptr, TSTRING, 6, 1, 1, k, pch, &status );
-  /* Reference frequency for phase */
-  fits_write_col( cfitsptr, TDOUBLE, 7, 1, 1, k, rfreq, &status );
-
-  /* Predicted pulse phase at obs start - reuse rfreq  */
-  for( i=0; i<k; i++ ) rfreq[i] = newcycle.WBpsr_timer_start_phase;
-  fits_write_col( cfitsptr, TDOUBLE, 8, 1, 1, k, rfreq, &status );
-
-  /* Reference MJD - NPBLK doubles */
-  fits_write_col( cfitsptr, TDOUBLE, 9, 1, 1, k, rmjd, &status );
-  /* Reference phase - NPBLK doubles */
-  fits_write_col( cfitsptr, TDOUBLE, 10, 1, 1, k, rphase, &status );
-  /* Reference F0 - NPBLK doubles */
-  fits_write_col( cfitsptr, TDOUBLE, 11, 1, 1, k, f0, &status );
-  /* Fit error - NPBLK doubles */
-  fits_write_col( cfitsptr, TDOUBLE, 12, 1, 1, k, lgfiterr, &status );
-  /* Polyco coefficients - NPBLK*NCOEF doubles */
-  j = k * MAX_COEFF;
-  fits_write_col( cfitsptr, TDOUBLE, 13, 1, 1, j, &coeff[0][0], &status );
-
-
-  /* Store last header hdu number */
-  fits_get_hdu_num( cfitsptr, &last_scanhdr_hdu );
-  
-  /* Restart SUBINT counter */
-  subint_cnt = 0;
-  
-  return( status );
-
-}
-
-
-
-void CDfits_fill_scanhdr( double *ut_secs )
-{
-  
-}
-
-
-int CDfits_fill_mosaic_list( char *buf, char *errstr )
-{
-
-  return(0);
-  
-}
-
-
-
-int CDfits_write_data( __complex__ float *data, int xant, int yant,
-		     float ut_secs, float u, float v, float w,
-		     int flag, int bin_num, int if_number, 
-		     int source_number, float integration_time )
-{
-  return( 0 );
-  
-}
-
-
-
-int CDfits_write_syscal( float ut_secs, int band_num, int source_num )
-{
-
-  return( 0 );
-  
-}
-
-int CDfits_write_subint( int num_cycles, int num_bins, int num_chans, int num_pols )
-{
-  int status;
-  int j, k;
-  int nscl, ndata;
-  float x;
-  double dx, dy, dz, ds, dc;
-    
-  int nrows, ncols, col;
-  char *ttype[19], *tform[19], *tunit[19];
-  long naxes[3];
-  
-  char Cstr16[16], Estr16[16], Istr16[16];
-
-#define ASTR_LEN 32
-  char astr[ ASTR_LEN ];
-
-  
-  /* BEGIN */
-
-  nscl =  num_chans * num_pols;
-  ndata = num_bins * nscl;
-
-  status = 0;
-  
-  /* Increment SUBINT counter and if first SUBINT, write header */
-  if( ++subint_cnt == 1 ) {
-
-    /* Add START TIME to primary HDU */
-    /* Move to primary HDU */
-    fits_movabs_hdu( cfitsptr, 1, NULL, &status );
-
-    if( bat_to_ut_str( astr, ASTR_LEN, newcycle.WBpsr_timer_start_bat ) < 0 ) {
-      return( -9999 );
-    }
-    
-    astr[10] = '\0';
-    fits_update_key( cfitsptr, TSTRING, "STT_DATE", astr,
-		     "Start UT date (YYYY-MM-DD)", &status);
-    fits_update_key( cfitsptr, TSTRING, "STT_TIME", &astr[11],
-		     "Start UT (hh:mm:ss)", &status);
-
-    bat_to_mjd( &dx, newcycle.WBpsr_timer_start_bat );
-
-    dz = modf( dx, &dy );   /* dz = fractional day,  dy = days */    
-
-    j = (int) floor( ( dy + 0.1 ) );  /* Add 0.1d to make sure we get the correct one */
-    fits_update_key( cfitsptr, TINT, "STT_IMJD", &j,
-		     "Start MJD (UTC days) (J)", &status);
-    
-    dy = dz * 86400.0;   /* This should be an exact second - timer starts on 1pps */
-    k = (int) floor( ( dy + 0.1 ) );   /* Add 0.1s to make sure we get the correct one */
-    fits_update_key( cfitsptr, TINT, "STT_SMJD", &k,
-		     "[s] Start time (sec past UTC 00h) (J)", &status);
-
-    /* Add in offset = 1 - start phase - one bin !!!!!!!!!!! */
-    /* 9 Jun 2004 - remove one bin offset - wrong !! */
-    /* Was:
-       dz = 1.0 - modf( newcycle.WBpsr_start_psr_phase, &dx ) - 1.0 / (double) num_bins; 
-       dz *= (*c_c).pulsar_period;
-       Now: the offset time is available directly */
-    dz = newcycle.WBpsr_timer_start_offset_secs;
-    
-    /* Quantise to 128MHz clock cycles */
-    dz *= 128.0E06;
-    dx = floor( dz );
-    dx /= 128.0E06;
-    
-    fits_update_key( cfitsptr, TDOUBLE, "STT_OFFS", &dx,
-		     "[s] Start time offset (D)", &status);
-
-    /* LST provided corresponds to integ. start time, i.e. oldcycle.bat */
-    bat_to_ut_secs( &dy, oldcycle.bat );
-    dy += dx;
-    dx = scan_start_time_secs - dy;
-    if( dx < -43200.0 ) dx += 86400.0;
-    if( dx >  43200.0 ) dx -= 86400.0;
-    dy = ( ( oldcycle.lst * 86400.0 ) / TwoPi ) + ( dx * 1.002737909350795 );
-    if( dy < 0.0 ) dy += 86400.0;
-    if( dy > 86400.0 ) dy -= 86400.0;
-    fits_update_key( cfitsptr, TDOUBLE, "STT_LST ", &dy,
-		     "[s] Start LST (D)", &status);
-
-    /* Finished with primary HDU */
-
-    /* Move to last created HDU in scan header */
-    fits_movabs_hdu( cfitsptr, last_scanhdr_hdu, NULL, &status );
-    
-
-    /* Create SUBINT BINTABLE */
-
-    nrows = 0; /* naxis2 - Let CFITSIO sort this out */
-    ncols = 19; /* tfields */
-
-    ttype[0] = "ISUBINT ";    /* Subint number. If NAXIS=-1, 0 indicates EOD. */
-    tform[0] = "1J      ";
-    tunit[0] = "";
-    ttype[1] = "INDEXVAL";    /* Optionally used if INT_TYPE != TIME */
-    tform[1] = "1D      ";
-    tunit[1] = "";
-    ttype[2] = "TSUBINT ";    /* [s] Length of subintegration */
-    tform[2] = "1D      ";
-    tunit[2] = "";
-    ttype[3] = "OFFS_SUB";    /* [s] Offset from Start UTC of subint centre */
-    tform[3] = "1D      ";
-    tunit[3] = "";
-    ttype[4] = "LST_SUB ";    /* [s] LST at subint centre */
-    tform[4] = "1D      ";
-    tunit[4] = "";
-    ttype[5] = "RA_SUB  ";    /* [turns] RA (J2000) at subint centre */
-    tform[5] = "1D      ";
-    tunit[5] = "";
-    ttype[6] = "DEC_SUB ";    /* [turns] Dec (J2000) at subint centre */
-    tform[6] = "1D      ";
-    tunit[6] = "";
-    ttype[7] = "GLON_SUB";    /* [deg] Gal longitude at subint centre */
-    tform[7] = "1D      ";
-    tunit[7] = "";
-    ttype[8] = "GLAT_SUB";    /* [deg] Gal latitude at subint centre */
-    tform[8] = "1D      ";
-    tunit[8] = "";
-    ttype[9] = "FD_ANG  ";    /* [deg] Feed angle at subint centre */
-    tform[9] = "1E      ";
-    tunit[9] = "";
-    ttype[10] = "POS_ANG ";    /* [deg] Position angle of feed at subint centre */
-    tform[10] = "1E      ";
-    tunit[10] = "";
-    ttype[11] = "PAR_ANG ";    /* [deg] Parallactic angle at subint centre */
-    tform[11] = "1E      ";
-    tunit[11] = "";
-    ttype[12] = "TEL_AZ  ";    /* [deg] Telescope azimuth at subint centre */
-    tform[12] = "1E      ";
-    tunit[12] = "";
-    ttype[13] = "TEL_ZEN ";    /* [deg] Telescope zenith angle at subint centre */
-    tform[13] = "1E      ";
-    tunit[13] = "";
-
-    sprintf( Cstr16, "%dE", num_chans );
-    ttype[14] = "DAT_FREQ";
-    tform[14] = Cstr16;
-    tunit[14] = "";
-    ttype[15] = "DAT_WTS ";
-    tform[15] = Cstr16;
-    tunit[15] = "";
-
-    sprintf( Estr16, "%dE", nscl );
-    ttype[16] = "DAT_OFFS";
-    tform[16] = Estr16;
-    tunit[16] = "";
-    ttype[17] = "DAT_SCL ";
-    tform[17] = Estr16;
-    tunit[17] = "";
-
-    sprintf( Istr16, "%dI", ndata );
-    ttype[18] = "DATA    ";
-    tform[18] = Istr16;
-    tunit[18] = "Jy      ";
-
-
-    fits_create_tbl( cfitsptr, BINARY_TBL, nrows, ncols, 
-		     ttype, tform, tunit, "SUBINT  ", &status);
-
-    /* Add dimensions of column 'ncols' = SUBINT Data */
-    naxes[0] = num_bins;
-    naxes[1] = num_chans;
-    naxes[2] = num_pols;
-  
-    fits_write_tdim( cfitsptr, ncols, 3, naxes, &status );
-
-    /* Add keywords */
-    fits_update_key( cfitsptr, TSTRING, "INT_TYPE", "TIME",
-		     "Time axis (TIME, BINPHSPERI, BINLNGASC, etc)", &status);
-
-    fits_update_key( cfitsptr, TSTRING, "INT_UNIT", "SEC",
-		     "Unit of time axis (SEC, PHS (0-1), DEG)", &status);
-
-    fits_update_key( cfitsptr, TINT, "NCH_FILE", &num_chans,
-		     "Number of channels/sub-bands in this file (I)", &status);
-    j = 0;
-    fits_update_key( cfitsptr, TINT, "NCH_STRT", &j,
-		     "Start channel/sub-band number (0 to NCHAN-1) (I)", &status);
-    
-    /* Store subint hdu number */
-    fits_get_hdu_num( cfitsptr, &subint_hdu );
-
-  }
-  
-  /* Write SUBINT BINTABLE columns */
-
-  /* Fill in columns of table */
-  col = 1;
-  
-  /* Subint number. If NAXIS=-1, 0 indicates EOD. */
-  fits_write_col( cfitsptr, TINT, col, subint_cnt, 1, 1, &subint_cnt, &status );
-  col++;
-  
-  /* INDEXVAL - Optionally used if INT_TYPE != TIME */
-  dx = 0.0;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [s] Length of subint */
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &sum_subint_len_secs, &status );
-  col++;
-
-  /* [s] Offset from Start UTC of subint centre */
-  dx = sum_subint_mid_pt / sum_subint_len_secs;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [s] LST at subint centre */
-  ds = sum_subint_lst_sin / sum_subint_len_secs;
-  dc = sum_subint_lst_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 86400.0;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [turns] RA (J2000) at subint centre */
-  ds = sum_subint_ra_sin / sum_subint_len_secs;
-  dc = sum_subint_ra_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [turns] Dec (J2000) at subint centre */
-  ds = sum_subint_dec_sin / sum_subint_len_secs;
-  dc = sum_subint_dec_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) / TwoPi;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [deg] Gal longitude at subint centre */
-  ds = sum_subint_Glon_sin / sum_subint_len_secs;
-  dc = sum_subint_Glon_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 360.0;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [deg] Gal latitude at subint centre */
-  ds = sum_subint_Glat_sin / sum_subint_len_secs;
-  dc = sum_subint_Glat_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) * 360.0 / TwoPi;
-  fits_write_col( cfitsptr, TDOUBLE, col, subint_cnt, 1, 1, &dx, &status );
-  col++;
-
-  /* [deg] Feed angle at subint centre */
-  ds = sum_subint_fa_sin / sum_subint_len_secs;
-  dc = sum_subint_fa_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) * 360.0 / TwoPi;
-  x = (float) dx;
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, 1, &x, &status );
-  col++;
-
-  /* [deg] Parallactic angle at subint centre */
-  ds = sum_subint_pa_sin / sum_subint_len_secs;
-  dc = sum_subint_pa_cos / sum_subint_len_secs;
-  dy = atan2( ds, dc ) * 360.0 / TwoPi;
-
-  /* [deg] Position angle of feed at subint centre */
-  dx = dx + dy;
-  if( dx > 180.0 ) dx -= 360.0;
-  if( dx < 180.0 ) dx += 360.0;
-  x = (float) dx;
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, 1, &x, &status );
-  col++;
-
-  /* [deg] Parallactic angle at subint centre */
-  x = (float) dy;
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, 1, &x, &status );
-  col++;
-
-  /* [deg] Telescope azimuth at subint centre */
-  ds = sum_subint_az_sin / sum_subint_len_secs;
-  dc = sum_subint_az_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 360.0;
-  x = (float) dx;
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, 1, &x, &status );
-  col++;
-
-  /* [deg] Telescope zenith angle at subint centre */
-  ds = sum_subint_el_sin / sum_subint_len_secs;
-  dc = sum_subint_el_cos / sum_subint_len_secs;
-  dx = 90.0 - ( atan2( ds, dc ) * 360.0 / TwoPi );
-  x = (float) dx;
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, 1, &x, &status );
-  col++;
-
-
-  /* Centre freq. for each channel - NCHAN floats */
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, num_chans, binned_freq, &status );
-  col++;
-
-  /* Weights for each channel -  NCHAN floats */
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, num_chans, binned_weight, &status );
-  col++;
-
-  /* Data offset for each channel - NCHAN*NPOL floats */
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, nscl, binned_offset, &status );
-  col++;
-
-  /* Data scale factor for each channel - NCHAN*NPOL floats */
-  fits_write_col( cfitsptr, TFLOAT, col, subint_cnt, 1, nscl, binned_scale, &status );
-  col++;
-
-  /* Subint data table - Dimensions of data table = (NBIN,NCHAN,NPOL) */
-  fits_write_col( cfitsptr, TSHORT, col, subint_cnt, 1, ndata, binned_data, &status );
-  col++;
-  
-  /* Finished SUBINT */
-
-#define STEP_BACK
-#ifdef STEP_BACK
-
-  /* Move to digitiser statistics  */
-  fits_movabs_hdu( cfitsptr, dig_stats_hdu, NULL, &status );
-
-  if( subint_cnt == 1 ) {
-    
-    /* Now we know whether samplers are in fixed or auto mode - Add DIGLEV key */
-    if( (*c_c).wb_ifsam.freq[0].ant[0].pol[0].sam_status & WBSAM_FIXED )
-      strcpy( astr, "FIX" );
-    else 
-      strcpy( astr, "AUTO" );
-    fits_update_key( cfitsptr, TSTRING, "DIGLEV", astr,
-		     "Digitiser level-setting mode (AUTO, FIX)", &status);
-  }
-  
-  /* Add data for this subint */
-  fits_write_col( cfitsptr, TFLOAT, 1, subint_cnt, 1, num_wbsam_stats, wbsam_stats, &status );
-
-
-  /* Move to bandpass  */
-  fits_movabs_hdu( cfitsptr, bpass_hdu, NULL, &status );
-  /* Overwrite row 1 with latest data  */
-
-  /* Data offset for each receiver channel - NRCVR floats */
-  fits_write_col( cfitsptr, TFLOAT, 1, 1, 1, nrcvr, bpass_offset, &status );
-
-  /* Data scale factor for each receiver channel - NRCVR floats */
-  fits_write_col( cfitsptr, TFLOAT, 2, 1, 1, nrcvr, bpass_scale, &status );
-
-  /* Bandpass data table - Dimensions of data table = (NCHAN_orig,NRCVR) */
-  ndata = nchan_orig * nrcvr;
-  fits_write_col( cfitsptr, TSHORT, 3, 1, 1, ndata, bpass_data, &status );
-
-
-  /* Move back to subint HDU for next subint */
-  fits_movabs_hdu( cfitsptr, subint_hdu, NULL, &status );
-
-#endif /* STEP_BACK */
-
-  /* Now FLUSH any internal buffers to the file */
-  fits_flush_file( cfitsptr, &status );
-
-
-  return( status );
-  
-}
-
-
-
-int CDfits_close_reopen_file( void )
-{
-  return( 0 );
-  
-}
-
-int CDfits_close_file( void )
-{
-  int status;
-  
-  status = 0;
-  fits_close_file( cfitsptr, &status );
-  return( status );
-  
-}
-
-
diff --git a/filterbank-gmrt/chan_freqs.c b/filterbank-gmrt/chan_freqs.c
deleted file mode 100644
index 4e404ce..0000000
--- a/filterbank-gmrt/chan_freqs.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-/* 
-   return a pointer to an array of filterbank channel frequencies given the
-   center frequency fmid and the offset between each of the nchan channels
-   IHS incorporated additional offset for WAPP data (wapp_off)
-*/
-double *chan_freqs(double fmid, double foff, int nchans, int wapp_off) /* includefile */
-{
-  int i; 
-  double *chanfreq;
-  chanfreq = (double *) malloc( nchans * sizeof(double) ); 
-  for (i=0;i<nchans;i++)  {
-    chanfreq[i]=fmid+(nchans/2-i)*foff-0.5*((double)wapp_off)*foff;
-  }
-  return (chanfreq);
-}
diff --git a/filterbank-gmrt/chaninfo.f b/filterbank-gmrt/chaninfo.f
deleted file mode 100644
index efff2ab..0000000
--- a/filterbank-gmrt/chaninfo.f
+++ /dev/null
@@ -1,253 +0,0 @@
-c program to determine the statistics of 1 bit filter data
-c orginally SJ - giant pulse searching code
-c adapted SJ - Feb 2006 for MMB survey
-c
-c
-	program chaninfo
-
-	implicit none
-
-c PARAMETER DEFINITIONS
-c nbuf=buffer size in bytes
-c chmax=max channels
-c nblkmax=max number of blocks allowed
-	integer chmax,nbuf,nblkmax,hdrsize
-	parameter(nbuf=49152,hdrsize=640,chmax=513,nblkmax=10000)
-
-c VARIABLE DECLARATIONS
-	byte bbuf(nbuf)
-	integer b,i,j,k,bval,samp_blk,lf
-	integer nchans,nchans8,nch,ngulp,ival,ibit,nsamp
-	integer bit_offset(chmax),chsum(chmax)
-	integer itab(-1:7,-128:127),nbyte,nargs
-	real chave(chmax),threshold,chbw,frch1,freq
-	real*8 rms,chrms(chmax)
-	character fname*70,hdrfname*70,ans*1,string*70,hdr*(640)
-
-	integer blockgood(nblkmax),ngood,nbad,lastngood,niter
-	real blockmean(nblkmax),globmean,globrms
-	real lastglobmean,lastglobrms
-	real bbm,sample_amp,sigma,amp_expected,rms_expected
-c	integer band_amp(chmax)
-
-c read in the arguments
-	nargs = IARGC()
-        if(nargs.lt.1)then
-	  write(*,*)
-          write(*,'(''chaninfo - time series stats of 1-bit data'')')
-	  write(*,*)
-          write(*,'(''usage: chaninfo file (nblk) (cthr) (bthr)'')')
-	  write(*,*)
-          write(*,'(''file - name of raw .dat file '')')
-          write(*,'(''nblk - (optional) blocks to read (def=all)'')')
-          write(*,'(''cthr - (optional) threshold for bad channels'',
-     +              '' (def=+/-0.2)'')')
-          write(*,'(''bthr - (optional) threshold for bad blocks'',
-     +              '' (def=3 sigma)'')')
-	  write(*,*)
-          stop
-        endif
-	call getarg(1,fname)
-	open(unit=10,file=fname,status='old',form='unformatted',err=990)
-        ngulp=0
-	if(nargs.gt.1)then
-	  call getarg(2,string)
-	  read(string,*)ngulp
-        endif
-	if(ngulp.eq.0)ngulp=nblkmax
-        threshold=0.2
-	sigma=3.0
-	if(nargs.gt.2)then
-          call getarg(3,string)
-          read(string,*)threshold
-        endif
-	if(nargs.eq.4)then
-          call getarg(4,string)
-          read(string,*)sigma
-        endif
-
-c read the header for useful info
-	lf=index(fname,' ')-1
-	hdrfname=fname(1:lf-4)//'.hdr'
-	open(unit=11,file=hdrfname,status='old',form='unformatted',err=991)
-	read(11,err=992)hdr
-	close(11)
-	read(hdr(222:224),'(i3)',err=992)nchans
-	if(nchans.gt.chmax)then
-	  write(*,'('' ERROR - nchans is greater than chmax !! '')')
-	  stop
-	endif
-	read(hdr(205:212),'(f8.0)',err=992)chbw
-	if(chbw.gt.0.)then
-	  write(*,'('' WARNING - chbw is positive - flipping channels'')')
-	endif
-	read(hdr(242:253),'(f12.0)')frch1
-
-	nchans8=nchans/8
-c expected mean and rms of a sample
-	amp_expected=nchans/2.0
-	rms_expected=0.5*sqrt(nchans/2.0)
-c samples per block
-	samp_blk=nbuf*8/nchans
-
-c setup the table
-c For byte value = ival, if bit ibit of byte is set, then tab(ibit,ival)=1
-        do ival=-128,127
-          do ibit=0,7
-            if(btest(ival,ibit))then
-              itab(ibit,ival)=1
-            else
-              itab(ibit,ival)=0
-            endif
-          enddo
-        enddo
-	do i=1,nchans
-	  bit_offset(i)=mod(i-1,8)
-	  chsum(i)=0
-	  chrms(i)=0.0
-	enddo
-
-c read in the data and compute the mean and rms of each channel
-c compute the mean of each block of data
-	nsamp=0
- 15 	do b=1,ngulp
- 	  read(10,end=20)bbuf
-	  nbyte=0
-	  bbm=0.0
-c	  do j=1,nchans8
-c	    band_amp(j)=0
-c	  enddo
-	  do i=1,samp_blk
-	    nsamp=nsamp+1
-	    sample_amp=0.0
-	    nch=0
-	    do j=1,nchans8
-	      nbyte=nbyte+1
-	      do k=1,8
-	        nch=nch+1
-	        bval=itab(bit_offset(nch),bbuf(nbyte))
-	        chsum(nch)=chsum(nch)+bval
-	        chrms(nch)=chrms(nch)+bval*bval
-	        sample_amp=sample_amp+bval
-c	        band_amp(j)=band_amp(j)+bval
-	      enddo
-	    enddo
-	    bbm=bbm+sample_amp
-	  enddo
-c	  write(77,'(24i8)')(band_amp(j),j=1,nchans8)
-	  blockmean(b)=bbm/samp_blk
-	enddo
-
- 20	b=b-1
-	close(10)
-	open(unit=33,file='chan.info',form='formatted',status='unknown')
-	write(33,'('' Finished reading '',i4,'' blocks '')')b
-	write(33,'('' Number of samples per channel = '',i8)')nsamp
-	rms=0.5/sqrt(real(nsamp))
-	write(33,'('' Expected rms per channel = '',f12.8)')rms
-	write(33,*)
-
-	write(33,'('' Ch       Freq          Sum      Ave        RMS'')')
-	do i=1,nchans
-	  freq=frch1+(i-1)*chbw
-	  chave(i)=real(chsum(i))/nsamp
-          chrms(i)=sqrt(chrms(i)/nsamp - chave(i)*chave(i))
-	  write(33,'(i4,f12.4,i12,f10.6,f12.6)')i,freq,
-     +              chsum(i),chave(i),chrms(i)
-	enddo
-	close(33)
-
-c determine the bad channels and write out to bad.chans
-c good channels to good.chan
-c NOTE - these are inverted if chbw>0 for dice routine
-	open(unit=11,file='bad.chans',form='formatted',status='unknown')
-	open(unit=12,file='good.chans',form='formatted',status='unknown')
-	if(chbw.lt.0.)then
-          do i=1,nchans
-            if(chave(i).gt.0.5+threshold .or.
-     +         chave(i).lt.0.5-threshold)then
-              write(*,'('' Bad channel '',i4,'' with average '',
-     +          f10.6)')i,chave(i)
-              write(11,*)i,chave(i)
-            else
-              write(12,*)i
-	    endif
-	  enddo
-	else
-          do i=nchans,1,-1
-            if(chave(i).gt.0.5+threshold .or.
-     +         chave(i).lt.0.5-threshold)then
-              write(*,'('' Bad channel '',i4,'' with average '',
-     +          f10.6)')nchans-i+1,chave(i)
-              write(11,*)nchans-i+1,chave(i)
-            else
-              write(12,*)nchans-i+1
-	    endif
-	  enddo
-	endif
-        close(11)
-        close(12)
-
-c do the block statistics
-	do i=1,nblkmax
-	  blockgood(i)=1
-	enddo
-	lastglobmean=0.0
-	lastglobrms=1.e6
-	niter=0
-
-c this is an iterative loop which marks as bad those blocks
-c more than "sigma" from the mean. The loop continues until
-c either the number of bad blocks is constant or for 10 trials
- 100	globmean=0.0
-	globrms=0.0
-	lastngood=ngood
-	ngood=0
-	nbad=0
-	do i=1,b
-	  if(blockmean(i).gt.lastglobmean+sigma*lastglobrms .or. 
-     +	     blockmean(i).lt.lastglobmean-sigma*lastglobrms) then
-	     blockgood(i)=0
-             nbad=nbad+1
-	  else
-	    ngood=ngood+1
-	    globmean=globmean+blockmean(i)
-	    globrms=globrms+blockmean(i)*blockmean(i)
-	  endif
-	enddo
-	globmean=globmean/ngood
-	globrms=sqrt(globrms/ngood - globmean*globmean)
-	lastglobmean=globmean
-	lastglobrms=globrms
-	niter=niter+1
-	if(niter.eq.10)goto 120
-	if(lastngood.ne.ngood)goto 100
-
-c write out the information
- 120	continue
-	write(*,*)
-	write(*,'('' There are '',i8,'' good blocks'')')ngood
-	write(*,'('' There are '',i8,'' bad blocks'')')nbad
-	write(*,'('' Iterations : '',i4)')niter
-	open(unit=44,file='block.info',form='formatted',status='unknown')
-	write(44,'('' Block   Mean   Status '')')
-	open(unit=45,file='bad.blocks',form='formatted',status='unknown')
-	nsamp=1
-	do i=1,b
-	  write(44,*)i,blockmean(i),blockgood(i)
-	  if(blockgood(i).eq.0)write(45,*)nsamp,nsamp+samp_blk-1
-	  nsamp=nsamp+samp_blk
-	enddo
-	close(44)
-	close(45)
-	goto 999
-
- 990    write(*,'('' ERROR - could not open data file !!! '')')
-	stop
- 991    write(*,'('' ERROR - could not open header file !!! '')')
-	stop
- 992    write(*,'('' ERROR - problem reading header file !!! '')')
-	stop
-
- 999	continue
-	end
diff --git a/filterbank-gmrt/clip.c b/filterbank-gmrt/clip.c
deleted file mode 100644
index 8ab85da..0000000
--- a/filterbank-gmrt/clip.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include "dedisperse.h"
-int nbands,nobits;
-double userdm;
-main (int argc, char *argv[])
-{
-  float block[32768],copy[32768],mean,sigma,sum,ssq,mnsq,median;
-  int i,n,headersize=0;
-  input=fopen(argv[1],"rb");
-  output=stdout;
-
-  if (!(headersize=read_header(input))) 
-    error_message("could not read header parameters!");
-  userdm=refdm;
-  nobits=nbits;
-  nbands=1;
-  dedisperse_header();
-
-  while((n=read_block(input,nbits,block,32768))) {
-    for (i=0;i<n;i++) copy[i]=block[i];
-    median=nrselect((unsigned long)n/2,(unsigned long)n,copy);
-    sum=ssq=0.0;
-    for (i=0; i<n; i++) {
-      sum+=block[i];
-      ssq+=block[i]*block[i];
-    }
-    mean=sum/(float)n;
-    mnsq=ssq/(float)n;
-    sigma=sqrt(mnsq-mean*mean);
-    for (i=0; i<n; i++) if (abs(block[i]-median)>sigma) block[i]=median;
-    fwrite(block,sizeof(float),n,output);
-  }
-
-}
diff --git a/filterbank-gmrt/clock.f b/filterbank-gmrt/clock.f
deleted file mode 100644
index ccbdf65..0000000
--- a/filterbank-gmrt/clock.f
+++ /dev/null
@@ -1,34 +0,0 @@
-c==============================================================================
-      subroutine clock(yy,mm,dd,hh,mi,ss)
-c==============================================================================
-c
-c     Returns the present time from the Sun-OS clock
-c      
-c     yy - i4 - year   
-c     mm - i4 - month
-c     dd - i4 - day  
-c     hh - i4 - hour
-c     mi - i4 - minute
-c     ss - i4 - second
-c      
-c     Creation date: 98/06/08 (dlorimer@naic.edu)
-c      
-c==============================================================================
-c      
-      implicit none
-      integer yy,mm,dd,hh,mi,ss
-      
-      integer iarray(3)
-      
-      call idate(iarray)
-      mm=iarray(2)
-      dd=iarray(1)
-      yy=iarray(3)
-      call itime(iarray)
-      hh=iarray(1)
-      mi=iarray(2)
-      ss=iarray(3)
-      end
-c
-c==============================================================================
-
diff --git a/filterbank-gmrt/close_log.c b/filterbank-gmrt/close_log.c
deleted file mode 100644
index 5747f3e..0000000
--- a/filterbank-gmrt/close_log.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include <stdio.h>
-FILE *logfile;
-int logging_mode;
-void close_log() /*includefile*/
-{
-  if (logging_mode) fclose(logfile);
-}
diff --git a/filterbank-gmrt/complex.h b/filterbank-gmrt/complex.h
deleted file mode 100644
index 72f0f38..0000000
--- a/filterbank-gmrt/complex.h
+++ /dev/null
@@ -1,36 +0,0 @@
-#ifndef _NR_COMPLEX_H_
-#define _NR_COMPLEX_H_
-
-#ifndef _FCOMPLEX_DECLARE_T_
-typedef struct FCOMPLEX {float r,i;} fcomplex;
-#define _FCOMPLEX_DECLARE_T_
-#endif /* _FCOMPLEX_DECLARE_T_ */
-
-#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */
-
-fcomplex Cadd(fcomplex a, fcomplex b);
-fcomplex Csub(fcomplex a, fcomplex b);
-fcomplex Cmul(fcomplex a, fcomplex b);
-fcomplex Complex(float re, float im);
-fcomplex Conjg(fcomplex z);
-fcomplex Cdiv(fcomplex a, fcomplex b);
-float Cabs(fcomplex z);
-fcomplex Csqrt(fcomplex z);
-fcomplex RCmul(float x, fcomplex a);
-
-#else /* ANSI */
-/* traditional - K&R */
-
-fcomplex Cadd();
-fcomplex Csub();
-fcomplex Cmul();
-fcomplex Complex();
-fcomplex Conjg();
-fcomplex Cdiv();
-float Cabs();
-fcomplex Csqrt();
-fcomplex RCmul();
-
-#endif /* ANSI */
-
-#endif /* _NR_COMPLEX_H_ */
diff --git a/filterbank-gmrt/configure b/filterbank-gmrt/configure
deleted file mode 100755
index 442fbc6..0000000
--- a/filterbank-gmrt/configure
+++ /dev/null
@@ -1,60 +0,0 @@
-#!/bin/csh
-echo "Configuration script for SIGPROC makefile..."
-set osname = `printenv OSTYPE`
-if ($osname == "") then
-	echo "your OSTYPE variable is undefined..."
-	echo "edit your .cshrc file first to include the line"
-	echo ""
-	echo "setenv OSTYPE osname"
-	echo ""
-	echo "where osname should be either solaris, linux, hpux or darwin"
-	echo "contact drl@jb.man.ac.uk if you encounter any problems"
-	exit
-endif
-echo "Before generating makefile.$osname, please enter the full path to"
-echo "the directory where the SIGPROC executables will be placed..."
-echo "[default = $PWD] "         | awk '{printf "%s ",$0}'
-set bin_dir = $<
-if ($bin_dir == "") set bin_dir = $PWD
-set makefile = makefile.$osname
-echo "Creating $makefile ..." | awk '{printf "%s ",$0}'
-echo "# makefile.$osname - your system-specific makefile for SIGPROC" \
-		 > $makefile
-echo "BIN = $bin_dir" >> $makefile
-echo "# edit this by hand if you want to change the C compiler options" \
-		>> $makefile
-echo "CCC = gcc -O2" >> $makefile
-echo "F77 = gfortran" >> $makefile
-echo "# The following optional libraries need to be edited by hand..." \
-		>> $makefile
-set pgplotdir = `printenv PGPLOT_DIR`
-
-if($pgplotdir == "") then
-echo "#LPGPLOT = -lpgplot -lcpgplot -L/usr/X11R6/lib -lX11" \
-                >> $makefile
-else
-echo "LPGPLOT = -L$PGPLOT_DIR -lpgplot -lcpgplot -L/usr/X11R6/lib -lX11" \
-	        >> $makefile
-endif
-
-echo "#LFITS = -L/usr/local/src/cfitsio -lcfitsio" \
-		>> $makefile
-echo "#LFFTW = -L/usr/local/lib/ -lfftw3 -lfftw3f" \
-		>> $makefile
-if ($osname == "solaris") then
-	echo "DFITS = " >> $makefile
-	echo "DFFTW = " >> $makefile
-	echo "SUNLM = -lsunmath" >> $makefile
-else
-	echo "SUNLM = " >> $makefile
-        echo "ifneq (Z(origin LFITS), undefined)" | sed s/'Z'/'$'/ >> $makefile
-  	echo "	DFITS = -DPSRFITS"                   >> $makefile
-	echo "endif"                                 >> $makefile
-        echo "ifneq (Z(origin LFFTW), undefined)" | sed s/'Z'/'$'/ >> $makefile
-  	echo "	DFFTW = -DFFTW"                      >> $makefile
-        echo "endif"                                 >> $makefile
-endif
-echo "DONE"
-echo "You are ready to compile the programs by typing 'make' at the prompt"
-echo "good luck... contact drl@jb.man.ac.uk if you have any problems......"
-exit
diff --git a/filterbank-gmrt/conv.c b/filterbank-gmrt/conv.c
deleted file mode 100644
index a33f05b..0000000
--- a/filterbank-gmrt/conv.c
+++ /dev/null
@@ -1,24 +0,0 @@
-#include "dedisperse.h"
-main(int argc, char **argv)
-{
-  FILE *tim;
-  char c;
-  float s;
-  output=stdout;
-  send_string("HEADER_START");
-  send_int("telescope_id",5);
-  send_int("machine_id",6);
-  send_int("data_type",2);
-  send_double("refdm",0.0);
-  send_int("nchans",1);
-  send_int("nbits",32);  
-  send_double("tsamp",atof(argv[1]));
-  send_int("nifs",1);
-  send_string("HEADER_END");
-  tim=fopen(argv[2],"rb");
-  while (!feof(tim)) {
-    fread(&c, 1, 1, tim);	
-    s=c;
-    fwrite(&s,4, 1, output);
-  }
-}
diff --git a/filterbank-gmrt/cpgplot.h b/filterbank-gmrt/cpgplot.h
deleted file mode 100644
index ded5bf0..0000000
--- a/filterbank-gmrt/cpgplot.h
+++ /dev/null
@@ -1,115 +0,0 @@
-#ifndef cpgplot_h
-#define cpgplot_h
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-typedef int Logical;
-
-void cpgarro(float x1, float y1, float x2, float y2);
-void cpgask(Logical flag);
-int cpgband(int mode, int posn, float xref, float yref, float *x, float *y, char *ch_scalar);
-void cpgbbuf(void);
-int cpgbeg(int unit, const char *file, int nxsub, int nysub);
-void cpgbin(int nbin, const float *x, const float *data, Logical center);
-void cpgbox(const char *xopt, float xtick, int nxsub, const char *yopt, float ytick, int nysub);
-void cpgcirc(float xcent, float ycent, float radius);
-void cpgclos(void);
-void cpgconb(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, const float *c, int nc, const float *tr, float blank);
-void cpgconl(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, float c, const float *tr, const char *label, int intval, int minint);
-void cpgcons(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, const float *c, int nc, const float *tr);
-void cpgcont(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, const float *c, int nc, const float *tr);
-void cpgctab(const float *l, const float *r, const float *g, const float *b, int nc, float contra, float bright);
-int cpgcurs(float *x, float *y, char *ch_scalar);
-void cpgdraw(float x, float y);
-void cpgebuf(void);
-void cpgend(void);
-void cpgenv(float xmin, float xmax, float ymin, float ymax, int just, int axis);
-void cpgeras(void);
-void cpgerrb(int dir, int n, const float *x, const float *y, const float *e, float t);
-void cpgerrx(int n, const float *x1, const float *x2, const float *y, float t);
-void cpgerry(int n, const float *x, const float *y1, const float *y2, float t);
-void cpgetxt(void);
-void cpggray(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, float fg, float bg, const float *tr);
-void cpghi2d(const float *data, int nxv, int nyv, int ix1, int ix2, int iy1, int iy2, const float *x, int ioff, float bias, Logical center, float *ylims);
-void cpghist(int n, const float *data, float datmin, float datmax, int nbin, int pgflag);
-void cpgiden(void);
-void cpgimag(const float *a, int idim, int jdim, int i1, int i2, int j1, int j2, float a1, float a2, const float *tr);
-void cpglab(const char *xlbl, const char *ylbl, const char *toplbl);
-void cpglcur(int maxpt, int *npt, float *x, float *y);
-void cpgldev(void);
-void cpglen(int units, const char *string, float *xl, float *yl);
-void cpgline(int n, const float *xpts, const float *ypts);
-void cpgmove(float x, float y);
-void cpgmtxt(const char *side, float disp, float coord, float fjust, const char *text);
-void cpgncur(int maxpt, int *npt, float *x, float *y, int symbol);
-void cpgnumb(int mm, int pp, int form, char *string, int *string_length);
-void cpgolin(int maxpt, int *npt, float *x, float *y, int symbol);
-int cpgopen(const char *device);
-void cpgpage(void);
-void cpgpanl(int nxc, int nyc);
-void cpgpap(float width, float aspect);
-void cpgpixl(const int *ia, int idim, int jdim, int i1, int i2, int j1, int j2, float x1, float x2, float y1, float y2);
-void cpgpnts(int n, const float *x, const float *y, const int *symbol, int ns);
-void cpgpoly(int n, const float *xpts, const float *ypts);
-void cpgpt(int n, const float *xpts, const float *ypts, int symbol);
-void cpgptxt(float x, float y, float angle, float fjust, const char *text);
-void cpgqah(int *fs, float *angle, float *barb);
-void cpgqcf(int *font);
-void cpgqch(float *size);
-void cpgqci(int *ci);
-void cpgqcir(int *icilo, int *icihi);
-void cpgqcol(int *ci1, int *ci2);
-void cpgqcr(int ci, float *cr, float *cg, float *cb);
-void cpgqcs(int units, float *xch, float *ych);
-void cpgqfs(int *fs);
-void cpgqhs(float *angle, float *sepn, float *phase);
-void cpgqid(int *id);
-void cpgqinf(const char *item, char *value, int *value_length);
-void cpgqitf(int *itf);
-void cpgqls(int *ls);
-void cpgqlw(int *lw);
-void cpgqpos(float *x, float *y);
-void cpgqtbg(int *tbci);
-void cpgqtxt(float x, float y, float angle, float fjust, const char *text, float *xbox, float *ybox);
-void cpgqvp(int units, float *x1, float *x2, float *y1, float *y2);
-void cpgqvsz(int units, float *x1, float *x2, float *y1, float *y2);
-void cpgqwin(float *x1, float *x2, float *y1, float *y2);
-void cpgrect(float x1, float x2, float y1, float y2);
-float cpgrnd(float x, int *nsub);
-void cpgrnge(float x1, float x2, float *xlo, float *xhi);
-void cpgsah(int fs, float angle, float barb);
-void cpgsave(void);
-void cpgunsa(void);
-void cpgscf(int font);
-void cpgsch(float size);
-void cpgsci(int ci);
-void cpgscir(int icilo, int icihi);
-void cpgscr(int ci, float cr, float cg, float cb);
-void cpgscrn(int ci, const char *name, int *ier);
-void cpgsfs(int fs);
-void cpgshls(int ci, float ch, float cl, float cs);
-void cpgshs(float angle, float sepn, float phase);
-void cpgsitf(int itf);
-void cpgslct(int id);
-void cpgsls(int ls);
-void cpgslw(int lw);
-void cpgstbg(int tbci);
-void cpgsubp(int nxsub, int nysub);
-void cpgsvp(float xleft, float xright, float ybot, float ytop);
-void cpgswin(float x1, float x2, float y1, float y2);
-void cpgtbox(const char *xopt, float xtick, int nxsub, const char *yopt, float ytick, int nysub);
-void cpgtext(float x, float y, const char *text);
-void cpgupdt(void);
-void cpgvect(const float *a, const float *b, int idim, int jdim, int i1, int i2, int j1, int j2, float c, int nc, const float *tr, float blank);
-void cpgvsiz(float xleft, float xright, float ybot, float ytop);
-void cpgvstd(void);
-void cpgwedg(const char *side, float disp, float width, float fg, float bg, const char *label);
-void cpgwnad(float x1, float x2, float y1, float y2);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/filterbank-gmrt/cprofc.c b/filterbank-gmrt/cprofc.c
deleted file mode 100644
index d453b6d..0000000
--- a/filterbank-gmrt/cprofc.c
+++ /dev/null
@@ -1,49 +0,0 @@
-#include <math.h>
-
-#define NBINMAX 8192
-
-void cprofc(float *prof, int nbins, float *amp, float *pha)
-{
-
-  int i,nh,n2;
-  int forward = 1, back = -1, real = 1, complex = 0; 
-  float temp[NBINMAX][2];
-
-  nh = nbins/2;
-  n2 = nbins*2;
-  
-  for(i=0;i<nh;i++) {
-    temp[i][0] = prof[2*i];
-    temp[i][1] = prof[2*i+1];
-    temp[nh+i][0] = 0.;
-    temp[nh+i][1] = 0.;  
-  }
-
-  ffft_(&temp[0][0],&nbins,&forward,&real);
-
-  for(i=0;i<nh+1;i++) {
-    amp[i] = sqrt(temp[i][0]*temp[i][0] + temp[i][1]*temp[i][1]);
-    pha[i] = 0.;
-    if(amp[i] > 0.) 
-      pha[i] = atan2(temp[i][1],temp[i][0]); 
-  }
-
-}
-
-void uncprofc(float *amp, float *pha, int nbins, float *c)
-{
-
-  int i,nh;
-  
-  nh = nbins/2;
-
-  for(i=0;i<nh;i++) {
-    c[2*i] = amp[i]*cos((double)pha[i]);
-    c[2*i+1] = amp[i]*sin((double)pha[i]);
-  }
-  for(i=1;i<nh+1;i++) {  /* Important to set Nyquist component!!!  */
-    c[2*nbins-2*i] = amp[i]*cos((double)pha[i]);
-    c[2*nbins-2*i+1] = -amp[i]*sin((double)pha[i]);
-  }
-
-}
diff --git a/filterbank-gmrt/csamp.inc b/filterbank-gmrt/csamp.inc
deleted file mode 100644
index f0e4d0d..0000000
--- a/filterbank-gmrt/csamp.inc
+++ /dev/null
@@ -1,4 +0,0 @@
-c==============================================================================
-      real samp
-      common /csamp/samp(npts)
-c==============================================================================
diff --git a/filterbank-gmrt/csampacc.inc b/filterbank-gmrt/csampacc.inc
deleted file mode 100644
index 410e846..0000000
--- a/filterbank-gmrt/csampacc.inc
+++ /dev/null
@@ -1,4 +0,0 @@
-c==============================================================================
-      real sampacc
-      common /csampacc/sampacc(npts)
-c==============================================================================
diff --git a/filterbank-gmrt/csearch.csh b/filterbank-gmrt/csearch.csh
deleted file mode 100755
index 806d66e..0000000
--- a/filterbank-gmrt/csearch.csh
+++ /dev/null
@@ -1,47 +0,0 @@
-###############################################################################
-#
-# csearch - script to do a companion search on a dedispersed time series
-#
-# The script requires a .tim file with the dedispersed data and an "aclist" file
-# which is an ASCII list of the trial ACs and ADOTs to use in the search.
-#
-###############################################################################
-set seek       = $bin/seek
-set header     = $bin/header
-set polyco     = $bin/polyco
-set depolyco   = $bin/depolyco
-set source     = $1
-set pulsar     = $2
-if ($source == "") then
-	echo "usage: csearch filestem parstem"
-	exit
-endif
-if (! -e $source.tim) then
-	echo "Time series file: $source.tim not found..."	
-	exit
-endif
-if (! -e a1list) then
-	echo "File a1list with A1 ranges not found..."
-	exit
-endif
-if (! -e $pulsar.par) then
-	echo "TEMPO par file not found..."
-	exit
-endif
-echo "Hunting file $source.tim for periodicities... check back here later"
-echo "A1:" | awk '{printf "%s ", $1}'
-set append = ""
-set mjd = `$header $source.tim -tstart`
-set tel = `$header $source.tim -telescope`
-set frq = `$header $source.tim -fsamp`
-foreach a1 (`cat a1list`)
-	echo $a1 | awk '{printf "%s ", $1}'
-	cp $pulsar.par $TEMPO/tzpar
-	echo "A1 $a1"  >> $TEMPO/tzpar/$pulsar.par
-	echo "F0 $frq" >> $TEMPO/tzpar/$pulsar.par
-	$polyco $pulsar -mjd $mjd -site $tel -maxha 12 -nspan 60 > /dev/null
-	$depolyco $source.tim polyco.dat > $pulsar.tim
-	$seek $pulsar.tim -q $append -D$a1 -c4
-	set append = "-A"
-end
-exit
diff --git a/filterbank-gmrt/decimate.c b/filterbank-gmrt/decimate.c
deleted file mode 100644
index 644320f..0000000
--- a/filterbank-gmrt/decimate.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
-  DECIMATE  - decimate filterbank data by adding channels and/or time samples
-*/
-
-#include "decimate.h"
-
-main (int argc, char *argv[])
-{
-  int i, nc, headersize, headerless=0;
-  char string[80];
-
-  /* set up default global variables */
-  obits=headerless=naddc=naddt=nsamp=0;
-  input=stdin;
-  strcpy(inpfile,"stdin");
-  output=stdout;
-  strcpy(outfile,"stdout");
-
-  if (argc > 1) {
-    /* check command-line parameters */ 
-    print_version(argv[0],argv[1]);
-    i=1;
-    while (i<argc) {
-      if (strings_equal(argv[i],"-c")) {
-	i++;
-	naddc=atoi(argv[i]);
-      } else if (strings_equal(argv[i],"-t")) {
-	i++;
-	naddt=atoi(argv[i]);
-      } else if (strings_equal(argv[i],"-o")) {
-	/* get and open file for output */
-	output=fopen(argv[++i],"wb");
-      } else if (strings_equal(argv[i],"-T")) {
-	i++;
-	nsamp=atoi(argv[i]);
-      } else if (strings_equal(argv[i],"-n")) {
-	i++;
-	obits=atoi(argv[i]);
-      } else if (strings_equal(argv[i],"-headerless")) {
-	headerless=1;
-      } else if (help_required(argv[1])) {
-	decimate_help();
-	exit(0);
-      } else if (file_exists(argv[i])) {
-	strcpy(inpfile,argv[i]);
-	input=open_file(inpfile,"rb");
-      } else {
-	decimate_help();
-	sprintf(string,"unknown argument (%s) passed to decimate",argv[i]);
-	error_message(string);
-      }
-      i++;
-    }
-  }
-
-  /* read in the header to establish what the input data are... */
-  if ((headersize=read_header(input))) {
-    if ( (nsamp > 0) && !strings_equal(inpfile,"stdin") ) {
-      naddt=nsamples(inpfile,headersize,nbits,nifs,nchans)/nsamp;
-      if (naddt%2) naddt--;
-    }
-    switch (data_type) {
-    case 1:
-      break;
-    case 2:
-      nchans=1;
-      break;
-    default:
-      error_message("input data to decimate is not in filterbank format");
-      break;
-    }
-    /* check number of time samples to add */
-    if (naddt <= 1) naddt=1;
-    /*if (naddt%2) error_message("time decimation must be a power of 2");*/
-    /* check number of frequency channels to add (integer multiple) */
-    if (naddc<1) naddc=nchans;
-    nc=nchans/naddc;
-    if ( (nc*naddc) != nchans ) 
-      error_message("nchans must be integer multiple of decimation factor");
-    if (obits == 0) obits=nbits;
-    if (obits==1) error_message("output of 1-bit data will result in vastly reduced S/N!\nselect a higher output bit size with the -n option");
-    /* all ok - broadcast the new header */
-    if (!headerless) decimate_header();
-  } else {
-    error_message("input data file is of unknown origin!!!");
-  }
-  
-  /* finally decimate and output the data */
-  decimate_data(input,output);
-
-  exit(0);
-}
diff --git a/filterbank-gmrt/decimate.h b/filterbank-gmrt/decimate.h
deleted file mode 100644
index 677f52a..0000000
--- a/filterbank-gmrt/decimate.h
+++ /dev/null
@@ -1,8 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include "sigproc.h"
-#include "header.h"
-int nsamp,naddc,naddt,headerless,obits;
-char inpfile[80], outfile[80];
-FILE *input, *output, *logfile;
diff --git a/filterbank-gmrt/decimate_data.c b/filterbank-gmrt/decimate_data.c
deleted file mode 100644
index 3f0152a..0000000
--- a/filterbank-gmrt/decimate_data.c
+++ /dev/null
@@ -1,64 +0,0 @@
-#include "decimate.h"
-
-void decimate_data(FILE *input, FILE *output) /*includefile*/
-{ 
-  char string[80];
-  float *fblock,min,max,realtime,fsaved[2];
-  unsigned short *sblock;
-  unsigned char  *cblock;
-  int nsaved=0,ns,nsblk,opened=0,nout;
-
-  nsblk=nchans*nifs*naddt;
-  fblock=(float *) malloc(nsblk*sizeof(float));
-  sblock=(unsigned short *) malloc(nsblk*sizeof(unsigned short));
-  cblock=(unsigned char *) malloc(nsblk*sizeof(unsigned short));
-  realtime=min=0.0;
-  max=(float) pow(2.0,(double)obits) -1.0;
-
-  /* main decimation loop */
-  while ((ns=read_block(input,nbits,fblock,nsblk))>0) {
-    add_channels(fblock,ns,naddc);
-    add_samples(fblock,nifs,nchans/naddc,naddt);
-    if (!opened) {
-      /* open up logfile */
-      open_log("decimate.monitor");
-      opened=1;
-    }
-    nout=ns/naddt/naddc;
-    switch (obits) {
-    case 32:
-      fwrite(fblock,sizeof(float),nout,output);
-      break;
-    case 16:
-      float2short(fblock,nout,min,max,sblock);
-      fwrite(sblock,sizeof(unsigned short),nout,output);
-      break;
-    case 8:
-      float2char(fblock,nout,min,max,cblock);
-      fwrite(cblock,sizeof(unsigned char),nout,output);
-      break;
-    case 4:
-      if (nout==1) {
-	/* must have at least two samples for four-bit packing save this one */
-	fsaved[nsaved]=fblock[0];
-	nsaved++;
-	if (nsaved==2) {
-	  /* we have 2 saved! write out */
-	  float2four(fsaved,nsaved,min,max,cblock);
-	  fwrite(cblock,sizeof(unsigned char),1,output);
-	  nsaved=0;
-	}
-      } else {
-	/* normal case */
-	float2four(fblock,nout,min,max,cblock);
-	fwrite(cblock,sizeof(unsigned char),nout/2,output);
-      }
-      break;
-    }
-    realtime+=(float) tsamp * (float) ns/(float) nchans/(float) nifs;
-    sprintf(string,"time:%.1fs",realtime);
-    update_log(string);
-  }
-  update_log("finished");
-  close_log();
-}
diff --git a/filterbank-gmrt/decimate_header.c b/filterbank-gmrt/decimate_header.c
deleted file mode 100644
index 8df7142..0000000
--- a/filterbank-gmrt/decimate_header.c
+++ /dev/null
@@ -1,30 +0,0 @@
-#include "decimate.h"
-void decimate_header() /* includefile */
-{
-  /* go no further here if not interested in header parameters */
-  if (headerless) return;
-  /* broadcast the header parameters to the output stream */
-  send_string("HEADER_START");
-  if (!strings_equal(source_name,"")) {
-    send_string("source_name");
-    send_string(source_name);
-  }
-  send_int("telescope_id",telescope_id); 
-  send_int("machine_id",machine_id);
-  send_coords(src_raj,src_dej,az_start,za_start);
-  if (nchans/naddc==1) {
-    send_int("data_type",2);
-    send_double("refdm",0.0);
-  } else {
-    send_int("data_type",1);
-  }
-  send_double("fch1",fch1);
-  send_double("foff",foff*(double)naddc);
-  send_int("nchans",nchans/naddc);
-  send_int("nbits",obits);
-  send_double ("tstart",tstart); 
-  send_double("tsamp",tsamp*(double)naddt);
-  send_int("nifs",nifs);
-  send_int("barycentric",barycentric);
-  send_string("HEADER_END");
-}
diff --git a/filterbank-gmrt/dedisperse.c b/filterbank-gmrt/dedisperse.c
deleted file mode 100644
index cb0c585..0000000
--- a/filterbank-gmrt/dedisperse.c
+++ /dev/null
@@ -1,245 +0,0 @@
-/*
-  dedisperse  - dedisperses raw filterbank data or folded pulse profiles
-*/
-#include "dedisperse.h"
-FILE *input, *output;
-char  inpfile[80], outfile[80], ignfile[80];
-
-/* global variables describing the operating mode */
-int ascii, asciipol, stream, swapout, headerless, nbands, userbins, usrdm, baseline, clipping, sumifs, profnum1, profnum2, nobits, wapp_inv, wapp_off;
-double refrf,userdm,fcorrect;
-float clipvalue,jyf1,jyf2;
-int fftshift;
-#include "wapp_header.h"
-#include "key.h"
-struct WAPP_HEADER *wapp;
-struct WAPP_HEADER head;
-
-main (int argc, char *argv[])
-{
-  /* local variables */
-  char string[80];
-  int i,useroutput=0,autooutput=0,nfiles,fileidx,sigproc,scan_number,subscan=0;
-
-  /* check number of command-line arguments and print help if necessary */
-  if (argc<2) {
-    dedisperse_help();
-    exit(0);
-  } else {
-    print_version(argv[0],argv[1]);
-  }
-
-  /* print help if necessary */
-  if (help_required(argv[1])) {
-    dedisperse_help();
-    exit(0);
-  }
-  /* work out how many files are on the command line */
-  i=1;
-  nfiles=0;
-  while(file_exists(argv[i])) {
-	nfiles++;
-	i++;
-  }
-
-  /* set up default globals */
-  userbins=usrdm=asciipol=stream=clipping=swapout=headerless=0;
-  sumifs=wapp_inv=wapp_off=barycentric=0;
-  nobits=32;
-  ascii=1;
-  fftshift=1;
-  profnum1 = 0;
-  profnum2 = 1000;
-  nbands=baseline=1;
-  clipvalue=refrf=userdm=fcorrect=0.0;
-  jyfactor=jyf1=jyf2=1.0;
-  refdm=-1.0;
-  output=NULL;
-  strcpy(ignfile,"");
-
-  /* now parse any remaining command line parameters */
-  if (argc>nfiles) {
-    i=nfiles+1;
-    while (i<argc) {
-      if (strings_equal(argv[i],"-d")) {
-	/* get DM from the user */
-	userdm=atof(argv[++i]);
-	usrdm=1;
-      } else if (strings_equal(argv[i],"-b")) {
-	if (strings_equal(argv[++i],"nchans")) {
-	  nbands=0;
-	} else {
-	  /* get number of subbands */
-	  nbands=atoi(argv[i]);
-	}
-      } else if (strings_equal(argv[i],"-B")) {
-	/* get output number of bits */
-	nobits=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-o")) {
-	/* get and open file for output */
-	strcpy(outfile,argv[++i]);
-	useroutput=1;
-      } else if (strings_equal(argv[i],"-autooutput")) {
-	/* open output files automatically as mjd.frq.scn */
-	autooutput=1;
-      } else if (strings_equal(argv[i],"-c")) {
-	/* set clipvalue */
-	clipvalue=atof(argv[++i]);
-	baseline=clipping=1;
-      } else if (strings_equal(argv[i],"-j")) {
-	/* get user-supplied Jansky calibration factor */
-	jyfactor=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-J")) {
-	/* get user-supplied Jansky calibration factors */
-	jyf1=atof(argv[++i]);
-	jyf2=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-old")) {
-	/* revert to the old method of profile dedispersion ! */
-	fftshift=0;
-      } else if (strings_equal(argv[i],"-f")) {
-	/* get optional reference frequency for dedispersion */
-	if (strings_equal(argv[++i],"mid")) {
-		/* will set reference frequency to band centre */
-		refrf = -1.0; 
-	} else {
-		/* will set user-supplied reference frequency */
-		refrf = atof(argv[i]);
-	}
-      } else if (strings_equal(argv[i],"-F")) {
-	/* get optional frequency to correct value in header */
-        fcorrect = atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-n")) {
-	/* get number of bins */
-	userbins=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-i")) {
-	/* file containing channel numbers to ignore */
-	strcpy(ignfile,argv[++i]);
-      } else if (strings_equal(argv[i],"-p")) {
-	/* get which profile numbers to use - starts at 0 */
-	profnum1=atoi(argv[++i]);
-	profnum2=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-wappinvert")) {
-        /* Make wapp frequency channel increments negative */
-        wapp_inv=1;
-      } else if (strings_equal(argv[i],"-wappoffset")) {
-        /* Puts fmid between two middle channels; otherwise it's in the
-	 * 	middle of one of those channels (for use with 
-	 * 	pre-52900 data ONLY) */
-        wapp_off=1;
-      } else if (strings_equal(argv[i],"-swapout")) {
-	/* perform byte swapping on all output data */
-	swapout=1;
-      } else if (strings_equal(argv[i],"-headerless")) {
-	/* no headers */
-	headerless=1;
-      } else if (strings_equal(argv[i],"-nobaseline")) {
-	/* no baseline subtraction */
-	baseline=0;
-      } else if (strings_equal(argv[i],"-sumifs")) {
-	/* Sum IFs for final profile */
-	sumifs = 1;;
-      } else if (strings_equal(argv[i],"-epn")) {
-	/* write EPN profiles when dedispersing folded data */
-	ascii=0;
-      } else if (strings_equal(argv[i],"-ascii")) {
-	/* write ascii profiles when dedispersing folded data */
-	ascii=1;
-      } else if (strings_equal(argv[i],"-asciipol")) {
-      /* write data as ASCII numbers for Jim's polarization code */
-	asciipol=1;
-      } else if (strings_equal(argv[i],"-stream")) {
-      /* write data as ASCII streams */
-	stream=1;
-      } else {
-	/* unknown argument passed down - stop! */
-	dedisperse_help();
-	sprintf(string,"unknown argument (%s) passed to %s",argv[i],argv[0]);
-	error_message(string);
-      }
-      i++;
-    }
-  }
-
-  if (!useroutput && !autooutput) {
-    /* no output file selected, use standard output */
-    output=stdout;
-    strcpy(outfile,"stdout");
-  }
-
-  if (!nfiles) {
-    strcpy(inpfile,"stdin");
-    nfiles=1;
-  }
-  fileidx=1;
-  
-
-  /* main loop around input files */
-  while (fileidx <= nfiles) {
-
-    /* open input datafile and get type of file from the input data */
-    if (strings_equal(inpfile,"stdin")) {
-      input=stdin;
-    } else {
-      strcpy(inpfile,argv[fileidx]);
-      input=open_file(inpfile,"rb");
-    }
-
-    if (autooutput) {
-      /* get scan number from the file name's last four digits */
-      scan_number=atoi(strtok(&inpfile[strlen(inpfile)-7],"."));
-    }
-
-    /* read in the header to establish what the input data are... */
-    while (!feof(input)) {
-    sigproc=read_header(input);
-    if (sigproc) {
-      if (data_type == 3) {
-	if (autooutput) {
-	  subscan++;
-	  sprintf(outfile,"%.0f.%.0f.%03d%03d.prf",floor(tstart),fch1+foff*((float)nchans)/2.0,scan_number,subscan);
-	  output=open_file(outfile,"w");
-	} else {
-	  if (output != stdout && fileidx == 1) output=open_file(outfile,"w");
-	}
-	machine2prf(input,output);
-      } else {
-	if (foff > 0.0) 
-	  error_message("dedisperse can't handle low->high frequency ordering!");
-	if (fileidx == 1) {
-	  /* this is filterbank data */
-	  if (output!=stdout) output=open_file(outfile,"wb");
-	  /* open up logfile */
-	  open_log("dedisperse.monitor");
-	  /* broadcast header */
-	  dedisperse_header();
-	}
-	/* dedisperse */
-	dedisperse_data(input,output);
-	/* close log files if on last input file */
-	if (fileidx == nfiles) {
-	  update_log("finished");
-	  close_log();
-	}
-      }
-    } else {
-      /* this is something else - possibly folded data - check it out.... */
-      switch(typeof_inputdata(input,argv[1])) {
-      case 2:
-      case 4:
-      case 6:
-	/* SIGPROC/PSPM/WAPP/BPP timing-mode data */
-	if (output != stdout && fileidx == 1) output=open_file(outfile,"w");
-	machine2prf(input,output);
-	exit(0);
-	break;
-      default:
-	error_message("input data file is of unknown origin!!!");
-      }
-    }
-    if (autooutput) fclose(output);
-    }
-    fileidx++;
-    fclose(input);
-  }
-  exit(0);
-}
diff --git a/filterbank-gmrt/dedisperse.h b/filterbank-gmrt/dedisperse.h
deleted file mode 100644
index 7614bbf..0000000
--- a/filterbank-gmrt/dedisperse.h
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-extern FILE *input, *output, *logfile, *calptr;
-extern char  inpfile[80], outfile[80], ignfile[80], calfile[80];
-
-/* global variables describing the operating mode */
-extern int ascii, asciipol, stream, swapout, headerless, nbands, userbins, usrdm, baseline, clipping, sumifs, profnum1, profnum2, nobits, wapp_inv, wapp_off,calflag;
-extern double refrf,userdm,fcorrect;
-extern float clipvalue,jyfactor,jyf1,jyf2;
-
-/* global variables describing the data */
-#include "header.h"
-
-/* list of subroutines and functions */
-#include "sigproc.h"
diff --git a/filterbank-gmrt/dedisperse_data.c b/filterbank-gmrt/dedisperse_data.c
deleted file mode 100644
index 6f87b5b..0000000
--- a/filterbank-gmrt/dedisperse_data.c
+++ /dev/null
@@ -1,215 +0,0 @@
-#include "dedisperse.h"
-/* 
-   orders incoming blocks of data into dedispersed sub-bands 
-*/
-void dedisperse_data(FILE *input, FILE *output) /*includefile*/
-{ 
-  char message[80];
-  float *buff[2], *dedisp, realtime, nextbaseline, *offset, *tmpblk;
-  int readnext=0,isamp,bnum,nsamp,i,j,s,c,b,indx,ns[2],soffset,ddidx;
-  int ic,ixnb,ixnc,*ishift,maxshift,nsblk,nsmax,cpb,d,spb,x,nsout,nxb;
-  int *ignore;
-
-  /* calculate table of shift values given the filterbank and DM */
-  ishift=dmshift(fch1,foff,nchans,nbands,userdm,refrf,tsamp,frequency_table);
-  maxshift=ishift[nchans-1];
-
-  /* set the buffer size based on the maximum shift */
-  nsblk=256*nchans; nsout=32*nchans;
-  /*nsblk=256*nchans; nsout=32768*nchans;*/
-  nsmax=maxshift*nifs*nchans;
-  if (nsmax>nsblk) nsblk=nsmax;
-  nxb=nifs*nbands;
-
-  /* define the buffers and initialize counters */
-  dedisp =(float *) malloc(nxb*nsout*sizeof(float));
-  offset =(float *) malloc(nxb*sizeof(float));
-  tmpblk =(float *) malloc(nsout*sizeof(float));
-  buff[0]=(float *) malloc(nsblk*sizeof(float));
-  buff[1]=(float *) malloc(nsblk*sizeof(float));
-  for (i=0;i<nxb;i++) offset[i]=0.0;
-  d=bnum=isamp=0;
-  ic=nchans*nifs;
-  nextbaseline=realtime=0.0;
-
-  /* zero any channels that are in the ignored list of channels */
-  if (file_exists(ignfile)) {
-    ignore=ignored_channels(ignfile,nchans);
-  } else {
-    ignore=(int *) malloc(nchans*sizeof(int));
-    for (i=0;i<nchans;i++) ignore[i]=0;
-  }
-
-  /* number of channels per band to dedisperse (cpb) must be an integer */
-  cpb=nchans/nbands; 
-  if ((cpb*nbands) != nchans) error_message("silly sub-band selection!");
-
-  /* main loop - keep going until no more data comes in */
-  while (1) {
-
-    /* read in the buffer to be processed if not done so already */
-    if (!readnext) {
-      sprintf(message,"time:%.1fs:DM:%.1fpc/cc",realtime,refdm);
-      update_log(message);
-      if ((ns[bnum]=read_block(input,nbits,buff[bnum],nsblk))<=0) {
-	if (isamp)write_dedisp(dedisp,isamp,nifs,nbands,offset,output);
-	return;
-      }
-    }
-
-    /* number of samples in this buffer */
-    nsamp=ns[bnum]/ic;
-
-    /* flag to signify whether next buffer has been read in (1=yes;0=no) */
-    readnext=0;
-
-    /* dedispersing loop over all samples in this buffer */
-    for (s=0; s<nsamp; s++) {
-      soffset=isamp*nxb;
-      /* loop over the IFs */
-      for (i=0; i<nifs; i++) {
-	/* number of channels to skip within this IF */
-	ixnc=i*nchans; 
-	ixnb=i*nbands;
-	for (b=0; b<nbands; b++) {
-	  /* calculate index of this sample */
-	  ddidx=soffset+ixnb+b;
-	  /* clear array element for storing dedispersed subband */
-	  dedisp[ddidx]=0.0; 
-	  /* loop over the channels in this subband */
-	  for (c=b*cpb;c<(b+1)*cpb;c++) {
-	    /* proceed only if selected channel # is not in ignore list */
-	    if (!ignore[c]) 
-	    {
-	      /* calculate index of sample to be added */
-	      indx=(s+ishift[c])*ic+ixnc+c;
-	      /* required sample will be in either this buffer or the next */
-	      if (indx<ns[bnum]) {
-	        dedisp[ddidx]+=buff[bnum][indx];
-	      } else {
-	        if (!readnext) {
-		  if ((ns[!bnum]=read_block(input,nbits,buff[!bnum],nsblk))<=0) {
-		    if (isamp) {
-		      write_dedisp(dedisp,isamp,nifs,nbands,offset,output);
-		    }
-		    return;
-		  }
-		  sprintf(message,"time:%.1fs:DM:%.1fpc/cc",realtime,refdm);
-		  update_log(message);
-		  readnext=1;
-	        }
-	        dedisp[ddidx]+=buff[!bnum][indx-ns[bnum]];
-	      }
-	    }
-	  }
-	} /* end of loop over subbands */
-      } /* end of loop over IFs */
-      /* update number of samples dedispersed and elapsed time */
-      isamp++; realtime+=tsamp;
-      if (isamp==nsout) {
-	if (baseline) {
-	  for (i=0;i<nifs;i++) {
-	    ixnb=i*nbands;
-	    for (b=0;b<nbands;b++) {
-	      for (j=0;j<nsout;j++) tmpblk[j]=dedisp[j*nxb+ixnb+b];
-	      offset[ixnb+b]=nrselect(nsout/2,nsout,tmpblk-1);
-	      //fprintf(stderr,"%d %f\n",ixnb+b,offset[ixnb+b]);
-	    }
-	  }
-	}
-	write_dedisp(dedisp,nsout,nifs,nbands,offset,output);
-	isamp=0;
-      }
-    } /* end of loop over samples */
-    /* switch to next buffer */
-    bnum=!bnum;
-  } /* end of main loop */
-}
-
-/* subtract current offset from the dedisperse time samples and write */
-void write_dedisp(float *dedisp, int nsout, int nifs, int nbands, float *offset, FILE *output)/*includefile*/
-{
-  int s,i,b,ixnb,sxib,n;
-  static int first=1;
-  static float *clipthreshold;
-  float *temp,outliers,sample,sumsq;
-  char *onebyte;
-  short *twobyte;
-
-  /* multiply outgoing data by Jansky calibration factor if supplied */
-  if (jyfactor != 1.0) for (i=0;i<nsout*nifs*nbands;i++) dedisp[i]*=jyfactor;
-
-  if (first) {
-    /* allocate an array for holding blocks from a given subband */
-    temp=malloc(sizeof(float)*nsout);
-    /* allocate an array for saving the clipping threshold */
-    clipthreshold=malloc(sizeof(float)*nbands*nifs);
-    for (i=0;i<nifs*nbands;i++) clipthreshold[i]=0.0;
-  }
-		       
-  for (i=0;i<nifs;i++) {
-    ixnb=i*nbands;
-    for (b=0;b<nbands;b++) {
-      if (first) {
-	/* copy sub-band into temporary store for absolute value */
-	for (s=0;s<nsout;s++) {
-	  sxib=s*nifs*nbands;
-	  temp[s]=fabs(dedisp[sxib+ixnb+b]-offset[ixnb+b]);
-	}
-	/* find the value below which 90% of the samples lie */
-	outliers=nrselect(nsout/10,nsout,temp-1);
-	n=0;
-	sumsq=0.0;
-	/* calculate sum of squares based on the inner 90% of samples */
-	for (s=0;s<nsout;s++) {
-	  if (temp[s]<outliers) {
-	    sumsq+=temp[s]*temp[s];
-	    n++;
-	  }
-	}
-	/* now set the threshold based on the sum of squares */
-	if (n) 
-	  clipthreshold[ixnb+b]=clipvalue*sqrt((double)sumsq/(double)n);
-	else 
-	  clipping=0;
-      }
-      for (s=0;s<nsout;s++) {
-	sxib=s*nifs*nbands;
-	/* subtract off median value of this block */
-	sample=dedisp[sxib+ixnb+b]-offset[ixnb+b];
-	/* clip this sample if it exceeds the threshold */
-	if (fabs(sample)>clipthreshold[ixnb+b] && clipping) sample=0.0;
-	/* store the final produce and swap bytes if necessary */
-	dedisp[sxib+ixnb+b]=sample;
-	if (swapout) swap_float(&dedisp[sxib+ixnb+b]);
-      }
-    }
-  }
-
-  /* now write out samples and bat on */
-  switch (nobits) {
-  case 8:
-    onebyte = (char *) malloc(nsout*nifs*nbands);
-    for (i=0; i<nsout*nifs*nbands; i++) 
-      onebyte[i] = (char) dedisp[i];
-    fwrite(onebyte,sizeof(char),nsout*nifs*nbands,output);
-    break;
-  case 16:
-    twobyte = (short *) malloc(nsout*nifs*nbands);
-    for (i=0; i<nsout*nifs*nbands; i++) 
-      twobyte[i] = (short) dedisp[i];
-    fwrite(twobyte,sizeof(short),nsout*nifs*nbands,output);
-    break;
-  case 32:
-    fwrite(dedisp,sizeof(float),nsout*nifs*nbands,output);
-    break;
-  default:
-    error_message("requested output number of bits can only be 8, 16 or 32");
-    break;
-  }
-
-  if (first) {
-    first=0;
-    free(temp);
-  }
-}
diff --git a/filterbank-gmrt/dedisperse_header.c b/filterbank-gmrt/dedisperse_header.c
deleted file mode 100644
index 738ec1f..0000000
--- a/filterbank-gmrt/dedisperse_header.c
+++ /dev/null
@@ -1,43 +0,0 @@
-#include "dedisperse.h"
-
-void dedisperse_header() /* includefile */
-{
-  /* go no further here if not interested in header parameters */
-  if (headerless) return;
-
-  /* broadcast the header parameters to the output stream */
-  send_string("HEADER_START");
-
-  if (!strings_equal(source_name,"")) {
-    send_string("source_name");
-    send_string(source_name);
-  }
-  send_int("telescope_id",telescope_id); 
-  send_int("machine_id",machine_id);
-  send_coords(src_raj,src_dej,az_start,za_start);
-  if (refdm == -1.0) refdm=userdm;
-  if (nbands==1) {
-    send_int("data_type",2);
-    send_double("refdm",refdm);
-  } else {
-    send_int("data_type",6);
-    send_double("refdm",refdm);
-    send_double("foff",foff*(double)(nchans/nbands));
-  }
-
-  if ( (fch1 == 0.0) && (frequency_table[0] == 0.0) ) 
-    error_message("help... missing frequency information!");
-
-  if (fch1 == 0.0) 
-    send_double("fch1",frequency_table[0]);
-  else
-    send_double("fch1",fch1);
-
-  send_int("barycentric",barycentric);
-  send_int("nchans",nbands);
-  send_int("nbits",nobits);  
-  send_double ("tstart",tstart); 
-  send_double("tsamp",tsamp);
-  send_int("nifs",nifs);
-  send_string("HEADER_END");
-}
diff --git a/filterbank-gmrt/dedispersecal.c b/filterbank-gmrt/dedispersecal.c
deleted file mode 100644
index 1ca7bb3..0000000
--- a/filterbank-gmrt/dedispersecal.c
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
-  dedisperse  - dedisperses raw filterbank data or folded pulse profiles
-*/
-#include "dedisperse.h"
-  //  CHANGE HERE BCJ 260319
-FILE *input, *output, *calptr;
-char  inpfile[80], outfile[80], ignfile[80], calfile[80];
-int calflag;
-  //  CHANGE HERE BCJ 260319
-
-/* global variables describing the operating mode */
-int ascii, asciipol, stream, swapout, headerless, nbands, userbins, usrdm, baseline, clipping, sumifs, profnum1, profnum2, nobits, wapp_inv, wapp_off;
-double refrf,userdm,fcorrect;
-float clipvalue,jyf1,jyf2;
-int fftshift;
-#include "wapp_header.h"
-#include "key.h"
-struct WAPP_HEADER *wapp;
-struct WAPP_HEADER head;
-
-main (int argc, char *argv[])
-{
-  /* local variables */
-  char string[80];
-  int i,useroutput=0,autooutput=0,nfiles,fileidx,sigproc,scan_number,subscan=0;
-
-  /* check number of command-line arguments and print help if necessary */
-  if (argc<2) {
-    dedisperse_help();
-    exit(0);
- } else {
-    print_version(argv[0],argv[1]);
-  }
-
-  /* print help if necessary */
-  if (help_required(argv[1])) {
-    dedisperse_help();
-    exit(0);
-  }
-  /* work out how many files are on the command line */
-  i=1;
-  nfiles=0;
-  while(file_exists(argv[i])) {
-	nfiles++;
-	i++;
-  }
-
-  /* set up default globals */
-  userbins=usrdm=asciipol=stream=clipping=swapout=headerless=0;
-  sumifs=wapp_inv=wapp_off=barycentric=0;
-  nobits=32;
-  ascii=1;
-  fftshift=1;
-  profnum1 = 0;
-  profnum2 = 1000;
-  nbands=baseline=1;
-  clipvalue=refrf=userdm=fcorrect=0.0;
-  jyfactor=jyf1=jyf2=1.0;
-  refdm=-1.0;
-  output=NULL;
-  strcpy(ignfile,"");
-  //  CHANGE HERE BCJ 260319
-  calflag = 0;
-  //  CHANGE HERE BCJ 260319
-
-  /* now parse any remaining command line parameters */
-  if (argc>nfiles) {
-    i=nfiles+1;
-    while (i<argc) {
-      if (strings_equal(argv[i],"-d")) {
-	/* get DM from the user */
-	userdm=atof(argv[++i]);
-	usrdm=1;
-      } else if (strings_equal(argv[i],"-b")) {
-	if (strings_equal(argv[++i],"nchans")) {
-	  nbands=0;
-	} else {
-	  /* get number of subbands */
-	  nbands=atoi(argv[i]);
-	}
-      } else if (strings_equal(argv[i],"-B")) {
-	/* get output number of bits */
-	nobits=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-o")) {
-	/* get and open file for output */
-	strcpy(outfile,argv[++i]);
-	useroutput=1;
-      } else if (strings_equal(argv[i],"-autooutput")) {
-	/* open output files automatically as mjd.frq.scn */
-	autooutput=1;
-      } else if (strings_equal(argv[i],"-c")) {
-	/* set clipvalue */
-	clipvalue=atof(argv[++i]);
-	baseline=clipping=1;
-  //  CHANGE HERE BCJ 260319
-      } else if (strings_equal(argv[i],"-j")) {
-	/* get user-supplied Jansky calibration factor */
-	strcpy(calfile,argv[++i]);
-	calflag=1;
-  //  CHANGE HERE BCJ 260319
-      } else if (strings_equal(argv[i],"-J")) {
-	/* get user-supplied Jansky calibration factors */
-	jyf1=atof(argv[++i]);
-	jyf2=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-old")) {
-	/* revert to the old method of profile dedispersion ! */
-	fftshift=0;
-      } else if (strings_equal(argv[i],"-f")) {
-	/* get optional reference frequency for dedispersion */
-	if (strings_equal(argv[++i],"mid")) {
-		/* will set reference frequency to band centre */
-		refrf = -1.0; 
-	} else {
-		/* will set user-supplied reference frequency */
-		refrf = atof(argv[i]);
-	}
-      } else if (strings_equal(argv[i],"-F")) {
-	/* get optional frequency to correct value in header */
-        fcorrect = atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-n")) {
-	/* get number of bins */
-	userbins=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-i")) {
-	/* file containing channel numbers to ignore */
-	strcpy(ignfile,argv[++i]);
-      } else if (strings_equal(argv[i],"-p")) {
-	/* get which profile numbers to use - starts at 0 */
-	profnum1=atoi(argv[++i]);
-	profnum2=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-wappinvert")) {
-        /* Make wapp frequency channel increments negative */
-        wapp_inv=1;
-      } else if (strings_equal(argv[i],"-wappoffset")) {
-        /* Puts fmid between two middle channels; otherwise it's in the
-	 * 	middle of one of those channels (for use with 
-	 * 	pre-52900 data ONLY) */
-        wapp_off=1;
-      } else if (strings_equal(argv[i],"-swapout")) {
-	/* perform byte swapping on all output data */
-	swapout=1;
-      } else if (strings_equal(argv[i],"-headerless")) {
-	/* no headers */
-	headerless=1;
-      } else if (strings_equal(argv[i],"-nobaseline")) {
-	/* no baseline subtraction */
-	baseline=0;
-      } else if (strings_equal(argv[i],"-sumifs")) {
-	/* Sum IFs for final profile */
-	sumifs = 1;;
-      } else if (strings_equal(argv[i],"-epn")) {
-	/* write EPN profiles when dedispersing folded data */
-	ascii=0;
-      } else if (strings_equal(argv[i],"-ascii")) {
-	/* write ascii profiles when dedispersing folded data */
-	ascii=1;
-      } else if (strings_equal(argv[i],"-asciipol")) {
-      /* write data as ASCII numbers for Jim's polarization code */
-	asciipol=1;
-      } else if (strings_equal(argv[i],"-stream")) {
-      /* write data as ASCII streams */
-	stream=1;
-      } else {
-	/* unknown argument passed down - stop! */
-	dedisperse_help();
-	sprintf(string,"unknown argument (%s) passed to %s",argv[i],argv[0]);
-	error_message(string);
-      }
-      i++;
-    }
-  }
-
-  if (!useroutput && !autooutput) {
-    /* no output file selected, use standard output */
-    output=stdout;
-    strcpy(outfile,"stdout");
-  }
-
-  if (!nfiles) {
-    strcpy(inpfile,"stdin");
-    nfiles=1;
-  }
-  fileidx=1;
-  
-
-  /* main loop around input files */
-  while (fileidx <= nfiles) {
-
-    /* open input datafile and get type of file from the input data */
-    if (strings_equal(inpfile,"stdin")) {
-      input=stdin;
-    } else {
-      strcpy(inpfile,argv[fileidx]);
-      input=open_file(inpfile,"rb");
-    }
-
-    if (autooutput) {
-      /* get scan number from the file name's last four digits */
-      scan_number=atoi(strtok(&inpfile[strlen(inpfile)-7],"."));
-    }
-
-    /* read in the header to establish what the input data are... */
-    while (!feof(input)) {
-    sigproc=read_header(input);
-    if (sigproc) {
-      if (data_type == 3) {
-	if (autooutput) {
-	  subscan++;
-	  sprintf(outfile,"%.0f.%.0f.%03d%03d.prf",floor(tstart),fch1+foff*((float)nchans)/2.0,scan_number,subscan);
-	  output=open_file(outfile,"w");
-	} else {
-	  if (output != stdout && fileidx == 1) output=open_file(outfile,"w");
-	}
-	machine2prf(input,output);
-      } else {
-	if (foff > 0.0) 
-	  error_message("dedisperse can't handle low->high frequency ordering!");
-	if (fileidx == 1) {
-	  /* this is filterbank data */
-	  if (output!=stdout) output=open_file(outfile,"wb");
-	  /* open up logfile */
-	  open_log("dedisperse.monitor");
-	  /* broadcast header */
-	  dedisperse_header();
-	}
-	/* dedisperse */
-  //  CHANGE HERE BCJ 260319
-	dedispersecal_data(input,output);
-  //  CHANGE HERE BCJ 260319
-	/* close log files if on last input file */
-	if (fileidx == nfiles) {
-	  update_log("finished");
-	  close_log();
-	}
-      }
-    } else {
-      /* this is something else - possibly folded data - check it out.... */
-      switch(typeof_inputdata(input,argv[1])) {
-      case 2:
-      case 4:
-      case 6:
-	/* SIGPROC/PSPM/WAPP/BPP timing-mode data */
-	if (output != stdout && fileidx == 1) output=open_file(outfile,"w");
-	machine2prf(input,output);
-	exit(0);
-	break;
-      default:
-	error_message("input data file is of unknown origin!!!");
-      }
-    }
-    if (autooutput) fclose(output);
-    }
-    fileidx++;
-    fclose(input);
-  }
-  exit(0);
-}
diff --git a/filterbank-gmrt/dedispersecal_data.c b/filterbank-gmrt/dedispersecal_data.c
deleted file mode 100644
index c398f3e..0000000
--- a/filterbank-gmrt/dedispersecal_data.c
+++ /dev/null
@@ -1,289 +0,0 @@
-#include "dedisperse.h"
-  //  CHANGE HERE BCJ 260319
-extern int calflag;
-  //  CHANGE HERE BCJ 260319
-/* 
-   orders incoming blocks of data into dedispersed sub-bands 
-*/
-  //  CHANGE HERE BCJ 260319
-void dedispersecal_data(FILE *input, FILE *output) /*includefile*/
-  //  CHANGE HERE BCJ 260319
-{ 
-  char message[80];
-  float *buff[2], *dedisp, realtime, nextbaseline, *offset, *tmpblk;
-  int readnext=0,isamp,bnum,nsamp,i,j,s,c,b,indx,ns[2],soffset,ddidx;
-  int ic,ixnb,ixnc,*ishift,maxshift,nsblk,nsmax,cpb,d,spb,x,nsout,nxb;
-  int *ignore;
-
-  /* calculate table of shift values given the filterbank and DM */
-  ishift=dmshift(fch1,foff,nchans,nbands,userdm,refrf,tsamp,frequency_table);
-  maxshift=ishift[nchans-1];
-
-  /* set the buffer size based on the maximum shift */
-  nsblk=256*nchans; nsout=32*nchans;
-  /*nsblk=256*nchans; nsout=32768*nchans;*/
-  nsmax=maxshift*nifs*nchans;
-  if (nsmax>nsblk) nsblk=nsmax;
-  nxb=nifs*nbands;
-
-  //  CHANGE HERE BCJ 260319
-  float *calfac;
-  //  FILE *fplogbcj;
-  //  fplogbcj = fopen ("bcjlog.txt", "w");
-  //  fprintf(fplogbcj,"%d\n",calflag);
-  //  fflush(fplogbcj);
-  if (calflag) {
-  calfac =(float *) malloc(nbands*sizeof(float));
-  calptr=open_file(calfile,"r");
-  for(i=0;i<nbands;i++)
-    fscanf( calptr,"%f", &calfac[i]);
-  close(calptr);
-  //  for(i=0;i<nbands;i++)
-  //    fprintf(fplogbcj,"%f\n", calfac[i]);
-  //  fflush(fplogbcj);
-  }
-  //  CHANGE HERE BCJ 260319
-  /* define the buffers and initialize counters */
-  dedisp =(float *) malloc(nxb*nsout*sizeof(float));
-  offset =(float *) malloc(nxb*sizeof(float));
-  tmpblk =(float *) malloc(nsout*sizeof(float));
-  buff[0]=(float *) malloc(nsblk*sizeof(float));
-  buff[1]=(float *) malloc(nsblk*sizeof(float));
-  for (i=0;i<nxb;i++) offset[i]=0.0;
-  d=bnum=isamp=0;
-  ic=nchans*nifs;
-  nextbaseline=realtime=0.0;
-
-  /* zero any channels that are in the ignored list of channels */
-  if (file_exists(ignfile)) {
-    ignore=ignored_channels(ignfile,nchans);
-  } else {
-    ignore=(int *) malloc(nchans*sizeof(int));
-    for (i=0;i<nchans;i++) ignore[i]=0;
-  }
-
-  /* number of channels per band to dedisperse (cpb) must be an integer */
-  cpb=nchans/nbands; 
-  if ((cpb*nbands) != nchans) error_message("silly sub-band selection!");
-
-  /* main loop - keep going until no more data comes in */
-  while (1) {
-
-    /* read in the buffer to be processed if not done so already */
-    if (!readnext) {
-      sprintf(message,"time:%.1fs:DM:%.1fpc/cc",realtime,refdm);
-      update_log(message);
-      if ((ns[bnum]=read_block(input,nbits,buff[bnum],nsblk))<=0) {
-	if (isamp)write_dedispcal(dedisp,isamp,nifs,nbands,offset,output,calfac);
-	return;
-      }
-    }
-
-    /* number of samples in this buffer */
-    nsamp=ns[bnum]/ic;
-
-    /* flag to signify whether next buffer has been read in (1=yes;0=no) */
-    readnext=0;
-
-    /* dedispersing loop over all samples in this buffer */
-    for (s=0; s<nsamp; s++) {
-      soffset=isamp*nxb;
-      /* loop over the IFs */
-      for (i=0; i<nifs; i++) {
-	/* number of channels to skip within this IF */
-	ixnc=i*nchans; 
-	ixnb=i*nbands;
-	for (b=0; b<nbands; b++) {
-	  /* calculate index of this sample */
-	  ddidx=soffset+ixnb+b;
-	  /* clear array element for storing dedispersed subband */
-	  dedisp[ddidx]=0.0; 
-	  /* loop over the channels in this subband */
-	  for (c=b*cpb;c<(b+1)*cpb;c++) {
-	    /* proceed only if selected channel # is not in ignore list */
-	    if (!ignore[c]) 
-	    {
-	      /* calculate index of sample to be added */
-	      indx=(s+ishift[c])*ic+ixnc+c;
-	      /* required sample will be in either this buffer or the next */
-	      if (indx<ns[bnum]) {
-	        dedisp[ddidx]+=buff[bnum][indx];
-	      } else {
-	        if (!readnext) {
-		  if ((ns[!bnum]=read_block(input,nbits,buff[!bnum],nsblk))<=0) {
-		    if (isamp) {
-		      write_dedispcal(dedisp,isamp,nifs,nbands,offset,output,calfac);
-		    }
-		    return;
-		  }
-		  sprintf(message,"time:%.1fs:DM:%.1fpc/cc",realtime,refdm);
-		  update_log(message);
-		  readnext=1;
-	        }
-	        dedisp[ddidx]+=buff[!bnum][indx-ns[bnum]];
-	      }
-	    }
-	  }
-	} /* end of loop over subbands */
-      } /* end of loop over IFs */
-      /* update number of samples dedispersed and elapsed time */
-      isamp++; realtime+=tsamp;
-      if (isamp==nsout) {
-	if (baseline) {
-	  for (i=0;i<nifs;i++) {
-	    ixnb=i*nbands;
-	    for (b=0;b<nbands;b++) {
-	      for (j=0;j<nsout;j++) tmpblk[j]=dedisp[j*nxb+ixnb+b];
-	      offset[ixnb+b]=nrselect(nsout/2,nsout,tmpblk-1);
-	      //fprintf(stderr,"%d %f\n",ixnb+b,offset[ixnb+b]);
-	    }
-	  }
-	}
-	write_dedispcal(dedisp,nsout,nifs,nbands,offset,output,calfac);
-	isamp=0;
-      }
-    } /* end of loop over samples */
-    /* switch to next buffer */
-    bnum=!bnum;
-  } /* end of main loop */
-  //  close(fplogbcj);
-  free(calfac);
-}
-
-/* subtract current offset from the dedisperse time samples and write */
-  //  CHANGE HERE BCJ 260319
-void write_dedispcal(float *dedisp, int nsout, int nifs, int nbands, float *offset,FILE *output,float *calfac)/*includefile*/
-  //  CHANGE HERE BCJ 260319
-{
-  int s,i,b,ixnb,sxib,n;
-  static int first=1;
-  static int firstwr=1;
-  static int kkk=0;
-  static float *clipthreshold;
-  float *temp,outliers,sample,sumsq;
-  char *onebyte;
-  short *twobyte;
-
-  static int ncall=0;
-  //  fprintf(lg,"called %d\n", ncall);
-  //  fprintf(lg,"total %d %d\n",nsout*nifs*nbands,nbands );
-  //  fflush(lg);
-  ncall++;
-  //  CHANGE HERE BCJ 260319
-  int jband, jif,indx;
-  if (calflag) {
-    for (i=0;i<nsout;i++) 
-      {
-	for( jif = 0; jif < nifs; jif++)
-	  {
-	    for ( jband = 0; jband < nbands ; jband++)
-	      {
-		indx = i*nifs*nbands+jif*nbands+jband;
-		/*		if( firstwr ) 
-		  {
-		    if( jband < nbands ){
-		      fprintf(lg,"%d %d %f %f ", i, jband, dedisp[indx], calfac[jband]);
-		      fflush(lg);
-		    }
-		    }*/
-		if( (int)(calfac[jband]) != 0 )
-		  dedisp[indx] = dedisp[indx] / calfac[jband];
-		else
-		  dedisp[indx] = 0.0;
-		/*		if( firstwr ) 
-		  {
-		    if( jband < ( nbands -1 )) {
-		      fprintf(lg," %f\n", dedisp[indx]);
-		      fflush(lg);
-		    }
-		    else
-		      {
-			kkk++;
-			if( kkk == 100) {
-			  firstwr = 0;
-			}
-		      }
-		  }*/
-	      }
-	  }
-      }
-  }
-
-  /* multiply outgoing data by Jansky calibration factor if supplied */
-  //  if (jyfactor != 1.0) for (i=0;i<nsout*nifs*nbands;i++) dedisp[i]*=jyfactor;
-  //  CHANGE HERE BCJ 260319
-
-  if (first) {
-    /* allocate an array for holding blocks from a given subband */
-    temp=malloc(sizeof(float)*nsout);
-    /* allocate an array for saving the clipping threshold */
-    clipthreshold=malloc(sizeof(float)*nbands*nifs);
-    for (i=0;i<nifs*nbands;i++) clipthreshold[i]=0.0;
-  }
-		       
-  for (i=0;i<nifs;i++) {
-    ixnb=i*nbands;
-    for (b=0;b<nbands;b++) {
-      if (first) {
-	/* copy sub-band into temporary store for absolute value */
-	for (s=0;s<nsout;s++) {
-	  sxib=s*nifs*nbands;
-	  temp[s]=fabs(dedisp[sxib+ixnb+b]-offset[ixnb+b]);
-	}
-	/* find the value below which 90% of the samples lie */
-	outliers=nrselect(nsout/10,nsout,temp-1);
-	n=0;
-	sumsq=0.0;
-	/* calculate sum of squares based on the inner 90% of samples */
-	for (s=0;s<nsout;s++) {
-	  if (temp[s]<outliers) {
-	    sumsq+=temp[s]*temp[s];
-	    n++;
-	  }
-	}
-	/* now set the threshold based on the sum of squares */
-	if (n) 
-	  clipthreshold[ixnb+b]=clipvalue*sqrt((double)sumsq/(double)n);
-	else 
-	  clipping=0;
-      }
-      for (s=0;s<nsout;s++) {
-	sxib=s*nifs*nbands;
-	/* subtract off median value of this block */
-	sample=dedisp[sxib+ixnb+b]-offset[ixnb+b];
-	/* clip this sample if it exceeds the threshold */
-	if (fabs(sample)>clipthreshold[ixnb+b] && clipping) sample=0.0;
-	/* store the final produce and swap bytes if necessary */
-	dedisp[sxib+ixnb+b]=sample;
-	if (swapout) swap_float(&dedisp[sxib+ixnb+b]);
-      }
-    }
-  }
-
-  /* now write out samples and bat on */
-  switch (nobits) {
-  case 8:
-    onebyte = (char *) malloc(nsout*nifs*nbands);
-    for (i=0; i<nsout*nifs*nbands; i++) 
-      onebyte[i] = (char) dedisp[i];
-    fwrite(onebyte,sizeof(char),nsout*nifs*nbands,output);
-    break;
-  case 16:
-    twobyte = (short *) malloc(nsout*nifs*nbands);
-    for (i=0; i<nsout*nifs*nbands; i++) 
-      twobyte[i] = (short) dedisp[i];
-    fwrite(twobyte,sizeof(short),nsout*nifs*nbands,output);
-    break;
-  case 32:
-    fwrite(dedisp,sizeof(float),nsout*nifs*nbands,output);
-    break;
-  default:
-    error_message("requested output number of bits can only be 8, 16 or 32");
-    break;
-  }
-
-  if (first) {
-    first=0;
-    free(temp);
-  }
-}
diff --git a/filterbank-gmrt/deg2dms.c b/filterbank-gmrt/deg2dms.c
deleted file mode 100644
index 9d6b1a8..0000000
--- a/filterbank-gmrt/deg2dms.c
+++ /dev/null
@@ -1,28 +0,0 @@
-#include <math.h>
-double deg2dms(double angle) /*includefile*/
-{
-  int deg,min;
-  double sec,sign;
-
-  if (angle<0.0) 
-    sign=-1.0;
-  else
-    sign=+1.0;
-
-  angle=fabs(angle);
-  deg=(int)angle;
-  angle-=(double)deg;
-  angle*=60.0;
-  min=(int)angle;
-  angle-=(double)min;
-  angle*=60.0;
-  sec=angle;
-  return(sign*((double)deg*10000.0+(double)min*100.0+sec));
-}
-double h2hms(double hours) /*includefile*/
-{
-  double hms;
-  hms=deg2dms(hours);
-  return(hms);
-}
-
diff --git a/filterbank-gmrt/depolyco.c b/filterbank-gmrt/depolyco.c
deleted file mode 100644
index 38a1c26..0000000
--- a/filterbank-gmrt/depolyco.c
+++ /dev/null
@@ -1,290 +0,0 @@
-/* 
-   depolyco.c - barycentre or take out binary motion 
-   contained within a preprepared set of polynomial coefficients 
-   in "polyco.dat". The polyco file is made by setting the pulsar
-   period to be the data sampling time, tsamp. Code adapted from
-   seek's resample.f (dlorimer@atnf.csiro.au; Oct 15, 2003)
-
-   Revised version Nov 1, 2003 (drl@jb.man.ac.uk) runs TEMPO to
-   get the barycentric MJD which is written out into the resulting
-   resampled time series header. 
-
-   Revised version Aug 20, 2004 (drl@jb.man.ac.yk) runs TEMPO to
-   generate a polycofile for the barycentric case. Pulsarcentering
-   is done by the user generating a .par file with F0=1/tsamp!
-
-   This _could_ be extended further to run TEMPO in the pulsarcentric
-   case also. However more pressing is to really develop code so that
-   entire filterbank files can be barycentered/pulsarcentered.
-*/
-#include "dedisperse.h"
-char polyco_filename[80];
-int verbose;
-/* subroutine to call TEMPO to calculate a polyco.bar file for barycentering */
-void make_polycofile(char ra[],char dec[],char topo[], char site,
-			    double mjdtopo, double tsamp)
-{
-  FILE *resid2,*parfile, *tzfile;
-  float junk;
-  double mjdbary;
-  parfile=fopen("tssb.par","w");
-  fprintf(parfile,"PSR 0000+00\n");
-  fprintf(parfile,"RAJ %s\n",ra);
-  fprintf(parfile,"DECJ %s\n",dec);
-  fprintf(parfile,"F0 %f\n",1.0/tsamp);
-  fprintf(parfile,"DM 0.0\n");
-  fprintf(parfile,"PEPOCH %s\n",topo);
-  fclose(parfile);
-  tzfile=fopen("tz.in","w");
-  fprintf(tzfile,"%c    2  30  9 1410\n",site);
-  fprintf(tzfile,"\n \n");
-  fprintf(tzfile,"0000+00 60 9 12 1410\n");
-  fclose(tzfile);
-  tzfile=fopen("runtempo.csh","w");
-  fprintf(tzfile,"#!/bin/csh\n",site);
-  fprintf(tzfile,"tempo -z -f tssb.par << EOD\n");
-  fprintf(tzfile,"%f %f\n",mjdtopo-1.0,mjdtopo+1.0);
-  fprintf(tzfile,"EOD");
-  fclose(tzfile);
-  system("csh runtempo.csh > /dev/null");
-  system("mv polyco.dat polyco.bar");
-  system("rm -f tssb.par tz.in tz.tmp");
-  system("rm -f fort.22 tempo.lis runtempo.csh ");
-}
-
-/* subroutine to call TEMPO to calculate the barycentric MJD */
-double barycentric_time(char ra[],char dec[],char topo[], char site,
-			    double mjdtopo)
-{
-  FILE *resid2,*parfile, *timfile;
-  float junk;
-  double mjdbary;
-  parfile=fopen("tssb.par","w");
-  fprintf(parfile,"PSR 0000+00\n");
-  fprintf(parfile,"RAJ %s\n",ra);
-  fprintf(parfile,"DECJ %s\n",dec);
-  fprintf(parfile,"F0 1.0\n");
-  fprintf(parfile,"DM 0.0\n");
-  fprintf(parfile,"PEPOCH %s\n",topo);
-  fclose(parfile);
-  timfile=fopen("tssb.tim","w");
-  fprintf(timfile,"%c    0  0000+00 9999.000 %.13f     1.00\n",site,mjdtopo);
-  fprintf(timfile,"%c    0  0000+00 9999.000 %.13f     1.00\n",site,mjdtopo);
-  fprintf(timfile,"%c    0  0000+00 9999.000 %.13f     1.00\n",site,mjdtopo);
-  fclose(timfile);
-  system("tempo tssb.tim > /dev/null");
-  resid2=fopen("resid2.tmp","r");
-  fread(&junk,4,1,resid2);
-  fread(&mjdbary,8,1,resid2);
-  fclose(resid2);
-  system("rm -f tssb.tim tssb.par 0000+00.par");
-  system("rm -f matrix.tmp tempo.lis resid2.tmp ");
-  return(mjdbary);
-}
-
-
-int poly_override;
-double override_f0;
-/* the subroutine that does all the work... adapted from resample.f */
-void depolyco(int ntim, double tstart, double tsamp, int singlebyte)
-{
-  double time,taut,next;
-  static int n8k=8192;
-  float series[n8k],resamp[n8k],polyfreq,inputfreq;
-  unsigned char packed[n8k];
-  char message[80];
-  int i,j,n;
-  struct POLYCO polyco;
-  FILE *polycofile;
-  
-  polycofile=open_file(polyco_filename,"r");
-  if (verbose) fprintf(stderr,"opened %s\n",polyco_filename);
-  poly_override=1;
-  override_f0=1.0/tsamp;
-  if (!read_polycoset(polycofile,&polyco)) {
-    error_message("depolyco: error reading polyco.dat...");
-  } else {
-    get_nearest_polyco(polyco_filename,tstart,&polyco);
-    taut=polyco_period(tstart,polyco);
-    fread(series,sizeof(float),n8k,input);
-  }
-
-  polyfreq=(float) polyco.f0;
-  inputfreq=(float) 1.0/tsamp;
-  if (verbose) fprintf(stderr,"polyfreq %f Hz\n",polyfreq);
-  if (polyfreq!=inputfreq)
-  error_message("requested polyco file needs to be remade with F0=1.0/tsamp!");
-
-  /* initialize loop counters and buffers */
-  for (i=0; i<n8k; i++) resamp[i]=0.0;
-  i=j=n=1;
-  time=0.0;
-  next=taut;
-
-  while (n<ntim) {
-
-    if (next>tsamp*(double)n) {
-      resamp[j-1]+=series[i-1]*((double)n*tsamp-(next-taut))/tsamp;
-      n++;
-      i++;
-    }
-    if (n==ntim) break;
-    
-    if (next<=tsamp*(double)n) {
-      resamp[j-1]+=series[i-1]*(next-(double)(n-1)*tsamp)/tsamp;
-      j++;
-      if (j==n8k) {
-	/* it's time to write out a block of resampled data */
-	if (singlebyte) {
-	  /* single byte output assumes that the time series has zero mean! */
-	  for (j=0;j<n8k;j++) 
-	    packed[j] = 128 + (unsigned char) (resamp[j]);
-	  fwrite(packed,sizeof(char),n8k,output);
-	} else {
-	  fwrite(resamp,sizeof(float),n8k,output);
-	}
-	/* now clear the block ready for the next set of samples */
-	for (j=0;j<n8k;j++) resamp[j]=0.0;
-	j=1;
-	/* check if we're still reading the best polyco set */
-	get_nearest_polyco(polyco_filename,tstart+time/86400.0,&polyco);
-      }
-      time=next;
-      taut=polyco_period(tstart+time/86400.0,polyco);
-      next+=taut;
-    }
-
-
-    if (i==n8k) {
-      /* it's time to read in a block of raw data */
-      fread(series,sizeof(float),n8k,input);
-      i=1;
-      /* update the log every 8k samples */
-      sprintf(message,"time:%.1fs",time);
-      update_log(message);
-    }
-  }
-}
-
-char inpfile[80], outfile[80];
-main (int argc, char *argv[]) 
-{
-  int i,ntim,headersize,rah,ram,ded,dem,headerless,singlebyte,notempo;
-  double ras,des,mjdbary;
-  char ra[80], dec[80], topo[80], sra[6], sde[6], site;
-  float *series;
-  if (argc<2 || help_required(argv[1])) {
-    depolyco_help();
-    exit(0);
-  } else {
-    print_version(argv[0],argv[1]);
-  }
-
-  if (!file_exists(argv[1]))
-    error_message("time series does not exist!");
-
-  strcpy(inpfile,argv[1]);
-  strcpy(outfile,"stdout");
-  output=stdout;
-  verbose=headerless=singlebyte=0;
-  strcpy(polyco_filename,"unknown");
-  strcpy(ra,"");strcpy(dec,"");
-  i=2;
-  notempo=headerless=singlebyte=verbose=0;
-  while (i<argc) {
-    if (strings_equal(argv[i],"-notempo")) notempo=1;
-    if (strings_equal(argv[i],"-headerless")) headerless=1;
-    if (strings_equal(argv[i],"-singlebyte")) singlebyte=1;
-    if (strings_equal(argv[i],"-verbose")) verbose=1;
-    if (strings_equal(argv[i],"-raj")) strcpy(ra,argv[++i]);
-    if (strings_equal(argv[i],"-decj")) strcpy(dec,argv[++i]);
-    /* if the user supplies a polyco file -- it's pulsarcentric! */
-    if (file_exists(argv[i])) {
-      strcpy(polyco_filename,argv[i]);
-      pulsarcentric=1;
-    }
-    i++;
-  }
-
-  input=open_file(inpfile,"r");
-
-  if ((headersize=read_header(input))) {
-    if (data_type != 2) error_message("input file is not a time series!");
-    if (nbits != 32) error_message("depolyco can only read 32-bit data!");
-
-    /* parse the header parameters for RA */
-    angle_split(src_raj,&rah,&ram,&ras);
-    if (ras<10.0) {
-      sprintf(sra,"0%.1f",ras);
-    } else {
-      sprintf(sra,"%.1f",ras);
-    }
-    if (strings_equal(ra,"")) sprintf(ra,"%02d:%02d:%s",rah,ram,sra);
-
-    /* parse the header parameters for DEC */
-    angle_split(src_dej,&ded,&dem,&des);
-    if (des<10.0) {
-      sprintf(sde,"0%.1f",des);
-    } else {
-      sprintf(sde,"%.1f",des);
-    }
-    if (strings_equal(dec,"")) sprintf(dec,"%02d:%02d:%s",ded,dem,sde);
-
-    if (!notempo) {
-      /* now call TEMPO to calculate the barycentric MJD */
-      sprintf(topo,"%.12f",tstart);
-      site=tempo_site(telescope_id);
-      if (strings_equal(polyco_filename,"unknown")) {
-	make_polycofile(ra,dec,topo,site,tstart,tsamp);
-	strcpy(polyco_filename,"polyco.bar");
-	if (verbose) fprintf(stderr,"generated polyco.dat\n");
-	barycentric=1;
-      }
-      if (verbose) fprintf(stderr,"RAJ %s DECJ %s SITE %c\n",ra,dec,site);
-      if (verbose) fprintf(stderr,"Topocentric MJD %.13f\n",tstart);
-      mjdbary=barycentric_time(ra,dec,topo,site,tstart);
-      if (verbose) fprintf(stderr,"Barycentric MJD %.13f\n",mjdbary);
-    } else {
-      mjdbary=tstart; /* no barycentric time correction */
-    }
-
-    if (strings_equal(polyco_filename,"unknown")) 
-      error_message("polyco file not created...");
-
-    /* write out header with barycentric MJD if required */
-    if (!headerless) {
-      send_string("HEADER_START");
-      if (!strings_equal(source_name,"")) {
-	send_string("source_name");
-	send_string(source_name);
-      }
-      send_int("telescope_id",telescope_id); 
-      send_int("machine_id",machine_id);
-      send_coords(src_raj,src_dej,az_start,za_start);
-      send_int("data_type",2);
-      send_int("barycentric",barycentric);
-      send_int("pulsarcentric",pulsarcentric);
-      send_double("refdm",refdm);
-      if (fch1 == 0.0) 
-	send_double("fch1",frequency_table[0]);
-      else
-	send_double("fch1",fch1);
-      send_int("nchans",1);
-      if (singlebyte) 
-	send_int("nbits",8);  
-      else
-	send_int("nbits",32);  
-      send_double ("tstart",mjdbary); 
-      send_double("tsamp",tsamp);
-      send_int("nifs",nifs);
-      send_string("HEADER_END");
-    }
-
-    /* now call the routine that does the work */
-    open_log("depolyco.monitor");
-    ntim=nsamples(inpfile,headersize,nbits,nifs,nchans);
-    depolyco(ntim,tstart,tsamp,singlebyte);
-    update_log("finished");
-    close_log("depolyco.monitor");
-  }
-}
diff --git a/filterbank-gmrt/dice.c b/filterbank-gmrt/dice.c
deleted file mode 100644
index a66097b..0000000
--- a/filterbank-gmrt/dice.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-  DICE - dice up a filterbank file by removing unwanted channels
-  Initial version (Feb 2006) adapted from splice.c
-  Modified (Feb 23, 2006) to write out fch1 and foff wherever possible
-*/
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include "sigproc.h"
-#include "header.h"
-FILE *output;
-main (int argc, char **argv)
-{
-  int i=1, j, k, channum, *numbt, kchans=0, ns, nbytes, *keep, simple;
-  double *frmhz;
-  FILE *input,*keepfile;
-  float *block;
-  unsigned char *charblock;
-  unsigned short *shortblock;
-
-  output=stdout;
-  /* print help if necessary */
-  if (argc!=3 || help_required(argv[1])) {
-    /*dice_help();*/
-    puts("");
-    puts("usage: dice filterbank_file keep_file");
-    puts("");
-    puts("keep file is the list of channels to keep in the output");
-    puts("");
-    exit(0);
-  } else {
-    print_version(argv[0],argv[1]);
-  }
-
-  if (strings_equal(argv[1],"stdin")) {
-	input = stdin;
-  } else {
-        /* open up file */
-  	if (!file_exists(argv[1])) 
-    		error_message("input file does not exist...");
-  	input=open_file(argv[1],"rb");
-  }
-
-  /* read in header info */
-  if (!read_header(input)) 
-    error_message("problem reading header parameters");
-
-  if (data_type != 1) 
-    error_message("input data are not in filterbank format!");
-
-  keep=(int *) malloc(nchans*sizeof(int));
-
-  /* open up file to give channel numbers to keep */
-  if (!file_exists(argv[2])) 
-    error_message("keep file does not exist...");
-
-  keepfile=open_file(argv[2],"r");
-  frmhz = (double *) malloc(sizeof(double)*nchans);
-  keep  = (int *) malloc(sizeof(int)*nchans);
-  for (i=0;i<nchans;i++) keep[i]=0;
-  k=0;
-  while (fscanf(keepfile,"%d\n",&channum)==1) {
-    keep[channum-1]=1;
-    frmhz[k++]=fch1+(channum-1)*foff;
-    kchans++;
-  }
-
-  /* do a check to see whether fch1 and foff are sufficient to describe
-     the diced channels */
-  fch1=frmhz[0];
-  simple=1;
-  for (i=0;i<kchans;i++) if (frmhz[i] != fch1+i*foff) simple=0;
-
-  /* broadcast header for output file */
-  send_string("HEADER_START");
-  send_int("machine_id",machine_id);
-  send_int("telescope_id",telescope_id);
-  send_int("data_type",1);
-
-  if (simple) {
-    send_double("fch1",fch1);
-    send_double("foff",foff);
-    send_int("nchans",kchans);
-  } else {
-    send_string("FREQUENCY_START");
-    send_int("nchans",kchans);
-    for (i=0; i<kchans; i++) send_double("fchannel",frmhz[i]);
-    send_string("FREQUENCY_END");
-  }
-
-  if (!strings_equal(source_name,"")) {
-    send_string("source_name");
-    send_string(source_name);
-  }
-  send_coords(src_raj,src_dej,az_start,za_start);
-  send_int("nbits",nbits);
-  send_double("tstart",tstart);
-  send_double("tsamp",tsamp);
-  send_int("nifs",nifs);
-  send_string("HEADER_END");
-
-  block = (float *) malloc(nchans*sizeof(float));
-  charblock = (unsigned char *) malloc(nchans*sizeof(unsigned char));
-  shortblock = (unsigned short *) malloc(nchans*sizeof(unsigned short));
-
-  while (read_block(input,nbits,block,nchans)==nchans) {
-    k=0;
-    for (i=0; i<nchans; i++) if (keep[i]) block[k++]=block[i];
-    switch (nbits) {
-    case 8:
-      for (i=0;i<k;i++) charblock[i]=block[i];
-      fwrite(charblock,1,k,output);
-      break;
-    case 16:
-      for (i=0;i<k;i++) shortblock[i]=block[i];
-      fwrite(shortblock,2,k,output);
-      break;
-    default:
-    error_message("dice - currently only works with 8 or 16 bit data");
-    }
-  }
-
-}
diff --git a/filterbank-gmrt/differ.csh b/filterbank-gmrt/differ.csh
deleted file mode 100755
index 1b0b8e5..0000000
--- a/filterbank-gmrt/differ.csh
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/csh
-# script to output which files are different
-foreach file (`ls`)
-    if (-e $1/$file) then
-    set diff = `diff -q $file $1 | awk '{print $NF}'`
-    if ($diff == "differ") then
-	echo $file
-    endif
-    else
-    echo $file does not exist in $1
-    endif
-end
-exit
diff --git a/filterbank-gmrt/dmdelay.c b/filterbank-gmrt/dmdelay.c
deleted file mode 100644
index 2c033ac..0000000
--- a/filterbank-gmrt/dmdelay.c
+++ /dev/null
@@ -1,10 +0,0 @@
-/* 
-   return the delay in seconds between two sky frequencies f1 and f2 (MHz) 
-   N.B. constant of proportionality derived from e^2 pcm2 / (2pi c me) where 
-   the elementary charge is assumed to be in Gaussian units: 4.8032068e-20
-   and pc2m = 3.0856776e16 is the conversion between metres and parsecs 
-*/
-double dmdelay(double f1, double f2, double dm) /* includefile */
-{
-  return(4148.741601*((1.0/f1/f1)-(1.0/f2/f2))*dm);
-}
diff --git a/filterbank-gmrt/dmshift.c b/filterbank-gmrt/dmshift.c
deleted file mode 100644
index 8f3f212..0000000
--- a/filterbank-gmrt/dmshift.c
+++ /dev/null
@@ -1,22 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-int *dmshift(double f1, double df, int nchans, int nbands, double dm, double refrf, double tsamp, double frequency_table[]) /*includefile*/
-{
-  int i, cpb, *shift;
-  double fi;
-
-  shift = (int *) malloc(nchans * sizeof(int));
-  fi=f1;
-  cpb=nchans/nbands;
-  if (frequency_table[0] != 0.0) f1=frequency_table[0];
-
-  for (i=0; i<nchans; i++) {
-    if (refrf > 0.0) f1=refrf;
-    if (frequency_table[0] != 0.0) fi=frequency_table[i];
-    shift[i]=(int)(dmdelay(fi,f1,dm)/tsamp);
-    fi+=df; 
-    printf("%f %d\n", fi, shift[i]);
-    if (!((i+1)%cpb)) f1+=(double) cpb * df; 
-  }
-  return shift;
-}
diff --git a/filterbank-gmrt/documentation.tex b/filterbank-gmrt/documentation.tex
deleted file mode 100644
index f8ee646..0000000
--- a/filterbank-gmrt/documentation.tex
+++ /dev/null
@@ -1,1454 +0,0 @@
-\documentclass[11pt]{article}
-\usepackage{makeidx}
-\makeindex
-\def\lapp{\ifmmode\stackrel{<}{_{\sim}}\else$\stackrel{<}{_{\sim}}$\fi}
-\def\gapp{\ifmmode\stackrel{>}{_{\sim}}\else$\stackrel{>}{_{\sim}}$\fi}
-\textheight 670pt 
-\textwidth 500pt  
-\evensidemargin 5mm            
-\oddsidemargin -5mm  
-\topmargin -15mm     
-\headheight 12pt 
-\headsep 15pt
-\parindent 0pt
-\parskip 8pt plus 2pt minus 1pt
-
-\begin{document}
-\begin{center}
-{\LARGE {\sc SIGPROC--vX.X} : {\bf (Pulsar) Signal Processing Programs}}\\
-\bigskip
-\bigskip
-{\large Dunc Lorimer --- Jodrell Bank Observatory --- {\tt drl@jb.man.ac.uk} --- RELEASE}
-\end{center}
-\noindent {\bf Summary:} The SIGPROC package is a collection of
-programs written to convert and process fast-sampled pulsar data into
-a compact and easy-to-use format suitable for off-line analyses for
-searching, timing and polarimetry applications. This document
-describes how to install and run the various programs. Several example
-applications are presented using real and simulated data sets.
-\tableofcontents
-
-\clearpage
-\section{About SIGPROC}
-
-\index{Backends!AOFTM}
-\index{Backends!WAPP}
-\index{Backends!PSPM}
-\index{Backends!BPP}
-\index{Backends!Parkes/Jodrell filterbanks}
-\index{Backends!OOTY}
-SIGPROC is a package designed to standardize the initial analysis of
-the many types of fast-sampled pulsar data. Currently recognized
-machines are the Wide Band Arecibo Pulsar Processor (WAPP), the Penn
-State Pulsar Machine (PSPM), the Arecibo Observatory Fourier Transform
-Machine (AOFTM), the Berkeley Pulsar Processors (BPP), the Parkes/Jodrell
-1-bit filterbanks (SCAMP) and the
-filterbank at the Ooty radio telescope (OOTY). The package
-should help users look at their data quickly, without the need to
-write (yet) another routine to read data or worry about big/little
-\index{byte swapping} \index{big endian} \index{little endian}
-endian compatibility (byte swapping is handled automatically).  The
-current suite of programs is:
-
-\index{Programs!{\tt filterbank}}
-\bigskip
-\noindent {\tt filterbank} - convert raw pulsar-machine data to 
-filterbank format: a stream of n-bit numbers corresponding to multiple
-polarization and/or frequency channels. 
-
-\index{Programs!{\tt splice}}
-\smallskip
-\noindent {\tt splice} - join together multiple filterbank
-files which have the same time stamp.
-
-\index{Programs!{\tt fake}}
-\smallskip
-\noindent {\tt fake} - produce fake filterbank format data
-containing periodic signals immersed in Gaussian noise for
-testing and calibration of downstream programs.
-
-\index{Programs!{\tt decimate}}
-\smallskip
-\noindent {\tt decimate} - add together frequency channels
-and/or time samples of incoming filterbank data to reduce
-the time and/or frequency resolution (useful for quick-look
-purposes).
-
-\index{Programs!{\tt dedisperse}}
-\smallskip
-\noindent {\tt dedisperse} - correct incoming filterbank data
-for interstellar dispersion, writing the output time series as
-one or more dedispersed sub-bands.
-
-\index{Programs!{\tt fold}}
-\smallskip
-\noindent {\tt fold} - fold incoming filterbank or time series
-data modulo a pulse period. Pulses are output in ASCII
-EPN (\S \ref{epn}) or PSRFITS format. An Expect script to 
-generate polynomial coefficients is also available.
-
-\index{Programs!{\tt profile}}
-\smallskip
-\noindent {\tt profile} - displays profiles from {\tt fold} in
-ASCII or pseudo grey-scale plots to the standard output.
-
-\index{Programs!{\tt pgplotter}}
-\smallskip
-\noindent {\tt pgplotter} - displays profiles from {\tt fold} 
-and other SIGPROC output to a PGPLOT window.
-
-\index{Programs!{\tt bandpass}}
-\smallskip
-\noindent {\tt bandpass} - write out the mean bandpass to an ASCII file.
-
-\index{Programs!{\tt header}}
-\smallskip
-\noindent {\tt header} - read raw data files,
-filterbank or time series data and display header info as plain ASCII.
-
-\index{Programs!{\tt header}}
-\smallskip
-\noindent {\tt reader} - read the filterbank or time series
-data and display in human-readable form.
-
-\index{Programs!{\tt quicklook}}
-\smallskip
-\noindent {\tt quicklook} - csh script to perform a quick
-analysis of total-power filterbank data on a known pulsar.
-
-\index{Programs!{\tt monitor}}
-\smallskip
-\noindent {\tt monitor} - wish script to
-monitor programs running in a given
-directory using a Tk pop-up widget.
-
-\bigskip
-\noindent
-All of the programs within SIGPROC are written in C and can be run
-from the UNIX command-line. Use is made of standard input and output
-streams so that piping between programs is possible to ``glue''
-together various tasks. As an example, the following pipeline:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19 -s 4 | fold -p polyco.dat > B0823+26.prf
-\end{verbatim}
-will read in and dedisperse raw PSPM data into four subbands which are
-then folded modulo the pulse period based on a set of polynomial
-coefficients generated by TEMPO stored in the file {\tt polyco.dat}.
-The folded profiles for each band are written in ASCII format
-to the file {\tt B0823+26.prf}.  
-\index{polyco.dat}
-
-A detailed description of these programs and scripts is given in the
-remainder of this document which is structured as follows: in \S
-\ref{install} we describe how to install SIGPROC; \S \ref{dataformat}
-describes the filterbank data and header format used by all the
-programs; producing real and fake filterbank data is described in \S
-\ref{filterbank} and \S \ref{fake} respectively; programs to look at
-the headers and raw data are discussed in \S \ref{headers} and \S
-\ref{looking}; data reduction tasks (decimation and dedispersion) are
-described in \S \ref{reduction}; folding filterbank data to produce
-pulse profiles is described in \ref{folding}; a script do quick data
-analyses is presented in \S \ref{quicklook} respectively; version
-history and plans for future work (\S \ref{past/future}). 
-Supplementary appendices deal with
-monitoring the programs (\S \ref{monitoring}), 
-generating {\tt polyco.dat} files using {\sc TEMPO}
-(\S \ref{polyco}) and the EPN data format (\S \ref{epn}).
-
-\section{Installation procedure}
-\label{install}
-\index{installation}
-SIGPROC has so far been successfully installed for use on Solaris,
-Linux, HP-UX and Macs.
-ANSII C was (hopefully!)  adhered to fairly closely
-during writing of the programs so that installation on other operating
-systems should also be possible.  Installation proceeds as follows:
-
-\noindent {\bf 0:}
-Download the package from 
-\verb+http://www.jb.man.ac.uk/~drl/sigproc/sigproc.tar.gz+
-
-\noindent {\bf 1:}
-Unpack the gzip-compressed tar file and extract its contents:
-
-\noindent 
-{\tt gunzip -c sigproc-X.X.tar.gz | tar xvf -}
-
-\noindent {\bf 2:}
-The contents of the tar file will be distributed in the directory
-{\tt sigproc-X.X/}. Go into this directory and run the configuration
-script by typing: 
-
-\noindent
-{\tt cd sigproc-X.X}\\
-{\tt ./configure}
-
-\noindent
-When prompted, supply the name
-of a directory in which you would like the SIGPROC executables to
-be placed.
-If compiling on more than one system, log into the the other system
-and run the same script on this computer.
-Note that only one copy of the source code is required
-if you are compiling under multiple platforms.
-
-\noindent {\bf 3:}
-For each operating system you are using, type:
-
-\noindent
-{\tt make}
-
-\noindent in the
-{\tt sigproc-X.X} directory
-and let the compiler go to work. 
-
-Four other software packages are desirable, but not absolutely
-necessary.  To output profiles in PSRFITS format, you will need
-CFITSIO ({\tt 
-heasarc.gsfc.nasa.gov/docs/software/fitsio/fitsio.html})
-and uncomment and edit the appropriate path to the LFITS variable in your
-{\tt makfile.osname} file. To take advantage of the FFTW subroutines,
-you will need to install version 3 of this package (available from
-{\tt fftw.org}) and then uncomment and edit the LFFTW variable in
-{\tt makfile.osname}.
-To create files containing polynomial coefficients for
-high-precision folding, install the {\sc TEMPO} software package which
-\index{Software Packages!{\sc TEMPO}}
-is freely available from the Princeton pulsar website ({\tt
-pulsar.princeton.edu}).  To monitor the programs using a Tk
-pop-up widget make sure that the {\tt wish} shell is in your path (we
-recommend use of Tcl/Tk version 8.0 or higher). This is freely
-available from {\tt scriptics.com}. For making diagnostic
-\index{Software Packages!Tcl/Tk}
-plots you will need to compile the {\tt quickplot} Fortran program which
-requires the {\sc PGPLOT} graphics package available from 
-\verb+astro.caltech.edu/~tjp/pgplot+. Edit the {\tt
-makefile} to give the appropriate path to {\sc PGPLOT} on your system
-\index{Software Packages!{\sc PGPLOT}}
-before typing {\tt make quickplot}.
-
-\clearpage
-\section{Header information and data format}
-\label{dataformat}
-\index{Data formats!SIGPROC}
-Before describing the programs in detail, some description of the
-header and data formats used within SIGPROC is appropriate for those
-wishing to read the data into other programs.  The {\tt filterbank}
-program (see \S \ref{filterbank}) reads in the raw data files produced
-by the machine, dealing with the header information contained in the
-files and the (usually non-trivial) channel ordering of the
-samples. {\tt filterbank} outputs the data in the following way:
-\begin{verbatim}
-HEADER_START stream_of_header_parameters HEADER_END stream_of_data_values
-\end{verbatim}
-The \verb+HEADER_START+ and \verb+HEADER_END+ character strings
-signal the start and
-finish of a stream of header parameters that describe the data.  The
-default is to include these at the beginning of the data file.  We
-recognize that some users will prefer not to have to deal with the
-header in this way. For these users, {\tt filterbank} has a {\tt
--headerfile} command-line option to pipe the header into a seperate
-ASCII file (this is described along with the other command-line
-options later on).
-
-The header variables have been restricted to key parameters for ease of use.
-Currently these are:
-\begin{itemize}
-\item {\bf telescope\_id} (\verb+int+): 
-\index{Header parameters!{\bf telescope\_id}}
-0=fake data; 1=Arecibo; 2=Ooty... others to be added
-\item {\bf machine\_id} (\verb+int+): 
-\index{Header parameters!{\bf machine\_id}}
-0=FAKE; 1=PSPM; 2=WAPP; 3=OOTY... others to be added
-\item {\bf data\_type} (\verb+int+): 
-\index{Header parameters!{\bf data\_type}}
-1=filterbank; 2=time series... others to be added
-\item {\bf rawdatafile} (\verb+char []+): 
-\index{Header parameters!{\bf rawdatafile}}
-the name of the original data file
-\item {\bf source\_name} (\verb+char []+): 
-\index{Header parameters!{\bf source\_name}}
-the name of the source being observed by the telescope
-\item {\bf barycentric} (\verb+int+):
-equals 1 if data are barycentric or 0 otherwise
-\item {\bf pulsarcentric} (\verb+int+):
-equals 1 if data are pulsarcentric or 0 otherwise
-\item {\bf az\_start} (\verb+double+): 
-\index{Header parameters!{\bf az\_start}}
-telescope azimuth at start of scan (degrees)
-\item {\bf za\_start} (\verb+double+): 
-\index{Header parameters!{\bf za\_start}}
-telescope zenith angle at start of scan (degrees)
-\item {\bf src\_raj} (\verb+double+): 
-\index{Header parameters!{\bf src\_raj}}
-right ascension (J2000) of source (hhmmss.s)
-\item {\bf src\_dej} (\verb+double+): 
-\index{Header parameters!{\bf src\_dej}}
-declination (J2000) of source (ddmmss.s)
-\item {\bf tstart} (\verb+double+): 
-\index{Header parameters!{\bf tstart}}
-time stamp (MJD) of first sample
-\item {\bf tsamp}  (\verb+double+): 
-\index{Header parameters!{\bf tsamp}}
-time interval between samples (s)
-\item {\bf nbits} (\verb+int+): 
-\index{Header parameters!{\bf nbits}}
-number of bits per time sample
-\item {\bf nsamples} (\verb+int+): 
-\index{Header parameters!{\bf nsamples}}
-number of time samples in the data file (rarely used any more)
-\item {\bf fch1}  (\verb+double+): 
-\index{Header parameters!{\bf fch1}}
-centre frequency (MHz) of first filterbank channel
-\item {\bf foff}  (\verb+double+): 
-\index{Header parameters!{\bf foff}}
-filterbank channel bandwidth (MHz)
-\item {\bf FREQUENCY\_START}  (\verb+character+): 
-\index{Header parameters!{\bf FREQUENCY\_START}}
-start of frequency table (see below for explanation)
-\item {\bf fchannel}  (\verb+double+): 
-\index{Header parameters!{\bf fchannel}}
-frequency channel value (MHz)
-\item {\bf FREQUENCY\_END}  (\verb+character+): 
-\index{Header parameters!{\bf FREQUENCY\_END}}
-end of frequency table (see below for explanation)
-\item {\bf nchans} (\verb+int+): 
-\index{Header parameters!{\bf nchans}}
-number of filterbank channels
-\item {\bf nifs} (\verb+int+): 
-\index{Header parameters!{\bf nifs}}
-number of seperate IF channels
-\item {\bf refdm}  (\verb+double+): 
-\index{Header parameters!{\bf refdm}}
-reference dispersion measure (cm$^{-3}$ pc)
-\item {\bf period}  (\verb+double+): 
-\index{Header parameters!{\bf period}}
-folding period (s)
-\end{itemize}
-A given header stream will contain most, but not necessarily all, of the 
-above variables. 
-
-In the general case, the data consists of {\bf nifs} polarization
-channels of {\bf nchans} frequency channels of {\bf nbit} numbers. The
-data stream following the header can then be thought of as 1-D array
-of $N$ elements with indices running between 0 and $N-1$, where
-\begin{displaymath}
-	N = {\rm \bf nifs} \times {\rm \bf nchans} \times {\rm \bf nsamples},
-\end{displaymath}
-and {\bf nsamples} is the observation time divided by {\bf tsamp}.
-Thus, for a given IF channel $i = (0,1,2,3)$ and frequency channel $c
-= (0 \dots {\rm \bf nchans}-1)$, the array index for sample $s =
-(0,1,2 \dots)$ is
-\begin{displaymath}
-s \times {\rm \bf nifs} \times {\rm \bf nchans}+ i \times {\rm \bf nchans} + c.
-\end{displaymath}
-The sky frequency of channel $c$ is then simply
-\begin{displaymath}
-		{\rm \bf fch1} + c \times {\rm \bf foff}.
-\end{displaymath}
-We follow the Parkes/Jodrell Bank
-convention of assigning a negative frequency to {\bf
-foff} in the headers to signify that the highest frequency channel is
-{\bf fch1}.  Currently, all filterbank data is written out in this order
-and the {\tt dedisperse} program relies on this fact in its dedispersing
-algorithm (see \S \ref{reduction}).
-
-Although this system works well for most applications, from version 2.3
-there is a more flexible way of describing the frequency channels.
-Instead of writing {\bf fch1} and {\bf foff}, it is now possible to 
-write the individual frequency channel frequencies directly into the header
-in the following way:
-\begin{verbatim}
-FREQUENCY_START f1 f2 f3 f4 FREQUENCY_END
-\end{verbatim}
-where \verb+f1+, \verb+f2+.... are the frequency channel
-values in MHz. These may be in any order, {\em provided that}
-the \verb+f1+ is the highest frequency (again this is 
-stipulated because of {\tt dedisperse}'s algorithm).
-This frequency table approach is used by the {\tt splice} program
-to deal with non-contiguous data described next.
-
-\clearpage
-\section{Data conversion using {\tt filterbank} and {\tt splice}}
-\label{filterbank}
-\index{Programs!{\tt filterbank}}
-
-The interface between the raw data and the rest of the SIGPROC package
-is the {\tt filterbank} program. As with all the programs on-line help
-is obtained by typing the name of the program followed by {\tt help}:
-\input{filterbank.help}
-Given just the name of the raw data file as the argument, {\tt
-filterbank} will determine the origin of the data and, if it can read
-the file, unpack the samples before writing the header parameters
-and data as described in \S \ref{dataformat}. The header and data go
-to the standard output by default but can be redirected to a file
-using the {\tt -o filename} option, or in the standard way:
-\begin{verbatim}
-% filterbank rawdatafile > filterbankfile
-\end{verbatim}
-With no further options, {\tt filterbank} will read and unscramble all
-the data in the original file. A specific portion of the data can be
-specified using the {\tt -r} and {\tt -s} command-line options. For example:
-\begin{verbatim}
-% filterbank rawdatafile -r 10.0 > filterbankfile
-\end{verbatim}
-reads just the first 10 seconds of data. These options are useful for
-a quick look at the data.
-
-\subsection*{Selecting and/or summing IF streams}
-\index{summing IFs}
-\index{selecting IF streams}
-By default, all the IF streams (if there are more than one) in the
-file are read and processed. To select one or more of these, ignoring
-the others, use the {\tt -i} option:
-\begin{verbatim}
-% filterbank rawdatafile -i 1 -i 2 > filterbankfile
-\end{verbatim}
-will process just the first two IF channels of the raw data file.
-{\tt filterbank} provides the option to sum {\sl just the first two} IF
-channels (to form total-power data) via the {\tt -sumifs} option:
-\begin{verbatim}
-% filterbank rawdatafile -sumifs > filterbankfile
-\end{verbatim}
-This is a useful, for example, to get just total power from
-polarimetry data for off-line searching.
-
-\subsection*{ASCII headers}
-\index{ASCII headers}
-As mentioned in \S \ref{dataformat}, {\tt filterbank} will broadcast a
-header stream before writing the data. This header is used by other
-downstream SIGPROC programs to process the data. To make use of it in
-analysis with other programs, call the function \verb+read_header+ and
-link with the other routines contained in the file
-\verb+read_header.c+.  For those who prefer not to be bothered with
-these routines, use the {\tt -headerfile} option when calling
-filterbank. For example:
-\begin{verbatim}
-% filterbank B0823+26.pspm -headerfile > B0823+26.fil
-\end{verbatim}
-will create the file {\tt B0823+26.fil} containing just the filterbank
-channels along with the relevant header parameters in an ASCII file
-{\tt head}. In this case:
-\begin{verbatim}
-Original PSPM file: B0823+26.pspm
-Sample time (us): 80.000002
-Time stamp (MJD): 51740.882986111108
-Number of samples/record: 512
-Center freq (MHz): 430.000000
-Channel band (kHz): 62.000000
-Number of channels/record: 128
-\end{verbatim}
-the user is then left to parse this file as he/she feels fit.
-An alternative means of getting header information would be
-to use the {\tt header} program in the following example:
-\begin{verbatim}
-% filterbank B0823+26.pspm | header -tstart
-\end{verbatim}
-which will return {\tt 51740.882986111108} to the standard output.
-Any of the header variable names listed in \S \ref{dataformat}
-can be given as a command-line option to the {\tt header} program.
-Further details are given in \S \ref{looking}.
-
-\subsection*{Changing the number of bits per sample}
-By default, {\tt filterbank} will write the outgoing data with the same
-number of bits per sample as the native format (e.g.~4 bits per sample
-for PSPM). For machines which write out larger numbers of bits
-(e.g.~the WAPP) it is useful to be able to pack the data more
-efficiently using the {\tt -n} option.  For example, the sequence:
-\begin{verbatim}
-% filterbank wappdatafile -n 8 > filterbankfile
-\end{verbatim}
-will process a WAPP data file (usually 16 bits per sample) and
-pack the outgoing samples as single-byte integers. For search
-purposes, where only marginal loss in sensitivity is seen and data products
-are reduced significantly, use of this option is highly recommended.
-For WAPP data, the loss in sensitivity from 16 to 8 bits is negligible,
-packing down to 4 bits results in losses $\sim$5\%.
-
-\subsection*{Floating-point output}
-\index{floating-point output}
-Currently, no descaling parameters are given in the header when
-packing down data. This means that for applications where the
-absolute value of the data is necessary (e.g.~polarization work)
-it is necessary to store the data as floating-point numbers.
-The option {\tt -floats} is provided for this purpose (although this
-is really just an alias for {\tt -n 32}).
-
-\subsection*{Byte swapping issues}
-\index{byte swapping}
-Multi-byte precision data are written in different orders depending on
-your machine's operating system. The original WAPP data, for example,
-was written on a PC (little endian format).  The {\tt filterbank}
-program knows about this and {\sl automatically} does any byte
-swapping required while reading. When it comes to writing the data
-out, however, the program will always write data in the native order
-of the processing machine.  To swap the bytes around before writing
-for use on other machines, use the {\tt -swapout} option.
-
-\subsection*{Correlator-specific options}
-Presently, the WAPP is the only correlator machine recognized by SIGPROC
-which records auto- and, in polarization mode, cross-correlation functions for 
-given numbers of lags. The autocorrelation function $R(\tau)$, as a 
-function of lag $\tau$ is defined by:
-\begin{displaymath}
-R(\tau) = \lim_{T\rightarrow\infty} \frac{1}{T} \int_0^T V(t) V^*(t+\tau) dt,
-\end{displaymath}
-where $V(t)$ is the complex signal voltage as a function of time $t$.
-From the Weiner-Khinchin theorem, the power 
-spectral density function $P(f)$ is the Fourier transform of $R(\tau)$:
-\begin{displaymath}
-P(f)=\frac{1}{2\pi} \int_{-\infty}^{+\infty} R(\tau) e^{-2\pi i f \tau} d\tau.
-\end{displaymath}
-In practice to obtain the equivalent of frequency channels of a
-filterbank, the lags from each IF channel need to be corrected for
-finite-level quantization --- the so-called van Vleck correction (see 
-\index{van Vleck correction}
-for example Hagen \& Farley 1973, Radio Science, {\bf 8}, 775--784)
-before the Fast Fourier Transform (FFT) to obtain the spectra. For
-reference, the three-level van Vleck formula used within {\tt filterbank} to 
-correct measured auto-correlation values ($r$) to unbiased ones ($\rho$)
-can be written as
-\begin{displaymath}
-r = \frac{1}{\pi} \int_0^{\rho} \left(
-\exp \left( \frac{-(\alpha/\sigma)^2}{1+x} \right) +
-\exp \left( \frac{-(\alpha/\sigma)^2}{1-x} \right) \right)
-\frac{dx}{\sqrt(1-x^2)},
-\end{displaymath}
-where $\alpha$ is the digitizer threshold and $\sigma$ the rms
-voltage. This correction is what {\tt filterbank} does by default
-before FFTing the correlation functions to produce spectra. 
-
-A number of options exist to modify the default processing.
-To reduce FFT leakage, either a Hanning or Hamming window
-\index{Hanning smoothing}
-\index{Hamming smoothing}
-can be applied to the correlation functions via the
-{\tt -hamming} and {\tt -hanning} switches. Select {\tt -rawcfs} to
-output the raw correlation functions quantized to the precision
-specified by {\bf nbits}.  To get at the raw correlation functions,
-include the floating-point option:
-\begin{verbatim}
-% filterbank wappdatafile -rawcfs -floats > rawcffile
-\end{verbatim}
-The {\tt -corcfs} option will write out the correlation 
-functions {\sl applying} the van Vleck correction.
-
-\subsection*{Obscure correlator options} For completeness, we mention two
-other correlator specific options: {\tt -novanvleck} and {\tt
--zerolag}. The {\tt -novanvleck} option will not apply the
-quantization correction before the FFT. This feature is really for
-instructional purposes since, to FFT the data to get frequency
-channels, signal-to-noise will be lost if the van Vleck correction
-is not applied. Another option that
-is primarily used for testing is {\tt -zerolag}. If selected, this
-outputs just the first correlation function for each IF (the so-called
-zero lag) as a floating-point number. Inserting $\tau=0$ into the
-above expression for $P(f)$, we note that the zero lag is just the sum
-over all the frequency channels --- equivalent to a time series with
-no dispersion measure correction. 
-
-For WAPP data, one final option is {\tt -invert}
-\index{bandpass inversion}
-which inverts the band after the FFT to change the frequency ordering.
-This should normally be dealt with in the WAPP header but is included
-here to process data where the header information about frequency
-ordering is incorrect.
-
-\subsection*{Splicing files}
-\index{Programs!{\tt splice}}
-
-Most data acquisition systems store the collected data as single
-files per observation. For the new multiple WAPP system at Arecibo,
-where each machine runs independently to sample a different part of
-the band, a number of data files result for each frequency band.
-In order to analyse these datasets together, the {\tt splice} program
-will join multiple filterbank files, provided that they all have
-on the same time stamp. The syntax is very simple:
-\begin{verbatim}
-	splice file1.fil file2.fil file3.fil > splice.fil
-\end{verbatim}
-where it is assumed that the input files \verb+file1.fil+, \verb+file2.fil+ and
-\verb+file3.fil+ have already been converted into filterbank format
-as described above. The resulting file, \verb+splice.fil+ in this
-example, is also in filterbank format and can be read by subsequent
-programs. Although the files need not span a contiguous
-radio frequency band,
-{\tt splice} will complain if the input files do not
-all have the same time stamp, or if they are not ordered in
-descending frequency order. The latter check is done so
-that the data conform to the order expected by the 
-dedispersion algorithm (\S \ref{reduction}).
-
-\clearpage
-\section{Creating mock data sets using {\tt fake}}
-\index{Programs!{\tt fake}}
-
-The {\tt fake} program was written to create test data sets containing
-pulses hidden in Gaussian noise:
-\label{fake}
-\input{fake.help}
-Default parameters are a filterbank similar to the PSPM. As an example, 
-consider some fake PSPM data for a 42-s observation of a
-pulsar with a period of $\sim\pi$ ms, a duty cycle of 10\% and a DM of 30:
-\begin{verbatim}
-% fake -period 3.1415927 -width 10 -dm 30 -tobs 42 -nbits 4 > pspm.fil
-\end{verbatim}
-Each channel of fake data has a zero mean and unit rms.  The
-signal-to-noise ratio refers to the height of a single pulse in each
-channel. In the above example, the default signal-to-noise was
-used. Weaker pulsars can be easily made to challenge limits of
-off-line search algorithms etc. By default, the fake pulse width $w$
-is smeared by an amount dependent on the filterbank setup using the
-quadrature sum:
-\begin{displaymath}
-	\sqrt{w^2 + {\rm \bf tsamp}^2 + t_{\rm DM}^2},
-\end{displaymath}
-where $t_{\rm DM}$ is the dispersion smearing of the pulse over a
-single filterbank channel given by:
-\begin{displaymath}
- t_{\rm DM} = 8.3 \times 10^6 {\rm ms} \, \, {\rm DM} \, \Delta \nu / \nu^3,
-\end{displaymath}
-assuming the centre frequency $\nu$ is much larger than the channel bandwidth
-$\Delta \nu$ (both measured in MHz). Smearing can be disabled using the {\tt
--nosmear} option. Bit-format and byte-swapping options are identical
-to those described for the {\tt filterbank} program in the previous
-section. The starting seed of the random number generator defaults to
-a number obtained by starting with the number of seconds since midnight
-and calling the random number generator that many times. This can be 
-overridden by specifying a seed using the {\tt -seed} option. 
-
-\section{Looking at headers using {\tt header}}
-\label{headers}
-\index{Programs!{\tt header}}
-The {\tt header} program allows humans easy access to the raw data
-file, or the binary header string in the filterbank data format.  
-As an example of the full
-output, here is the header of our PSPM test data:
-\begin{verbatim}
-% header B0823+26.fil
-
-Data file                        : B0823+26.fil
-Header size (bytes)              : 191
-Data size (bytes)                : 2359296
-Data type                        : filterbank
-Telescope                        : Arecibo
-Datataking Machine               : PSPM
-Frequency of channel 1 (MHz)     : 433.968000
-Channel bandwidth      (MHz)     : -0.062000
-Number of channels               : 128
-Time stamp of first sample (MJD) : 51740.882986111108
-Gregorian date (YYYY/MM/DD)      : 2000/07/15
-Sample time (us)                 : 80.00000
-Number of samples                : 36864
-Observation length (seconds)     : 2.949120
-Number of bits per sample        : 4
-Number of IFs                    : 1
-\end{verbatim}
-alternatively, {\tt header} can be used with one or more of the
-above command-line options to return just the value of the
-parameter of interest (this is particularly useful when 
-getting values from within scripts without having to parse
-the standard output). Currently available options are:
-\begin{verbatim}
--telescope  - return telescope name
--machine    - return datataking machine name
--fch1       - return frequency of channel 1 in MHz
--foff       - return channel bandwidth in MHz
--nchans     - return number of channels
--tstart     - return time stamp of first sample (MJD)
--tsamp      - return sample time (us)
--nbits      - return number of bits per sample
--nifs       - return number of IF channels
--headersize - return header size in bytes
--datasize   - return data size in bytes if known
--nsamples   - return number of samples if known
--tobs       - return length of observation if known (s)
-\end{verbatim}
-It should be noted that {\bf headersize}, {\bf datasize}, {\bf
-nsamples} and {\bf tobs} are not header variables {\it per se};
-they are derived by the program, based upon the file size and the real
-header variables.
-
-\clearpage
-\section{Looking at data using {\tt bandpass}, {\tt reader} and {\tt pgplotter}}
-\index{Programs!{\tt bandpass}}
-\label{looking}
-The {\tt bandpass} program is a simple utility to read incoming
-data and output a time-averaged bandpass:
-\input{bandpass.help}
-In its simplest form, {\tt bandpass} averages over the entire
-data file. The data for Fig.~\ref{0823band} were obtained using:
-\begin{verbatim}
-% filterbank B0823+26.pspm | bandpass > bandpass.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2.5)
-\put(1.2,3.2){\special{psfile=0823band.ps hscale=40 vscale=40 angle=270}}
-\end{picture}
-\caption{\sl Output data from {\tt bandpass} for the test
-observation of PSR B0823+26 using the PSPM.}
-\label{0823band}
-\end{figure}
-The ASCII data is written in a simple format with one line
-for each frequency channel: \verb+frequency if1 if2...+ for
-up to {\bf nifs} seperate IFs. The {\tt -d} and {\tt -t} 
-options allow averaging and output of the bandpass for a
-given number of dumps, or seconds. Each dump is encapsulated
-within \verb+#START+ and \verb+#STOP+ separators:
-\begin{verbatim}
-#START
-freq(1)      if(1) .... if(nifs)
- ...           .    ..    ...
-freq(nchans) if(1) .... if(nifs)
-#STOP
-\end{verbatim}
-where the \verb+freq(1)+ is the sky frequency of channel 1 in MHz and
-so on for all {\bf nchans} channels. Although plotting is left up to
-the users discretion in general, SIGPROC provides a little PGPLOT
-utility {\tt pgplotter} which plots data streams passed in this
-format. For example, try
-\begin{verbatim}
-% filterbank B0823+26.pspm | bandpass | pgplotter
-\end{verbatim}
-\index{Programs!{\tt pgplotter}}
-
-Another useful program is {\tt reader} which will
-print out filterbank-format data as an ASCII stream to the 
-standard output. 
-\input{reader.help}
-In the general case, a filterbank file with 
-{\bf nchans} channels and {\bf nifs} IFs, output is of the form:
-\begin{verbatim}
-% reader filterbankfile
-
-time(1) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-time(2) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-time(3) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-\end{verbatim}
-the default case is to print out all IF and frequency channels.
-The output can be tailored by the {\tt -i} and {\tt -c} options
-to get just specific channels of interest. For example:
-\begin{verbatim}
-% filterbank B0823+26.pspm | reader -c 1 -c 2 -c 3 -c 4 | head
-
-0.000000 5.000000 5.000000 6.000000 5.000000 
-0.000080 7.000000 5.000000 7.000000 6.000000 
-0.000160 7.000000 5.000000 6.000000 6.000000 
-0.000240 5.000000 5.000000 5.000000 7.000000 
-0.000320 5.000000 4.000000 5.000000 6.000000 
-0.000400 5.000000 4.000000 5.000000 6.000000 
-0.000480 5.000000 5.000000 5.000000 6.000000 
-0.000560 5.000000 5.000000 6.000000 5.000000 
-0.000640 6.000000 4.000000 5.000000 7.000000 
-0.000720 6.000000 6.000000 6.000000 5.000000 
-\end{verbatim}
-shows just the first four frequency channels of the PSPM data
-as a function of time. The {\tt -numerate} switch will
-change this time stamp to an integer counter. Time or
-integer counters can be turned off completely via the
-{\tt -noindex} option. The {\tt -stream} option will,
-\index{Data formats!{\tt -stream}}
-as in the case of the continuous {\tt bandpass} output
-above, output a stream of numbers encapsulated by
-\verb+#START+ and \verb+#STOP+ separators. As before, this
-format may be passed to {\tt pgplotter} for plotting.
-\index{Programs!{\tt reader}}
-
-\section{Data reduction using {\tt decimate} and {\tt dedisperse}}
-\label{reduction}
-\index{Programs!{\tt decimate}}
-
-Adding of adjacent time and/or frequency channels 
-together to reduce the original resolution and size of the original
-data file is possible using the {\tt decimate} program:
-\input{decimate.help}
-Output data from {\tt decimate} is in standard filterbank format
-so that it can be easily read in by other SIGPROC programs.
-To get ASCII data, use the {\tt reader} program (see \S \ref{looking}).
-The following example adds all the frequency channels together,
-and every 32 time samples, to create the time series shown in
-Fig.~\ref{0823time}.
-\begin{verbatim}
-% filterbank B0823+26.pspm | decimate -t 32 -n 32 | reader > timeseries.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2.5)
-\put(1.2,3.2){\special{psfile=0823time.ps hscale=40 vscale=40 angle=270}}
-\end{picture}
-\caption{\sl Output time series from {\tt decimate} for the test
-observation of PSR B0823+26 using the PSPM.}
-\label{0823time}
-\end{figure}
-Note that we have used the {\tt -n} option to force the output
-number of bits per sample to be 32. By default {\tt decimate}
-outputs data with the same number of bits as the incoming filterbank
-data. In this case, where there are strong single pulses,
-adding all the channels together would result in a signal-to-noise
-loss when trying to write the output time series with 4-bit precision.
-
-While {\tt decimate} is a good means for getting time series of weakly
-dispersed pulsars, it does not take into account the effects of
-dispersion by the interstellar medium where pulses emitted at higher
-radio frequencies travel faster through the interstellar medium,
-arriving earlier than those emitted at lower frequencies.  The time
-delay $\Delta t$ between a high frequency $\nu_{\rm hi}$ relative to a
-lower on $\nu_{\rm lo}$ is \index{dedispersion}
-\begin{displaymath}
- \Delta t = 4.15 \times 10^6 \, \, {\rm ms} \, \,
- \times (\nu_{\rm lo}^{-2} - \nu_{\rm hi}^{-2})  
- \times {\rm DM},
-\end{displaymath}
-where the frequencies are in MHz and the dispersion measure 
-${\rm DM} = \int_{\rm 0}^{d} \,\, n_{\rm e} \,\, dl$
-(cm$^{-3}$ pc) is the integrated
-column density of free electrons along the line of sight.
-Here, $d$ is the distance to the pulsar (pc) and $n_{\rm e}$ is the
-free electron density (cm$^{-3}$). For distant high-DM pulsars,
-especially those with short periods, dispersion needs
-to be accounted for to retain full time resolution.  The {\tt
-dedisperse} program does this by adding frequency channels with the
-appropriate time delays given a DM value:
-\input{dedisperse.help}
-The dedispersion algorithm reads in a block of data and
-gets the appropriately delayed sample by looking forward in
-the array. This there requires that the frequency channels
-are passed down in descending frequency order and {\tt dedisperse}
-will complain if this condition is not met!
-\index{Programs!{\tt dedisperse}}
-
-In the example data for the 1.5578-ms pulsar B1937+21 shown in 
-Fig.~\ref{1937giant}, the left panel was produced via:
-\begin{verbatim}
-% filterbank B1937+21.539 | dedisperse -d 71.04 | reader > timeseries.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2)
-\put(-0.1,2.4){\special{psfile=1937whole.ps hscale=33 vscale=33 angle=270}}
-\put(+3.7,2.2){\special{psfile=1937bands.ps hscale=28 vscale=28 angle=270}}
-\end{picture}
-\caption{\sl A WAPP observation of the millisecond pulsar B1937+21
-showing a single ``giant''pulse. Left: the dedispersed time series over the
-entire 100-MHz band. Right: the pulse seen in four dedispersed 25-MHz 
-subbands. The length of the time series segment is $\sim0.26$ s. 
-The sampling time is 63.32 $\mu$s.}
-\label{1937giant}
-\end{figure}
-This single pulse is shown in four dedispersed frequency subbands in
-the right-hand panel of Fig.~\ref{1937giant}. These were obtained
-by adding a {\tt -b 4} option into the dedisperse
-command-line in the above pipeline. In this case, dedispersion is
-carried out relative to the frequency of the first summed channel in
-each of the bands.
-
-\section{Getting pulse profiles using {\tt fold} and {\tt profile}}
-\label{folding}
-\index{Programs!{\tt fold}}
-
-Obtaining integrated pulse profiles, and single pulses, from your
-data files is possible using the {\tt fold} program which allows you
-to fold filterbank data modulo a pulse period to produce
-pulse profiles. In addition, there is now a basic ASCII viewing
-program {\tt profile} which displays profiles from {\tt fold} to the
-standard output. {\tt fold} accepts
-any number of IF and/or frequency channels, producing
-{\bf nifs} $\times$ {\bf nchans} sets of profiles. The folding
-algorithm used is a simple one: for each time sample, compute
-the phase based on a, possibly time-dependent, value of the
-pulse period and add that sample to the nearest phase bin of
-the appropriate profile. The synopsis of {\tt fold} is summarized below:
-\input{fold.help}
-
-\subsection*{Folding data at a fixed period} Consider folding a series containing
-our fake $\sim\pi$-ms pulsar:
-\begin{verbatim}
-% fake -period 3.14159 -nchans 1 -nbits 32 | fold -p 3.14159 > profile.ascii
-\end{verbatim}
-Note that the default profile output is in ASCII format. 
-\index{Data formats!{\tt -ascii}}
-This may be substituted by EPN or PSRFITS using the {\tt -epn} or
-{\tt -psrfits} options on the command line. The
-format of this output is a line for each bin:
-\begin{verbatim}
-bin_number if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-\end{verbatim}
-In order to avoid overflows during folding, {\tt fold} will by default
-subtract an offset from each folded sample calculated as the median
-value of a given data block. To turn off this feature, use the {\tt
--nobaseline} option.  The default number of bins is given by the next
-largest integer value to the ratio of the folding period divided by
-the sampling time. This is, however, completely flexible. A lower
-number of bins would be desirable, for example, when folding data for
-a faint pulsar or candidate.  {\tt fold} will permit oversampling
-\index{oversampling}
-which can pay dividends for high signal-to-noise observations of
-short-period pulsars.
-
-A useful feature of {\tt fold} for weak pulsars, and those for which the 
-pulse happens to lie on the edge of the window is the {\tt -m} option
-which allows the display of multiple pulses. For example, try:
-\begin{verbatim}
-% fake -period 3.14159 -nchans 1 -nbits 32 | fold -p 3.14159 -m 2 | pgplotter
-\end{verbatim}
-
-\subsection*{Folding data using polynomial coefficients} For practical
-applications, the apparent pulse period is time-variable during
-the integration due to Doppler shifts resulting from the Earth's
-motion and (for binary pulsars) from Doppler shifts induced by
-orbiting companions. To account for these the folding period 
-needs to be updated during the integration. The {\sc TEMPO}
-\index{Software Packages!{\sc TEMPO}}
-timing package can be used to create a set of polynomial coefficients
-to predict the change in period with time and {\tt fold} can
-read these ``polyco'' files from {\sc TEMPO} for these
-purposes. A script to run {\sc TEMPO} to produce these files
-is described in \S \ref{polyco}.
-To tell {\tt fold} to read a polyco file, supply
-the name of the filename with the {\tt -p} option.
-\begin{verbatim}
-% filterbank B0823+26.pspm | fold -p polyco.dat -n 128 -epn > B0823+26.epn
-\end{verbatim}
-will fold each channel of the sample PSPM data for PSR B0823+26 to
-produce 128-bin profiles written to the file {\tt B0823+26.epn} in
-EPN format. If no {\tt -p} option is given to {\tt fold} the program
-will look for the file {\tt polyco.dat} as a matter of course so
-that, in the above case, it was not strictly necessary to specify
-the name of the polyco file. This is assumed in the following pipeline
-where the data are first dedispersed at the reference DM value of
-19.4 cm$^{-3}$ pc before being passed to {\tt fold}:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19.4 -epn | fold > B0823+26.epn
-\end{verbatim}
-\index{polyco.dat}
-
-\subsection*{Getting sub-integrations} In the above examples,
-{\tt fold} produces one profile for each of {\bf nchans} $\times$ {\bf nifs}
-incoming data streams which corresponds to folding over the entire data 
-set. It is often desirable to look at sub-profiles dumped at regular
-intervals during the observation --- the {\tt -d} (dump) option allows you 
-to do this. Specifying a floating-point number, say $f$ seconds, in this 
-mode will output the accumulated profile every $f$ seconds.
-The following example on
-our fake millisecond pulsar data would dump a subintegration exactly
-every 15 seconds:
-\begin{verbatim}
-% fold fakepulsar.fil -d 15.0 -p 3.1415927 -epn > fakeprofiles.epn
-\end{verbatim}
-Supplying an integer argument with the {\tt -d} option, 
-say $n$, the profiles are dumped every $n$ pulses. So {\tt -d 15}
-in the above example
-results in a profile being dumped every 15 periods (about 47 ms).
-
-\subsection*{Single pulses and windowing profiles} Individual pulses
-\index{single pulses}
-can be obtained by specifying {\tt -d 1} to the {\tt fold}
-command line. The following example demonstrates this for the
-PSR B0823+26 PSPM data:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19.4 | fold -d 1 -epn > B0823+26.epn
-\end{verbatim}
-The resulting EPN file contains a record for each single pulse.
-For this short data set, this amounts to just
-five single pulses shown in Fig.~\ref{0823sps}.
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,1.5)
-\put(-0.25,2){\special{psfile=nowindow.ps hscale=67 vscale=67 angle=270}}
-\put(-0.25,1){\special{psfile=window.ps   hscale=67 vscale=67 angle=270}}
-\end{picture}
-\caption{\sl Top: dedispersed single pulses for
-the PSPM test observation of PSR B0823+26. Bottom: the same data
-set after applying a phase window of 0.825 to 0.925 (see text)}
-\label{0823sps}
-\end{figure}
-
-For single-pulse applications, where the off-pulse region of the
-\index{pulse windowing}
-profile is usually not interesting, it is desirable to be able to set
-a window around the pulse. The {\tt fold} program allows setting of
-windows via the {\tt -l} and/or {\tt -r} command-line options which
-specify the left and right-hand phase values of the windows. 
-Phase values should be specified in turns ranging between 0.0
-and 1.0. For example, the pulses in the lower panel of Fig.~\ref{0823sps}
-were obtained using {\tt fold -l 0.825 -r 0.925} for the PSR B0823+26
-dataset. As before for the full profile, unless specified otherwise,
-{\tt fold} will choose the number of bins based on the size of
-the window divided by the sampling interval. 
-
-All of the above examples have used a seperate plotting program
-to produce the profiles for the figures. Since each user tends
-to have his/her favourite method for producing such plots, no
-facility exists within SIGPROC to to this. To get a quick look
-at profiles, there is now a program {\tt profile} which will
-display ASCII representations to the standard output. The program
-has two modes of operation: 2-D profile ``plots'' or 1-D grey-scale
-representations. To get a 2-D profile - the output from fold needs
-to come in the standard ASCII format. For example, let's create
-and fold data from a 1-s pulsar:
-\begin{verbatim}
-fake -period 1000.0 -nchans 1 | fold -p 1000.0 | profile
-\end{verbatim}
-The output from {\tt profile} would then be a mock 2-D profile
-and will look something like this:
-\begin{verbatim}
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ###                              
-                              ####                              
-                              ####                              
-                              ####                              
-   #                          ####                              
-####   #  # ##  #    #   # ## ##### #  ##  # # #     #### ### ##
-################################################################
-\end{verbatim}
-
-To get a 1-D pseudo ``grey-scale'' plot, the profiles need
-to be output from fold using the {\tt stream} option. This is
-particularly useful if you wish to display profiles as sub-integrations
-or folded frequency channels. For example, to display additions of
-every 2 pulses from our 1-s fake pulsar we would do the following:
-\begin{verbatim}
-fake -period 1000.0 -nchans 1 | fold -p 1000.0 -stream -d 2 -nobaseline| profile
-\end{verbatim}
-to produce the following output showing subintegration index and
-elapsed time to the left of each profile:
-\begin{verbatim}
-|0001|00:00:00|                              ,$#,                              |
-|0002|00:00:02|                               $#,                              |
-|0003|00:00:04|                              ,#$,                              |
-|0004|00:00:07|                              ,@#:                              |
-|0005|00:00:09|                               ##,                              |
-|0006|00:00:09|                               $#,                              |
-\end{verbatim}
-Where the {\tt -nobaseline} option during folding has been used to 
-preserve the original levels which would otherwise get changed each
-subintegration. Note also that the last ``subintegration'' in this
-plot is in fact the integrated profile which is dumped by {\tt fold}
-as a matter of course. Frequency channel plots can be produced in a 
-similar way. For example, try creating a 100-ms pulsar with 32 channels
-and a DM of 500 and piping this through {\tt fold} and {\tt profile}.
-\begin{verbatim}
-fake ..... | fold -p 100.0 -stream -nobaseline | profile -frequency
-\end{verbatim}
-where the {\tt -frequency} option will be required to label
-the frequency channels correctly.
-
-\section{Putting it all together: the {\tt quicklook} data reduction script}
-\label{quicklook}
-\index{Programs!{\tt quicklook}}
-As an application of most of the programs discussed in the preceding
-sections, we conclude with the {\tt quicklook} data analysis script
-which is designed to dedisperse and fold raw pulsar machine data taken
-on a known pulsar and produce a diagnostic output plot summarizing
-various aspects of the data:
-\input{quicklook.help}
-%Most of the above command-line options should be obvious given
-%the above explanation and the discussions of various aspects
-%of the preceding programs. 
-%{\tt quicklook} will try to construct
-%a source name based on the name of the raw datafile and generate
-%a polyco file. If it fails to do this, use the {\tt -psr} option
-%to specify the name of the pulsar required. The {\tt -mypolyco}
-%option will use a pre-existing {\tt polyco.dat} file to calculate
-%the period and get the dispersion measure. Alternatively it is
-%possible to process the data using a fixed period and dispersion
-%measure with the {\tt -period} and {\tt -dm} options. 
-As an example, the command:
-\begin{verbatim}
-% quicklook J1713+0747.744 -nbands 64 -nsints 32 -read 5
-\end{verbatim}
-reduces the first 5 seconds of a WAPP observation of the 
-millisecond pulsar J1713+0747 producing the plot shown in Fig.~\ref{1713}.
-N.B.~Use of this script assumes that you have the {\tt quickplot}
-program compiled (see \S \ref{install} for further details).
-
-\clearpage
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,6.8)
-\put(-0.1,-0.6){\special{psfile=J1713+0747.744.ps hscale=80 vscale=80}}
-\end{picture}
-\label{1713}
-\caption{\sl Sample output from the {\tt quicklook} script for the
-millisecond pulsar J1713+0747 observed by the WAPP. Top panel shows a
-1024-point average of the dedispersed time series which has been
-normalised (as far as possible) so that it has a zero mean and unit
-rms. Below this are two panels showing the dedispersed frequency
-sub-bands (which clearly show the dispersion of the pulsar) and time
-sub-integrations as a function of pulse phase. The bottom plot
-is the integrated pulse profile. The signal-to-noise rato of this
-profile is reported at the top of the plot along with essential header
-information.}
-\end{figure}
-\clearpage
-
-\section{Version history and plans for future work}
-\label{past/future}
-The file {\tt version.history} summarizes the work done
-on SIGPROC to date:
-\input{version.history}
-
-\noindent
-All suggestions for improvements, including (best of all!)
-offers to contribute write and/or improved routines for future 
-releases of the package are most welcome via email:
-{\tt drl@jb.man.ac.uk}.
-
-\section*{Acknowledgements}
-
-In putting together the SIGPROC package, I had the good fortune to
-work with a number of people who kindly donated existing routines or
-offered to write new ones.  Andy Dowd wrote the original version of
-what became the {\tt wapp2fb} routine for converting raw WAPP
-correlation values into spectra. Jeff Hagen also contributed to this
-effort and wrote the routines used for reading WAPP headers and byte
-swapping. Ingrid Stairs provided the \verb+pspm_decode+ routine --- a
-C-version of an original Fortran--77 subroutine written by Alex
-Wolsczcan. Ingrid also debugged {\tt dedisperse} so that it can handle
-WAPP timing-mode data.  Mike Keith and Ralph Eatough added the binary
-options to fake. Use was also made of some Numerical Recipes
-routines for FFTs and random number generation in {\tt fake}. Finally,
-many thanks to Jim Cordes, Maura Mclaughlin, Ramesh Bhat, Ingrid
-Stairs and Joanna Rankin
-for their help in putting together and debugging some of the
-routines, and their suggestions for functionality.
-
-\clearpage
-\appendix
-\section{Monitoring programs using the Tk {\tt monitor} widget}
-\label{monitoring}
-\index{Software Packages!Tcl/Tk}
-\index{monitoring programs}
-The SIGPROC programs run without any messages to the standard
-output. To keep track of their progress, a {\tt wish} script:
-{\tt monitor} can run in the background. 
-
-To start the {\tt monitor} script running, go to the directory
-where you are processing your files and type {\tt monitor}.
-For example, starting a filterbank command:
-\begin{verbatim}
-% filterbank J1713+0747.744 -sumifs > J1713+0747.744.fil
-\end{verbatim}
-will cause the following status bar to appear in the upper left-hand
-corner of the screen:
-
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,0.5)
-\put(0.4,-3.6){\special{psfile=monitor.ps hscale=70 vscale=70}}
-\end{picture}
-\end{figure}
-
-This counter will tick away updating as the file gets updated
-until the program is finished. If you have several jobs running,
-in a pipeline for example, several status bars will appear
-until their respective job is completed. To stop the monitor
-script at any time, type:
-\begin{verbatim}
-% monitor off
-\end{verbatim}
-Once the program
-is finished what it is doing, the monitor will go to sleep
-and wait for another SIGPROC program to start.
-
-Note that you will confuse the script if you have two
-programs running from the same directory (for example
-two {\tt filterbank} processes running on different
-raw datafiles) since the {\tt programname.monitor} file
-will get updated by both programs. For such applications,
-run the programs from separate directories.
-
-The {\tt monitor} script polls programs by looking at 
-logfiles which are written whenever the file {\tt monitor.running}
-exists in the working directory. If you prefer not to
-use {\tt monitor} but would like to look at these logfiles,
-simply create the file {\tt monitor.running} in your area
-\begin{verbatim}
-% touch monitor.running
-\end{verbatim}
-then run a SIGPROC program and {\tt tail} the resulting
-{\tt programname.monitor} file to keep track of what is
-going on. For example, while {\tt dedisperse} is running
-in a pipeline you would see the following:
-\begin{verbatim}
-% tail dedisperse.monitor
-input stdin status time:0.1s:DM:35.0pc/cc output stdout
-input stdin status time:0.2s:DM:35.0pc/cc output stdout
-\end{verbatim}
-To turn off this logging mode, simply delete the 
-{\tt monitor.running} file.
-
-\section{Running {\sc TEMPO} to generate polynomial coefficients}
-\label{polyco}
-\index{Software Packages!{\sc TEMPO}}
-\index{polyco.dat}
-If you have {\tt expect} in your path, you will also be able
-to take advantage of {\tt polyco} a simple script designed
-to take the pain out of running {\sc TEMPO} to generate 
-files containing polynomial coefficients for use by {\tt fold}.
-The synopsis of {\tt polyco} is as follows:
-\input{polyco.help}
-It is assumed that you have {\sc TEMPO} installed on your
-computer so that the {\tt tempo} executable file is in
-your path, and the {\tt TEMPO} environment variable set.
-At Arecibo, a solaris version of {\sc TEMPO} can be found
-in {\tt /home/pulsar/bin/tempo} and the {\tt TEMPO} 
-environment variable should be set to {\tt /home/pulsar/tempo11}.
-
-Running {\tt polyco} is then a matter of giving a pulsar name
-from the list of ephemeredes contained in \verb+$TEMPO/tztot.dat+
-and the start and stop MJD ranges over which you wish the 
-coefficients to apply. The default is to generate coefficients
-for use at the time you run {\sc TEMPO}.
-
-\section{The EPN data format}
-\label{epn}
-\index{Data formats!EPN}
-The {\bf E}uropean {\bf P}ulsar {\bf N}etwork (``{\bf EPN}'') is an
-association of European astrophysical research institutes that
-co--operate in the subject of pulsar research. The EPN format
-was developed for the exchange of pulse profiles between different
-groups of individuals to permit a free interchange of data.
-The following text was taken from a paper which originally
-appeared in Astronomy \& Astrophysics Supplement Series  (1998)
-{\bf 128} 541--544 and is included here for quick reference.
-
-Each EPN file consists of one or more blocks.  The basic structure
-of an EPN block is shown in Fig.~\ref{epnblock}.  
-Each file has a common fixed
-length {\it header} followed by a number of individual {\it data
-streams} of equal length. The header describes the data, containing
-information on the pulsar itself, the observing system used to make
-the observation as well as some free-form information about the
-processing history of the data. The onus is on the site--specific
-conversion process to ensure correct conversion to the standardized
-entries and reference to common catalogues (e.g.~the Taylor et al.~1993
-catalogue of pulsar
-parameters).  The full list of header variables is given in Tables 
-\ref{epnheader} and \ref{epnsubheader}.
-
-\begin{figure}[hbt]
-\small
-\begin{center}
-\begin{minipage}{3.8cm}
-\fbox{
- \parbox{3.5cm}{\begin{center} {\bf  Header } \\  480 Characters \end{center}} 
-      }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\   \end{center} } }
- \end{minipage}
-       }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\   \end{center} } }
- \end{minipage}
-       }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\  \end{center} } }
- \end{minipage}
-       } 
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf etc. ...}  \end{center} }} 
- \end{minipage}
-} 
-\end{minipage}
-\end{center}
-\caption{\sl Schematic representation of an EPN data block.}
-\label{epnblock}
-\end{figure}
-
-The data streams themselves may be outputs of different
-polarization channels, or individual channels (bands) of a filterbank
-or a combination thereof. In total, there may be $N_{\rm freq}$ data
-streams of i.e. different frequencies for each polarization.  Each
-data stream starts with a small, fixed length sub-header in front of
-the actual data values.  The number of data streams and their length may
-vary between different EPN files, but is constant within each file.  A
-character field and an ordinal number is provided for each stream for
-its identification. 
- 
-\begin{table}
-\begin{center}
-\footnotesize
-\begin{tabular}{|rcccp{8cm}|}
-\hline
-Position & Name & Format & Unit & Comment \\
-\hline 
-\hline
-1   &  version &  A8 & &  EPN + version of format (presently EPN05.00)\\
-9   &  counter &  I4 & &  No. of records contained in this data block\\
-13  &  history & A68  &  &comments and history of the data \\
-\hline
-81    & jname &  A12 & &  pulsar jname \\
-93   & name & A12 &  & common name              \\
-105   & $P_{\rm bar}$ &  F16.12 & s & current barycentric period\\
-121    & DM      &  F8.3   & pc cm$^{-3}$& dispersion measure\\
-129   & RM      &  F10.3  & rad m$^{-2}$ & rotation measure \\
-139  & CATREF &  A6   & & pulsar parameter catalogue in use \\
-145   & BIBREF    &  A8     & & bibliographical reference key (or observer's name) \\
-153   &         & 8X   &  &  blank space free for future expansion \\
-\hline
-161   & $\alpha_{2000}$  & I2,I2,F6.3 & hhmmss& right ascension of source \\
-171   & $\delta_{2000}$ & I3,I2,F6.3 & ddmmss& declination of source\\
-182  & telname   & A8  & & name of the observing telescope (site) \\
-190  & EPOCH  & F10.3 & day & modified Julian date of observation \\
-200  & OPOS   & F8.3  & degrees & position angle of telescope \\
-208  & PAFLAG & A1    &  &  A = absolute polarization position angle, else undefined\\
-209  & TIMFLAG & A1   &  &  A = absolute time stamps (UTC), else undefined \\
-210 &         & 31X   &  &  blank space free for future expansion \\
-\hline
-241  & $x_{\rm tel}$& F17.5& m & topocentric X rectangular position of telescope \\
-258  & $y_{\rm tel}$& F17.5& m & topocentric Y rectangular position of telescope \\
-275  & $z_{\rm tel}$& F17.5& m & topocentric Z rectangular position of telescope \\
-292 &         & 29X   &  &  blank space free for future expansion \\
-\hline
-321  & CDATE & I2,I2,I4 & d m y & creation/modification date of the dataset \\
-329  & SCANNO & I4 &  & sequence number of the observation \\
-333  & SUBSCAN & I4 &  &sub--sequence number of the observation \\
-337  & $N_{\rm pol}$ & I2 &  & number of polarizations observed \\ 
-339  & $N_{\rm freq}$ & I4 & & number of frequency bands per polarisation \\
-343  & $N_{\rm bin}$ & I4  & & number of phase bins per frequency (1-9999) \\
-347  & $t_{\rm bin}$ & F12.6 & $\mu$s & duration (sampling interval) of a phase bin \\
-359  & $t_{\rm res}$ & F12.6 & $\mu$s & temporal resolution of the data \\
-371  & $N_{\rm int}$ & I6  & & number of integrated pulses per block of data \\
-377  & $n_{\rm cal}$ & I4 & $t_{\rm bin}$ & bin number for start of calibration signal\\
-381  & $l_{\rm cal}$ & I4 & $t_{\rm bin}$ & length of calibration signal \\
-385  & FLUXFLAG      & A1 &    & F = data are flux calibrated in mJy, else undefined \\
-386  & & 15X  & & blank space free for future expansion \\
-\hline
-401 &         & 80X   &  &  blank space free for future expansion \\
-\hline
-\end{tabular}
-\normalsize
-\caption{\sl A description of the EPN format variables.}
-\label{epnheader}
-\end{center}
-\end{table}
-
-\begin{table}
-\begin{center}
-\footnotesize
-\begin{tabular}{|rcccp{8cm}|}
-\hline
-Position & Name & Format & Unit & Comment \\
-\hline 
-\hline
-481  & IDfield &  A8 & &  type of data stream (I,Q,U,V etc.) \\
-489  & $n_{\rm band}$& I4 & &  ordinal number of current stream  \\
-493  & $n_{\rm avg}$ & I4 & & number of streams averaged into the current one \\
-497  & $ f_0$ & F12.8 &  & effective centre sky frequency of this stream\\
-509  & $ U_f$ & A8 &  & unit of $f_0$ \\
-517  & $ \Delta f $&  F12.6 &  & effective band width \\
-529  & $ U_{\Delta} $&  A8 &  & unit of $\Delta f$\\
-537  & $ t_{\rm start} $ & F17.5 & $\mu$s& time of first phase bin w.r.t. EPOCH \\
-554  &               & 7X    &        & blank space free for future expansion\\
-\hline
-561  & SCALE  & E12.6 &  & scale factor for the data\\
-573  & OFFSET & E12.6 &  & offset to be added to the data \\
-585  & RMS    & E12.6 &  & rms for this data stream\\
-597   & $P_{\rm app}$ &  F16.12 & s & apparent period at time of first phase bin\\
-613  &     &  28X    &       & blank space free for future expansion\\
-\hline
-641 & Data(1)& I4 & & scaled data for first bin \\
-$ 4 (N_{\rm bin}-1)+641$& Data($N_{\rm bin}$) & I4 &  & 
-data for last bin of stream\\
-\hline 
-$640 + N_{\rm records}*80$& & & & end of first stream \\
-\hline
-\end{tabular}
-\normalsize
-\caption{\sl The sub-header variables within an EPN file}
-\label{epnsubheader}
-\end{center}
-\end{table}
-
-\subsection*{Format Compatible Software}
-
-To incorporate the capability to read and write data in this format
-within existing analysis software, a simple routine exists which can
-read and write data in this format. In addition, we have written some
-sample programs which can plot the data and display the header
-parameters.  The software are written in 
-{\it Fortran---77}\footnote{some simple C utilities are planned for
-a future version of SIGPROC} and have
-been packaged into a single UNIX tar file which is freely available
-via the {\it Internet} from 
-\verb+http://www.jb.man.ac.uk/~drl/download/epn.tar.gz+
-
-To uncompress and extract the contents of the tar file on a UNIX
-operating system, issue the commands:
-
-\begin{verbatim}
-% gunzip epnsoft.tar.gz
-% tar xvf epnsoft.tar
-\end{verbatim}
-
-\noindent
-The present package contains some sample data and two example programs ---
-{\tt plotepn} and {\tt viewepn} which plot and view EPN files respectively.
-The ASCII file {\bf 00README} in this packages gives further details of the 
-software and how to use it.
-
-\section{Barycentre correction using {\tt barycentre}}
-
-A simple utility \verb+barycentre+ exists to convert a time
-series or filterbank file to an equivalent frame which is
-at rest with respect to the solar system barycentre.
-The synposis of the program is
-\input{barycentre.help}
-
-By default, {\tt barycentre} runs {\tt TEMPO} to create a file
-{\tt polyco.bar} which it then uses to perform the correction.
-If you would prefer to supply a file to do this, create one in
-advance, call it {\tt polyco.bar} and use the {\tt -mypolyco} option. 
-
-%\section{Searching for pulsars using SEEK}
-%
-%The SEEK package searches for radio pulsars in noisy data sets.  So
-%far SEEK has found over 30 pulsars in a
-%number of projects with different telescopes and data acquisition
-%systems.  Since SEEK now operates on SIGPROC formatted data, the
-%entire package will shortly be merged into a future SIGPROC
-%release. Full documentation on this package will then be available
-%within this manual. The key programs are:
-%
-%\bigskip
-%\noindent {\tt find} - a program to look for periodic signals in noisy
-%time series.
-%
-%\smallskip
-%\noindent {\tt best} - report the best candidates from \verb+find+'s 
-%analysis
-%
-%\smallskip
-%\noindent {\tt hunt/accn} - scripts to search data 
-%using \verb+find+ over a range of DMs and trial accelerations.
-
-%\bigskip
-%\noindent
-%SEEK is currently available on the web at
-%\verb+http://www.jb.man.ac.uk/~drl/seek+.
-
-\section*{}
-\printindex
-\addcontentsline{toc}{section}{Index}
-
-\end{document}
diff --git a/filterbank-gmrt/dosearch.f b/filterbank-gmrt/dosearch.f
deleted file mode 100644
index 5fb2039..0000000
--- a/filterbank-gmrt/dosearch.f
+++ /dev/null
@@ -1,375 +0,0 @@
-c=============================================================================
-      subroutine dosearch(llog,dump,rspc,pmzap,sfile,pmax)
-c=============================================================================
-c
-c     Does the search for the pulsars in the Frequency domain.
-c
-c     - form power spectrum
-c     - zaps any interfering bins in spectrum
-c     - normalises resulting spectrum to zero mean and unit rms
-c     - harmonic summing 1,2,4,8,16 and search for strongest peaks 
-c
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-      include 'csamp.inc'
-      integer llog
-      logical dump,rspc,pmzap
-      character*80 sfile
-c
-c     Local variables
-c      
-      integer h,i,j,k,npf,fold,fb,lun,nc,ncal,istat,n
-      real snrbest,rms,sumsq,snrc,thresh,fnyq,spcsnr
-      integer indx(npts/8),snum(npts/8)
-      integer top,nsm,nf1,c(5),cmin,cmax
-      parameter(top=1024,nsm=1024*8)
-      real rmea(nsm),rrms(nsm),sres,flo,fhi,fhr,smax
-      real*8 freq,pmax,fbest,ratio,pc(top)
-      logical harm1,harm3,harm5,harm6
-      real*8 pcand(5,top),ptmp
-      real scand(5,top),sc(top),spc(512)
-      integer nav,ntot,fbin,blo,bhi
-      character*80 pfile,ffile
-
-      fold=0
-
-      if (rspc) then
-         call readspec(sfile,fold,samp,refdm,refac,tsamp,npf)
-         nf1=real(tsamp)*2*npf/real(pmax)
-      else
-         nf1=real(tsamp)*ntim/real(pmax)
-         write(llog,*) 'Forming power spectrum. (Pmax=',pmax,' s!)'
-         call formspec(npf,nf1)
-         sres=real(freq(tsamp,npf,1,2))-real(freq(tsamp,npf,1,1))
-      endif
-
-      fnyq=0.5/real(tsamp)
-      write(llog,*) 'Nyquist frequency:',fnyq,' Hz'
-
-      if (dumpraw) then
-	  fold=0
-	  if (sfile.ne.' ') then
-	    pfile=sfile
-	  else
-            write(pfile,'(a,i1,a)') filename(1:lst)//'_',fold,'.spc'
-	  endif
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-	  stop
-      else if (dump) then
-          write(pfile,'(a4,i1,a4)') 'fold',0,'.spc'
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-      endif 
-c
-c     Spectral mask
-c
-      if (maskfile(1).ne.' ') then
-        if (nmasks.gt.1) then
-           write(llog,*) 'Reading spectral mask...'
-        else
-           write(llog,*) 'Reading spectral masks...'
-        endif
-        call glun(lun)
-	istat=0
-	open(unit=lun,file=maskfile(1),status='old',iostat=istat)
-        if (istat.ne.0) then
-           write(*,*) 'WARNING - mask file not found...'
-        else
-           j=0
-           do while(istat.eq.0)
-              read(lun,*,iostat=istat) i
-              if (istat.eq.0) then
-                 samp(i)=0.0
-                 j=j+1
-              endif
-           enddo
-           write(llog,*) 'Masked',j,' spectral bins from fold 1'
-         endif
-         close(unit=lun)
-      endif
-c
-c     Zap birdies before doing any spectral manipulation
-c        
-      if (zapfile.ne.' ') call zapit(llog,1,zapfile,samp,npf,tsamp)
-
-      write(llog,*) 'Whitening spectrum...'
-
-      nav=max(128,npf/nsm)
-      write(llog,*) 'Calculating spectral mean/rms every',
-     &nav,' bins...',real(freq(tsamp,npf,1,nav+1))
-     &-real(freq(tsamp,npf,1,1)),' Hz'
-c
-c     Form the running median
-c      
-      call getrmea(samp,npf,nav,rmea,ncal)
-c      call getrmed(samp,npf,nav,rmea,ncal)
-c
-c     Form the rms of the data ater subtracting the mean
-c      
-      call getrrms(samp,npf,rmea,nav,rrms)
-c
-c     Subtract running mean and scale it so that the rms=1
-c
-c      if (fbrute.gt.0.0) 
-c     &   write(llog,*) 'Brutal zapping above',fbrute,' Hz!'
-      if (fbrute.gt.0.0) 
-     &   write(llog,*) 'Brutal zapping below',fbrute,' Hz!'
-      n=0
-      sumsq=0.0
-      do i=1,npf
-         h=min(ncal,i/nav+1)
-         if (samp(i).ne.0.0) samp(i)=(samp(i)-rmea(h))/rrms(h)
-         if (mod(i,1024).eq.0.and.samp(i).lt.3.0) then
-            n=n+1
-            sumsq=sumsq+samp(i)*samp(i)
-         endif
-c
-c this line is the -b option which brutally zaps all RFI and psrs < fbrute Hz
-c changed for 47tuc analysis Mar 17, 2003
-	 if (fbrute.gt.0.0.and.freq(tsamp,npf,1,i).lt.fbrute.and.
-     &      samp(i).gt.10.0) samp(i)=1.0
-      enddo
-
-      rms=sqrt(sumsq/real(n))
-      write(llog,*) 'Resulting spectral RMS:',rms
-c
-c     for Parkes Multibeam Data - call zapping algorithm if -pmzap selected
-c
-      if (pmzap) call zap_birdies(samp,npf,nf1,tsamp*1000.0,rms,0.0,1)
-c
-c     original spectrum + 4 harmonic sums (Lyne/Ashworth code)
-c      
-      write(llog,*) 'Doing harmonic summing...'
-      call sumhrm(samp,npf,nf1)
-c      
-c     mask out folds 2-5 in addition to fold 1 (done above) if 
-c     mask files are present (drl - 28/04/05)
-c
-      if (nmasks.eq.5) then
-         do fold=2,5
-           j=0
-           call glun(lun)
-           istat=0
-           open(unit=lun,file=maskfile(fold),status='old',iostat=istat)
-           do while(istat.eq.0)
-              read(lun,*,iostat=istat) i
-              if (istat.eq.0) then
-                 power(fold,i)=0.0
-                 j=j+1
-              endif
-           enddo
-           write(llog,*) 'Masked',j,' spectral bins from fold',fold
-           close(lun)
-         enddo
-      endif
-
-      fb=0
-      fbest=0.0
-      snrbest=0.0
-      ntot=0
-c
-c     Search for candidates over all harmonic folds
-c
-      write(llog,*) 'Doing harmonic searching...'
-      do fold=1,5
-        c(fold)=0
-        thresh=5.0
- 5      do i=1,npf
-          ptmp=1.0/freq(tsamp,npf,fold,i)
-          if (ptmp.gt.pmax) power(fold,i)=0.0 ! Zap P>Pmax signals
-          snrc=power(fold,i)/rms
-          if (snrc.gt.thresh.and.c(fold).lt.top) then
-             c(fold)=c(fold)+1
-             samp(c(fold))=power(fold,i)
-             snum(c(fold))=i
-c          else if (snrc.gt.thresh) then
-c             write(*,*) 'WARNING: not enough candidates saved!!'
-          endif
-        enddo
-        if (c(fold).lt.2) then
-           thresh=thresh-1.0
-           goto 5
-        endif
-c
-c       Sort power spectrum in amplitude (propto signal-to-noise) order...
-c
-        call indexxf77(c(fold),samp,indx)
-c
-c     
-        j=0
-        do i=c(fold),1,-1
-          j=j+1
-          pcand(fold,j)=1000.0/freq(tsamp,npf,fold,snum(indx(i)))
-          snrc=samp(indx(i))/rms
-          scand(fold,j)=snrc
-          if (snrc.gt.snrbest) then
-            snrbest=snrc
-            fbest=1000.0/pcand(fold,j)
-            fb=fold
-          endif
-        enddo
-
-        do i=1,c(fold)
-           do j=1,c(fold)
-              if (j.ne.i.and.scand(fold,j).gt.0.0.and.
-     &           scand(fold,i).gt.0.0) then
-                 ratio=pcand(fold,i)/pcand(fold,j)
-                 if (ratio.lt.1.0) ratio=1.0/ratio
-                 ratio=ratio-int(ratio)
-                 harm1=ratio.gt.0.999.or.ratio.lt.0.001
-                 harm3=ratio.gt.0.329.and.ratio.lt.0.331
-                 harm5=ratio.gt.0.499.and.ratio.lt.0.501
-                 harm6=ratio.gt.0.659.and.ratio.lt.0.661
-                 if(harm1.or.harm3.or.harm5.or.harm6)scand(fold,j)=0.0
-              endif
-           enddo
-        enddo
-
-        j=0
-        do i=1,c(fold)
-           if (scand(fold,i).gt.5.0) then  
-              j=j+1
-              scand(fold,j)=scand(fold,i)
-              pcand(fold,j)=pcand(fold,i)
-           endif
-        enddo
-        c(fold)=j
-
-        do i=1,c(fold)
-           ntot=ntot+1
-           if (ntot.le.top) then
-             sc(ntot)=scand(fold,i)
-             pc(ntot)=pcand(fold,i)
-           else
-c             write(*,*) 'WARNING: master candidate list full!'
-           endif
-        enddo
-        
-        if (dump) then
-          do i=1,npf
-            samp(i)=power(fold,i)
-          enddo
-          write(pfile,'(a,i1,a)') filename(1:lst)//'_',fold,'.spc'
-          write(pfile,'(a,a)') filename(1:lst),'.spc'
-          write(pfile,'(a4,i1,a4)') 'fold',fold,'.spc'
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-        endif
-
-        rms=rms*sqrt(2.0) ! Each fold increases rms by root 2...
-      enddo
-
-      cmin=top
-      do i=1,5
-         cmin=min(cmin,c(i))
-      enddo
-      
-      cmax=0
-      do i=1,5
-         cmax=max(cmax,c(i))
-      enddo
-      
-      call glun(lun)
-      pfile=filename(1:lst)//'.prd'
-      open(unit=lun,file=pfile,status='unknown',access=facc)
-      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-      do i=1,cmax
-         do j=1,5
-            if (i.gt.c(j)) then
-              pcand(j,i)=1.0
-              scand(j,i)=0.0
-            endif
-         enddo
-         write(lun,1) scand(1,i),pcand(1,i),scand(2,i),pcand(2,i),
-     &                scand(3,i),pcand(3,i),scand(4,i),pcand(4,i),
-     &                scand(5,i),pcand(5,i)
-      enddo
-      close(unit=lun)
-      ffile=filename(1:lst)//'.frq'
-      open(unit=lun,file=ffile,status='unknown',access=facc)
-      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-      do i=1,cmax
-         write(lun,1) scand(1,i),1000.0/pcand(1,i),scand(2,i),
-     &                1000.0/pcand(2,i),scand(3,i),
-     &                1000.0/pcand(3,i),scand(4,i),
-     &                1000.0/pcand(4,i),scand(5,i),
-     &                1000.0/pcand(5,i)
-      enddo
-      close(unit=lun)
-
-      call indexxf77(ntot,sc,indx)
-      do i=ntot,1,-1
-         k=indx(i)
-         do j=1,ntot
-            if (j.ne.k.and.sc(j).gt.0.0.and.
-     &           sc(k).gt.0.0) then
-               ratio=pc(k)/pc(j)
-               if (ratio.lt.1.0) ratio=1.0/ratio
-               ratio=ratio-int(ratio)
-               harm1=ratio.gt.0.999.or.ratio.lt.0.001
-               harm3=ratio.gt.0.329.and.ratio.lt.0.331
-               harm5=ratio.gt.0.499.and.ratio.lt.0.501
-               harm6=ratio.gt.0.659.and.ratio.lt.0.661
-               if(harm1.or.harm3.or.harm5.or.harm6)sc(j)=0.0
-            endif
-         enddo
-      enddo
-      
-      nc=0
-      do i=ntot,1,-1
-         if (sc(indx(i)).gt.0.0) then
-            do j=1,512
-               spc(j)=0.0
-            enddo
-            smax=0.0
-            do h=1,128
-               fhr=real(h)*1000.0/pc(indx(i))
-               flo=fhr-1000.0/pc(indx(i))*0.05
-               blo=fbin(tsamp,npf,1,flo)
-               fhi=fhr+1000.0/pc(indx(i))*0.05
-               bhi=min(blo+511,fbin(tsamp,npf,1,fhi))
-               if (bhi.lt.npf) then
-                  j=0
-                  do k=blo,bhi
-                    j=j+1
-                    spc(j)=spc(j)+power(1,k)
-                  enddo
-                  smax=max(smax,spcsnr(spc,j))
-               endif
-            enddo
-            nc=nc+1
-            pcand(1,nc)=pc(indx(i))
-            scand(1,nc)=smax
-            scand(2,nc)=sc(indx(i))
-         endif
-      enddo
-      do i=1,nc
-         sc(i)=scand(2,i) ! scand(1,i) are the "optimised" SNRs (need's work)
-      enddo
-      call indexxf77(nc,sc,indx)
-      
-c      ffile=filename(1:lst)//'.opt'
-c      open(unit=lun,file=ffile,status='unknown',access=facc)
-cc      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-c      do i=nc,1,-1
-c         j=indx(i)
-c         ratio=pcand(1,j)/pcand(1,indx(nc))
-c         if (ratio.lt.1.0) ratio=1.0/ratio
-c         if (sc(j).gt.9.9)write(lun,2) sc(j),pcand(1,j),ratio,scand(2,j)
-c      enddo
-c      close(unit=lun)
-      
- 1    format(5(f5.1,1x,f13.8,1x))
- 2    format(f5.1,1x,f9.4,3x,f7.3,1x,f5.1)
-      
-      write(llog,*) 'Best suspect:',1000.0/fbest,' ms'
-      write(llog,'(x,a,x,f5.1)') 'SNR:',snrbest
-      write(llog,*) 'Found peak at:',fbest,' Hz'
-      write(llog,*) 'Harmonic fold:',fb
-
-      ffile=filename(1:lst)//'.top'
-      open(unit=lun,file=ffile,status='unknown',access=facc)
-      write(lun,*) 1000.0/fbest,snrbest,refdm
-      close(unit=lun)
-
-      end
-      
diff --git a/filterbank-gmrt/dosearchnew.f b/filterbank-gmrt/dosearchnew.f
deleted file mode 100644
index 988f73f..0000000
--- a/filterbank-gmrt/dosearchnew.f
+++ /dev/null
@@ -1,383 +0,0 @@
-c=============================================================================
-      subroutine dosearchnew(llog,dump,rspc,pmzap,sfile,pmax)
-c=============================================================================
-c
-c     Does the search for the pulsars in the Frequency domain.
-c
-c     - form power spectrum
-c     - zaps any interfering bins in spectrum
-c     - normalises resulting spectrum to zero mean and unit rms
-c     - harmonic summing 1,2,4,8,16 and search for strongest peaks 
-c
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-      include 'csamp.inc'
-c Code Added for GMGPS BCJ 03-06-2011      
-
-c      include 'csampacc.inc'
-
-c Code Added for GMGPS BCJ 03-06-2011
-      
-      integer llog
-      logical dump,rspc,pmzap
-      character*80 sfile
-c
-c     Local variables
-c      
-      integer h,i,j,k,npf,fold,fb,lun,nc,ncal,istat,n
-      real snrbest,rms,sumsq,snrc,thresh,fnyq,spcsnr
-      integer indx(npts/8),snum(npts/8)
-      integer top,nsm,nf1,c(5),cmin,cmax
-      parameter(top=1024,nsm=1024*8)
-      real rmea(nsm),rrms(nsm),sres,flo,fhi,fhr,smax
-      real*8 freq,pmax,fbest,ratio,pc(top)
-      logical harm1,harm3,harm5,harm6
-      real*8 pcand(5,top),ptmp
-      real scand(5,top),sc(top),spc(512)
-      integer nav,ntot,fbin,blo,bhi
-      character*80 pfile,ffile
-
-      fold=0
-
-c     if (rspc) then
-c        call readspec(sfile,fold,samp,refdm,refac,tsamp,npf)
-c        nf1=real(tsamp)*2*npf/real(pmax)
-c     else
-        nf1=real(tsamp)*ntim/real(pmax)
-c        write(llog,*) 'Forming power spectrum. (Pmax=',pmax,' s!)'
-c        call formspec(npf,nf1)
-c        sres=real(freq(tsamp,npf,1,2))-real(freq(tsamp,npf,1,1))
-c     endif
-
-      npf=ntim/2
-      fnyq=0.5/real(tsamp)
-      write(llog,*) 'Nyquist frequency:',fnyq,' Hz'
-
-      if (dumpraw) then
-	  fold=0
-	  if (sfile.ne.' ') then
-	    pfile=sfile
-	  else
-            write(pfile,'(a,i1,a)') filename(1:lst)//'_',fold,'.spc'
-	  endif
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-	  stop
-      else if (dump) then
-          write(pfile,'(a4,i1,a4)') 'fold',0,'.spc'
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-      endif 
-c
-c     Spectral mask
-c
-      if (maskfile(1).ne.' ') then
-        if (nmasks.gt.1) then
-           write(llog,*) 'Reading spectral mask...'
-        else
-           write(llog,*) 'Reading spectral masks...'
-        endif
-        call glun(lun)
-	istat=0
-	open(unit=lun,file=maskfile(1),status='old',iostat=istat)
-        if (istat.ne.0) then
-           write(*,*) 'WARNING - mask file not found...'
-        else
-           j=0
-           do while(istat.eq.0)
-              read(lun,*,iostat=istat) i
-              if (istat.eq.0) then
-                 samp(i)=0.0
-                 j=j+1
-              endif
-           enddo
-           write(llog,*) 'Masked',j,' spectral bins from fold 1'
-         endif
-         close(unit=lun)
-      endif
-c
-c     Zap birdies before doing any spectral manipulation
-c        
-      if (zapfile.ne.' ') call zapit(llog,1,zapfile,samp,npf,tsamp)
-
-      write(llog,*) 'Whitening spectrum...'
-
-      nav=max(128,npf/nsm)
-      write(llog,*) 'Calculating spectral mean/rms every',
-     &nav,' bins...',real(freq(tsamp,npf,1,nav+1))
-     &-real(freq(tsamp,npf,1,1)),' Hz'
-c
-c     Form the running median
-c      
-
-      call getrmea(samp,npf,nav,rmea,ncal)
-c      call getrmed(samp,npf,nav,rmea,ncal)
-c
-c     Form the rms of the data ater subtracting the mean
-c      
-      call getrrms(samp,npf,rmea,nav,rrms)
-c
-c     Subtract running mean and scale it so that the rms=1
-c
-c      if (fbrute.gt.0.0) 
-c     &   write(llog,*) 'Brutal zapping above',fbrute,' Hz!'
-      if (fbrute.gt.0.0) 
-     &   write(llog,*) 'Brutal zapping below',fbrute,' Hz!'
-      n=0
-      sumsq=0.0
-      do i=1,npf
-         h=min(ncal,i/nav+1)
-         if (samp(i).ne.0.0) samp(i)=(samp(i)-rmea(h))/rrms(h)
-         if (mod(i,1024).eq.0.and.samp(i).lt.3.0) then
-            n=n+1
-            sumsq=sumsq+samp(i)*samp(i)
-         endif
-c
-c this line is the -b option which brutally zaps all RFI and psrs < fbrute Hz
-c changed for 47tuc analysis Mar 17, 2003
-	 if (fbrute.gt.0.0.and.freq(tsamp,npf,1,i).lt.fbrute.and.
-     &      samp(i).gt.10.0) samp(i)=1.0
-      enddo
-
-      rms=sqrt(sumsq/real(n))
-      write(llog,*) 'Resulting spectral RMS:',rms
-c
-c     for Parkes Multibeam Data - call zapping algorithm if -pmzap selected
-c
-      if (pmzap) call zap_birdies(samp,npf,nf1,tsamp*1000.0,rms,0.0,1)
-c
-c     original spectrum + 4 harmonic sums (Lyne/Ashworth code)
-c      
-      write(llog,*) 'Doing harmonic summing...'
-      call sumhrm(samp,npf,nf1)
-c      
-c     mask out folds 2-5 in addition to fold 1 (done above) if 
-c     mask files are present (drl - 28/04/05)
-c
-      if (nmasks.eq.5) then
-         do fold=2,5
-           j=0
-           call glun(lun)
-           istat=0
-           open(unit=lun,file=maskfile(fold),status='old',iostat=istat)
-           do while(istat.eq.0)
-              read(lun,*,iostat=istat) i
-              if (istat.eq.0) then
-                 power(fold,i)=0.0
-                 j=j+1
-              endif
-           enddo
-           write(llog,*) 'Masked',j,' spectral bins from fold',fold
-           close(lun)
-         enddo
-      endif
-
-      fb=0
-      fbest=0.0
-      snrbest=0.0
-      ntot=0
-c
-c     Search for candidates over all harmonic folds
-c
-      write(llog,*) 'Doing harmonic searching...'
-      do fold=1,5
-        c(fold)=0
-        thresh=5.0
- 5      do i=1,npf
-          ptmp=1.0/freq(tsamp,npf,fold,i)
-          if (ptmp.gt.pmax) power(fold,i)=0.0 ! Zap P>Pmax signals
-          snrc=power(fold,i)/rms
-          if (snrc.gt.thresh.and.c(fold).lt.top) then
-             c(fold)=c(fold)+1
-             samp(c(fold))=power(fold,i)
-             snum(c(fold))=i
-c          else if (snrc.gt.thresh) then
-c             write(*,*) 'WARNING: not enough candidates saved!!'
-          endif
-        enddo
-        if (c(fold).lt.2) then
-           thresh=thresh-1.0
-           goto 5
-        endif
-c
-c       Sort power spectrum in amplitude (propto signal-to-noise) order...
-c
-        call indexxf77(c(fold),samp,indx)
-c
-c     
-        j=0
-        do i=c(fold),1,-1
-          j=j+1
-          pcand(fold,j)=1000.0/freq(tsamp,npf,fold,snum(indx(i)))
-          snrc=samp(indx(i))/rms
-          scand(fold,j)=snrc
-          if (snrc.gt.snrbest) then
-            snrbest=snrc
-            fbest=1000.0/pcand(fold,j)
-            fb=fold
-          endif
-        enddo
-
-        do i=1,c(fold)
-           do j=1,c(fold)
-              if (j.ne.i.and.scand(fold,j).gt.0.0.and.
-     &           scand(fold,i).gt.0.0) then
-                 ratio=pcand(fold,i)/pcand(fold,j)
-                 if (ratio.lt.1.0) ratio=1.0/ratio
-                 ratio=ratio-int(ratio)
-                 harm1=ratio.gt.0.999.or.ratio.lt.0.001
-                 harm3=ratio.gt.0.329.and.ratio.lt.0.331
-                 harm5=ratio.gt.0.499.and.ratio.lt.0.501
-                 harm6=ratio.gt.0.659.and.ratio.lt.0.661
-                 if(harm1.or.harm3.or.harm5.or.harm6)scand(fold,j)=0.0
-              endif
-           enddo
-        enddo
-
-        j=0
-        do i=1,c(fold)
-           if (scand(fold,i).gt.5.0) then  
-              j=j+1
-              scand(fold,j)=scand(fold,i)
-              pcand(fold,j)=pcand(fold,i)
-           endif
-        enddo
-        c(fold)=j
-
-        do i=1,c(fold)
-           ntot=ntot+1
-           if (ntot.le.top) then
-             sc(ntot)=scand(fold,i)
-             pc(ntot)=pcand(fold,i)
-           else
-c             write(*,*) 'WARNING: master candidate list full!'
-           endif
-        enddo
-        
-        if (dump) then
-          do i=1,npf
-            samp(i)=power(fold,i)
-          enddo
-          write(pfile,'(a,i1,a)') filename(1:lst)//'_',fold,'.spc'
-          write(pfile,'(a,a)') filename(1:lst),'.spc'
-          write(pfile,'(a4,i1,a4)') 'fold',fold,'.spc'
-          call writespec(llog,pfile,fold,samp,refdm,refac,tsamp,npf)
-        endif
-
-        rms=rms*sqrt(2.0) ! Each fold increases rms by root 2...
-      enddo
-
-      cmin=top
-      do i=1,5
-         cmin=min(cmin,c(i))
-      enddo
-      
-      cmax=0
-      do i=1,5
-         cmax=max(cmax,c(i))
-      enddo
-      
-      call glun(lun)
-      pfile=filename(1:lst)//'.prd'
-      open(unit=lun,file=pfile,status='unknown',access=facc)
-      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-      do i=1,cmax
-         do j=1,5
-            if (i.gt.c(j)) then
-              pcand(j,i)=1.0
-              scand(j,i)=0.0
-            endif
-         enddo
-         write(lun,1) scand(1,i),pcand(1,i),scand(2,i),pcand(2,i),
-     &                scand(3,i),pcand(3,i),scand(4,i),pcand(4,i),
-     &                scand(5,i),pcand(5,i)
-      enddo
-      close(unit=lun)
-      ffile=filename(1:lst)//'.frq'
-      open(unit=lun,file=ffile,status='unknown',access=facc)
-      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-      do i=1,cmax
-         write(lun,1) scand(1,i),1000.0/pcand(1,i),scand(2,i),
-     &                1000.0/pcand(2,i),scand(3,i),
-     &                1000.0/pcand(3,i),scand(4,i),
-     &                1000.0/pcand(4,i),scand(5,i),
-     &                1000.0/pcand(5,i)
-      enddo
-      close(unit=lun)
-
-      call indexxf77(ntot,sc,indx)
-      do i=ntot,1,-1
-         k=indx(i)
-         do j=1,ntot
-            if (j.ne.k.and.sc(j).gt.0.0.and.
-     &           sc(k).gt.0.0) then
-               ratio=pc(k)/pc(j)
-               if (ratio.lt.1.0) ratio=1.0/ratio
-               ratio=ratio-int(ratio)
-               harm1=ratio.gt.0.999.or.ratio.lt.0.001
-               harm3=ratio.gt.0.329.and.ratio.lt.0.331
-               harm5=ratio.gt.0.499.and.ratio.lt.0.501
-               harm6=ratio.gt.0.659.and.ratio.lt.0.661
-               if(harm1.or.harm3.or.harm5.or.harm6)sc(j)=0.0
-            endif
-         enddo
-      enddo
-      
-      nc=0
-      do i=ntot,1,-1
-         if (sc(indx(i)).gt.0.0) then
-            do j=1,512
-               spc(j)=0.0
-            enddo
-            smax=0.0
-            do h=1,128
-               fhr=real(h)*1000.0/pc(indx(i))
-               flo=fhr-1000.0/pc(indx(i))*0.05
-               blo=fbin(tsamp,npf,1,flo)
-               fhi=fhr+1000.0/pc(indx(i))*0.05
-               bhi=min(blo+511,fbin(tsamp,npf,1,fhi))
-               if (bhi.lt.npf) then
-                  j=0
-                  do k=blo,bhi
-                    j=j+1
-                    spc(j)=spc(j)+power(1,k)
-                  enddo
-                  smax=max(smax,spcsnr(spc,j))
-               endif
-            enddo
-            nc=nc+1
-            pcand(1,nc)=pc(indx(i))
-            scand(1,nc)=smax
-            scand(2,nc)=sc(indx(i))
-         endif
-      enddo
-      do i=1,nc
-         sc(i)=scand(2,i) ! scand(1,i) are the "optimised" SNRs (need's work)
-      enddo
-      call indexxf77(nc,sc,indx)
-      
-c      ffile=filename(1:lst)//'.opt'
-c      open(unit=lun,file=ffile,status='unknown',access=facc)
-cc      write(lun,*) 'DM:',refdm,' AC:',refac,' AD:',refad
-c      do i=nc,1,-1
-c         j=indx(i)
-c         ratio=pcand(1,j)/pcand(1,indx(nc))
-c         if (ratio.lt.1.0) ratio=1.0/ratio
-c         if (sc(j).gt.9.9)write(lun,2) sc(j),pcand(1,j),ratio,scand(2,j)
-c      enddo
-c      close(unit=lun)
-      
- 1    format(5(f5.1,1x,f13.8,1x))
- 2    format(f5.1,1x,f9.4,3x,f7.3,1x,f5.1)
-      
-      write(llog,*) 'Best suspect:',1000.0/fbest,' ms'
-      write(llog,'(x,a,x,f5.1)') 'SNR:',snrbest
-      write(llog,*) 'Found peak at:',fbest,' Hz'
-      write(llog,*) 'Harmonic fold:',fb
-
-      ffile=filename(1:lst)//'.top'
-      open(unit=lun,file=ffile,status='unknown',access=facc)
-      write(lun,*) 1000.0/fbest,snrbest,refdm
-      close(unit=lun)
-
-      end
-      
diff --git a/filterbank-gmrt/downsample.c b/filterbank-gmrt/downsample.c
deleted file mode 100644
index 286c77f..0000000
--- a/filterbank-gmrt/downsample.c
+++ /dev/null
@@ -1,39 +0,0 @@
-#include "filterbank.h"
-int obits;
-#define GULP 32768*16
-main (int argc, char *argv[])
-{
-  float block[GULP],copy[GULP];
-  int ixnc,kxnc,i,j,k,n,off,nadd,nread,headersize=0;
-
-  input=fopen(argv[1],"rb");
-  output=fopen(argv[2],"wb");
-  nadd=atoi(argv[3]);
-
-  for (i=0;i<4;i++) ifstream[i]='Y';
-
-  if (!(headersize=read_header(input))) 
-    error_message("could not read header parameters!");
-  obits=32;
-  tsamp*=nadd;
-  filterbank_header(output);
-  for (i=0;i<GULP;i++) block[i]=copy[i]=0.0;
-  nread=GULP/nchans;
-
-  while(n=read_block(input,nbits,block,nread)) {
-    k=off=0;
-    for (i=0;i<n/nchans;i++) {
-      ixnc=i*nchans;
-      kxnc=k*nchans;
-      for (j=0;j<nchans;j++) copy[off+j]+=block[ixnc+j];
-      k++;
-      if (k==nadd) {
-	off+=nchans;
-	k=0;
-      }
-    }
-    for (j=0;j<n/nadd;j++) copy[j]/=(float)nadd;
-    fwrite(copy,sizeof(float),n/nadd,output);
-    for (j=0;j<n/nadd;j++) copy[j]=0.0;
-  }
-}
diff --git a/filterbank-gmrt/epn.h b/filterbank-gmrt/epn.h
deleted file mode 100644
index c4639a4..0000000
--- a/filterbank-gmrt/epn.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-  C structure containing EPN header information and data for a pulse profile
-  for further details on the header parameters, see the infamous EPN paper:
-  Lorimer et al. in A&A Suppl. Series, v.128, p.541-544 [astro-ph/9801097] 
-*/
-struct EPN {
-  char history[72];     /* some (preferably meaningful) notes about the data */
-  char jname[12];       /* Name of pulsar derived from its J2000 coordinates */
-  char cname[12];       /* Common name of pulsar (either B- or J-name) */
-  double pbar;          /* Barycentric period of pulsar (s) (present epoch) */
-  double dm;            /* Dispersion measure (pc/cc) */
-  double rm;            /* Rotation measure of pulsar (rad m^2) */
-  char catref[6];       /* Tag showing which catalogue in use */
-  char bibref[8];       /* Bibliographic reference for data */
-  double raj;           /* Right ascension J2000 hhmmss.s */
-  double dec;           /* Declination J2000 ddmmss.s */
-  char telname[8];      /* Telescope name */
-  float epoch;          /* modified Julian date of observation */
-  float opos;           /* position angle of feed (degrees) */
-  char paflag;          /* "A" signifies absolute PAs else undefined */
-  char timflag;         /* "U" signifies UTC time "B" barycentric UTC */
-  float xtel;           /* Topocentric rectangular position of telescope [m] */
-  float ytel;           /* Topocentric rectangular position of telescope [m] */
-  float ztel;           /* Topocentric rectangular position of telescope [m] */
-  int day;              /* year (eg 1996) */
-  int month;            /* month (1-12) */
-  int year;             /* day (1-31) */
-  int scanno;           /* sequence number of the observation */
-  int subscan;          /* sub-sequence number of the observation */
-  int npol;             /* number of polarisations observed */
-  int nfreq;            /* number of frequency bands per polarisation */
-  int nbins;            /* number of phase bins per frequency */
-  double tbin;          /* sampling interval (us) */
-  int nint;             /* number of integrated pulses per data block */
-  int ncal;             /* bin number of start of cal signal */
-  int lcal;             /* number of bins in the cal signal */
-  double tres;          /* temporal resolution (us) */
-  char fluxflag;        /* "F" signifies flux (mJy) calibrated data */
-  char idfield[8];      /* Description of data stream I Q U V etc. etc. */
-  int nband;            /* Ordinal number of data stream */
-  int navg;             /* Number of streams averaged into this one */
-  double f0;            /* Effective centre sky frequency of this stream */
-  char uf[8];           /* String giving unit of f0 [default is GHz] */
-  double df;            /* Effective bandwidth of this stream */
-  char ud[8];           /* String giving unit of df [default is MHz] */
-  double tstart;        /* Time of first bin wrt EPOCH [us] */
-  float scale;          /* scale factor for the data */
-  float offset;         /* offset to be added to the data */
-  float rms;            /* rms of the data */
-  double papp;          /* apparent period at time of first phase bin (us) */
-  /* 
-     the final entry in the structure is iprofile ---- the profile scaled to
-     an integer value between 0 and 65535. To convert this to floating point
-     use the scaling:  profile[i]=scale*(float)iprofile[i]+offset
-  */
-  unsigned long *iprofile; 
-} ;
diff --git a/filterbank-gmrt/epnhdr.f b/filterbank-gmrt/epnhdr.f
deleted file mode 100644
index 47ba5a4..0000000
--- a/filterbank-gmrt/epnhdr.f
+++ /dev/null
@@ -1,155 +0,0 @@
-c==============================================================================
-c
-c     Include file "epnhdr.f"
-c
-c     This file defines the variables used in the EPN-header
-c
-c==============================================================================
-c		Main Header   - 6 Lines 80 characters per line
-c==============================================================================
-c     version     - A8     - version number of EPN format.
-c     counter     - I4     - the number of 80 character records in this block
-c     history     - A72    - some (preferably meaningful) notes about the data
-c------------------------------------------------------------------------------
-c     jname       - A12    - Name of pulsar derived from its J2000 coordinates
-c     cname       - A12    - Common name of pulsar (either B- or J-name)
-c     pbar        - F16.11 - Barycentric period of pulsar (s) (present epoch)
-c     dm          - F8.3   - Dispersion measure (pc/cc)
-c     rm          - F10.3  - Rotation measure of pulsar (rad m^2)
-c     catref      - A6     - Tag showing which catalogue in use 
-c     bibref      - A8     - Bibliographic reference for data 
-c------------------------------------------------------------------------------
-c     rah         - I2     - Hours of right ascension (J2000)
-c     ram         - I2     - Mins. of right ascension (J2000)
-c     ras         - F6.3   - Secs. of right ascension (J2000)
-c     ded         - I3     - Degrees of declination   (J2000)
-c     dem         - I2     - Minutes of declination   (J2000)
-c     des         - F6.3   - Seconds of declination   (J2000)
-c     telname     - A8     - Telescope name
-c     epoch       - F10.3  - modified Julian date of observation
-c     opos        - F8.3   - position angle of feed (degrees)
-c     paflag      - A1     - "A" signifies absolute PAs else undefined
-c     timflag     - A1     - "U" signifies UTC time "B" barycentric UTC 
-c------------------------------------------------------------------------------
-c     xtel        - F17.5  - Topocentric rectangular position of telescope [m]
-c     ytel        - F17.5  - Topocentric rectangular position of telescope [m]
-c     ztel        - F17.5  - Topocentric rectangular position of telescope [m]
-c------------------------------------------------------------------------------
-c     cdy         - I4     - year (eg 1996)
-c     cdm         - I2     - month (1-12)
-c     cdd         - I2     - day (1-31)
-c     scanno      - I4     - sequence number of the observation
-c     subscan     - I4     - sub-sequence number of the observation
-c     npol        - I2     - number of polarisations observed
-c     nfreq       - I4     - number of frequency bands per polarisation
-c     nbin        - I4     - number of phase bins per frequency
-c     tbin        - F12.6  - sampling interval (us)
-c     nint        - I6     - number of integrated pulses per data block
-c     ncal        - I4     - bin number of start of cal signal
-c     lcal        - I4     - number of bins in the cal signal
-c     tres        - F12.6  - temporal resolution (us)
-c     fluxflag    - A1     - "F" signifies flux (mJy) calibrated data
-c==============================================================================
-c     Block sub-header.... 2 Lines 80 Characters per Line
-c==============================================================================
-c     idfield     - A8     - Description of data stream I Q U V etc. etc.
-c     nband       - I4     - ordinal number of data stream
-c     navg        - I4     - number of streams averaged into current one
-c     f0          - f12.8  - Effective centre sky frequency of this stream
-c     f0u         - A8     - String giving unit of f0 [default is GHz]
-c     df          - f12.6  - Effective bandwidth of this stream
-c     dfu         - A8     - String giving unit of df [default is MHz]
-c     tstart      - F17.5  - Time of first bin wrt EPOCH [us]
-c------------------------------------------------------------------------------
-c     scale       - E12.6  - Scale factor for the data
-c     offset      - E12.6  - Offset to be added to the data
-c     rms         - E12.6  - rms of the data stream
-c     papp        - F16.12 - Apparent period at time of first phase bin [s]
-c==============================================================================
-c
-c     EPN Filename
-c
-      character*80 filename
-c
-c     First line of main header
-c
-      character version*8, history*72
-      integer*4 counter
-      common/epn1/version,history,counter
-c      
-c     Second line of main header
-c
-      character jname*12, cname*12
-      real*8    pbar, dm, rm
-      character catref*6
-      character bibref*8
-      common/epn2/jname,cname,pbar,dm,rm,catref,bibref
-c
-c     Third line of main header
-c
-      integer*4 rah, ram, ded, dem
-      real      ras, des
-      character telname*8
-      real*8    epoch , opos
-      character paflag*1, timflag*1
-      common/epn3/rah,ram,ded,dem,ras,des,telname,epoch,opos,
-     &             paflag,timflag
-c
-c     Fourth line of main header
-c
-      real*8 xtel, ytel, ztel
-      common/epn4/xtel,ytel,ztel
-c
-c     Fifth line of main header
-c
-      integer*4 cdy, cdm, cdd
-      integer*4 scanno, subscan, npol, nfreq, nbin
-      real*8    tbin, tres
-      integer*4 nint ,ncal, lcal
-      real      fcal
-      character fluxflag*1
-      common/epn5/cdy,cdm,cdd,scanno,subscan,npol,nfreq,nbin,tbin,
-     &             nint,ncal,lcal,fcal,tres,fluxflag
-c
-c     Maximum blocks writing to sub-header...
-c
-      integer maxblk
-      parameter(maxblk=8)
-c
-c     First line of block sub-header 
-c
-      character idfield*8
-      integer*4 nband, navg
-      real*8    f0, df
-      character*8 f0u,dfu
-      double precision tstart
-      common/epns1/idfield(maxblk),nband(maxblk),navg(maxblk),
-     & f0(maxblk),f0u(maxblk),df(maxblk),dfu(maxblk),tstart(maxblk)
-c
-c     Second line of block sub-header (required to scale/descale data)
-c
-      real*8    scale,offset,rms,papp
-      common/epns2/offset(maxblk),scale(maxblk),rms(maxblk),papp(maxblk)
-c
-c     Data block 
-c
-      integer maxbin
-      parameter(maxbin=16384)
-      real*4 rawdata
-      common/dblk/rawdata(maxblk,maxbin)
-c
-c     Reading or writing?
-c
-      integer readwri     ! = 1 write = -1 read
-c
-c     Record number for reading... and record length
-c
-      integer recno
-c
-c     Pad out the record to its maximum length
-c
-      logical padout
-c
-c     That's all folks!
-c
-c==============================================================================
diff --git a/filterbank-gmrt/epnhdr.inc b/filterbank-gmrt/epnhdr.inc
deleted file mode 100644
index b228505..0000000
--- a/filterbank-gmrt/epnhdr.inc
+++ /dev/null
@@ -1,155 +0,0 @@
-c==============================================================================
-c
-c     Include file "epnhdr.inc"
-c
-c     This file defines the variables used in the EPN-header
-c
-c==============================================================================
-c		Main Header   - 6 Lines 80 characters per line
-c==============================================================================
-c     version     - A8     - version number of EPN format.
-c     counter     - I4     - the number of 80 character records in this block
-c     history     - A72    - some (preferably meaningful) notes about the data
-c------------------------------------------------------------------------------
-c     jname       - A12    - Name of pulsar derived from its J2000 coordinates
-c     cname       - A12    - Common name of pulsar (either B- or J-name)
-c     pbar        - F16.11 - Barycentric period of pulsar (s) (present epoch)
-c     dm          - F8.3   - Dispersion measure (pc/cc)
-c     rm          - F10.3  - Rotation measure of pulsar (rad m^2)
-c     catref      - A6     - Tag showing which catalogue in use 
-c     bibref      - A8     - Bibliographic reference for data 
-c------------------------------------------------------------------------------
-c     rah         - I2     - Hours of right ascension (J2000)
-c     ram         - I2     - Mins. of right ascension (J2000)
-c     ras         - F6.3   - Secs. of right ascension (J2000)
-c     ded         - I3     - Degrees of declination   (J2000)
-c     dem         - I2     - Minutes of declination   (J2000)
-c     des         - F6.3   - Seconds of declination   (J2000)
-c     telname     - A8     - Telescope name
-c     epoch       - F10.3  - modified Julian date of observation
-c     opos        - F8.3   - position angle of feed (degrees)
-c     paflag      - A1     - "A" signifies absolute PAs else undefined
-c     timflag     - A1     - "U" signifies UTC time "B" barycentric UTC 
-c------------------------------------------------------------------------------
-c     xtel        - F17.5  - Topocentric rectangular position of telescope [m]
-c     ytel        - F17.5  - Topocentric rectangular position of telescope [m]
-c     ztel        - F17.5  - Topocentric rectangular position of telescope [m]
-c------------------------------------------------------------------------------
-c     cdy         - I4     - year (eg 1996)
-c     cdm         - I2     - month (1-12)
-c     cdd         - I2     - day (1-31)
-c     scanno      - I4     - sequence number of the observation
-c     subscan     - I4     - sub-sequence number of the observation
-c     npol        - I2     - number of polarisations observed
-c     nfreq       - I4     - number of frequency bands per polarisation
-c     nbin        - I4     - number of phase bins per frequency
-c     tbin        - F12.6  - sampling interval (us)
-c     nint        - I6     - number of integrated pulses per data block
-c     ncal        - I4     - bin number of start of cal signal
-c     lcal        - I4     - number of bins in the cal signal
-c     tres        - F12.6  - temporal resolution (us)
-c     fluxflag    - A1     - "F" signifies flux (mJy) calibrated data
-c==============================================================================
-c     Block sub-header.... 2 Lines 80 Characters per Line
-c==============================================================================
-c     idfield     - A8     - Description of data stream I Q U V etc. etc.
-c     nband       - I4     - ordinal number of data stream
-c     navg        - I4     - number of streams averaged into current one
-c     f0          - f12.8  - Effective centre sky frequency of this stream
-c     f0u         - A8     - String giving unit of f0 [default is GHz]
-c     df          - f12.6  - Effective bandwidth of this stream
-c     dfu         - A8     - String giving unit of df [default is MHz]
-c     tstart      - F17.5  - Time of first bin wrt EPOCH [us]
-c------------------------------------------------------------------------------
-c     scale       - E12.6  - Scale factor for the data
-c     offset      - E12.6  - Offset to be added to the data
-c     rms         - E12.6  - rms of the data stream
-c     papp        - F16.12 - Apparent period at time of first phase bin [s]
-c==============================================================================
-c
-c     EPN Filename
-c
-      character*80 filename
-c
-c     First line of main header
-c
-      character version*8, history*72
-      integer*4 counter
-      common/epn1/version,history,counter
-c      
-c     Second line of main header
-c
-      character jname*12, cname*12
-      real*8    pbar, dm, rm
-      character catref*6
-      character bibref*8
-      common/epn2/jname,cname,pbar,dm,rm,catref,bibref
-c
-c     Third line of main header
-c
-      integer*4 rah, ram, ded, dem
-      real      ras, des
-      character telname*8
-      real*8    epoch , opos
-      character paflag*1, timflag*1
-      common/epn3/rah,ram,ded,dem,ras,des,telname,epoch,opos,
-     &             paflag,timflag
-c
-c     Fourth line of main header
-c
-      real*8 xtel, ytel, ztel
-      common/epn4/xtel,ytel,ztel
-c
-c     Fifth line of main header
-c
-      integer*4 cdy, cdm, cdd
-      integer*4 scanno, subscan, npol, nfreq, nbin
-      real*8    tbin, tres
-      integer*4 nint ,ncal, lcal
-      real      fcal
-      character fluxflag*1
-      common/epn5/cdy,cdm,cdd,scanno,subscan,npol,nfreq,nbin,tbin,
-     &             nint,ncal,lcal,fcal,tres,fluxflag
-c
-c     Maximum blocks writing to sub-header...
-c
-      integer maxblk
-      parameter(maxblk=8)
-c
-c     First line of block sub-header 
-c
-      character idfield*8
-      integer*4 nband, navg
-      real*8    f0, df
-      character*8 f0u,dfu
-      double precision tstart
-      common/epns1/idfield(maxblk),nband(maxblk),navg(maxblk),
-     & f0(maxblk),f0u(maxblk),df(maxblk),dfu(maxblk),tstart(maxblk)
-c
-c     Second line of block sub-header (required to scale/descale data)
-c
-      real*8    scale,offset,rms,papp
-      common/epns2/offset(maxblk),scale(maxblk),rms(maxblk),papp(maxblk)
-c
-c     Data block 
-c
-      integer maxbin
-      parameter(maxbin=16384)
-      real*4 rawdata
-      common/dblk/rawdata(maxblk,maxbin)
-c
-c     Reading or writing?
-c
-      integer readwri     ! = 1 write = -1 read
-c
-c     Record number for reading... and record length
-c
-      integer recno
-c
-c     Pad out the record to its maximum length
-c
-      logical padout
-c
-c     That's all folks!
-c
-c==============================================================================
diff --git a/filterbank-gmrt/epnpack.f b/filterbank-gmrt/epnpack.f
deleted file mode 100644
index b514fa8..0000000
--- a/filterbank-gmrt/epnpack.f
+++ /dev/null
@@ -1,259 +0,0 @@
-c==============================================================================
-      subroutine hex2b10(hexstr,b10no)
-c==============================================================================
-
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      b10no=0
-      dig=0
-
-      do i=4,1,-1
-         do j=1,16
-            if (hexstr(i:i).eq.hex(j)) goto 5
-         enddo
- 5       continue
-         b10no=b10no+int(16.0**float(dig)*float(j-1))
-         dig=dig+1
-      enddo
-
-      end
-c==============================================================================
-      subroutine b102hex(b10no,hexstr)
-c==============================================================================
-c
-c	Converts a base 10 number passed down as the integer "b10no"
-c	to a hexadeximal string returned as the character*4 "hexstr"
-c       N.B. maximum integer for 4 character hex string is 65535
-c
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,no,num,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      no=b10no
-      dig=0
-
-      do i=4,1,-1
-         do j=15,0,-1
-            num=int(float(j)*16.0**float(i-1))
-            if (num.le.no) goto 5
-         enddo
- 5       continue
-         dig=dig+1
-         hexstr(dig:dig)=hex(j+1)
-         no=no-num
-      enddo
-
-      end
-c==============================================================================
-      subroutine rawtfint(raw,nbin,intdata,scale,offset,rms,dirn,maxint)
-c==============================================================================
-c
-c     Routine to convert "raw" (i.e. floating point) to/from integer
-c     format. In this case, the integer may vary between 0 and maxint.
-c     Raw data is passed down from site software and stored as integers
-c     in the EPN files.
-c
-c     The direction of the conversion is controlled by "dirn":
-c
-c     dirn = +1 : raw -> int
-c     dirn = -1 : int -> raw
-c
-c==============================================================================
-c    
-      implicit none
-c
-c     Passed down variables
-c
-      real raw(*)
-      real*8 scale, offset, rms
-      integer nbin, intdata(*), dirn, maxint
-c
-c     Local variables
-c
-      real dmin, dmax, sumsq, pmax, sum, mean, ndiv
-      integer i, ibmax, nshift
-      if (dirn.eq.1) then
-c
-c       Scale the data:
-c
-c       Find minimum & maximum values of the data
-c
-        dmin = raw(1)
-        dmax = raw(1)
-        do i=1,nbin
-          dmax=max(raw(i),dmax)
-          dmin=min(raw(i),dmin)
-        enddo
-        offset=dmin
-        scale=float(maxint)/(dmax-dmin)
-c
-c       Now do the scaling
-c
-        do i=1,nbin
-          intdata(i)=int((raw(i)-offset)*scale)
-        enddo
-c
-c-------------------------------------------------------------
-c       If no rms has been supplied by the user, have a go at 
-c       calculating it from the wings of the profile after 
-c       shifting it so that its peak lies at bin number nbin/2
-c-------------------------------------------------------------
-c
-        if (rms.eq.0.0) then
-          pmax=-1.0e32
-          ibmax=0
-          do i=1,nbin
-             if (raw(i).gt.pmax) then
-                ibmax=i
-                pmax=raw(i)
-             endif
-          enddo
-          nshift=nbin/2-ibmax
-          call sprof(raw,nbin,nshift)
-          sumsq=0.0
-          sum=0.0
-          do i=1,nbin/15
-            sumsq=sumsq+raw(i)*raw(i)
-            sumsq=sumsq+raw(nbin-i+1)*raw(nbin-i+1)
-            sum=sum+raw(i)
-            sum=sum+raw(nbin-i+1)
-          enddo
-	  ndiv=max(1.0,float(2*nbin/15))
-          rms=sqrt(sumsq/ndiv)
-          mean=sum/ndiv
-        endif
-      else if (dirn.eq.-1) then
-c
-c       Prepare to de-scale the data:
-c
-        do i=1,nbin
-          raw(i)=real(offset+dble(intdata(i))/scale)
-        enddo
-      else
-c
-c       Silly option was passed down...
-c
-        write(*,*) 'Invalid value for dirn passed to rawtfint : ',dirn
-        stop
-      endif
-c
-c     Job done!
-c
-      end
-c==============================================================================
-      integer function nepnrec(filename)
-c==============================================================================
-c
-c     Function to find out the number of records in an EPN file.
-c
-c     This can in principle be done with an INQUIRE statement but
-c     it is system dependent. The following approach uses a simple
-c     binary search algorithm to find the last record which is far
-c     quicker than reading in every record in very large EPN files.
-c
-c     if the file doesn't exist nepnrec is returned as 0
-c     nepnrec = -1 if an error occurred whilst reading the file
-c
-c     Created 96/12/03 DRL@MPIfR
-c     Modified October 1997 to return -1 on error
-c
-c
-      implicit none
-      character*80 filename
-
-      character lin1*12,recrd*80
-      integer irec,istat,counter,recln,hirec,lorec,orec,lun
-      logical filex
-c
-c     Check to see whether the EPN file exists...
-c     return nepnrec=0 if it doesn't
-c
-      nepnrec=0
-      inquire(file=filename,exist=filex)
-      if (.not.filex) return 
-c
-c     It exists! Open it and find out the true record length..
-c
-      call glun(lun)
-      nepnrec=-1 ! This will be the value of nepnrec if an error occurs
-      irec=-1
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=12,err=999)
-      read(lun,rec=1,err=999)lin1
-      read(lin1,'(8x,i4)',err=999)counter
-      close(unit=lun)
-      recln=counter*80
-      if (recln.le.0) return ! Error
-c
-c     Find out crude lower and upper bounds for the last record
-c
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=recln,err=999)
-      irec=1
-      istat=0
-      do while(.true.)
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.ne.0) goto 998
-         irec=irec*2
-      enddo
- 998  hirec=irec
-      lorec=irec/2
-c
-c     Now search for the last record within these bounds iteratively
-c
-      istat=0
-      orec=0
-      do while(orec.ne.irec)
-         orec=irec
-         irec=lorec+(hirec-lorec)/2
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.eq.0) then
-            lorec=irec
-         else
-            hirec=irec
-         endif
-      enddo
- 999  continue
-      close(unit=lun)
-      nepnrec=irec
-      end
-c============================================================================= 
-      subroutine dattim(date,hh,mm,ss)
-c============================================================================= 
-c
-c     Returns the time obtained by truncating the MJD passed down
-c     as date
-c
-      implicit none 
-      double precision date,dummy,ss
-      integer hh,mm
-
-
-      dummy=abs(date-int(date))
-
-      dummy=dummy*24.0
-      hh=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      mm=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      ss=dummy
-
-      end
diff --git a/filterbank-gmrt/error_message.c b/filterbank-gmrt/error_message.c
deleted file mode 100644
index 37116f6..0000000
--- a/filterbank-gmrt/error_message.c
+++ /dev/null
@@ -1,6 +0,0 @@
-#include <stdio.h>
-void error_message(char *message) /*includefile */
-{
-  fprintf(stderr,"ERROR: %s\n",message);
-  exit(1);
-}
diff --git a/filterbank-gmrt/exporter.csh b/filterbank-gmrt/exporter.csh
deleted file mode 100755
index bf34def..0000000
--- a/filterbank-gmrt/exporter.csh
+++ /dev/null
@@ -1,23 +0,0 @@
-#!/bin/csh
-# exporter.csh - script to produce a tar file for exporting to other machines
-set d = `pwd | awk -F/ '{print $NF}'`
-set v = `awk '{print $1}' version.history | tail -2 | head -1`
-set date = `date +"%A %B %e, %Y"`
-echo "% THIS FILE SHOULD NOT BE EDITED -- EDIT documentation.tex" >! sigproc.tex
-cat documentation.tex|sed s/"X.X"/"$v"/|sed s/"RELEASE"/"$date"/>>sigproc.tex
-echo "#define SIGPROC_VERSION $v" > version.h
-echo "      character*60 version" >! vers.inc
-echo "      parameter(version='is part of SIGPROC version: $v')" >> vers.inc
-cd ..
-if ($d != "sigproc-$v") mv $d sigproc-$v
-set d = sigproc-$v
-if (-e $d.tar) rm -f $d.tar
-if (-e $d.tar.gz) rm -f $d.tar.gz
-tar cf $d.tar $d/version.history $d/makefile $d/configure $d/*.tex \
-       $d/*.ps $d/*.c $d/*.h $d/*.l $d/*.y $d/*.csh $d/*.tcl $d/*.tk \
-       $d/*.f $d/*.inc
-gzip   $d.tar
-echo "export version of $d ready..."
-ls -l  $d.tar.gz
-scp    $d.tar.gz drl@aten.jb.man.ac.uk:download
-exit
diff --git a/filterbank-gmrt/extract.c b/filterbank-gmrt/extract.c
deleted file mode 100644
index 3227886..0000000
--- a/filterbank-gmrt/extract.c
+++ /dev/null
@@ -1,48 +0,0 @@
-#include "filterbank.h"
-FILE *input, *output;
-
-main(int argc, char **argv)
-{
-  int i, start_sample, block_size;
-  long int offset, samples_to_read, bytes_to_read;
-  char *block;
-  fpos_t pos;
-
-  if (argc<4) {
-    puts("usage: extract filterbank_file start_sample samples_to_read");
-    exit(0);
-  }
-   
-  if (file_exists(argv[1])) {
-    strcpy(inpfile,argv[1]);
-    input=open_file(inpfile,"rb");
-    output=stdout;
-  } else {
-    error_message("input file does not exist...");
-  }
-  start_sample=atol(argv[2]); samples_to_read=atol(argv[3]);
-  
-  if ((read_header(input)) && (data_type==1)) {
-    obits=-1;
-    for (i=0; i<nifs; i++) ifstream[i]='Y';
-    block_size = nifs*nchans*nbits/8;
-    block = (char *) malloc(block_size);
-    start_time=(double)(start_sample-1)*tsamp;
-    filterbank_header(output);
-    offset=(start_sample-1);
-    /* jumping to the start position */
-    for (i=0; i<block_size; i++) {
-      if (fseek(input,offset,SEEK_CUR) != 0) {
-	error_message("error setting start position in file");
-      }
-    }
-    /* copying the samples */
-    for (i=0; i<samples_to_read; i++) {
-      fread(block,1,block_size,input);
-      fwrite(block,1,block_size,output);
-    }
-  } else {
-    error_message("extract can currently only work with filterbank data!");
-  }
-
-}
diff --git a/filterbank-gmrt/fake.c b/filterbank-gmrt/fake.c
deleted file mode 100644
index 146c08f..0000000
--- a/filterbank-gmrt/fake.c
+++ /dev/null
@@ -1,468 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-
-/* global variables describing the data */
-#include "header.h"
-
-/* list of subroutines and functions */
-#include "sigproc.h"
-
-#define PI 3.14159265
-#define SPEED_OF_LIGHT 2.99792458e8
-#define T_SUN 4.92544947
-
-
-#define M_SUN 2.0e30
-#define G 6.672e-11  
-
-
-
-char inpfile[80], outfile[80];
-
-FILE *output;
-
-
-struct BinaryParams{
-	double orbitalPeriod; 	/* Secconds */
-	double eccentricity;
-	double massPulsar; 	/* Solar masses */
-	double massCompanion; 	/* Solar masses */
-	double startPhase; 	/*0.0 - 1.0 to determine way though orbit at start */
-	double inclination; 	/* Degrees */
-	double omega;  		/*Longitude of periastron*/
-};
-
-
-/* 
- * A function for tuning the apparent period of the pulsar if it were in a binary system
- * 
- * M Keith, R Eatough 2006
- */
-double binary_papp(struct BinaryParams params,double pRest, double time);
-
-
-main (int argc, char *argv[])
-{
-	int i,c,j,k,s,swapout,smear,nsblk=512,ic,arraysize,evenodd,headerless;
-	float pulse,snr,min=-4.0,max=4.0;
-	char string[80];
-	double psrdm,faketime,obstime,period,pulsephase,rising,trailing,dc,*shift;
-	double nexttime,timestep,tdm,p0,pdot,accn,speed_of_light=299792458.0,plst;
-	long seed;
-	float *fblock;
-	unsigned short *sblock;
-	unsigned char *cblock;
-
-	int usebinary;
-	struct BinaryParams binaryParams;
-
-	
-	if (argc<2) {
-		fake_help();
-		exit(0);
-	} else {
-		print_version(argv[0],argv[1]);
-	}
-
-	/* print help if necessary */
-	if (help_required(argv[1])) {
-		fake_help();
-		exit(0);
-	}
-
-	/* set up default variables */
-	strcpy(inpfile,"stdin");
-	strcpy(outfile,"stdout");
-	machine_id=telescope_id=0;
-	nchans=128;
-	nbits=4;
-	tstart=50000.0;
-	tsamp=80.0e-6;
-	fch1=433.968;
-	foff=-0.062;
-	smear=nifs=1;
-	obstime=10.0;
-	output=stdout;
-	seed=-1;
-	faketime=plst=0.0;
-	psrdm=period=-1.0;
-	pdot=accn=0.0;
-	pulse=0.0;
-	snr=1.0;
-	dc=0.04;
-	evenodd=swapout=0;
-	headerless=0;
-	
-	usebinary = 0;
-	binaryParams.orbitalPeriod = 36000; 	/* 10 hours */
-	binaryParams.eccentricity = 0.0;	/* Circular */
-	binaryParams.massPulsar = 1.4;
-	binaryParams.massCompanion = 5.0;
-	binaryParams.startPhase = 0.0;
-	binaryParams.inclination = 90.0; 	/* edge on to LOS */
-	binaryParams.omega = 0.0;
-	
-	
-	/* parse the command line if specified */
-	if (argc>1) {
-		i=1;
-		while (i<argc) {
-			if (strings_equal(argv[i],"-nchans")) {
-				i++;
-				nchans=atoi(argv[i]);
-			} else if (strings_equal(argv[i],"-period")) {
-				i++;
-				period=1.0e-3*atof(argv[i]);
-			} else if (strings_equal(argv[i],"-pdot")) {
-				i++;
-				pdot=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-accn")) {
-				i++;
-				accn=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-snrpeak")) {
-				i++;
-				snr=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-dm")) {
-				i++;
-				psrdm=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-width")) {
-				i++;
-				dc=atof(argv[i])/100.0;
-			} else if (strings_equal(argv[i],"-tsamp")) {
-				i++;
-				tsamp=1.0e-6*atof(argv[i]);
-			} else if (strings_equal(argv[i],"-tstart")) {
-				i++;
-				tstart=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-tobs")) {
-				i++;
-				obstime=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-nifs")) {
-				i++;
-				nifs=atoi(argv[i]);
-			} else if (strings_equal(argv[i],"-nbits")) {
-				i++;
-				nbits=atoi(argv[i]);
-			} else if (strings_equal(argv[i],"-fch1")) {
-				i++;
-				fch1=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-foff")) {
-				i++;
-				foff=atof(argv[i]);
-			} else if (strings_equal(argv[i],"-seed")) {
-				i++;
-				seed=atol(argv[i]);
-			} else if (strings_equal(argv[i],"-swapout")) {
-				swapout=1;
-			} else if (strings_equal(argv[i],"-nosmear")) {
-				smear=0;
-			} else if (strings_equal(argv[i],"-evenodd")) {
-				nbits=32;
-				evenodd=1;
-				smear=0;
-				psrdm=0.0;
-			} else if (strings_equal(argv[i],"-headerless")) {
-				headerless=1;
-			} else if (strings_equal(argv[i],"-binary")) {
-				usebinary=1;
-			} else if (strings_equal(argv[i],"-bper")) {
-				i++;
-				binaryParams.orbitalPeriod = 3600*atof(argv[i]);
-			} else if (strings_equal(argv[i],"-becc")) {
-				i++;
-				binaryParams.eccentricity = atof(argv[i]);
-			} else if (strings_equal(argv[i],"-binc")) {
-				i++;
-				binaryParams.inclination =  atof(argv[i]);
-			} else if (strings_equal(argv[i],"-bomega")) {
-				i++;
-				binaryParams.omega = (PI/180.0)*atof(argv[i]);
-			} else if (strings_equal(argv[i],"-bphase")) {
-				i++;
-				binaryParams.startPhase = atof(argv[i]);
-			} else if (strings_equal(argv[i],"-bpmass")) {
-				i++;
-				binaryParams.massPulsar = atof(argv[i]);
-			} else if (strings_equal(argv[i],"-bcmass")) {
-				i++;
-				binaryParams.massCompanion = atof(argv[i]);
-	
-			} else {
-				/* unknown argument passed down - stop! */
-				fake_help();
-				sprintf(string,"unknown argument (%s) passed to fake.",argv[i]);
-				error_message(string);
-			}
-			i++;
-		}
-	}
-
-	/* get seed from ship's clock if not set */
-	if (seed == -1) seed = startseed();
-
-	/* get random period between 1 ms and 1 s if not set */
-	if (period < 0.0) period=flat(1.0e-3,1.0,&seed);
-
-	/* get random DM between 1  and 1000 pc/cc if not set */
-	if (psrdm < 0.0) psrdm=flat(1.0,1.0e3,&seed);
-
-	/* make sure first channel is always highest frequency i.e. foff<0 */
-	if (foff > 0.0) foff*=-1.0;
-
-	if (smear && period > 0.0) {
-		/* DM smearing time in seconds (small channel approximation) */
-		tdm=8.3e3*psrdm*foff/fch1/fch1/fch1;
-		dc*=period;
-		dc=sqrt(tdm*tdm+tsamp*tsamp+dc*dc);
-		dc/=period;
-	}
-
-	/* set pulse window if the data are correctly dedispersed then phase=0.5 */
-	rising=0.5-dc/2.0;
-	trailing=0.5+dc/2.0;
-
-	/* get dm shift times */
-	shift=(double *) malloc(sizeof(double)*nchans);
-	for (c=0;c<nchans;c++) {
-		shift[c]=dmdelay(fch1,fch1+((double)c*foff),psrdm);
-	}
-
-	/* scale single-pulse signal to noise by number of channels */
-	snr/=sqrt((double) nchans);
-	if (snr > 1.0) max*=snr;
-
-	/* define the data blocks */
-	arraysize=nchans*nifs*nsblk;
-	fblock=(float *) malloc(sizeof(float)*arraysize);
-	sblock=(unsigned short *) malloc(sizeof(unsigned short)*arraysize);
-	cblock=(unsigned char *) malloc(sizeof(unsigned char)*arraysize);
-
-
-	/* open up logfile */
-	open_log("fake.monitor");
-	update_log("starting");
-
-	if (!headerless) {
-		/* broadcast header */
-		if (evenodd) {
-			strcpy(source_name,"Even-Odd channel test");
-		} else {
-			sprintf(source_name,"P: %.12f ms, DM: %.3f",period*1000.0,psrdm);
-		}
-		send_string("HEADER_START");
-		send_string("source_name");
-		send_string(source_name);
-		send_int("machine_id",machine_id);
-		send_int("telescope_id",telescope_id);
-		if (nchans > 1) { 
-			send_int("data_type",1);
-		} else {
-			send_int("data_type",2); 
-			send_double("refdm",psrdm);
-		}
-		send_double("fch1",fch1);
-		send_double("foff",foff);
-		send_int("nchans",nchans);
-		send_int("nbits",nbits);
-		send_double("tstart",tstart);
-		send_double("tsamp",tsamp);
-		send_int("nifs",nifs);
-		send_string("HEADER_END");
-	}
-	nexttime=timestep=1.0;
-	ic=nifs*nchans;
-
-	p0=period;
-	if (accn != 0.0) p0=period/(1.0+accn*obstime/2.0/speed_of_light);
-	period=p0;
-
-	/* main loop */
-	do  {
-		if (faketime>nexttime) {
-			sprintf(string,"faketime: %.1f speriod: %.12f",nexttime,period);
-			update_log(string);
-			nexttime+=timestep;
-		}
-		for (s=0;s<nsblk;s++) {
-			faketime+=tsamp;
-			for (i=0;i<nifs;i++) {
-				for (c=0;c<nchans;c++) {
-					if (evenodd) {
-						fblock[s*ic+i*nchans+c]=(float)(c%2);
-					} else {
-						if (period > 0.0) {
-							pulsephase=(faketime+shift[c])/period;
-							pulsephase=pulsephase-floor(pulsephase);
-							if ( (pulsephase>=rising) && (pulsephase<=trailing) ) {
-								pulse=snr;
-							} else {
-								pulse=0.0;
-							}
-							if (plst>pulsephase) {
-								if (pdot != 0.0) period=p0+pdot*faketime;
-								if (accn != 0.0) period=p0*(1.0+accn*faketime/speed_of_light);
-								if (usebinary)   period = binary_papp(binaryParams, p0, faketime);
-							}
-							plst=pulsephase;
-						}
-						fblock[s*ic+i*nchans+c]=gasdev(&seed)+pulse;
-					}
-				}
-			}
-		}
-		/* write out a block */
-		switch (nbits) {
-			case 32:
-				if (swapout) for (i=0; i<arraysize; i++) swap_float(&fblock[i]);
-				fwrite(fblock,sizeof(float),arraysize,output);
-				break;
-			case 16:
-				float2short(fblock,arraysize,min,max,sblock);
-				if (swapout) for (i=0; i<arraysize; i++) swap_short(&sblock[i]);
-				fwrite(sblock,sizeof(unsigned short),arraysize,output);
-				break;
-			case 8:
-				float2char(fblock,arraysize,min,max,cblock);
-				fwrite(cblock,sizeof(unsigned char),arraysize,output);
-				break;
-			case 4:
-				float2four(fblock,arraysize,min,max,cblock);
-				fwrite(cblock,sizeof(unsigned char),arraysize/2,output);
-				break;
-			default:
-				sprintf(string,"fake cannot quantize data to %d bits",nbits);
-				error_message(string);
-				break;
-		}
-	} while (faketime < obstime);
-
-	/* all done, update log, close all files and exit normally */
-	update_log("finished");
-	close_log();
-	fclose(output);  
-	free(fblock);free(cblock);free(sblock);
-	exit(0);
-}
-
-
-
-
-/* 
- *  * A function for tuning the apparent period of the pulsar if it were in a binary system
- *   * 
- *    * M Keith, R Eatough 2006
- *     */
-double binary_papp(struct BinaryParams params,double pRest, double time){
-	
-	double pApp;
-
-	double meanAnomaly;
-	double eccentricAnomaly;
-	double trueAnomaly;
-
-	double massFunction;
-	double asini;
-	double omegaB;
-	double t0;
-
-	double velocity;
-
-	double eNext;
-	double incl;
-
-	int i;
-
-	incl = params.inclination * (PI/180);
-
-	omegaB = 2.0 * PI / params.orbitalPeriod;
-	t0 = params.startPhase * params.orbitalPeriod;
-
-	massFunction = pow((params.massCompanion * sin(incl)),3)/pow((params.massCompanion+params.massPulsar),2);
-
-
-
-	
-	asini=pow(( M_SUN *massFunction * G * params.orbitalPeriod * params.orbitalPeriod / (4.0*PI*PI)),0.333333333333);
-		
-	  
-
-/* 
- * Solve for the Excentric Anomoly.
- *
- * meanAnomoly, M = E - e*sin(E) = omageB * (t-t0)
- *
- */
-
-	meanAnomaly = omegaB * (time-t0);
-
-/* 
- * Need a better start point than this!!!!
- */
-	
-	eccentricAnomaly = meanAnomaly;
-
-	
-	for(i = 0 ; i < 10 ; i++){
-		
-		eNext = eccentricAnomaly - (eccentricAnomaly - params.eccentricity * sin(eccentricAnomaly) - meanAnomaly)
-			/
-			(1.0 - params.eccentricity*cos(eccentricAnomaly));
-		
-		if(fabs(eNext - eccentricAnomaly) < 1.0e-10) break;
-	}
-
-
-
-	trueAnomaly = 2.0 * atan(
-			sqrt(
-				(1.0 + params.eccentricity)
-				/
-				(1.0 - params.eccentricity)
-			) * tan(eccentricAnomaly/2.0)
-		);
-
-	
-	velocity = omegaB
-		* (asini / (sqrt(1.0 - pow(params.eccentricity,2))))
-		* (cos(params.omega + trueAnomaly) + params.eccentricity * cos(params.omega));	
-			
-
-	
-	pApp = pRest * (1.0 + (velocity / SPEED_OF_LIGHT));
-
-			
-	return pApp;
-
-
-
-
-
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-	
-
diff --git a/filterbank-gmrt/fetch_hdrval.c b/filterbank-gmrt/fetch_hdrval.c
deleted file mode 100644
index 834a6dc..0000000
--- a/filterbank-gmrt/fetch_hdrval.c
+++ /dev/null
@@ -1,27 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <math.h>
-#include <strings.h>
-#include "wapp_header.h"
-#include "key.h"
-
-struct WAPP_HEADER head;
-/*--------------------------------------------------------------*
- * Generic Conversion from HEADEREP to write into 
- *  a destination.
- *--------------------------------------------------------------*/
-int fetch_hdrval(struct HEADERP *h,char *name,void *dest,int ndest) 
-{
-  struct HEADERVAL hdrval;
-  int nsrc;
-  bzero(dest,ndest);
-  if( find_hdrval(h,name,&hdrval))
-  {
-    /*fprintf(stderr,"Error Finding header value: %s\n",name);*/
-    return(0);
-  }
-  nsrc = hdrval.key->alen * hdrval.key->len;
-  bcopy(hdrval.value,dest,(ndest<nsrc)?ndest:nsrc);
-  return(1);
-}
diff --git a/filterbank-gmrt/ffft.f b/filterbank-gmrt/ffft.f
deleted file mode 100644
index 45e9b8e..0000000
--- a/filterbank-gmrt/ffft.f
+++ /dev/null
@@ -1,71 +0,0 @@
-C @(#)ffft.f	1.1 9/7/90
-	subroutine ffft(d,npts,isign,ireal)
-
-C  Fourier transform of length npts=2**k, performed in place.
-C  Input data in array d, treated as complex if ireal=0, and as real if ireal=1.
-C  In either case the transform values are returned in array d, treated as
-C  complex. The DC term is d(1), and d(npts/2+1) is the term at the Nyquist
-C  frequency.  The basic algorithm is the same as Norm Brenner's FOUR1, and
-C  uses radix-2 transforms.
-
-C  J. H. Taylor, Princeton University.
-
-	parameter(MAXSAM=8192)
-	complex d(MAXSAM),t,w,wstep,tt,uu
-	data pi/3.14159265/
-
-C  Shuffle the data to bit-reversed order.
-
-	imax=npts/(ireal+1)
-	irev=1
-	do 5 i=1,imax
-	if(i.ge.irev) go to 2
-	t=d(i)
-	d(i)=d(irev)
-	d(irev)=t
-2	mmax=imax/2
-3	if(irev.le.mmax) go to 5
-	irev=irev-mmax
-	mmax=mmax/2
-	if(mmax.ge.1) go to 3
-5	irev=irev+mmax
-
-C  The radix-2 transform begins here.
-
-	api=isign*pi/2.
-	mmax=1
-6	istep=2*mmax
-	wstep=cmplx(-2.*sin(api/mmax)**2,sin(2.*api/mmax))
-	w=1.
-	do 9 m=1,mmax
-
-C  This in the inner-most loop -- optimization here is important!
-	do 8 i=m,imax,istep
-	t=w*d(i+mmax)
-	d(i+mmax)=d(i)-t
-8	d(i)=d(i)+t
-
-9	w=w*(1.+wstep)
-	mmax=istep
-	if(mmax.lt.imax) go to 6
-
-	if(ireal.eq.0) return
-
-C  Now complete the last stage of a doubled-up real transform.
-
-	jmax=imax/2 + 1
-	wstep=cmplx(-2.*sin(isign*pi/npts)**2,sin(isign*pi/imax))
-	w=1.0
-	d(imax+1)=d(1)
-
-	do 10 j=1,jmax
-	uu=cmplx(real(d(j))+real(d(2+imax-j)),aimag(d(j)) - 
-     +    aimag(d(2+imax-j)))
-	tt=w*cmplx(aimag(d(j))+aimag(d(2+imax-j)),-real(d(j)) +
-     +    real(d(2+imax-j)))
-	d(j)=uu+tt
-	d(2+imax-j)=conjg(uu-tt)
-10	w=w*(1.+wstep)
-
-	return
-	end
diff --git a/filterbank-gmrt/ffreq.c b/filterbank-gmrt/ffreq.c
deleted file mode 100644
index a049470..0000000
--- a/filterbank-gmrt/ffreq.c
+++ /dev/null
@@ -1,21 +0,0 @@
-#include<math.h>
-double ffreq(double tsamp, int npf, int fold, int k) /*includefile*/
-{
-/*
-  Returns the fluctuation frequency (Hz) of bin k in the amplitude
-  spectrum having npf points. Tsamp is the sampling interval
-  of the corresponding time domain data (seconds), whilst fold
-  refers to 1 plus the number of harmonic sums that have produced
-  the present spectrum. e.g fold=1 -> refers to the raw spectrum
-  fold=5 refers to 4 harmonic sums (16 harmonics).
-*/
-  return((double)k/(2.0*tsamp*(double)npf*pow(2.0,(double)(fold-1))));
-}
-int fbin(double tsamp, int npf, int fold, double freq) /*includefile*/
-/*
-  Mathematical inverse of the above routine - returns bin number for
-  given frequency
-*/
-{
-  return((int)(freq*(2.0*tsamp)*(double)npf*pow(2.0,(double)(fold-1))));
-}
diff --git a/filterbank-gmrt/fftdata.f b/filterbank-gmrt/fftdata.f
deleted file mode 100644
index c0a2240..0000000
--- a/filterbank-gmrt/fftdata.f
+++ /dev/null
@@ -1,693 +0,0 @@
-c=============================================================================
-      subroutine fftdata(llog)
-c=============================================================================
-c
-c     FFTs the time series using a call to Singleton's incore FFT routine
-c     NB since the time series is purely real need to do only
-c     and ntim/2 transform plus unscrambling with realtr.      
-c
-c     llog    - i4  - llogical unit number for all but warning messages.
-c
-c     Last edit: 97/12/16 -> dunc@mpifr-bonn.mpg.de
-c      
-c=============================================================================
-c
-      implicit none
-      include 'seek.inc'
-      integer n,llog
-      n=ntim/2
-      write(llog,*) 'FFT: (Singleton 1968)...'
-      call sglfft(series,series(2),n,n,n,2)
-      call realtr(series,series(2),n,2)
-      ntim=n*2
-      end
-c      
-c=============================================================================
-C @(#)fft.f	3.1 12/17/92
-*DECK FFT
-*
-*
-**********************************************************************
-*      FFT
-*  MULTIVARIATE COMPLEX FOURIER TRANSFORM, COMPUTED IN PLACE
-*    USING MIXED-RADIX FAST FOURIER TRANSFORM ALGORITHM.
-*  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968.
-*  ARRAYS A AND B ORIGINALLY HOLD THE REAL AND IMAGINARY
-*    COMPONENTS OF THE DATA, AND RETURN THE REAL AND
-*    IMAGINARY COMPONENTS OF THE RESULTING FOURIER COFFICIENTS.
-*  MULTIVARIATE DATA IS INDEXED ACCORDING TO THE FORTRAN
-*    ARRAY ELEMENT SUCCESSOR FUNCTION, WITHOUT LIMIT
-*    ON THE NUMBER OF IMPLIED MULTIPLE SUBSCRIPTS.
-*    THE SUBROUTINE IS CALLED ONCE FOR EACH VARIATE.
-*    THE CALLS FOR A MULTIVARIATE TRANSFORM MAY BE IN ANY ORDER.
-*  NTOT IS THE TOTAL NUMBER OF COMPLEX DATA VALUES.
-*  N IS THE DIMENSION OF THE CURRENT VARIABLE.
-*  NSPAN/N IS THE SPACING OF CONSECUTIVE VALUES
-*    WHILE INDEXING THE CURRENT VARIABLE.
-*  THE SIGN OF ISN DETERMINES THE SIGN OF THE COMPLEX
-*    EXPONENTIAL, AND THE MAGNITUDE OF ISN IS NORMALLY ONE.
-*  A TRI-VARIATE TRANSFORM WITH A(N1,N2,N3), B(N1,N2,N3)
-*    IS COMPUTED BY
-*      CALL SGLFFT(A,B,N1*N2*N3,N1,N1,1)
-*      CALL SGLFFT(A,B,N1*N2*N3,N2,N1*N2,1)
-*      CALL SGLFFT(A,B,N1*N2*N3,N3,N1*N2*N3,1)
-*  FOR A SINGLE-VARIATE TRANSFORM,
-*    NTOT = N = NSPAN = (NUMBER OF COMPLEX DATA VALUES), F.G.
-*      CALL SGLFFT(A,B,N,N,N,1)
-*  THE DATA MAY ALTERNATIVELY BE STORED IN A SINGLE COMPLEX
-*    ARRAY A, THEN THE MAGNITUDE OF ISN IS CHANGED TO TWO TO
-*    GIVE THE CORRECT INDEXING INCREMENT AND A(2) IS USED TO
-*    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
-*    VALUES, E.G.
-*      CALL SGLFFT(A,A(2),NTOT,N,NSPAN,2)
-*  ARRAYS AT(MAXF),CK(MAXF),BT(MAXF),SK(MAXF), AND NP(MAXP)
-*    ARE USED FOR TEMPORARY STORAGE.  IF THE AVAILABLE STORAGE
-*    IS INSUFFICIENT, THE PROGRAM IS TERMINATED BY A STOP.
-*    MAXF MUST BE .GE. THE MAXIMUM PRIME FACTOR OF N.
-*    MAXP MUST BE .GT. THE NUMBER OF PRIME FACTORS OF N.
-*    IN ADDITION, IF THE SQUARE-FREE PORTION K OF N HAS TWO OR
-*    MORE PRIME FACTORS, THEN MAXP MUST BE .GE. K-1.
-*  ARRAY STORAGE IN NFAC FOR A MAXIMUM OF 14/2 + 1 FACTORS OF N.
-*  IF N HAS MORE THAN ONE SQUARE-FREE FACTOR, THE PRODUCT OF THE
-*    SQUARE-FREE FACTORS MUST BE .LE. 210
-*  ARRAY STORAGE FOR MAXIMUM PRIME FACTOR OF 23
-*
-      SUBROUTINE SGLFFT(A,B,NTOT,N,NSPAN,ISN)
-*
-      DIMENSION A(1),B(1)
-      DIMENSION NFAC(14),NP(209)
-      DIMENSION AT(23),CK(23),BT(23),SK(23)
-      EQUIVALENCE (I,II)
-*----------------------------------------------------------------------
-*  THE FOLLOWING TWO CONSTANTS SHOULD AGREE WITH THE ARRAY DIMENSIONS.
-*
-      MAXF=23
-      MAXP=209
-      IF(N.LT.2) RETURN
-      INC=ISN
-      RAD=8.0*ATAN(1.0)
-      S72=RAD/5.0
-      C72=COS(S72)
-      S72=SIN(S72)
-      S120=SQRT(0.75)
-      IF(ISN.GE.0) GO TO 10
-      S72=-S72
-      S120=-S120
-      RAD=-RAD
-      INC=-INC
-   10 NT=INC*NTOT
-      KS=INC*NSPAN
-      KSPAN=KS
-      NN=NT-INC
-      JC=KS/N
-      RADF=RAD*FLOAT(JC)*0.5
-      I=0
-      JF=0
-*--------------------------------------------------------------------
-*  DETERMINE THE FACTORS OF N
-*
-      M=0
-      K=N
-      GO TO 20
-   15 M=M+1
-      NFAC(M)=4
-      K=K/16
-   20 IF(K-(K/16)*16.EQ.0) GO TO 15
-      J=3
-      JJ=9
-      GO TO 30
-   25 M=M+1
-      NFAC(M)=J
-      K=K/JJ
-   30 IF(MOD(K,JJ).EQ.0) GO TO 25
-      J=J+2
-      JJ=J**2
-      IF(JJ.LE.K) GO TO 30
-      IF(K.GT.4) GO TO 40
-      KT=M
-      NFAC(M+1)=K
-      IF(K.NE.1) M=M+1
-      GO TO 80
-   40 IF(K-(K/4)*4.NE.0) GO TO 50
-      M=M+1
-      NFAC(M)=2
-      K=K/4
-   50 KT=M
-      J=2
-   60 IF(MOD(K,J).NE.0) GO TO 70
-      M=M+1
-      NFAC(M)=J
-      K=K/J
-   70 J=((J+1)/2)*2+1
-      IF(J .LE. K) GO TO 60
-   80 IF(KT .EQ. 0) GO TO 100
-      J=KT
-   90 M=M+1
-      NFAC(M)=NFAC(J)
-      J=J-1
-      IF(J .NE. 0) GO TO 90
-*----------------------------------------------------------------------
-*  COMPUTE FOURIER TRANSFORM
-*
-  100 SD=RADF/FLOAT(KSPAN)
-      CD=2.0*SIN(SD)**2
-      SD=SIN(SD+SD)
-      KK=1
-      I=I+1
-      IF(NFAC(I) .NE. 2) GO TO 400
-*----------------------------------------------------------------------
-*  TRANSFORM FOR FACTOR OF 2 (INCLUDING ROTATION FACTOR)
-*
-      KSPAN=KSPAN/2
-      K1=KSPAN+2
-  210 K2=KK+KSPAN
-      AK=A(K2)
-      BK=B(K2)
-      A(K2)=A(KK)-AK
-      B(K2)=B(KK)-BK
-      A(KK)=A(KK)+AK
-      B(KK)=B(KK)+BK
-      KK=K2+KSPAN
-      IF(KK .LE. NN) GO TO 210
-      KK=KK-NN
-      IF(KK .LE. JC) GO TO 210
-      IF(KK .GT.KSPAN) GO TO 800
-  220 C1=1.0-CD
-      S1=SD
-  230 K2=KK+KSPAN
-      AK=A(KK)-A(K2)
-      BK=B(KK)-B(K2)
-      A(KK)=A(KK)+A(K2)
-      B(KK)=B(KK)+B(K2)
-      A(K2)=C1*AK-S1*BK
-      B(K2)=S1*AK+C1*BK
-      KK=K2+KSPAN
-      IF(KK .LT. NT) GO TO 230
-      K2=KK-NT
-      C1=-C1
-      KK=K1-K2
-      IF(KK .GT. K2) GO TO 230
-      AK=C1-(CD*C1+SD*S1)
-      S1=(SD*C1-CD*S1)+S1
-*---------------------------------------------------------------------
-*  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION
-*  ERROR.  IF ROUNDED ARITHMETIC IS USED, SUBSTITUTE
-*     C1=AK
-*
-      C1=AK
-C      C1=0.5/(AK**2+S1**2)+0.5
-C      S1=C1*S1
-C      C1=C1*AK
-      KK=KK+JC
-      IF(KK .LT. K2) GO TO 230
-      K1=K1+INC+INC
-      KK=(K1-KSPAN)/2+JC
-      IF(KK .LE. JC+JC) GO TO 220
-      GO TO 100
-*----------------------------------------------------------------------
-*  TRANSFORM FOR FACTOR OF 3 (OPTIONAL CODE)
-*
-  320 K1=KK+KSPAN
-      K2=K1+KSPAN
-      AK=A(KK)
-      BK=B(KK)
-      AJ=A(K1)+A(K2)
-      BJ=B(K1)+B(K2)
-      A(KK)=AK+AJ
-      B(KK)=BK+BJ
-      AK=-0.5*AJ+AK
-      BK=-0.5*BJ+BK
-      AJ=(A(K1)-A(K2))*S120
-      BJ=(B(K1)-B(K2))*S120
-      A(K1)=AK-BJ
-      B(K1)=BK+AJ
-      A(K2)=AK+BJ
-      B(K2)=BK-AJ
-      KK=K2+KSPAN
-      IF(KK .LT. NN) GO TO 320
-      KK=KK-NN
-      IF(KK .LE. KSPAN) GO TO 320
-      GO TO 700
-*---------------------------------------------------------------------
-*  TRANSFORM FOR FACTOR OF 4
-*
-  400 IF(NFAC(I) .NE. 4) GO TO 600
-      KSPNN=KSPAN
-      KSPAN=KSPAN/4
-  410 C1=1.0
-      S1=0
-  420 K1=KK+KSPAN
-      K2=K1+KSPAN
-      K3=K2+KSPAN
-      AKP=A(KK)+A(K2)
-      AKM=A(KK)-A(K2)
-      AJP=A(K1)+A(K3)
-      AJM=A(K1)-A(K3)
-      A(KK)=AKP+AJP
-      AJP=AKP-AJP
-      BKP=B(KK)+B(K2)
-      BKM=B(KK)-B(K2)
-      BJP=B(K1)+B(K3)
-      BJM=B(K1)-B(K3)
-      B(KK)=BKP+BJP
-      BJP=BKP-BJP
-      IF(ISN.LT.0) GO TO 450
-      AKP=AKM-BJM
-      AKM=AKM+BJM
-      BKP=BKM+AJM
-      BKM=BKM-AJM
-      IF(S1.EQ.0.0) GO TO 460
-  430 A(K1)=AKP*C1-BKP*S1
-      B(K1)=AKP*S1+BKP*C1
-      A(K2)=AJP*C2-BJP*S2
-      B(K2)=AJP*S2+BJP*C2
-      A(K3)=AKM*C3-BKM*S3
-      B(K3)=AKM*S3+BKM*C3
-      KK=K3+KSPAN
-      IF(KK.LE.NT) GO TO 420
-  440 C2=C1-(CD*C1+SD*S1)
-      S1=(SD*C1-CD*S1)+S1
-*----------------------------------------------------------------------
-*  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION
-*    ERROR.  IF ROUNDED ARITHMETIC IS USED, SUBSTITUTE
-*     C1=C2
-*
-      C1=C2
-C      C1=0.5/(C2**2+S1**2)+0.5
-C      S1=C1*S1
-C      C1=C1*C2
-      C2=C1**2-S1**2
-      S2=2.0*C1*S1
-      C3=C2*C1-S2*S1
-      S3=C2*S1+S2*C1
-      KK=KK-NT+JC
-      IF(KK.LE.KSPAN) GO TO 420
-      KK=KK-KSPAN+INC
-      IF(KK.LE.JC) GO TO 410
-      IF(KSPAN.EQ.JC) GO TO 800
-      GO TO 100
-  450 AKP=AKM+BJM
-      AKM=AKM-BJM
-      BKP=BKM-AJM
-      BKM=BKM+AJM
-      IF(S1.NE.0.0) GO TO 430
-  460 A(K1)=AKP
-      B(K1)=BKP
-      A(K2)=AJP
-      B(K2)=BJP
-      A(K3)=AKM
-      B(K3)=BKM
-      KK=K3+KSPAN
-      IF(KK.LE.NT) GO TO 420
-      GO TO 440
-*---------------------------------------------------------------------
-*  TRANSFORM FOR FACTOR OF 5 (OPTIONAL CODE)
-*
-  510 C2=C72**2-S72**2
-      S2=2.0*C72*S72
-  520 K1=KK+KSPAN
-      K2=K1+KSPAN
-      K3=K2+KSPAN
-      K4=K3+KSPAN
-      AKP=A(K1)+A(K4)
-      AKM=A(K1)-A(K4)
-      BKP=B(K1)+B(K4)
-      BKM=B(K1)-B(K4)
-      AJP=A(K2)+A(K3)
-      AJM=A(K2)-A(K3)
-      BJP=B(K2)+B(K3)
-      BJM=B(K2)-B(K3)
-      AA=A(KK)
-      BB=B(KK)
-      A(KK)=AA+AKP+AJP
-      B(KK)=BB+BKP+BJP
-      AK=AKP*C72+AJP*C2+AA
-      BK=BKP*C72+BJP*C2+BB
-      AJ=AKM*S72+AJM*S2
-      BJ=BKM*S72+BJM*S2
-      A(K1)=AK-BJ
-      A(K4)=AK+BJ
-      B(K1)=BK+AJ
-      B(K4)=BK-AJ
-      AK=AKP*C2+AJP*C72+AA
-      BK=BKP*C2+BJP*C72+BB
-      AJ=AKM*S2-AJM*S72
-      BJ=BKM*S2-BJM*S72
-      A(K2)=AK-BJ
-      A(K3) = AK+BJ
-      B(K2)=BK+AJ
-      B(K3)=BK-AJ
-      KK = K4+KSPAN
-      IF(KK.LT.NN) GO TO 520
-      KK=KK-NN
-      IF(KK.LE.KSPAN) GO TO 520
-      GO TO 700
-*----------------------------------------------------------------------
-*  TRANSFORM FOR ODD FACTORS
-*
-  600 K=NFAC(I)
-      KSPNN=KSPAN
-      KSPAN=KSPAN/K
-      IF(K.EQ.3) GOTO 320
-      IF(K.EQ.5) GOTO 510
-      IF(K.EQ.JF) GOTO 640
-      JF = K
-      S1=RAD/FLOAT(K)
-      C1=COS(S1)
-      S1=SIN(S1)
-      IF(JF.GT.MAXF) GOTO 998
-      CK(JF)=1.0
-      SK(JF)=0.0
-      J=1
-  630 CK(J)=CK(K)*C1+SK(K)*S1
-      SK(J)=CK(K)*S1-SK(K)*C1
-      K=K-1
-      CK(K)=CK(J)
-      SK(K)=-SK(J)
-      J = J + 1
-      IF(J.LT.K) GOTO 630
-  640 K1=KK
-      K2=KK+KSPNN
-      AA=A(KK)
-      BB=B(KK)
-      AK=AA
-      BK=BB
-      J=1
-      K1=K1+KSPAN
-  650 K2=K2-KSPAN
-      J=J+1
-      AT(J)=A(K1)+A(K2)
-      AK=AT(J)+AK
-      BT(J)=B(K1)+B(K2)
-      BK=BT(J)+BK
-      J=J+1
-      AT(J)=A(K1)-A(K2)
-      BT(J)=B(K1)-B(K2)
-      K1=K1+KSPAN
-      IF(K1.LT.K2) GOTO 650
-      A(KK)=AK
-      B(KK)=BK
-      K1=KK
-      K2=KK+KSPNN
-      J=1
-  660 K1=K1+KSPAN
-      K2=K2-KSPAN
-      JJ=J
-      AK=AA
-      BK=BB
-      AJ=0.0
-      BJ=0.0
-      K=1
-  670 K = K+1
-      AK=AT(K)*CK(JJ)+AK
-      BK=BT(K)*CK(JJ)+BK
-      K=K+1
-      AJ=AT(K)*SK(JJ)+AJ
-      BJ=BT(K)*SK(JJ)+BJ
-      JJ=JJ+J
-      IF(JJ.GT.JF) JJ=JJ-JF
-      IF(K.LT.JF) GOTO 670
-      K=JF-J
-      A(K1)=AK-BJ
-      B(K1)=BK+AJ
-      A(K2)=AK+BJ
-      B(K2)=BK-AJ
-      J=J+1
-      IF(J.LT. K) GOTO 660
-      KK=KK+KSPNN
-      IF(KK.LE.NN) GOTO 640
-      KK=KK-NN
-      IF(KK.LE.KSPAN) GOTO 640
-*---------------------------------------------------------------------
-*  MULTIPLY BY ROTATION FACTOR (EXCEPT FOR FACTORS OF 2 AND 4)
-*
-  700 IF(I.EQ.M) GOTO 800
-      KK=JC+1
-  710 C2=1.0-CD
-      S1=SD
-  720 C1=C2
-      S2=S1
-      KK=KK+KSPAN
-  730 AK=A(KK)
-      A(KK)=C2*AK-S2*B(KK)
-      B(KK)=S2*AK+C2*B(KK)
-      KK=KK+KSPNN
-      IF(KK.LE.NT) GOTO 730
-      AK=S1*S2
-      S2=S1*C2+C1*S2
-      C2=C1*C2-AK
-      KK=KK-NT+KSPAN
-      IF(KK.LE.KSPNN) GOTO 730
-      C2=C1-(CD*C1+SD*S1)
-      S1=S1+(SD*C1-CD*S1)
-*---------------------------------------------------------------------
-*  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION
-*    ERROR.  IF ROUNDED ARITHMETIC IS USED, THEY MAY
-*    BE DELETED.
-*
-C      C1=0.5/(C2**2+S1**2)+0.5
-C      S1=C1*S1
-C      C2=C1*C2
-      KK=KK-KSPNN+JC
-      IF(KK.LE.KSPAN) GOTO 720
-      KK=KK-KSPAN+JC+INC
-      IF(KK.LE.JC+JC) GOTO 710
-      GOTO 100
-*----------------------------------------------------------------------
-*  PERMUTE THE RESULTS TO NORMAL ORDER---DONE IN TWO STAGES
-*  PERMUTATION FOR SQUARE FACTORS OF N
-*
-  800 NP(1)=KS
-      IF (KT.EQ. 0) GOTO 890
-      K=KT+KT+1
-      IF(M.LT.K) K=K-1
-      J=1
-      NP(K+1)=JC
-  810 NP(J+1)=NP(J)/NFAC(J)
-      NP(K)=NP(K+1)*NFAC(J)
-      J=J+1
-      K=K-1
-      IF(J.LT.K) GOTO 810
-      K3=NP(K+1)
-      KSPAN=NP(2)
-      KK=JC+1
-      K2=KSPAN+1
-      J=1
-      IF(N.NE.NTOT) GOTO 850
-*---------------------------------------------------------------------
-*  PERMUTATION FOR SINGLE-VARIATE TRANSFORM (OPTIONAL CODE)
-*
-  820 AK=A(KK)
-      A(KK)=A(K2)
-      A(K2)=AK
-      BK=B(KK)
-      B(KK)=B(K2)
-      B(K2)=BK
-      KK=KK+INC
-      K2=KSPAN+K2
-      IF(K2.LT.KS) GOTO 820
-  830 K2=K2-NP(J)
-      J=J+1
-      K2=NP(J+1)+K2
-      IF(K2.GT.NP(J)) GOTO 830
-      J=1
-  840 IF(KK.LT.K2) GOTO 820
-      KK=KK+INC
-      K2=KSPAN+K2
-      IF(K2.LT.KS ) GOTO 840
-      IF(KK .LT. KS) GOTO 830
-      JC = K3
-      GOTO 890
-*---------------------------------------------------------------------
-*  PERMUTATION FOR MULTI-VARIATE TRANSFORM
-*
-  850 K=KK+JC
-  860 AK=A(KK)
-      A(KK)=A(K2)
-      A(K2)=AK
-      BK=B(KK)
-      B(KK)=B(K2)
-      B(K2)=BK
-      KK=KK+INC
-      K2=K2+INC
-      IF(KK.LT.K) GOTO 860
-      KK=KK+KS-JC
-      K2=K2+KS-JC
-      IF(KK.LT.NT) GOTO 850
-      K2=K2-NT+KSPAN
-      KK=KK-NT+JC
-      IF(K2.LT.KS) GOTO 850
-  870 K2=K2-NP(J)
-      J=J+1
-      K2=NP(J+1)+K2
-      IF(K2.GT.NP(J)) GOTO 870
-      J=1
-  880 IF(KK.LT.K2) GOTO 850
-      KK=KK+JC
-      K2=KSPAN+K2
-      IF(K2.LT.KS) GOTO 880
-      IF(KK.LT.KS) GOTO 870
-      JC=K3
-  890 IF(2*KT+1 .GE. M) RETURN
-      KSPNN=NP(KT+1)
-*---------------------------------------------------------------------
-*  PERMUTATION FOR SQUARE-FREE FACTORS OF N
-*
-      J=M-KT
-      NFAC(J+1)=1
-  900 NFAC(J)=NFAC(J)*NFAC(J+1)
-      J=J-1
-      IF(J.NE.KT) GOTO 900
-      KT=KT+1
-      NN=NFAC(KT)-1
-      IF(NN.GT.MAXP) GOTO 998
-      JJ=0
-      J=0
-      GOTO 906
-  902 JJ=JJ-K2
-      K2=KK
-      K=K+1
-      KK=NFAC(K)
-  904 JJ=KK+JJ
-      IF(JJ.GE.K2) GOTO 902
-      NP(J) = JJ
-  906 K2=NFAC(KT)
-      K=KT+1
-      KK=NFAC(K)
-      J=J+1
-      IF(J.LE.NN) GOTO 904
-*----------------------------------------------------------------------
-*  DETERMINE THE PERMUTATION CYCLES OF LENGTH GREATER THAN 1
-*
-      J=0
-      GOTO 914
-  910 K=KK
-      KK=NP(K)
-      NP(K)=-KK
-      IF(KK.NE.J) GOTO 910
-      K3=KK
-  914 J=J+1
-      KK=NP(J)
-      IF(KK.LT.0) GOTO 914
-      IF(KK.NE.J) GOTO 910
-      NP(J)=-J
-      IF(J.NE.NN) GOTO 914
-      MAXF=INC*MAXF
-*----------------------------------------------------------------------
-*  REORDER A AND B, FOLLOWING THE PERMUTATION CYCLES
-*
-      GO TO 950
-  924 J=J-1
-      IF(NP(J) .LT. 0) GO TO 924
-      JJ=JC
-  926 KSPAN=JJ
-      IF(JJ .GT. MAXF) KSPAN=MAXF
-      JJ=JJ-KSPAN
-      K=NP(J)
-      KK=JC*K+II+JJ
-      K1=KK+KSPAN
-      K2=0
-  928 K2=K2+1
-      AT(K2)=A(K1)
-      BT(K2)=B(K1)
-      K1=K1-INC
-      IF(K1 .NE. KK) GO TO 928
-  932 K1=KK+KSPAN
-      K2=K1-JC*(K+NP(K))
-      K=-NP(K)
-  936 A(K1)=A(K2)
-      B(K1)=B(K2)
-      K1=K1-INC
-      K2=K2-INC
-      IF(K1 .NE. KK) GO TO 936
-      KK=K2
-      IF(K .NE. J) GO TO 932
-      K1=KK+KSPAN
-      K2=0
-  940 K2=K2+1
-      A(K1)=AT(K2)
-      B(K1)=BT(K2)
-      K1=K1-INC
-      IF(K1 .NE. KK) GO TO 940
-      IF(JJ .NE. 0) GO TO 926
-      IF(J .NE. 1) GO TO 924
-  950 J=K3+1
-      NT=NT-KSPNN
-      II=NT-INC+1
-      IF(NT .GE. 0) GO TO 924
-      RETURN
-*--------------------------------------------------------------------
-*  ERROR FINISH, INSUFFICIENT ARRAY STORAGE
-*
-  998 ISN=0
-      PRINT 999
-999   FORMAT(' FFT ARRAY DIMENSION OUT OF RANGE')
-      RETURN
-      END
-      SUBROUTINE REALTR(A,B,N,ISN)
-C  IF ISN=1, THIS SUBROUTINE COMPLETES THE FOURIER TRANSFORM
-C    OF 2*N REAL DATA VALUES, WHERE THE ORIGINAL DATA VALUES ARE
-C    STORED ALTERNATELY IN ARRAYS A AND B, AND ARE FIRST
-C    TRANSFORMED BY A COMPLEX FOURIER TRANSFORM OF DIMENSION N.
-C    THE COSINE COEFFICIENTS ARE IN A(1),A(2),...A(N+1) AND
-C    THE SINE COEFFICIENTS ARE IN B(1),B(2),...B(N+1).
-C    A TYPICAL CALLING SEQUENCE IS
-C      CALL SGLFFT(A,B,N,N,N,1)
-C      CALL REALTR(A,B,N,1)
-C    THE RESULTS SHOULD BE MULTIPLIED BY 0.5/N TO GIVE THE
-C    USUAL SCALING OF COEFFICIENTS.
-C  IF ISN=-1, THE INVERSE TRANSFORM IS DONE, THE FIRST STEP
-C    IN EVALUATING A REAL FOURIER SERIES.
-C    A TYPICAL CALLING SEQUENCE IS
-C      CALL REALTR(A,B,N,-1)
-C      CALL SGLFFT(A,B,N,N,N,-1)
-C    THE RESULTS SHOULD BE MULTIPLIED BY 0.5 TO GIVE THE USUAL
-C    SCALING,AND THE TIME DOMAIN RESULTS ALTERNATE IN ARRAYS A
-C    AND B, I.E. A(1),B(1),A(2),B(2),...A(N),B(N).
-C  THE DATA MAY ALTERNATELY BE STORED IN A SINGLE COMPLEX
-C    ARRAY A, THEN THE MAGNITUDE OF ISN IS CHANGED TO 2 TO
-C    GIVE THE CORRECT INDEXING INCREMENT AND A(2) USED TO
-C    PASS THE INITIAL ADDRESS FOR THE SEQUENCE OF IMAGINARY
-C    VALUES, E.G.
-C      CALL SGLFFT(A,A(2),N,N,N,2)
-C      CALL REALTR(A,A(2),N,2)
-C    IN THIS CASE THE COSINE AND SINE COEFFICIENTS ALTERNATE IN A.
-C  BY R. C. SINGLETON, STANFORD RESEARCH INSTITUTE, OCT. 1968.
-      DIMENSION A(1),B(1)
-      REAL IM
-      INC=IABS(ISN)
-      NK=N*INC+2
-      NH=NK/2
-      SD=2.0*ATAN(1.0)/FLOAT(N)
-      CD=2.0*SIN(SD)**2
-      SD=SIN(SD+SD)
-      SN=0.0
-      IF(ISN.LT.0) GO TO 30
-      CN=1.0
-      A(NK-1)=A(1)
-      B(NK-1)=B(1)
-10    DO 20 J=1,NH,INC
-      K=NK-J
-      AA=A(J)+A(K)
-      AB=A(J)-A(K)
-      BA=B(J)+B(K)
-      BB=B(J)-B(K)
-      RE=CN*BA+SN*AB
-      IM=SN*BA-CN*AB
-      B(K)=IM-BB
-      B(J)=IM+BB
-      A(K)=AA-RE
-      A(J)=AA+RE
-      AA=CN-(CD*CN+SD*SN)
-      SN=(SD*CN-CD*SN)+SN
-C  THE FOLLOWING THREE STATEMENTS COMPENSATE FOR TRUNCATION
-C    ERROR.  IF ROUNDED ARITHMETIC IS USED, SUBSTITUTE
- 20    CN=AA
-*      CN=0.5/(AA**2+SN**2)+0.5
-*      SN=CN*SN
-*20    CN=CN*AA
-      RETURN
-30    CN=-1.0
-      SD=-SD
-      GO TO 10
-      END
diff --git a/filterbank-gmrt/file_exists.c b/filterbank-gmrt/file_exists.c
deleted file mode 100644
index 00492b9..0000000
--- a/filterbank-gmrt/file_exists.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <stdio.h>
-int file_exists(char *filename) /*includefile*/
-{
-  if ((fopen(filename,"rb"))==NULL) {
-	return(0);
-  } else {
-	return(1);
-  }
-}
diff --git a/filterbank-gmrt/filterbank.c b/filterbank-gmrt/filterbank.c
deleted file mode 100644
index c3005ed..0000000
--- a/filterbank-gmrt/filterbank.c
+++ /dev/null
@@ -1,341 +0,0 @@
-/*
-  FILTERBANK  - convert raw data from a pulsar machine into "filterbank data"
-  a stream of samples: [s1,c1] [s1,c2]...[s1,cn] [s2,c1]...[s2,cn]..... etc
-  where the indices s1, s2.... are individual sample readouts and c1, c2.... 
-  are the individual channels. For each readout, there are "n" channels.
-  Before writing out a stream of samples, filterbank sends a header string
-  which is intercepted by other programs (dedisperse, fold etc) downstream.
-  (N.B. The header can be omitted using the -headerfile command-line option)
-*/
-#include "filterbank.h"
-int data_fmt=0;
-
-int wapp_isalfa;
-
-main (int argc, char *argv[])
-{
-  int i,nfiles,fileidx,fileidx_start,inputdata,opened=0;
-  char message[80];
-  int numsamps;
-  int bpp_headersize = 32768;
-  float f;
-  int sample_end,fileidx_final,byte_end,bytefinal;
-  double sample_final,scantime;
-  int data_size,sample_skip,bytestart,ns,blocksize;
-  double sample_start;
-  
-  /* check number of command-line arguments */
-  if (argc<2) {
-    filterbank_help();
-    exit(0);
-  } else {
-    print_version(argv[0],argv[1]);
-  }
- 
-  /* print help if necessary */
-  if (help_required(argv[1])) {
-    filterbank_help();
-    exit(0);
-  }
- 
-
-  /* set up default global variables */
-  hanning=hamming=zerolagdump=swapout=sumifs=headerless=headerfile=0;
-  wapp_isalfa=invert_band=clip_threshold=headeronly=0;
-  time_offset=start_time=final_time=0.0;
-  obits=-1;
-  do_vanvleck=compute_spectra=1;
-  strcpy(ifstream,"XXXX");
-
-  /* work out how many files are on the command line */
-  i=1;
-  nfiles=0;
-  while(file_exists(argv[i])) {
-	nfiles++;
-	i++;
-  }
-  if (!nfiles) error_message("no input files supplied on command line!");
-  fileidx=1;
-
-  /* now parse any remaining command line parameters */
-  if (argc>nfiles) {
-    i=nfiles+1;
-    while (i<argc) {
-      if (strings_equal(argv[i],"-o")) {
-	/* get and open file for output */
-	strcpy(outfile,argv[++i]);
-	output=fopen(outfile,"wb");
-	opened=1;
-      } else if (strings_equal(argv[i],"-c")) {
-	/* get clip threshold (sigma) */
-	clip_threshold=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-s")) {
-	/* get starting time (s) */
-	start_time=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-r")) {
-	/* get time to read (s) this is adjusted below if skipping */
-	final_time=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-n")) {
-	/* output number of bits per sample to write */
-	obits=atoi(argv[++i]);
-      } else if (strings_equal(argv[i],"-dt")) {
-	/* add a time offset in seconds to tstart */
-	time_offset=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-i")) {
-	/* flag IF stream to write */
-	i++;
-	if (atoi(argv[i])<1 || atoi(argv[i])>4) {
-	  error_message("IFstream must lie between 1 and 4");
-	}
-	ifstream[atoi(argv[i])-1]='Y';
-      } else if (strings_equal(argv[i],"-swapout")) {
-	/* perform byte swapping on all output data */
-	swapout=1;
-      } else if (strings_equal(argv[i],"-floats")) {
-	/* write data as floating point numbers */
-	obits=32;
-      } else if (strings_equal(argv[i],"-sumifs")) {
-	/* sum IFs if necessary */
-	sumifs=1;
-      } else if (strings_equal(argv[i],"-zerolag")) {
-	/* zerolagdump used for correlators e.g. WAPP */
-	zerolagdump=1;
-	obits=32;
-      } else if (strings_equal(argv[i],"-rawcfs")) {
-	/* write correlation functions only */
-	compute_spectra=do_vanvleck=0;
-      } else if (strings_equal(argv[i],"-corcfs")) {
-	/* write corrected correlation functions */
-	compute_spectra=0;
-	do_vanvleck=1;
-      } else if (strings_equal(argv[i],"-novanvleck")) {
-	/* don't apply van vleck correction */
-	do_vanvleck=0;
-      } else if (strings_equal(argv[i],"-invert")) {
-	/* invert the band after FFT */
-	invert_band=1;
-      } else if (strings_equal(argv[i],"-hamming")) {
-	/* Hamming smoothing */
-	hamming=1;
-	hanning=0;
-      } else if (strings_equal(argv[i],"-hanning")) {
-	/* Hanning smoothing */
-	hanning=1;
-	hamming=0;
-      } else if (strings_equal(argv[i],"-headerfile")) {
-	/* no binary headers but write data to "head" file */
-	headerless=headerfile=1;
-      } else if (strings_equal(argv[i],"-headeronly")) {
-	/* only binary header written */
-	headeronly=1;
-      } else if (strings_equal(argv[i],"-ts")) {
-	tsamp=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-rf")) {
-	fch1 =atof(argv[++i]) ;
-      } else if (strings_equal(argv[i],"-bw")) {
-	foff =atof(argv[++i]) ;
-      } else if (strings_equal(argv[i],"-nch")) {
-	nchans =atof(argv[++i]) ;
-      } else if (strings_equal(argv[i],"-mjd")) {
-        tstart =atof(argv[++i]) ;
-      } else if (strings_equal(argv[i],"-df")) {
-	/* type of gmrt dataformat */
-	/* printf("%s %s\n", argv[i], argv[i+1]); */
-	fflush(stdout);
-	if (strings_equal(argv[i+1],"gmusb256")) {
-	  data_fmt = 0;
-	} else if (strings_equal(argv[i+1],"gmusb512")) {
-	  data_fmt = 1;
-	} else if (strings_equal(argv[i+1],"gmlsb256")) {
-	  data_fmt = 2;
-	} else if (strings_equal(argv[i+1],"gmlsb256235")) {
-	  data_fmt = 3;
-	} else if (strings_equal(argv[i+1],"gmusb")) {
-	  data_fmt = 4;
-	} else if (strings_equal(argv[i+1],"gmlsb")) {
-	  data_fmt = 5;
-	} else if (strings_equal(argv[i+1],"gmusbbw")) {
-	  data_fmt = 6;
-	} else if (strings_equal(argv[i+1],"gmlsbbw")) {
-	  data_fmt = 7;
-        } else if (strings_equal(argv[i+1],"gmboth")) {
-          data_fmt = 8;
-	} else if (strings_equal(argv[i+1],"gmgsb32512")) {
-	  data_fmt = 9;
-	} else if (strings_equal(argv[i+1],"gmgwbr")) {
-	  data_fmt = 10;
-	} else if (strings_equal(argv[i+1],"gmgwbf")) {
-	  data_fmt = 11;
-	}
-	i++;i++;
-      } else {
-	/* unknown argument passed down - stop! */
-	filterbank_help();
-	sprintf(message,"unknown argument (%s) passed to filterbank.",argv[i]);
-	error_message(message);
-      }
-      i++;
-    }
-  }
-
-  /* if no IF streams selected, flag all */
-  if (strings_equal(ifstream,"XXXX")) strcpy(ifstream,"YYYY");
-
-  /* adjust finish time if necessary */
-  if (final_time > 0.0) final_time+=start_time;
-
-  if (!opened) {
-    /* no output file selected, use standard output */
-    output=stdout;
-    strcpy(outfile,"stdout");
-  }
-
-
-  fileidx_start = fileidx;
-  /* For BCPM data:  Test to see if the first input file is BCPM type*/
-  /* If the file type is not BCPM then close the file and continue normally */
-  /* open up the first input file*/
-  strcpy(inpfile,argv[fileidx]);
-  input=open_file(inpfile,"rb");
-  inputdata=typeof_inputdata(input,inpfile);
-  
-  /*Establish whether or not the file data type is BCPM*/
-  if (inputdata == 5) {
-    /* If the start time is not zero, find the file to start with */
-    data_size = sizeof_file(inpfile)-bpp_headersize;
-    scantime = (double)(data_size/((double)nchans/2)*(double)tsamp);
-    ns = 512;
-    blocksize = ns*(double)nchans/2;
-    
-    if(start_time) {
-      /* Calculate the no. of time samples */
-      /* Calculate the file corresponding to the start time */
-      fileidx_start = ceil(start_time/scantime);
-      sample_skip = floor(start_time/tsamp);
-      sample_start = sample_skip - (double)((fileidx_start-1)*(scantime/(double)tsamp));
-      bytestart = (sample_start*(double)nchans)/2.;
-
-      if(bytestart<blocksize/2){
-	fprintf(stderr,"bytestart is less than blocksize/2\n");
-	bytestart+=data_size-blocksize/2;
-	fileidx_start-=1;
-	sample_skip -= ns;
-	sample_start = sample_skip - (double)((fileidx_start-1)*(scantime/(double)tsamp));
-      }
-
-      fprintf(stderr,"Starting Time:  \n");
-      fprintf(stderr,"          Start File #              %2d\n",fileidx_start);
-      fprintf(stderr,"          Start Sample #  %12.3f\n",sample_start);
-      fprintf(stderr,"          Start Byte #    %12d\n",bytestart);
-      fprintf(stderr,"          Start Time (s)  %12.3f\n",sample_skip*(double)tsamp-(fileidx_start-1)*scantime);
-      fprintf(stderr,"\nAdvancing start time by   %12.5f\n\n",sample_skip*(double)tsamp);
-
-
-      fileidx = fileidx_start;
-    }
-    if(final_time) {
-      sample_end = ceil(final_time/(double)tsamp);
-      fileidx_final = ceil(final_time/scantime);
-      sample_final = sample_end-(double)((fileidx_final-1)*scantime/tsamp);
-      byte_end = sample_end*(double)nchans/2;
-      bytefinal = (double)sample_final*(double)nchans/2;
-      nfiles = fileidx_final;
-
-
-    }
-  }
-  fclose(input);
-
-  /* main loop around input files */
-  while (fileidx <= nfiles) {
-
-    /* open up input file */
-    strcpy(inpfile,argv[fileidx]);
-    input=open_file(inpfile,"rb");
-
-    /* open the raw data file and establish its origin and header pars */
-    if (!(inputdata=typeof_inputdata(input,inpfile)))
-    error_message("input data file is of unknown origin!!!");
-    /* check for timing data files - not processed here! */
-    switch (inputdata) {
-    case 2:
-      error_message("input data (PSPM timing mode) not read by this program!");
-      break;
-    case 4:
-      error_message("input data (WAPP timing mode) not read by this program!");
-      break;
-    case 6:
-      error_message("input data (BPP timing mode) not read by this program!");
-      break;
-    }
-
-    if (fileidx == fileidx_start) {
-  	/* add on a time offset in seconds to the start time */
-  	tstart+=time_offset/86400.0;
-  	/* broadcast the header */
-  	if (!wapp_isalfa) filterbank_header(output);
-	if (headeronly) exit(0);
-    }
-
-    /* now actually convert the raw data into filterbank format */
-    switch (inputdata) {
-    case 1: 
-      /* PSPM search-mode data */
-      pspm2fb(input,output);
-      break;
-    case 3:
-      /* WAPP fast-sampled data */
-      wapp2fb(input,output);
-      break;
-    case 5:
-      /* BPP fast-sampled data */
-      bpp2fb(input,output);
-      break;
-    case 7:
-      /* AOFTM fast-sampled data */
-      aoftm2fb(inpfile,output);
-      break;
-    case 8:
-      /* OOTY filterbank data */
-      ooty2fb(input,output);
-      break;
-    case 9:
-      /* SCAMP filterbank data */
-      scamp2fb(input,output);
-      break;
-    case 10:
-      /* GMRT filterbank data */
-      gmrt2fb(input,output);
-      break;
-    case 11:
-      /* GMRT filterbank data */
-      gmrt2fblsb(input,output);
-      break;
-    case 12 :
-       /* GMRT both SB filterbank data */
-      gmrt2fbusblsb(input,output);
-      break;
-    case 13 :
-      /* GMRT both SB filterbank data */
-      gmrt2fbgsb32512(input,output);
-      break;
-    case 14 :
-      /* GMRT GWB Higher LO reverseorder filterbank data */
-      gmrt2fbgwbr(input,output,nchans);
-      break;
-    case 15 :
-      /* GMRT GWB Lower LO forwardorder filterbank data */
-      gmrt2fbgwbf(input,output,nchans);
-      break;
-    }
-    fileidx++;
-    fclose(input);
-  }
-
-  /* all done, update log, close all files and exit normally */
-  update_log("finished");
-  close_log();
-  /*fclose(output);*/
-  exit(0);
-}
-
diff --git a/filterbank-gmrt/filterbank.h b/filterbank-gmrt/filterbank.h
deleted file mode 100644
index 635cdcf..0000000
--- a/filterbank-gmrt/filterbank.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* filterbank.h - include file for filterbank and related routines */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-/* input and output files and logfile (filterbank.monitor) */
-FILE *input, *output, *logfile;
-char  inpfile[80], outfile[80];
-
-/* global variables describing the data */
-#include "header.h"
-double time_offset;
-
-/* global variables describing the operating mode */
-float start_time, final_time, clip_threshold;
-
-int obits, sumifs, headerless, headerfile, swapout, invert_band;
-int compute_spectra, do_vanvleck, hanning, hamming, zerolagdump;
-int headeronly;
-char ifstream[8];
-
-/* library of subroutines and functions */
-#include "sigproc.h"
diff --git a/filterbank-gmrt/filterbank_header.c b/filterbank-gmrt/filterbank_header.c
deleted file mode 100644
index c037a15..0000000
--- a/filterbank-gmrt/filterbank_header.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include "filterbank.h"
-
-void filterbank_header(FILE *outptr) /* includefile */
-{
-  int i,j;
-  output=outptr;
-  if (obits == -1) obits=nbits;
-  /* go no further here if not interested in header parameters */
-  if (headerless) return;
-  /* broadcast the header parameters to the output stream */
-  if (machine_id != 0) {
-    send_string("HEADER_START");
-    send_string("rawdatafile");
-    send_string(inpfile);
-    if (!strings_equal(source_name,"")) {
-      send_string("source_name");
-      send_string(source_name);
-    }
-    send_int("machine_id",machine_id);
-    send_int("telescope_id",telescope_id);
-    send_coords(src_raj,src_dej,az_start,za_start);
-    if (zerolagdump) {
-      /* time series data DM=0.0 */
-      send_int("data_type",2);
-      refdm=0.0;
-      send_double("refdm",refdm);
-      send_int("nchans",1);
-    } else {
-      /* filterbank data */
-      send_int("data_type",1);
-      send_double("fch1",fch1);
-      send_double("foff",foff);
-      send_int("nchans",nchans);
-    }
-    /* beam info */
-    send_int("nbeams",nbeams);
-    send_int("ibeam",ibeam);
-    /* number of bits per sample */
-    send_int("nbits",obits);
-    /* start time and sample interval */
-    send_double("tstart",tstart+(double)start_time/86400.0);
-    send_double("tsamp",tsamp);
-    if (sumifs) {
-      send_int("nifs",1);
-    } else {
-      j=0;
-      for (i=1;i<=nifs;i++) if (ifstream[i-1]=='Y') j++;
-      if (j==0) error_message("no valid IF streams selected!");
-      send_int("nifs",j);
-    }
-    send_string("HEADER_END");
-  }
-  
-}
diff --git a/filterbank-gmrt/find.h b/filterbank-gmrt/find.h
deleted file mode 100644
index 2e059ba..0000000
--- a/filterbank-gmrt/find.h
+++ /dev/null
@@ -1,13 +0,0 @@
-/* find.h - include file for find program and related routines */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-/* input and output files and logfile (filterbank.monitor) */
-FILE *input, *output, *logfile;
-char  inpfile[80], outfile[80];
-
-/* global variables describing the data */
-#include "header.h"
-#include "sigproc.h"
diff --git a/filterbank-gmrt/find_summary.inc b/filterbank-gmrt/find_summary.inc
deleted file mode 100644
index ff4f8e6..0000000
--- a/filterbank-gmrt/find_summary.inc
+++ /dev/null
@@ -1,41 +0,0 @@
-C @(#)find_summary.inc	3.1 12/17/92
-c=================================================================
-c     VLSA : Include file for the  " .s. "  output file
-c=================================================================
-
-C n.b. remember to update the find_s_read.f file when new parameters
-C are added
-
-C split off the common block with the characters - pah - The HP optimizer
-C will produce garbage if characters in commons.
-
-      real*8 s_tsmp
-      
-      real s_dm,s_rms,s_avs,s_ave,s_sprms,s_alfa,
-     &    s_spectrum(2,1024,2),
-     &    s_pamp(100,5),s_prds(100,5),s_ixhst(15),s_iyhst(15),
-     &    s_bfa(20),s_bfb(20),snbrd(20)
-
-      integer s_lbig(100,5),s_nbrd,s_nba(20),s_nbb(20),s_ndat,
-     &    s_nskip,s_nclip,s_nrm,s_nfreq,s_ndatfft,s_nhbrd(20),
-     &    s_nkill,s_chk(16),s_loop,s_nssum,s_dm_step,s_rebin_step
-
-      character s_lb1*130,s_lb2*130,s_lb3*130
-	
-      byte bufc(32768), bufh(1024)
-
-      common/summary/s_tsmp,s_dm,s_rms,s_avs,s_ave,s_sprms,s_alfa,
-     &    s_ixhst,s_iyhst,s_nbrd,s_nba,s_nbb,s_nssum,
-     &    s_bfa,s_bfb,s_nhbrd,s_ndatfft,s_nkill,s_chk,
-     &    s_ndat,s_nskip,s_nclip,s_nrm,s_nfreq,
-     &    s_loop,s_dm_step,s_rebin_step,
-     &    s_spectrum,s_pamp,s_prds,s_lbig,snbrd
-
-      common/summaryc/s_lb1,s_lb2,s_lb3
-
-      equivalence(s_tsmp,bufc(1)),(s_tsmp,bufh(1))
-c==================================================================
-
-
-
-
diff --git a/filterbank-gmrt/fitsio.h b/filterbank-gmrt/fitsio.h
deleted file mode 100644
index 332664f..0000000
--- a/filterbank-gmrt/fitsio.h
+++ /dev/null
@@ -1,1557 +0,0 @@
-/*  Version Info: This file is distributed with version 2.490 of CFITSIO   */
-
-/*  The FITSIO software was written by William Pence at the High Energy    */
-/*  Astrophysic Science Archive Research Center (HEASARC) at the NASA      */
-/*  Goddard Space Flight Center.                                           */
-/*
-
-Copyright (Unpublished--all rights reserved under the copyright laws of
-the United States), U.S. Government as represented by the Administrator
-of the National Aeronautics and Space Administration.  No copyright is
-claimed in the United States under Title 17, U.S. Code.
-
-Permission to freely use, copy, modify, and distribute this software
-and its documentation without fee is hereby granted, provided that this
-copyright notice and disclaimer of warranty appears in all copies.
-
-DISCLAIMER:
-
-THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND,
-EITHER EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO,
-ANY WARRANTY THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY
-IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
-PURPOSE, AND FREEDOM FROM INFRINGEMENT, AND ANY WARRANTY THAT THE
-DOCUMENTATION WILL CONFORM TO THE SOFTWARE, OR ANY WARRANTY THAT THE
-SOFTWARE WILL BE ERROR FREE.  IN NO EVENT SHALL NASA BE LIABLE FOR ANY
-DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT, INDIRECT, SPECIAL OR
-CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM, OR IN ANY WAY
-CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
-CONTRACT, TORT , OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY
-PERSONS OR PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED
-FROM, OR AROSE OUT OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR
-SERVICES PROVIDED HEREUNDER."
-
-*/
-
-#ifndef _FITSIO_H
-#define _FITSIO_H
-
-#include <stdio.h>
-
-#if defined(linux) || defined(__APPLE__)
-#  include <sys/types.h>  /* apparently needed on debian linux systems */
-#endif                    /* to define off_t                           */
-
-#include <stdlib.h>  /* apparently needed to define size_t with gcc 2.8.1 */
-#include <limits.h>  /* needed for LLONG_MAX and INT64_MAX definitions */
-
-/* Define the datatype for variables which store file offset values. */
-/* The new 'off_t' datatype should be used for this purpose, but some */
-/* older compilers do not recognize this type, in which case we use 'long' */
-/* instead.  Note that _OFF_T is defined (or not) in stdio.h depending */
-/* on whether _LARGEFILE_SOURCE is defined in sys/feature_tests.h  */
-/* (at least on Solaris platforms using cc)  */
-
-/*  Debian systems require the 2nd test, below,         */
-/*  i.e, "(defined(linux) && defined(__off_t_defined))" */
-#if defined(_OFF_T) || (defined(linux) && defined(__off_t_defined)) || defined(_MIPS_SZLONG) || defined(__APPLE__) || defined(_AIX)
-#    define OFF_T off_t
-#else
-#    define OFF_T long
-#endif
-
-/* typedef the 'LONGLONG' data type to the intrinsice 8-byte integer type */
-
-#if defined(HAVE_LONGLONG) || defined(__APPLE__)
-    typedef long long LONGLONG;
-#   ifndef HAVE_LONGLONG
-#      define HAVE_LONGLONG 1
-#   endif
-#elif defined(_MSC_VER)   /* Windows PCs; Visual C++, but not Borland C++ */
-    typedef __int64 LONGLONG;
-#   ifndef HAVE_LONGLONG
-#      define HAVE_LONGLONG 1
-#   endif
-#else
-    typedef long LONGLONG;  /* intrinsic 8-byte integer not supported */
-#endif
-
-/*  The following exclusion if __CINT__ is defined is needed for ROOT */
-#ifndef __CINT__
-#include "longnam.h"
-#endif
- 
-/* global variables */
- 
-#define FLEN_FILENAME 1025 /* max length of a filename  */
-#define FLEN_KEYWORD   72  /* max length of a keyword (HIERARCH convention) */
-#define FLEN_CARD      81  /* length of a FITS header card */
-#define FLEN_VALUE     71  /* max length of a keyword value string */
-#define FLEN_COMMENT   73  /* max length of a keyword comment string */
-#define FLEN_ERRMSG    81  /* max length of a FITSIO error message */
-#define FLEN_STATUS    31  /* max length of a FITSIO status text string */
- 
-#define TBIT          1  /* codes for FITS table data types */
-#define TBYTE        11
-#define TSBYTE       12
-#define TLOGICAL     14
-#define TSTRING      16
-#define TUSHORT      20
-#define TSHORT       21
-#define TUINT        30
-#define TINT         31
-#define TULONG       40
-#define TLONG        41
-#define TINT32BIT    41  /* used when returning datatype of a column */
-#define TFLOAT       42
-#define TLONGLONG    81
-#define TDOUBLE      82
-#define TCOMPLEX     83
-#define TDBLCOMPLEX 163
-
-#define TYP_STRUC_KEY 10
-#define TYP_CMPRS_KEY 20
-#define TYP_SCAL_KEY  30
-#define TYP_NULL_KEY  40
-#define TYP_DIM_KEY   50
-#define TYP_RANG_KEY  60
-#define TYP_UNIT_KEY  70
-#define TYP_DISP_KEY  80
-#define TYP_HDUID_KEY 90
-#define TYP_CKSUM_KEY 100
-#define TYP_WCS_KEY   110
-#define TYP_REFSYS_KEY 120
-#define TYP_COMM_KEY  130
-#define TYP_CONT_KEY  140
-#define TYP_USER_KEY  150
-
-
-#define INT32BIT int  /* 32-bit integer datatype.  Currently this       */
-                      /* datatype is an 'int' on all useful platforms   */
-                      /* however, it is possible that that are cases    */
-                      /* where 'int' is a 2-byte integer, in which case */
-                      /* INT32BIT would need to be defined as 'long'.   */
-
-#define BYTE_IMG      8  /* BITPIX code values for FITS image types */
-#define SHORT_IMG    16
-#define LONG_IMG     32
-#define LONGLONG_IMG 64
-#define FLOAT_IMG   -32
-#define DOUBLE_IMG  -64
-                         /* The following 2 codes are not true FITS         */
-                         /* datatypes; these codes are only used internally */
-                         /* within cfitsio to make it easier for users      */
-                         /* to deal with unsigned integers.                 */
-#define SBYTE_IMG    10
-#define USHORT_IMG   20
-#define ULONG_IMG    40
-
-#define IMAGE_HDU  0  /* Primary Array or IMAGE HDU */
-#define ASCII_TBL  1  /* ASCII table HDU  */
-#define BINARY_TBL 2  /* Binary table HDU */
-#define ANY_HDU   -1  /* matches any HDU type */
-
-#define READONLY  0    /* options when opening a file */
-#define READWRITE 1
-
-/* adopt a hopefully obscure number to use as a null value flag */
-/* could be problems if the FITS files contain data with these values */
-#define FLOATNULLVALUE -9.11912E-36F
-#define DOUBLENULLVALUE -9.1191291391491E-36
- 
-/* Image compression algorithm types */
-#define MAX_COMPRESS_DIM     6
-#define RICE_1      11
-#define GZIP_1      21
-#define PLIO_1      31
-#define HCOMPRESS_1 41
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-#define CASESEN   1   /* do case-sensitive string match */
-#define CASEINSEN 0   /* do case-insensitive string match */
- 
-#define GT_ID_ALL_URI  0   /* hierarchical grouping parameters */
-#define GT_ID_REF      1
-#define GT_ID_POS      2
-#define GT_ID_ALL      3
-#define GT_ID_REF_URI 11
-#define GT_ID_POS_URI 12
-
-#define OPT_RM_GPT      0
-#define OPT_RM_ENTRY    1
-#define OPT_RM_MBR      2
-#define OPT_RM_ALL      3
-
-#define OPT_GCP_GPT     0
-#define OPT_GCP_MBR     1
-#define OPT_GCP_ALL     2
-
-#define OPT_MCP_ADD     0
-#define OPT_MCP_NADD    1
-#define OPT_MCP_REPL    2
-#define OPT_MCP_MOV     3
-
-#define OPT_MRG_COPY    0
-#define OPT_MRG_MOV     1
-
-#define OPT_CMT_MBR      1
-#define OPT_CMT_MBR_DEL 11
-
-typedef struct        /* structure used to store table column information */
-{
-    char ttype[70];   /* column name = FITS TTYPEn keyword; */
-    long tbcol;       /* offset in row to first byte of each column */
-    int  tdatatype;   /* datatype code of each column */
-    OFF_T trepeat;    /* repeat count of column; number of elements */
-    double tscale;    /* FITS TSCALn linear scaling factor */
-    double tzero;     /* FITS TZEROn linear scaling zero point */
-    long tnull;       /* FITS null value for int image or binary table cols */
-    char strnull[20]; /* FITS null value string for ASCII table columns */
-    char tform[10];   /* FITS tform keyword value  */
-    long  twidth;     /* width of each ASCII table column */
-}tcolumn;
-
-#define VALIDSTRUC 555  /* magic value used to identify if structure is valid */
-
-typedef struct      /* structure used to store basic FITS file information */
-{
-    int filehandle; /* handle returned by the file open function */
-    int driver;     /* defines which set of I/O drivers should be used */
-    int open_count; /* number of opened 'fitsfiles' using this structure */
-    char *filename; /* file name */
-    int validcode;  /* magic value used to verify that structure is valid */
-    OFF_T filesize; /* current size of the physical disk file in bytes */
-    OFF_T logfilesize; /* logical size of file, including unflushed buffers */
-    int lasthdu;    /* is this the last HDU in the file? 0 = no, else yes */
-    OFF_T bytepos;  /* current logical I/O pointer position in file */
-    OFF_T io_pos;   /* current I/O pointer position in the physical file */
-    int curbuf;     /* number of I/O buffer currently in use */ 
-    int curhdu;     /* current HDU number; 0 = primary array */
-    int hdutype;    /* 0 = primary array, 1 = ASCII table, 2 = binary table */
-    int writemode;  /* 0 = readonly, 1 = readwrite */
-    int maxhdu;     /* highest numbered HDU known to exist in the file */
-    int MAXHDU;     /* dynamically allocated dimension of headstart array */
-    OFF_T *headstart; /* byte offset in file to start of each HDU */
-    OFF_T headend;  /* byte offest in file to end of the current HDU header */
-    OFF_T nextkey;  /* byte offset in file to beginning of next keyword */
-    OFF_T datastart;/* byte offset in file to start of the current data unit */
-    int tfield;     /* number of fields in the table (primary array has 2 */
-    long origrows;  /* original number of rows (value of NAXIS2 keyword)  */
-    long numrows;   /* number of rows in the table (dynamically updated) */
-    OFF_T rowlength; /* length of a table row or image size (bytes) */
-    tcolumn *tableptr; /* pointer to the table structure */
-    OFF_T heapstart; /* heap start byte relative to start of data unit */
-    long heapsize;   /* size of the heap, in bytes */
-
-         /* the following elements are related to compressed images */
-    int request_compress_type;  /* requested image compression algorithm */
-    long request_tilesize[MAX_COMPRESS_DIM]; /* requested tiling size */
-    int request_rice_nbits;     /* requested noise bit parameter value */
-
-    int compressimg; /* 1 if HDU contains a compressed image, else 0 */
-    char zcmptype[12];      /* compression type string */
-    int compress_type;      /* type of compression algorithm */
-    int zbitpix;            /* FITS data type of image (BITPIX) */
-    int zndim;              /* dimension of image */
-    long znaxis[MAX_COMPRESS_DIM];  /* length of each axis */
-    long tilesize[MAX_COMPRESS_DIM]; /* size of compression tiles */
-    long maxtilelen;        /* max number of pixels in each image tile */
-    long maxelem;		/* maximum length of variable length arrays */
-
-    int cn_compressed;	    /* column number for COMPRESSED_DATA column */
-    int cn_uncompressed;    /* column number for UNCOMPRESSED_DATA column */
-    int cn_zscale;	    /* column number for ZSCALE column */
-    int cn_zzero;	    /* column number for ZZERO column */
-    int cn_zblank;          /* column number for the ZBLANK column */
-
-    double zscale;          /* scaling value, if same for all tiles */
-    double zzero;           /* zero pt, if same for all tiles */
-    double cn_bscale;       /* value of the BSCALE keyword in header */
-    double cn_bzero;        /* value of the BZERO keyword in header */
-    int zblank;             /* value for null pixels, if not a column */
-
-    int rice_blocksize;     /* first compression parameter */
-    int rice_nbits;         /* second compression parameter */
-} FITSfile;
-
-typedef struct      /* structure used to store basic HDU information */
-{
-    int HDUposition;  /* HDU position in file; 0 = first HDU */
-    FITSfile *Fptr;   /* pointer to FITS file structure */
-}fitsfile;
-
-typedef struct  /* structure for the iterator function column information */
-{  
-     /* elements required as input to fits_iterate_data: */
-
-    fitsfile *fptr;     /* pointer to the HDU containing the column */
-    int      colnum;    /* column number in the table (use name if < 1) */
-    char     colname[70]; /* name (= TTYPEn value) of the column (optional) */
-    int      datatype;  /* output datatype (converted if necessary  */
-    int      iotype;    /* = InputCol, InputOutputCol, or OutputCol */
-
-    /* output elements that may be useful for the work function: */
-
-    void     *array;    /* pointer to the array (and the null value) */
-    long     repeat;    /* binary table vector repeat value */
-    long     tlmin;     /* legal minimum data value */
-    long     tlmax;     /* legal maximum data value */
-    char     tunit[70]; /* physical unit string */
-    char     tdisp[70]; /* suggested display format */
-
-} iteratorCol;
-
-#define InputCol         0  /* flag for input only iterator column       */
-#define InputOutputCol   1  /* flag for input and output iterator column */
-#define OutputCol        2  /* flag for output only iterator column      */
-
-/* error status codes */
-
-#define SKIP_TABLE       -104 /* move to 1st image when opening file */
-#define SKIP_IMAGE       -103 /* move to 1st table when opening file */
-#define SKIP_NULL_PRIMARY -102 /* skip null primary array when opening file */
-#define USE_MEM_BUFF     -101  /* use memory buffer when opening file */
-#define OVERFLOW_ERR      -11  /* overflow during datatype conversion */
-#define PREPEND_PRIMARY    -9  /* used in ffiimg to insert new primary array */
-#define SAME_FILE         101  /* input and output files are the same */
-#define TOO_MANY_FILES    103  /* tried to open too many FITS files */
-#define FILE_NOT_OPENED   104  /* could not open the named file */
-#define FILE_NOT_CREATED  105  /* could not create the named file */
-#define WRITE_ERROR       106  /* error writing to FITS file */
-#define END_OF_FILE       107  /* tried to move past end of file */
-#define READ_ERROR        108  /* error reading from FITS file */
-#define FILE_NOT_CLOSED   110  /* could not close the file */
-#define ARRAY_TOO_BIG     111  /* array dimensions exceed internal limit */
-#define READONLY_FILE     112  /* Cannot write to readonly file */
-#define MEMORY_ALLOCATION 113  /* Could not allocate memory */
-#define BAD_FILEPTR       114  /* invalid fitsfile pointer */
-#define NULL_INPUT_PTR    115  /* NULL input pointer to routine */
-#define SEEK_ERROR        116  /* error seeking position in file */
-
-#define BAD_URL_PREFIX    121  /* invalid URL prefix on file name */
-#define TOO_MANY_DRIVERS  122  /* tried to register too many IO drivers */
-#define DRIVER_INIT_FAILED 123  /* driver initialization failed */
-#define NO_MATCHING_DRIVER 124  /* matching driver is not registered */
-#define URL_PARSE_ERROR    125  /* failed to parse input file URL */
-#define RANGE_PARSE_ERROR  126  /* failed to parse input file URL */
-
-#define	SHARED_ERRBASE	(150)
-#define	SHARED_BADARG	(SHARED_ERRBASE + 1)
-#define	SHARED_NULPTR	(SHARED_ERRBASE + 2)
-#define	SHARED_TABFULL	(SHARED_ERRBASE + 3)
-#define	SHARED_NOTINIT	(SHARED_ERRBASE + 4)
-#define	SHARED_IPCERR	(SHARED_ERRBASE + 5)
-#define	SHARED_NOMEM	(SHARED_ERRBASE + 6)
-#define	SHARED_AGAIN	(SHARED_ERRBASE + 7)
-#define	SHARED_NOFILE	(SHARED_ERRBASE + 8)
-#define	SHARED_NORESIZE	(SHARED_ERRBASE + 9)
-
-#define HEADER_NOT_EMPTY  201  /* header already contains keywords */
-#define KEY_NO_EXIST      202  /* keyword not found in header */
-#define KEY_OUT_BOUNDS    203  /* keyword record number is out of bounds */
-#define VALUE_UNDEFINED   204  /* keyword value field is blank */
-#define NO_QUOTE          205  /* string is missing the closing quote */
-#define BAD_KEYCHAR       207  /* illegal character in keyword name or card */
-#define BAD_ORDER         208  /* required keywords out of order */
-#define NOT_POS_INT       209  /* keyword value is not a positive integer */
-#define NO_END            210  /* couldn't find END keyword */
-#define BAD_BITPIX        211  /* illegal BITPIX keyword value*/
-#define BAD_NAXIS         212  /* illegal NAXIS keyword value */
-#define BAD_NAXES         213  /* illegal NAXISn keyword value */
-#define BAD_PCOUNT        214  /* illegal PCOUNT keyword value */
-#define BAD_GCOUNT        215  /* illegal GCOUNT keyword value */
-#define BAD_TFIELDS       216  /* illegal TFIELDS keyword value */
-#define NEG_WIDTH         217  /* negative table row size */
-#define NEG_ROWS          218  /* negative number of rows in table */
-#define COL_NOT_FOUND     219  /* column with this name not found in table */
-#define BAD_SIMPLE        220  /* illegal value of SIMPLE keyword  */
-#define NO_SIMPLE         221  /* Primary array doesn't start with SIMPLE */
-#define NO_BITPIX         222  /* Second keyword not BITPIX */
-#define NO_NAXIS          223  /* Third keyword not NAXIS */
-#define NO_NAXES          224  /* Couldn't find all the NAXISn keywords */
-#define NO_XTENSION       225  /* HDU doesn't start with XTENSION keyword */
-#define NOT_ATABLE        226  /* the CHDU is not an ASCII table extension */
-#define NOT_BTABLE        227  /* the CHDU is not a binary table extension */
-#define NO_PCOUNT         228  /* couldn't find PCOUNT keyword */
-#define NO_GCOUNT         229  /* couldn't find GCOUNT keyword */
-#define NO_TFIELDS        230  /* couldn't find TFIELDS keyword */
-#define NO_TBCOL          231  /* couldn't find TBCOLn keyword */
-#define NO_TFORM          232  /* couldn't find TFORMn keyword */
-#define NOT_IMAGE         233  /* the CHDU is not an IMAGE extension */
-#define BAD_TBCOL         234  /* TBCOLn keyword value < 0 or > rowlength */
-#define NOT_TABLE         235  /* the CHDU is not a table */
-#define COL_TOO_WIDE      236  /* column is too wide to fit in table */
-#define COL_NOT_UNIQUE    237  /* more than 1 column name matches template */
-#define BAD_ROW_WIDTH     241  /* sum of column widths not = NAXIS1 */
-#define UNKNOWN_EXT       251  /* unrecognizable FITS extension type */
-#define UNKNOWN_REC       252  /* unrecognizable FITS record */
-#define END_JUNK          253  /* END keyword is not blank */
-#define BAD_HEADER_FILL   254  /* Header fill area not blank */
-#define BAD_DATA_FILL     255  /* Data fill area not blank or zero */
-#define BAD_TFORM         261  /* illegal TFORM format code */
-#define BAD_TFORM_DTYPE   262  /* unrecognizable TFORM datatype code */
-#define BAD_TDIM          263  /* illegal TDIMn keyword value */
-#define BAD_HEAP_PTR      264  /* invalid BINTABLE heap address */
- 
-#define BAD_HDU_NUM       301  /* HDU number < 1 or > MAXHDU */
-#define BAD_COL_NUM       302  /* column number < 1 or > tfields */
-#define NEG_FILE_POS      304  /* tried to move before beginning of file  */
-#define NEG_BYTES         306  /* tried to read or write negative bytes */
-#define BAD_ROW_NUM       307  /* illegal starting row number in table */
-#define BAD_ELEM_NUM      308  /* illegal starting element number in vector */
-#define NOT_ASCII_COL     309  /* this is not an ASCII string column */
-#define NOT_LOGICAL_COL   310  /* this is not a logical datatype column */
-#define BAD_ATABLE_FORMAT 311  /* ASCII table column has wrong format */
-#define BAD_BTABLE_FORMAT 312  /* Binary table column has wrong format */
-#define NO_NULL           314  /* null value has not been defined */
-#define NOT_VARI_LEN      317  /* this is not a variable length column */
-#define BAD_DIMEN         320  /* illegal number of dimensions in array */
-#define BAD_PIX_NUM       321  /* first pixel number greater than last pixel */
-#define ZERO_SCALE        322  /* illegal BSCALE or TSCALn keyword = 0 */
-#define NEG_AXIS          323  /* illegal axis length < 1 */
- 
-#define NOT_GROUP_TABLE         340
-#define HDU_ALREADY_MEMBER      341
-#define MEMBER_NOT_FOUND        342
-#define GROUP_NOT_FOUND         343
-#define BAD_GROUP_ID            344
-#define TOO_MANY_HDUS_TRACKED   345
-#define HDU_ALREADY_TRACKED     346
-#define BAD_OPTION              347
-#define IDENTICAL_POINTERS      348
-#define BAD_GROUP_ATTACH        349
-#define BAD_GROUP_DETACH        350
-
-#define BAD_I2C           401  /* bad int to formatted string conversion */
-#define BAD_F2C           402  /* bad float to formatted string conversion */
-#define BAD_INTKEY        403  /* can't interprete keyword value as integer */
-#define BAD_LOGICALKEY    404  /* can't interprete keyword value as logical */
-#define BAD_FLOATKEY      405  /* can't interprete keyword value as float */
-#define BAD_DOUBLEKEY     406  /* can't interprete keyword value as double */
-#define BAD_C2I           407  /* bad formatted string to int conversion */
-#define BAD_C2F           408  /* bad formatted string to float conversion */
-#define BAD_C2D           409  /* bad formatted string to double conversion */
-#define BAD_DATATYPE      410  /* bad keyword datatype code */
-#define BAD_DECIM         411  /* bad number of decimal places specified */
-#define NUM_OVERFLOW      412  /* overflow during datatype conversion */
-
-# define DATA_COMPRESSION_ERR 413  /* error in imcompress routines */
-# define DATA_DECOMPRESSION_ERR 414 /* error in imcompress routines */
-# define NO_COMPRESSED_TILE  415 /* compressed tile doesn't exist */
-
-#define BAD_DATE          420  /* error in date or time conversion */
-
-#define PARSE_SYNTAX_ERR  431  /* syntax error in parser expression */
-#define PARSE_BAD_TYPE    432  /* expression did not evaluate to desired type */
-#define PARSE_LRG_VECTOR  433  /* vector result too large to return in array */
-#define PARSE_NO_OUTPUT   434  /* data parser failed not sent an out column */
-#define PARSE_BAD_COL     435  /* bad data encounter while parsing column */
-#define PARSE_BAD_OUTPUT  436  /* Output file not of proper type          */
-
-#define ANGLE_TOO_BIG     501  /* celestial angle too large for projection */
-#define BAD_WCS_VAL       502  /* bad celestial coordinate or pixel value */
-#define WCS_ERROR         503  /* error in celestial coordinate calculation */
-#define BAD_WCS_PROJ      504  /* unsupported type of celestial projection */
-#define NO_WCS_KEY        505  /* celestial coordinate keywords not found */
-#define APPROX_WCS_KEY    506  /* approximate WCS keywords were calculated */
-
-#define NO_CLOSE_ERROR    999  /* special value used internally to switch off */
-                               /* the error message from ffclos and ffchdu */
-
-/*------- following error codes are used in the grparser.c file -----------*/
-#define	NGP_ERRBASE		(360)			/* base chosen so not to interfere with CFITSIO */
-#define	NGP_OK			(0)
-#define	NGP_NO_MEMORY		(NGP_ERRBASE + 0)	/* malloc failed */
-#define	NGP_READ_ERR		(NGP_ERRBASE + 1)	/* read error from file */
-#define	NGP_NUL_PTR		(NGP_ERRBASE + 2)	/* null pointer passed as argument */
-#define	NGP_EMPTY_CURLINE	(NGP_ERRBASE + 3)	/* line read seems to be empty */
-#define	NGP_UNREAD_QUEUE_FULL	(NGP_ERRBASE + 4)	/* cannot unread more then 1 line (or single line twice) */
-#define	NGP_INC_NESTING		(NGP_ERRBASE + 5)	/* too deep include file nesting (inf. loop ?) */
-#define	NGP_ERR_FOPEN		(NGP_ERRBASE + 6)	/* fopen() failed, cannot open file */
-#define	NGP_EOF			(NGP_ERRBASE + 7)	/* end of file encountered */
-#define	NGP_BAD_ARG		(NGP_ERRBASE + 8)	/* bad arguments passed */
-#define	NGP_TOKEN_NOT_EXPECT	(NGP_ERRBASE + 9)	/* token not expected here */
-
-/*  The following exclusion if __CINT__ is defined is needed for ROOT */
-#ifndef __CINT__
-/*  the following 3 lines are needed to support C++ compilers */
-#ifdef __cplusplus
-extern "C" {
-#endif
-#endif
-
-/*----------------  FITS file URL parsing routines -------------*/
-int fits_get_token(char **ptr, char *delimiter, char *token, int *isanumber);
-char *fits_split_names(char *list);
-int ffiurl(char *url,  char *urltype, char *infile,
-                    char *outfile, char *extspec, char *rowfilter,
-                    char *binspec, char *colspec, int *status);
-int ffrtnm(char *url, char *rootname, int *status);
-int ffexts(char *extspec, int *extnum,  char *extname, int *extvers,
-          int *hdutype, char *colname, char *rowexpress, int *status);
-int ffextn(char *url, int *extension_num, int *status);
-int ffurlt(fitsfile *fptr, char *urlType, int *status);
-int ffbins(char *binspec, int *imagetype, int *haxis, 
-                      char colname[4][FLEN_VALUE], double *minin,
-                      double *maxin, double *binsizein,
-                      char minname[4][FLEN_VALUE], char maxname[4][FLEN_VALUE],
-                      char binname[4][FLEN_VALUE], double *weight, char *wtname,
-                      int *recip, int *status);
-int ffbinr(char **binspec, char *colname, double *minin, 
-                        double *maxin, double *binsizein, char *minname,
-                        char *maxname, char *binname, int *status);
-int ffimport_file( char *filename, char **contents, int *status );
-int ffrwrg( char *rowlist, long maxrows, int maxranges, int *numranges,
-      long *minrow, long *maxrow, int *status);
-
-/*----------------  FITS file I/O routines -------------*/
-int ffomem(fitsfile **fptr, const char *name, int mode, void **buffptr,
-           size_t *buffsize, size_t deltasize,
-           void *(*mem_realloc)(void *p, size_t newsize),
-           int *status);
-int ffopen(fitsfile **fptr, const char *filename, int iomode, int *status);
-int ffdopn(fitsfile **fptr, const char *filename, int iomode, int *status);
-int fftopn(fitsfile **fptr, const char *filename, int iomode, int *status);
-int ffiopn(fitsfile **fptr, const char *filename, int iomode, int *status);
-int ffreopen(fitsfile *openfptr, fitsfile **newfptr, int *status); 
-int ffinit(fitsfile **fptr, const char *filename, int *status);
-int ffimem(fitsfile **fptr,  void **buffptr,
-           size_t *buffsize, size_t deltasize,
-           void *(*mem_realloc)(void *p, size_t newsize),
-           int *status);
-int fftplt(fitsfile **fptr, const char *filename, const char *tempname,
-           int *status);
-int ffflus(fitsfile *fptr, int *status);
-int ffflsh(fitsfile *fptr, int clearbuf, int *status);
-int ffclos(fitsfile *fptr, int *status);
-int ffdelt(fitsfile *fptr, int *status);
-int ffflnm(fitsfile *fptr, char *filename, int *status);
-int ffflmd(fitsfile *fptr, int *filemode, int *status);
-
-/*---------------- utility routines -------------*/
-float ffvers(float *version);
-void ffupch(char *string);
-void ffgerr(int status, char *errtext);
-void ffpmsg(const char *err_message);
-void ffpmrk(void);
-int  ffgmsg(char *err_message);
-void ffcmsg(void);
-void ffcmrk(void);
-void ffrprt(FILE *stream, int status);
-void ffcmps(char *templt, char *colname, int  casesen, int *match,
-           int *exact);
-int fftkey(char *keyword, int *status);
-int fftrec(char *card, int *status);
-int ffnchk(fitsfile *fptr, int *status);
-int ffkeyn(char *keyroot, int value, char *keyname, int *status);
-int ffnkey(int value, char *keyroot, char *keyname, int *status);
-int ffgkcl(char *card);
-int ffdtyp(char *cval, char *dtype, int *status);
-int ffpsvc(char *card, char *value, char *comm, int *status);
-int ffgknm(char *card, char *name, int *length, int *status);
-int ffgthd(char *tmplt, char *card, int *hdtype, int *status);
-int ffasfm(char *tform, int *datacode, long *width, int *decim, int *status);
-int ffbnfm(char *tform, int *datacode, long *repeat, long *width, int *status);
-int ffgabc(int tfields, char **tform, int space, long *rowlen, long *tbcol,
-           int *status);
-int fits_get_section_range(char **ptr,long *secmin,long *secmax,long *incre,
-              int *status);
- 
-/*----------------- write single keywords --------------*/
-int ffpky(fitsfile *fptr, int datatype, char *keyname, void *value,
-          char *comm, int *status);
-int ffprec(fitsfile *fptr, const char *card, int *status);
-int ffpcom(fitsfile *fptr, const char *comm, int *status);
-int ffpunt(fitsfile *fptr, char *keyname, char *unit, int *status);
-int ffphis(fitsfile *fptr, const char *history, int *status);
-int ffpdat(fitsfile *fptr, int *status);
-int ffgstm(char *timestr, int *timeref, int *status);
-int ffgsdt(int *day, int *month, int *year, int *status);
-int ffdt2s(int year, int month, int day, char *datestr, int *status);
-int fftm2s(int year, int month, int day, int hour, int minute, double second,
-          int decimals, char *datestr, int *status);
-int ffs2dt(char *datestr, int *year, int *month, int *day, int *status);
-int ffs2tm(char *datestr, int *year, int *month, int *day, int *hour,
-          int *minute, double *second, int *status);
-int ffpkyu(fitsfile *fptr, char *keyname, char *comm, int *status);
-int ffpkys(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffpkls(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffplsw(fitsfile *fptr, int *status);
-int ffpkyl(fitsfile *fptr, char *keyname, int  value, char *comm, int *status);
-int ffpkyj(fitsfile *fptr, char *keyname, long value, char *comm, int *status);
-int ffpkyf(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffpkye(fitsfile *fptr, char *keyname, float  value, int decim, char *comm,
-          int *status);
-int ffpkyg(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffpkyd(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffpkyc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffpkym(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-int ffpkfc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffpkfm(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-int ffpkyt(fitsfile *fptr, char *keyname, long intval, double frac, char *comm,
-          int *status);
-int ffptdm( fitsfile *fptr, int colnum, int naxis, long naxes[], int *status);
-
-/*----------------- write array of keywords --------------*/
-int ffpkns(fitsfile *fptr, char *keyroot, int nstart, int nkey, char *value[],
-           char *comm[], int *status);
-int ffpknl(fitsfile *fptr, char *keyroot, int nstart, int nkey, int *value,
-           char *comm[], int *status);
-int ffpknj(fitsfile *fptr, char *keyroot, int nstart, int nkey, long *value,
-           char *comm[], int *status);
-int ffpknf(fitsfile *fptr, char *keyroot, int nstart, int nkey, float *value,
-           int decim, char *comm[], int *status);
-int ffpkne(fitsfile *fptr, char *keyroot, int nstart, int nkey, float *value,
-           int decim, char *comm[], int *status);
-int ffpkng(fitsfile *fptr, char *keyroot, int nstart, int nkey, double *value,
-           int decim, char *comm[], int *status);
-int ffpknd(fitsfile *fptr, char *keyroot, int nstart, int nkey, double *value,
-           int decim, char *comm[], int *status);
-int ffcpky(fitsfile *infptr,fitsfile *outfptr,int incol,int outcol,
-           char *rootname, int *status); 
-
-/*----------------- write required header keywords --------------*/
-int ffphps( fitsfile *fptr, int bitpix, int naxis, long naxes[], int *status);
-int ffphpr( fitsfile *fptr, int simple, int bitpix, int naxis, long naxes[],
-            long pcount, long gcount, int extend, int *status);
-int ffphtb(fitsfile *fptr, long naxis1, long naxis2, int tfields, char **ttype,
-          long *tbcol, char **tform, char **tunit, char *extname, int *status);
-int ffphbn(fitsfile *fptr, long naxis2, int tfields, char **ttype,
-          char **tform, char **tunit, char *extname, long pcount, int *status);
-
-/*----------------- write template keywords --------------*/
-int ffpktp(fitsfile *fptr, const char *filename, int *status);
-
-/*------------------ get header information --------------*/
-int ffghsp(fitsfile *fptr, int *nexist, int *nmore, int *status);
-int ffghps(fitsfile *fptr, int *nexist, int *position, int *status);
- 
-/*------------------ move position in header -------------*/
-int ffmaky(fitsfile *fptr, int nrec, int *status);
-int ffmrky(fitsfile *fptr, int nrec, int *status);
- 
-/*------------------ read single keywords -----------------*/
-int ffgnxk(fitsfile *fptr, char **inclist, int ninc, char **exclist,
-           int nexc, char *card, int  *status);
-int ffgrec(fitsfile *fptr, int nrec,      char *card, int *status);
-int ffgcrd(fitsfile *fptr, char *keyname, char *card, int *status);
-int ffgunt(fitsfile *fptr, char *keyname, char *unit, int  *status);
-int ffgkyn(fitsfile *fptr, int nkey, char *keyname, char *keyval, char *comm,
-           int *status);
-int ffgkey(fitsfile *fptr, char *keyname, char *keyval, char *comm,
-           int *status);
- 
-int ffgky( fitsfile *fptr, int datatype, char *keyname, void *value,
-           char *comm, int *status);
-int ffgkys(fitsfile *fptr, char *keyname, char *value, char *comm, int *status);
-int ffgkls(fitsfile *fptr, char *keyname, char **value, char *comm, int *status)
-;
-int ffgkyl(fitsfile *fptr, char *keyname, int *value, char *comm, int *status);
-int ffgkyj(fitsfile *fptr, char *keyname, long *value, char *comm, int *status);
-int ffgkye(fitsfile *fptr, char *keyname, float *value, char *comm,int *status);
-int ffgkyd(fitsfile *fptr, char *keyname, double *value,char *comm,int *status);
-int ffgkyc(fitsfile *fptr, char *keyname, float *value, char *comm,int *status);
-int ffgkym(fitsfile *fptr, char *keyname, double *value,char *comm,int *status);
-int ffgkyt(fitsfile *fptr, char *keyname, long *ivalue, double *dvalue,
-           char *comm, int *status);
-int ffgtdm(fitsfile *fptr, int colnum, int maxdim, int *naxis, long naxes[],
-           int *status);
-int ffdtdm(fitsfile *fptr, char *tdimstr, int colnum, int maxdim,
-           int *naxis, long naxes[], int *status);
-
-/*------------------ read array of keywords -----------------*/
-int ffgkns(fitsfile *fptr, char *keyname, int nstart, int nmax, char *value[],
-           int *nfound,  int *status);
-int ffgknl(fitsfile *fptr, char *keyname, int nstart, int nmax, int *value,
-           int *nfound, int *status);
-int ffgknj(fitsfile *fptr, char *keyname, int nstart, int nmax, long *value,
-           int *nfound, int *status);
-int ffgkne(fitsfile *fptr, char *keyname, int nstart, int nmax, float *value,
-           int *nfound, int *status);
-int ffgknd(fitsfile *fptr, char *keyname, int nstart, int nmax, double *value,
-           int *nfound, int *status);
-int ffh2st(fitsfile *fptr, char **header, int  *status);
-int ffhdr2str( fitsfile *fptr,  int exclude_comm, char **exclist,
-   int nexc, char **header, int *nkeys, int  *status);
-
-/*----------------- read required header keywords --------------*/
-int ffghpr(fitsfile *fptr, int maxdim, int *simple, int *bitpix, int *naxis,
-          long naxes[], long *pcount, long *gcount, int *extend, int *status);
- 
-int ffghtb(fitsfile *fptr,int maxfield, long *naxis1, long *naxis2,
-           int *tfields, char **ttype, long *tbcol, char **tform, char **tunit,
-           char *extname,  int *status);
- 
-int ffghbn(fitsfile *fptr, int maxfield, long *naxis2, int *tfields,
-           char **ttype, char **tform, char **tunit, char *extname,
-           long *pcount, int *status);
- 
-/*--------------------- update keywords ---------------*/
-int ffuky(fitsfile *fptr, int datatype, char *keyname, void *value,
-          char *comm, int *status);
-int ffucrd(fitsfile *fptr, char *keyname, char *card, int *status);
-int ffukyu(fitsfile *fptr, char *keyname, char *comm, int *status);
-int ffukys(fitsfile *fptr, char *keyname, char *value, char *comm, int *status);
-int ffukls(fitsfile *fptr, char *keyname, char *value, char *comm, int *status);
-int ffukyl(fitsfile *fptr, char *keyname, int value, char *comm, int *status);
-int ffukyj(fitsfile *fptr, char *keyname, long value, char *comm, int *status);
-int ffukyf(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffukye(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffukyg(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffukyd(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffukyc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffukym(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-int ffukfc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffukfm(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-
-/*--------------------- modify keywords ---------------*/
-int ffmrec(fitsfile *fptr, int nkey, char *card, int *status);
-int ffmcrd(fitsfile *fptr, char *keyname, char *card, int *status);
-int ffmnam(fitsfile *fptr, char *oldname, char *newname, int *status);
-int ffmcom(fitsfile *fptr, char *keyname, char *comm, int *status);
-int ffmkyu(fitsfile *fptr, char *keyname, char *comm, int *status);
-int ffmkys(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffmkls(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffmkyl(fitsfile *fptr, char *keyname, int value, char *comm, int *status);
-int ffmkyj(fitsfile *fptr, char *keyname, long value, char *comm, int *status);
-int ffmkyf(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffmkye(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffmkyg(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffmkyd(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffmkyc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffmkym(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-int ffmkfc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffmkfm(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
- 
-/*--------------------- insert keywords ---------------*/
-int ffirec(fitsfile *fptr, int nkey, char *card, int *status);
-int ffikey(fitsfile *fptr, char *card, int *status);
-int ffikyu(fitsfile *fptr, char *keyname, char *comm, int *status);
-int ffikys(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffikls(fitsfile *fptr, char *keyname, char *value, char *comm,int *status);
-int ffikyl(fitsfile *fptr, char *keyname, int value, char *comm, int *status);
-int ffikyj(fitsfile *fptr, char *keyname, long value, char *comm, int *status);
-int ffikyf(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffikye(fitsfile *fptr, char *keyname, float value, int decim, char *comm,
-          int *status);
-int ffikyg(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffikyd(fitsfile *fptr, char *keyname, double value, int decim, char *comm,
-          int *status);
-int ffikyc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffikym(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-int ffikfc(fitsfile *fptr, char *keyname, float *value, int decim, char *comm,
-          int *status);
-int ffikfm(fitsfile *fptr, char *keyname, double *value, int decim, char *comm,
-          int *status);
-
-/*--------------------- delete keywords ---------------*/
-int ffdkey(fitsfile *fptr, char *keyname, int *status);
-int ffdrec(fitsfile *fptr, int keypos, int *status);
- 
-/*--------------------- get HDU information -------------*/
-int ffghdn(fitsfile *fptr, int *chdunum);
-int ffghdt(fitsfile *fptr, int *exttype, int *status);
-int ffghad(fitsfile *fptr, long *headstart, long *datastart, long *dataend,
-           int *status);
-int ffghof(fitsfile *fptr, OFF_T *headstart, OFF_T *datastart, OFF_T *dataend,
-           int *status);
-int ffgipr(fitsfile *fptr, int maxaxis, int *imgtype, int *naxis,
-           long *naxes, int *status);
-int ffgidt(fitsfile *fptr, int *imgtype, int *status);
-int ffgiet(fitsfile *fptr, int *imgtype, int *status);
-int ffgidm(fitsfile *fptr, int *naxis,  int *status);
-int ffgisz(fitsfile *fptr, int nlen, long *naxes, int *status);
-
-/*--------------------- HDU operations -------------*/
-int ffmahd(fitsfile *fptr, int hdunum, int *exttype, int *status);
-int ffmrhd(fitsfile *fptr, int hdumov, int *exttype, int *status);
-int ffmnhd(fitsfile *fptr, int exttype, char *hduname, int hduvers,
-           int *status);
-int ffthdu(fitsfile *fptr, int *nhdu, int *status);
-int ffcrhd(fitsfile *fptr, int *status);
-int ffcrim(fitsfile *fptr, int bitpix, int naxis, long *naxes, int *status);
-int ffcrtb(fitsfile *fptr, int tbltype, long naxis2, int tfields, char **ttype,
-           char **tform, char **tunit, char *extname, int *status);
-int ffiimg(fitsfile *fptr, int bitpix, int naxis, long *naxes, int *status);
-int ffitab(fitsfile *fptr, long naxis1, long naxis2, int tfields, char **ttype,
-           long *tbcol, char **tform, char **tunit, char *extname, int *status);
-int ffibin(fitsfile *fptr,long naxis2, int tfields, char **ttype, char **tform,
-           char **tunit, char *extname, long pcount, int *status);
-int ffrsim(fitsfile *fptr, int bitpix, int naxis, long *naxes, int *status);
-int ffdhdu(fitsfile *fptr, int *hdutype, int *status);
-int ffcopy(fitsfile *infptr, fitsfile *outfptr, int morekeys, int *status);
-int ffcpfl(fitsfile *infptr, fitsfile *outfptr, int prev, int cur, int follow,
-            int *status);
-int ffcphd(fitsfile *infptr, fitsfile *outfptr, int *status);
-int ffcpdt(fitsfile *infptr, fitsfile *outfptr, int *status);
-int ffchfl(fitsfile *fptr, int *status);
-int ffcdfl(fitsfile *fptr, int *status);
-
-int ffrdef(fitsfile *fptr, int *status);
-int ffhdef(fitsfile *fptr, int morekeys, int *status);
-int ffpthp(fitsfile *fptr, long theap, int *status);
- 
-int ffcsum(fitsfile *fptr, long nrec, unsigned long *sum, int *status);
-void ffesum(unsigned long sum, int complm, char *ascii);
-unsigned long ffdsum(char *ascii, int complm, unsigned long *sum);
-int ffpcks(fitsfile *fptr, int *status);
-int ffupck(fitsfile *fptr, int *status);
-int ffvcks(fitsfile *fptr, int *datastatus, int *hdustatus, int *status);
-int ffgcks(fitsfile *fptr, unsigned long *datasum, unsigned long *hdusum,
-    int *status);
- 
-/*--------------------- define scaling or null values -------------*/
-int ffpscl(fitsfile *fptr, double scale, double zero, int *status);
-int ffpnul(fitsfile *fptr, long nulvalue, int *status);
-int fftscl(fitsfile *fptr, int colnum, double scale, double zero, int *status);
-int fftnul(fitsfile *fptr, int colnum, long nulvalue, int *status);
-int ffsnul(fitsfile *fptr, int colnum, char *nulstring, int *status);
- 
-/*--------------------- get column information -------------*/
-int ffgcno(fitsfile *fptr, int casesen, char *templt, int  *colnum,
-           int *status);
-int ffgcnn(fitsfile *fptr, int casesen, char *templt, char *colname,
-           int *colnum, int *status);
- 
-int ffgtcl(fitsfile *fptr, int colnum, int *typecode, long *repeat,
-           long *width, int *status);
-int ffeqty(fitsfile *fptr, int colnum, int *typecode, long *repeat,
-           long *width, int *status);
-int ffgncl(fitsfile *fptr, int  *ncols, int *status);
-int ffgnrw(fitsfile *fptr, long *nrows, int *status);
-int ffgacl(fitsfile *fptr, int colnum, char *ttype, long *tbcol,
-           char *tunit, char *tform, double *tscal, double *tzero,
-           char *tnull, char *tdisp, int *status);
-int ffgbcl(fitsfile *fptr, int colnum, char *ttype, char *tunit,
-           char *dtype, long *repeat, double *tscal, double *tzero,
-           long *tnull, char *tdisp, int  *status);
-int ffgrsz(fitsfile *fptr, long *nrows, int *status);
-int ffgcdw(fitsfile *fptr, int colnum, int *width, int *status);
-
-/*--------------------- read primary array or image elements -------------*/
-int ffgpxv(fitsfile *fptr, int  datatype, long *firstpix, long nelem,
-          void *nulval, void *array, int *anynul, int *status);
-int ffgpxf(fitsfile *fptr, int  datatype, long *firstpix, long nelem,
-           void *array, char *nullarray, int *anynul, int *status);
-int ffgsv(fitsfile *fptr, int datatype, long *blc, long *trc, long *inc,
-          void *nulval, void *array, int *anynul, int  *status);
-int ffgpv(fitsfile *fptr, int  datatype, long firstelem, long nelem,
-          void *nulval, void *array, int *anynul, int  *status);
-int ffgpf(fitsfile *fptr, int  datatype, long firstelem, long nelem,
-          void *array, char *nullarray, int  *anynul, int  *status);
-int ffgpvb(fitsfile *fptr, long group, long firstelem, long nelem, unsigned
-           char nulval, unsigned char *array, int *anynul, int *status);
-int ffgpvsb(fitsfile *fptr, long group, long firstelem, long nelem, signed
-           char nulval, signed char *array, int *anynul, int *status);
-int ffgpvui(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned short nulval, unsigned short *array, int *anynul, 
-           int *status);
-int ffgpvi(fitsfile *fptr, long group, long firstelem, long nelem,
-           short nulval, short *array, int *anynul, int *status);
-int ffgpvuj(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned long nulval, unsigned long *array, int *anynul, 
-           int *status);
-int ffgpvj(fitsfile *fptr, long group, long firstelem, long nelem,
-           long nulval, long *array, int *anynul, int *status);
-int ffgpvjj(fitsfile *fptr, long group, long firstelem, long nelem,
-           LONGLONG nulval, LONGLONG *array, int *anynul, int *status);
-int ffgpvuk(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned int nulval, unsigned int *array, int *anynul, int *status);
-int ffgpvk(fitsfile *fptr, long group, long firstelem, long nelem,
-           int nulval, int *array, int *anynul, int *status);
-int ffgpve(fitsfile *fptr, long group, long firstelem, long nelem,
-           float nulval, float *array, int *anynul, int *status);
-int ffgpvd(fitsfile *fptr, long group, long firstelem, long nelem,
-           double nulval, double *array, int *anynul, int *status);
- 
-int ffgpfb(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned char *array, char *nularray, int *anynul, int *status);
-int ffgpfsb(fitsfile *fptr, long group, long firstelem, long nelem,
-           signed char *array, char *nularray, int *anynul, int *status);
-int ffgpfui(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned short *array, char *nularray, int *anynul, int *status);
-int ffgpfi(fitsfile *fptr, long group, long firstelem, long nelem,
-           short *array, char *nularray, int *anynul, int *status);
-int ffgpfuj(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned long *array, char *nularray, int *anynul, int *status);
-int ffgpfj(fitsfile *fptr, long group, long firstelem, long nelem,
-           long *array, char *nularray, int *anynul, int *status);
-int ffgpfjj(fitsfile *fptr, long group, long firstelem, long nelem,
-           LONGLONG *array, char *nularray, int *anynul, int *status);
-int ffgpfuk(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned int *array, char *nularray, int *anynul, int *status);
-int ffgpfk(fitsfile *fptr, long group, long firstelem, long nelem,
-           int *array, char *nularray, int *anynul, int *status);
-int ffgpfe(fitsfile *fptr, long group, long firstelem, long nelem,
-           float *array, char *nularray, int *anynul, int *status);
-int ffgpfd(fitsfile *fptr, long group, long firstelem, long nelem,
-           double *array, char *nularray, int *anynul, int *status);
- 
-int ffg2db(fitsfile *fptr, long group, unsigned char nulval, long ncols,
-           long naxis1, long naxis2, unsigned char *array,
-           int *anynul, int *status);
-int ffg2dsb(fitsfile *fptr, long group, signed char nulval, long ncols,
-           long naxis1, long naxis2, signed char *array,
-           int *anynul, int *status);
-int ffg2dui(fitsfile *fptr, long group, unsigned short nulval, long ncols,
-           long naxis1, long naxis2, unsigned short *array,
-           int *anynul, int *status);
-int ffg2di(fitsfile *fptr, long group, short nulval, long ncols,
-           long naxis1, long naxis2, short *array,
-           int *anynul, int *status);
-int ffg2duj(fitsfile *fptr, long group, unsigned long nulval, long ncols,
-           long naxis1, long naxis2, unsigned long *array,
-           int *anynul, int *status);
-int ffg2dj(fitsfile *fptr, long group, long nulval, long ncols,
-           long naxis1, long naxis2, long *array,
-           int *anynul, int *status);
-int ffg2djj(fitsfile *fptr, long group, LONGLONG nulval, long ncols,
-           long naxis1, long naxis2, LONGLONG *array,
-           int *anynul, int *status);
-int ffg2duk(fitsfile *fptr, long group, unsigned int nulval, long ncols,
-           long naxis1, long naxis2, unsigned int *array,
-           int *anynul, int *status);
-int ffg2dk(fitsfile *fptr, long group, int nulval, long ncols,
-           long naxis1, long naxis2, int *array,
-           int *anynul, int *status);
-int ffg2de(fitsfile *fptr, long group, float nulval, long ncols,
-           long naxis1, long naxis2, float *array,
-           int *anynul, int *status);
-int ffg2dd(fitsfile *fptr, long group, double nulval, long ncols,
-           long naxis1, long naxis2, double *array,
-           int *anynul, int *status);
- 
-int ffg3db(fitsfile *fptr, long group, unsigned char nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           unsigned char *array, int *anynul, int *status);
-int ffg3dsb(fitsfile *fptr, long group, signed char nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           signed char *array, int *anynul, int *status);
-int ffg3dui(fitsfile *fptr, long group, unsigned short nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           unsigned short *array, int *anynul, int *status);
-int ffg3di(fitsfile *fptr, long group, short nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           short *array, int *anynul, int *status);
-int ffg3duj(fitsfile *fptr, long group, unsigned long nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           unsigned long *array, int *anynul, int *status);
-int ffg3dj(fitsfile *fptr, long group, long nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           long *array, int *anynul, int *status);
-int ffg3djj(fitsfile *fptr, long group, LONGLONG nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           LONGLONG *array, int *anynul, int *status);
-int ffg3duk(fitsfile *fptr, long group, unsigned int nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           unsigned int *array, int *anynul, int *status);
-int ffg3dk(fitsfile *fptr, long group, int nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           int *array, int *anynul, int *status);
-int ffg3de(fitsfile *fptr, long group, float nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           float *array, int *anynul, int *status);
-int ffg3dd(fitsfile *fptr, long group, double nulval, long ncols,
-           long nrows, long naxis1, long naxis2, long naxis3,
-           double *array, int *anynul, int *status);
- 
-int ffgsvb(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned char nulval, unsigned char *array,
-  int *anynul, int *status);
-int ffgsvsb(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, signed char nulval, signed char *array,
-  int *anynul, int *status);
-int ffgsvui(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned short nulval, unsigned short *array, 
-  int *anynul, int *status);
-int ffgsvi(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, short nulval, short *array, int *anynul, int *status);
-int ffgsvuj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned long nulval, unsigned long *array, 
-  int *anynul, int *status);
-int ffgsvj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, long nulval, long *array, int *anynul, int *status);
-int ffgsvjj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, LONGLONG nulval, LONGLONG *array, int *anynul,
-  int *status);
-int ffgsvuk(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned int nulval, unsigned int *array,
-  int *anynul, int *status);
-int ffgsvk(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, int nulval, int *array, int *anynul, int *status);
-int ffgsve(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, float nulval, float *array, int *anynul, int *status);
-int ffgsvd(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, double nulval, double *array, int *anynul,
-  int *status);
- 
-int ffgsfb(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned char *array, char *flagval,
-  int *anynul, int *status);
-int ffgsfsb(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, signed char *array, char *flagval,
-  int *anynul, int *status);
-int ffgsfui(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, unsigned short *array, char *flagval, int *anynul, 
-  int *status);
-int ffgsfi(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, short *array, char *flagval, int *anynul, int *status);
-int ffgsfuj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long  *trc, long *inc, unsigned long *array, char *flagval, int *anynul,
-  int *status);
-int ffgsfj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long  *trc, long *inc, long *array, char *flagval, int *anynul, int *status);
-int ffgsfjj(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long  *trc, long *inc, LONGLONG *array, char *flagval, int *anynul,
-  int *status);
-int ffgsfuk(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long  *trc, long *inc, unsigned int *array, char *flagval, int *anynul,
-  int *status);
-int ffgsfk(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long  *trc, long *inc, int *array, char *flagval, int *anynul, int *status);
-int ffgsfe(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, float *array, char *flagval, int *anynul, int *status);
-int ffgsfd(fitsfile *fptr, int colnum, int naxis, long *naxes, long *blc,
-  long *trc, long *inc, double *array, char *flagval, int *anynul,
-  int *status);
- 
-int ffggpb(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned char *array, int *status);
-int ffggpsb(fitsfile *fptr, long group, long firstelem, long nelem,
-           signed char *array, int *status);
-int ffggpui(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned short *array, int *status);
-int ffggpi(fitsfile *fptr, long group, long firstelem, long nelem,
-           short *array, int *status);
-int ffggpuj(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned long *array, int *status);
-int ffggpj(fitsfile *fptr, long group, long firstelem, long nelem,
-           long *array, int *status);
-int ffggpjj(fitsfile *fptr, long group, long firstelem, long nelem,
-           LONGLONG *array, int *status);
-int ffggpuk(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned int *array, int *status);
-int ffggpk(fitsfile *fptr, long group, long firstelem, long nelem,
-           int *array, int *status);
-int ffggpe(fitsfile *fptr, long group, long firstelem, long nelem,
-           float *array, int *status);
-int ffggpd(fitsfile *fptr, long group, long firstelem, long nelem,
-           double *array, int *status);
- 
-/*--------------------- read column elements -------------*/
-int ffgcv( fitsfile *fptr, int datatype, int colnum, long firstrow,
-           long firstelem, long nelem, void *nulval, void *array, int *anynul,
-           int  *status);
-int ffgcf( fitsfile *fptr, int datatype, int colnum, long firstrow,
-           long firstelem, long nelem, void *array, char *nullarray,
-           int *anynul, int *status);
-int ffgcvs(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, char *nulval, char **array, int *anynul, int *status);
-int ffgcl (fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, char *array, int  *status);
-int ffgcvl (fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, char nulval, char *array, int *anynul, int  *status);
-int ffgcvb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned char nulval, unsigned char *array,
-           int *anynul, int *status);
-int ffgcvsb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, signed char nulval, signed char *array,
-           int *anynul, int *status);
-int ffgcvui(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned short nulval, unsigned short *array, 
-           int *anynul, int *status);
-int ffgcvi(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, short nulval, short *array, int *anynul, int *status);
-int ffgcvuj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned long nulval, unsigned long *array, int *anynul,
-           int *status);
-int ffgcvj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, long nulval, long *array, int *anynul, int *status);
-int ffgcvjj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, LONGLONG nulval, LONGLONG *array, int *anynul,
-           int *status);
-int ffgcvuk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned int nulval, unsigned int *array, int *anynul,
-           int *status);
-int ffgcvk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, int nulval, int *array, int *anynul, int *status);
-int ffgcve(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, float nulval, float *array, int *anynul, int *status);
-int ffgcvd(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-         long nelem, double nulval, double *array, int *anynul, int *status);
-int ffgcvc(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, float nulval, float *array, int *anynul, int *status);
-int ffgcvm(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-         long nelem, double nulval, double *array, int *anynul, int *status);
-int ffgcx(fitsfile *fptr, int colnum, long firstrow, long firstbit,
-            long nbits, char *larray, int *status);
-int ffgcxui(fitsfile *fptr, int colnum, long firstrow, long nrows,
-            long firstbit, int nbits, unsigned short *array, int *status);
-int ffgcxuk(fitsfile *fptr, int colnum, long firstrow, long nrows,
-            long firstbit, int nbits, unsigned int *array, int *status);
-
-int ffgcfs(fitsfile *fptr, int colnum, long firstrow, long firstelem, long
-          nelem, char **array, char *nularray, int *anynul, int *status);
-int ffgcfl(fitsfile *fptr, int colnum, long firstrow, long firstelem, long
-          nelem, char *array, char *nularray, int *anynul, int *status);
-int ffgcfb(fitsfile *fptr, int colnum, long firstrow, long firstelem, long
-      nelem, unsigned char *array, char *nularray, int *anynul, int *status);
-int ffgcfsb(fitsfile *fptr, int colnum, long firstrow, long firstelem, long
-      nelem, signed char *array, char *nularray, int *anynul, int *status);
-int ffgcfui(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, unsigned short *array, char *nularray, int *anynul, 
-      int *status);
-int ffgcfi(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, short *array, char *nularray, int *anynul, int *status);
-int ffgcfuj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, unsigned long *array, char *nularray, int *anynul,
-      int *status);
-int ffgcfj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, long *array, char *nularray, int *anynul, int *status);
-int ffgcfjj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, LONGLONG *array, char *nularray, int *anynul, int *status);
-int ffgcfuk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, unsigned int *array, char *nularray, int *anynul,
-      int *status);
-int ffgcfk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, int *array, char *nularray, int *anynul, int *status);
-int ffgcfe(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, float *array, char *nularray, int *anynul, int *status);
-int ffgcfd(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, double *array, char *nularray, int *anynul, int *status);
-int ffgcfc(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, float *array, char *nularray, int *anynul, int *status);
-int ffgcfm(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-      long nelem, double *array, char *nularray, int *anynul, int *status);
- 
-int ffgdes(fitsfile *fptr, int colnum, long rownum, long *length,
-           long *heapaddr, int *status);
- 
-int ffgdess(fitsfile *fptr, int colnum, long firstrow, long nrows, long *length,
-           long *heapaddr, int *status);
- 
-int fftheap(fitsfile *fptr, long *heapsize, long *unused, long *overlap,
-            int *valid, int *status);
-int ffcmph(fitsfile *fptr, int *status);
-
-int ffgtbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
-           unsigned char *values, int *status);
- 
-/*------------ write primary array or image elements -------------*/
-int ffppx(fitsfile *fptr, int datatype, long  *firstpix, long nelem,
-          void *array, int *status);
-int ffppxn(fitsfile *fptr, int datatype, long  *firstpix, long nelem,
-          void *array, void *nulval, int *status);
-int ffppr(fitsfile *fptr, int datatype, long  firstelem, long nelem,
-          void *array, int *status);
-int ffpprb(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned char *array, int *status);
-int ffpprsb(fitsfile *fptr, long group, long firstelem,
-           long nelem, signed char *array, int *status);
-int ffpprui(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned short *array, int *status);
-int ffppri(fitsfile *fptr, long group, long firstelem,
-           long nelem, short *array, int *status);
-int ffppruj(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned long *array, int *status);
-int ffpprj(fitsfile *fptr, long group, long firstelem,
-           long nelem, long *array, int *status);
-int ffppruk(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned int *array, int *status);
-int ffpprk(fitsfile *fptr, long group, long firstelem,
-           long nelem, int *array, int *status);
-int ffppre(fitsfile *fptr, long group, long firstelem,
-           long nelem, float *array, int *status);
-int ffpprd(fitsfile *fptr, long group, long firstelem,
-           long nelem, double *array, int *status);
-int ffpprjj(fitsfile *fptr, long group, long firstelem,
-           long nelem, LONGLONG *array, int *status);
-
-int ffppru(fitsfile *fptr, long group, long firstelem, long nelem,
-           int *status);
-int ffpprn(fitsfile *fptr, long firstelem, long nelem, int *status);
- 
-int ffppn(fitsfile *fptr, int datatype, long  firstelem, long  nelem,
-          void  *array, void *nulval, int  *status);
-int ffppnb(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned char *array, unsigned char nulval, int *status);
-int ffppnsb(fitsfile *fptr, long group, long firstelem, long nelem,
-           signed char *array, signed char nulval, int *status);
-int ffppnui(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned short *array, unsigned short nulval,
-           int *status);
-int ffppni(fitsfile *fptr, long group, long firstelem,
-           long nelem, short *array, short nulval, int *status);
-int ffppnj(fitsfile *fptr, long group, long firstelem,
-           long nelem, long *array, long nulval, int *status);
-int ffppnuj(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned long *array, unsigned long nulval, int *status);
-int ffppnuk(fitsfile *fptr, long group, long firstelem, long nelem,
-           unsigned int *array, unsigned int nulval, int *status);
-int ffppnk(fitsfile *fptr, long group, long firstelem,
-           long nelem, int *array, int nulval, int *status);
-int ffppne(fitsfile *fptr, long group, long firstelem,
-           long nelem, float *array, float nulval, int *status);
-int ffppnd(fitsfile *fptr, long group, long firstelem,
-           long nelem, double *array, double nulval, int *status);
-int ffppnjj(fitsfile *fptr, long group, long firstelem,
-           long nelem, LONGLONG *array, long nulval, int *status);
-
-int ffp2db(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, unsigned char *array, int *status);
-int ffp2dsb(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, signed char *array, int *status);
-int ffp2dui(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, unsigned short *array, int *status);
-int ffp2di(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, short *array, int *status);
-int ffp2duj(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, unsigned long *array, int *status);
-int ffp2dj(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, long *array, int *status);
-int ffp2duk(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, unsigned int *array, int *status);
-int ffp2dk(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, int *array, int *status);
-int ffp2de(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, float *array, int *status);
-int ffp2dd(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, double *array, int *status);
-int ffp2djj(fitsfile *fptr, long group, long ncols, long naxis1,
-           long naxis2, LONGLONG *array, int *status);
-
-int ffp3db(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, unsigned char *array, int *status);
-int ffp3dsb(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, signed char *array, int *status);
-int ffp3dui(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, unsigned short *array, int *status);
-int ffp3di(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, short *array, int *status);
-int ffp3duj(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, unsigned long *array, int *status);
-int ffp3dj(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, long *array, int *status);
-int ffp3duk(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, unsigned int *array, int *status);
-int ffp3dk(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, int *array, int *status);
-int ffp3de(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, float *array, int *status);
-int ffp3dd(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, double *array, int *status);
-int ffp3djj(fitsfile *fptr, long group, long ncols, long nrows, long naxis1,
-           long naxis2, long naxis3, LONGLONG *array, int *status);
-
-int ffpss(fitsfile *fptr, int datatype,
-           long *fpixel, long *lpixel, void *array, int *status);
-int ffpssb(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, unsigned char *array, int *status);
-int ffpsssb(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, signed char *array, int *status);
-int ffpssui(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, unsigned short *array, int *status);
-int ffpssi(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, short *array, int *status);
-int ffpssuj(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, unsigned long *array, int *status);
-int ffpssj(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, long *array, int *status);
-int ffpssuk(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, unsigned int *array, int *status);
-int ffpssk(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, int *array, int *status);
-int ffpsse(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, float *array, int *status);
-int ffpssd(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, double *array, int *status);
-int ffpssjj(fitsfile *fptr, long group, long naxis, long *naxes,
-           long *fpixel, long *lpixel, LONGLONG *array, int *status);
-
-int ffpgpb(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned char *array, int *status);
-int ffpgpsb(fitsfile *fptr, long group, long firstelem,
-           long nelem, signed char *array, int *status);
-int ffpgpui(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned short *array, int *status);
-int ffpgpi(fitsfile *fptr, long group, long firstelem,
-           long nelem, short *array, int *status);
-int ffpgpuj(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned long *array, int *status);
-int ffpgpj(fitsfile *fptr, long group, long firstelem,
-           long nelem, long *array, int *status);
-int ffpgpuk(fitsfile *fptr, long group, long firstelem,
-           long nelem, unsigned int *array, int *status);
-int ffpgpk(fitsfile *fptr, long group, long firstelem,
-           long nelem, int *array, int *status);
-int ffpgpe(fitsfile *fptr, long group, long firstelem,
-           long nelem, float *array, int *status);
-int ffpgpd(fitsfile *fptr, long group, long firstelem,
-           long nelem, double *array, int *status);
-int ffpgpjj(fitsfile *fptr, long group, long firstelem,
-           long nelem, LONGLONG *array, int *status);
-
-/*--------------------- iterator functions -------------*/
-int fits_iter_set_by_name(iteratorCol *col, fitsfile *fptr, char *colname,
-          int datatype,  int iotype);
-int fits_iter_set_by_num(iteratorCol *col, fitsfile *fptr, int colnum,
-          int datatype,  int iotype);
-int fits_iter_set_file(iteratorCol *col, fitsfile *fptr);
-int fits_iter_set_colname(iteratorCol *col, char *colname);
-int fits_iter_set_colnum(iteratorCol *col, int colnum);
-int fits_iter_set_datatype(iteratorCol *col, int datatype);
-int fits_iter_set_iotype(iteratorCol *col, int iotype);
-
-fitsfile * fits_iter_get_file(iteratorCol *col);
-char * fits_iter_get_colname(iteratorCol *col);
-int fits_iter_get_colnum(iteratorCol *col);
-int fits_iter_get_datatype(iteratorCol *col);
-int fits_iter_get_iotype(iteratorCol *col);
-void * fits_iter_get_array(iteratorCol *col);
-long fits_iter_get_tlmin(iteratorCol *col);
-long fits_iter_get_tlmax(iteratorCol *col);
-long fits_iter_get_repeat(iteratorCol *col);
-char * fits_iter_get_tunit(iteratorCol *col);
-char * fits_iter_get_tdisp(iteratorCol *col);
-
-int ffiter(int ncols,  iteratorCol *data, long offset, long nPerLoop,
-           int (*workFn)( long totaln, long offset, long firstn,
-             long nvalues, int narrays, iteratorCol *data, void *userPointer),
-           void *userPointer, int *status);
-
-/*--------------------- write column elements -------------*/
-int ffpcl(fitsfile *fptr, int datatype, int colnum, long firstrow,
-          long firstelem, long nelem, void *array, int *status);
-int ffpcls(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, char **array, int *status);
-int ffpcll(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, char *array, int *status);
-int ffpclb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned char *array, int *status);
-int ffpclsb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, signed char *array, int *status);
-int ffpclui(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned short *array, int *status);
-int ffpcli(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, short *array, int *status);
-int ffpcluj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned long *array, int *status);
-int ffpclj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, long *array, int *status);
-int ffpcluk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned int *array, int *status);
-int ffpclk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, int *array, int *status);
-int ffpcle(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, float *array, int *status);
-int ffpcld(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, double *array, int *status);
-int ffpclc(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, float *array, int *status);
-int ffpclm(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, double *array, int *status);
-int ffpclu(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, int *status);
-int ffpclx(fitsfile *fptr, int colnum, long frow, long fbit, long nbit,
-            char *larray, int *status);
-int ffpcljj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, LONGLONG *array, int *status);
-
-int ffpcn(fitsfile *fptr, int datatype, int colnum, long firstrow,
-          long firstelem, long nelem, void *array, void *nulval, int *status);
-int ffpcns( fitsfile *fptr, int  colnum, long  firstrow, long  firstelem,
-            long  nelem, char **array, char  *nulvalue, int  *status);
-int ffpcnl( fitsfile *fptr, int  colnum, long  firstrow, long  firstelem,
-            long  nelem, char *array, char  nulvalue,  int  *status);
-int ffpcnb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned char *array, unsigned char nulvalue,
-           int *status);
-int ffpcnsb(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, signed char *array, signed char nulvalue,
-           int *status);
-int ffpcnui(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned short *array, unsigned short nulvalue,
-           int *status);
-int ffpcni(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, short *array, short nulvalue, int *status);
-int ffpcnuj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned long *array, unsigned long nulvalue,
-           int *status);
-int ffpcnj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, long *array, long nulvalue, int *status);
-int ffpcnuk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, unsigned int *array, unsigned int nulvalue,
-           int *status);
-int ffpcnk(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, int *array, int nulvalue, int *status);
-int ffpcne(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, float *array, float nulvalue, int *status);
-int ffpcnd(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, double *array, double nulvalue, int *status);
-int ffpcnjj(fitsfile *fptr, int colnum, long firstrow, long firstelem,
-           long nelem, LONGLONG *array, LONGLONG nulvalue, int *status);
-
-int ffpdes(fitsfile *fptr, int colnum, long rownum, long length,
-           long heapaddr, int *status);
- 
-int ffptbb(fitsfile *fptr, long firstrow, long firstchar, long nchars,
-           unsigned char *values, int *status);
- 
-int ffirow(fitsfile *fptr, long firstrow, long nrows, int *status);
-int ffdrow(fitsfile *fptr, long firstrow, long nrows, int *status);
-int ffdrrg(fitsfile *fptr, char *ranges, int *status);
-int ffdrws(fitsfile *fptr, long *rownum,  long nrows, int *status);
-int fficol(fitsfile *fptr, int numcol, char *ttype, char *tform, int *status);
-int fficls(fitsfile *fptr, int firstcol, int ncols, char **ttype,
-           char **tform, int *status);
-int ffmvec(fitsfile *fptr, int colnum, long newveclen, int *status);
-int ffdcol(fitsfile *fptr, int numcol, int *status);
-int ffcpcl(fitsfile *infptr, fitsfile *outfptr, int incol, int outcol, 
-           int create_col, int *status);
-
-/*--------------------- WCS Utilities ------------------*/
-int ffgics(fitsfile *fptr, double *xrval, double *yrval, double *xrpix,
-           double *yrpix, double *xinc, double *yinc, double *rot,
-           char *type, int *status);
-int ffgtcs(fitsfile *fptr, int xcol, int ycol, double *xrval,
-           double *yrval, double *xrpix, double *yrpix, double *xinc,
-           double *yinc, double *rot, char *type, int *status);
-int ffwldp(double xpix, double ypix, double xref, double yref,
-           double xrefpix, double yrefpix, double xinc, double yinc,
-           double rot, char *type, double *xpos, double *ypos, int *status);
-int ffxypx(double xpos, double ypos, double xref, double yref, 
-           double xrefpix, double yrefpix, double xinc, double yinc,
-           double rot, char *type, double *xpix, double *ypix, int *status);
-
-/*   WCS support routines (provide interface to Doug Mink's WCS library */
-int ffgiwcs(fitsfile *fptr,  char **header, int *status); 
-int ffgtwcs(fitsfile *fptr, int xcol, int ycol, char **header, int *status);
-
-/*--------------------- lexical parsing routines ------------------*/
-int fftexp( fitsfile *fptr, char *expr, int maxdim,
-	    int *datatype, long *nelem, int *naxis,
-	    long *naxes, int *status );
-
-int fffrow( fitsfile *infptr, char *expr,
-	    long firstrow, long nrows,
-            long *n_good_rows, char *row_status, int *status);
-
-int ffffrw( fitsfile *fptr, char *expr, long *rownum, int *status);
-
-int fffrwc( fitsfile *fptr, char *expr, char *timeCol,    
-            char *parCol, char *valCol, long ntimes,      
-            double *times, char *time_status, int  *status );
-
-int ffsrow( fitsfile *infptr, fitsfile *outfptr, char *expr, 
-            int *status);
-
-int ffcrow( fitsfile *fptr, int datatype, char *expr,
-	    long firstrow, long nelements, void *nulval,
-	    void *array, int *anynul, int *status );
-
-int ffcalc_rng( fitsfile *infptr, char *expr, fitsfile *outfptr,
-               char *parName, char *parInfo, int nRngs,
-                 long *start, long *end, int *status );
-
-int ffcalc( fitsfile *infptr, char *expr, fitsfile *outfptr,
-            char *parName, char *parInfo, int *status );
-
-  /* ffhist is not really intended as a user-callable routine */
-  /* but it may be useful for some specialized applications   */
-
-int ffhist(fitsfile **fptr, char *outfile, int imagetype, int naxis,
-           char colname[4][FLEN_VALUE],
-           double *minin, double *maxin, double *binsizein,
-           char minname[4][FLEN_VALUE], char maxname[4][FLEN_VALUE],
-           char binname[4][FLEN_VALUE], 
-           double weightin, char wtcol[FLEN_VALUE],
-           int recip, char *rowselect, int *status);
-
-int fits_select_image_section(fitsfile **fptr, char *outfile,
-           char *imagesection, int *status);
-int fits_select_section( fitsfile *infptr, fitsfile *outfptr,
-           char *imagesection, int *status);
-
-/*--------------------- grouping routines ------------------*/
-
-int ffgtcr(fitsfile *fptr, char *grpname, int grouptype, int *status);
-int ffgtis(fitsfile *fptr, char *grpname, int grouptype, int *status);
-int ffgtch(fitsfile *gfptr, int grouptype, int *status);
-int ffgtrm(fitsfile *gfptr, int rmopt, int *status);
-int ffgtcp(fitsfile *infptr, fitsfile *outfptr, int cpopt, int *status);
-int ffgtmg(fitsfile *infptr, fitsfile *outfptr, int mgopt, int *status);
-int ffgtcm(fitsfile *gfptr, int cmopt, int *status);
-int ffgtvf(fitsfile *gfptr, long *firstfailed, int *status);
-int ffgtop(fitsfile *mfptr,int group,fitsfile **gfptr,int *status);
-int ffgtam(fitsfile *gfptr, fitsfile *mfptr, int hdupos, int *status);
-int ffgtnm(fitsfile *gfptr, long *nmembers, int *status);
-int ffgmng(fitsfile *mfptr, long *nmembers, int *status);
-int ffgmop(fitsfile *gfptr, long member, fitsfile **mfptr, int *status);
-int ffgmcp(fitsfile *gfptr, fitsfile *mfptr, long member, int cpopt, 
-	   int *status);
-int ffgmtf(fitsfile *infptr, fitsfile *outfptr,	long member, int tfopt,	       
-	   int *status);
-int ffgmrm(fitsfile *fptr, long member, int rmopt, int *status);
-
-/*--------------------- group template parser routines ------------------*/
-
-int	fits_execute_template(fitsfile *ff, char *ngp_template, int *status);
-
-/*--------------------- image compression routines ------------------*/
-
-int fits_set_compression_type(fitsfile *fptr, int ctype, int *status);
-int fits_set_tile_dim(fitsfile *fptr, int ndim, long *dims, int *status);
-int fits_set_noise_bits(fitsfile *fptr, int noisebits, int *status);
-
-int fits_get_compression_type(fitsfile *fptr, int *ctype, int *status);
-int fits_get_tile_dim(fitsfile *fptr, int ndim, long *dims, int *status);
-int fits_get_noise_bits(fitsfile *fptr, int *noisebits, int *status);
-
-int fits_compress_img(fitsfile *infptr, fitsfile *outfptr, int compress_type,
-         long *tilesize, int parm1, int parm2, int *status);
-int fits_is_compressed_image(fitsfile *fptr, int *status);
-int fits_decompress_img (fitsfile *infptr, fitsfile *outfptr, int *status);
-
-/*  The following exclusion if __CINT__ is defined is needed for ROOT */
-#ifndef __CINT__
-#ifdef __cplusplus
-}
-#endif
-#endif
-
-#endif
-
diff --git a/filterbank-gmrt/flatten.c b/filterbank-gmrt/flatten.c
deleted file mode 100644
index 872ab7b..0000000
--- a/filterbank-gmrt/flatten.c
+++ /dev/null
@@ -1,26 +0,0 @@
-#include "dedisperse.h"
-int nbands,nobits;
-double userdm;
-main (int argc, char *argv[])
-{
-  float block[32768],copy[32768],median,median0;
-  int i,n,headersize=0;
-  input=fopen(argv[1],"rb");
-  output=stdout;
-
-  if (!(headersize=read_header(input))) 
-    error_message("could not read header parameters!");
-  userdm=refdm;
-  nobits=nbits;
-  nbands=1;
-  dedisperse_header();
-
-  while((n=read_block(input,nbits,block,32768))) {
-    for (i=0;i<n;i++) copy[i]=block[i];
-    median=nrselect((unsigned long)n/2,(unsigned long)n,copy);
-    if (median0==0.0) median0=median;
-    for (i=0;i<n;i++) copy[i]=(block[i]-median)/median0;
-    fwrite(copy,sizeof(float),n,output);
-  }
-
-}
diff --git a/filterbank-gmrt/flux.c b/filterbank-gmrt/flux.c
deleted file mode 100644
index ec0835d..0000000
--- a/filterbank-gmrt/flux.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-  profile - a program to produce quick ASCII/grey-scale plots of profiles
-  to the standard output. To use, simply fold a time series file and pipe
-  the output to this program. For profiles produced in regular prf format
-  an ASCII histogram is produced showing a 64-bin version of the profile.
-  For profiles produced with -stream option, a pseudo grey-scale output
-  is produced showing the profiles collapsed down to one line per profile.
-
-  Created April 9/10, 2002 - drl@jb.man.ac.uk
- */
-#include "profile.h"
-void getflux(float *profile, int nbins, float *smean, float *speak) 
-{
-  int i;
-  float sum;
-  sum=0.0;
-  *speak=profile[0];
-  for (i=0;i<nbins;i++) {
-    sum+=profile[i];
-    if (profile[i] > *speak) *speak=profile[i];
-  }
-  *smean=sum/(float)nbins;
-}
-void outflux(float smean, float speak, int mean, int peak, char *unit)
-{
-  if (strings_equal(unit,"mJy")) {
-    smean*=1.0e3;
-    speak*=1.0e3;
-  } else if (strings_equal(unit,"uJy")) {
-    smean*=1.0e6;
-    speak*=1.0e6;
-  } else if (!strings_equal(unit,"Jy")) {
-    error_message("invalid unit specified for flux density: Jy, mJy or uJy");
-  }
-  if (mean) printf("Smean = %.3f %s ",smean,unit);
-  if (peak) printf("Speak = %.3f %s ",speak,unit);
-  if (mean || peak) puts("");
-}
-main(int argc, char **argv) 
-{
-  float tsec,fmhz,smean,speak;
-  int i,dummy,peak=0,mean=0;
-  char line[240], hash, message[80], unit[3];
-
-  input=stdin;
-  strcpy(unit,"mJy");
-  if (argc > 1) {
-    print_version(argv[0],argv[1]);
-    if (help_required(argv[1])) {
-      /*flux_help();*/
-      exit(0);
-    }
-    i=1;
-    while (i<argc) {
-      if (file_exists(argv[i])) {
-	input=open_file(argv[i],"r");
-      } else if (strings_equal(argv[i],"-peak")) {
-	peak=1;
-      } else if (strings_equal(argv[i],"-mean")) {
-	mean=1;
-      } else if (strings_equal(argv[i],"-unit")) {
-	strcpy(unit,argv[++i]);
-      } else {
-	sprintf(message,"command-line argument %s not recognized...",argv[i]);
-	error_message(message);
-      }
-      i++;
-    }
-  }
-  if ((peak==0) && (mean==0)) mean=1;
-  fgets(line,sizeof(line),input);
-  sscanf(line,"%c %lf %lf %lf %ld %lf %lf %d",&hash,
-	 &mjdobs,&tstart,&period,&np,&fch1,&refdm,&nbins);
-  if (nbins > 0) {
-    while (!feof(input)) {
-      profile=(float *) malloc(sizeof(float)*nbins);
-      for (i=0; i<nbins; i++) fscanf(input,"%d %f",&dummy,&profile[i]);
-      getflux(profile,nbins,&smean,&speak);
-      outflux(smean,speak,mean,peak,unit);
-      free(profile);
-      nbins=0;
-      fgets(line,sizeof(line),input);
-      fgets(line,sizeof(line),input);
-      sscanf(line,"%c %lf %lf %lf %ld %lf %lf %d",&hash,
-	 &mjdobs,&tstart,&period,&np,&fch1,&refdm,&nbins);
-      if (nbins<=0) break;
-    }
-  } else {
-    while (!feof(input)) {
-      sscanf(line,"#START %d %f %f",&nbins,&tsec,&fmhz);
-      if (nbins <=0) break;
-      profile=(float *) malloc(sizeof(float)*nbins);
-      for (i=0; i<nbins; i++) fscanf(input,"%d %f",&dummy,&profile[i]);
-      getflux(profile,nbins,&smean,&speak);
-      outflux(smean,speak,mean,peak,unit);
-      fgets(line,sizeof(line),input);
-      fgets(line,sizeof(line),input);
-      free(profile);
-      fgets(line,sizeof(line),input);
-      nbins=0;
-    }
-  }
-}
diff --git a/filterbank-gmrt/fold.c b/filterbank-gmrt/fold.c
deleted file mode 100644
index c3db957..0000000
--- a/filterbank-gmrt/fold.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
-  FOLD  - fold filterbank channels or time series data to produce integrated
-  pulse profiles or single pulses.
-*/
-#include "fold.h"
-
-main (int argc, char *argv[])
-{
-  /* local variables */
-  double pfactor,newmjd=0.0;
-  float sefd;
-  int i,opened_input=0,opened_output=0,headersize=0;
-  char string[80];
-
-  /* set up default globals */
-  baseline=ascii=multiple=1;
-  npuls=binary=totalpower=accumulate=0;
-  time_offset=acceleration=skip_time=read_time=0.0;
-  asciipol=psrfits=stream=headerless=npulses=0;
-  phase_start=folding_period=dump_time=tsamp_user=0.0;
-  phase_finish=pfactor=1.0;
-  jyfactor=sefd=userbase=0.0;
-  nbins=0; /* this will get set in the folding routine if not set by user */
-  strcpy(polyco_file,"");
-
-  /* check the command line parameters */
-  i=1;
-  while (i<argc) {
-    print_version(argv[0],argv[1]);
-    if (strings_equal(argv[i],"-o")) {
-      /* get and open file for output */
-      i++;
-      strcpy(outfile,argv[i]);
-      output=fopen(outfile,"wb");
-      opened_output=1;
-    } else if (strings_equal(argv[i],"-m")) {
-      multiple=atoi(argv[++i]);
-    } else if (strings_equal(argv[i],"-p")) {
-      /* get folding period */
-      i++;
-      if (file_exists(argv[i])) {
-	strcpy(polyco_file,argv[i]);
-	folding_period=-1.0;
-      } else {
-	folding_period=atof(argv[i]);
-      }
-    } else if (strings_equal(argv[i],"-dt")) {
-      /* add a time offset in seconds to tstart */
-      time_offset=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-mjd")) {
-      /* change the start time completely! */
-      newmjd=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-sk")) {
-      /* skip the first skip_time seconds before folding */
-      skip_time=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-re")) {
-      /* read and fold only read_time seconds of data */
-      read_time=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-a")) {
-      /* get acceleration for folding */
-      acceleration=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-d")) {
-      /* get dumptime or number of pulses for subintegrations */
-      i++;
-      if (strcspn(".",argv[i])) {
-	npulses=atoi(argv[i]);
-      } else {
-	dump_time=atof(argv[i]);
-      }
-    } else if (strings_equal(argv[i],"-t")) {
-      /* get user-supplied sampling time */
-      i++;
-      tsamp_user=atof(argv[i]);
-    } else if (strings_equal(argv[i],"-j")) {
-      /* get user-supplied Jansky calibration factor */
-      jyfactor=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-s")) {
-      /* get user-supplied SEFD */
-      sefd=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-b")) {
-      /* get user-supplied baseline */
-      baseline=0;
-      userbase=atof(argv[++i]);
-    } else if (strings_equal(argv[i],"-f")) {
-      /* get period multiplication factor */
-      i++;
-      pfactor=atof(argv[i]);
-    } else if (strings_equal(argv[i],"-l")) {
-      /* get leading phase of pulse */
-      i++;
-      phase_start=atof(argv[i]);
-      if ( (phase_start < 0.0) || (phase_start > 1.0) ) 
-	error_message("start pulse phase out of range!");
-    } else if (strings_equal(argv[i],"-r")) {
-      /* get trailing phase of pulse */
-      i++;
-      phase_finish=atof(argv[i]);
-      if ( (phase_finish < 0.0) || (phase_finish > 1.0) ) 
-	error_message("final pulse phase out of range!");
-    } else if (strings_equal(argv[i],"-n")) {
-      /* get number of bins */
-      i++;
-      nbins=atoi(argv[i]);
-    } else if (strings_equal(argv[i],"-ascii")) {
-      /* write data as ASCII numbers */
-      ascii=1;
-    } else if (strings_equal(argv[i],"-totalpower")) {
-      /* sum polarizations 1+2 before writing */
-      totalpower=1;
-    } else if (strings_equal(argv[i],"-epn")) {
-      /* write data in EPN format */
-      ascii=0;
-    } else if (strings_equal(argv[i],"-bin")) {
-      /* write data in SIGPROC binary format */
-      binary=1;
-    } else if (strings_equal(argv[i],"-acc")) {
-      /* write out accumulated pulse profiles in subints */
-      accumulate=1;
-    } else if (strings_equal(argv[i],"-asciipol")) {
-      /* write data as ASCII numbers for Jim's polarization code */
-      asciipol=1;
-    } else if (strings_equal(argv[i],"-psrfits")) {
-      /* write data in PSRFITS format */
-      ascii=0;
-      psrfits=1;
-#ifndef PSRFITS
-      error_message("-psrfits option not supported in this compilation...\nConsult the SIGPROC manual for further information about PSRFITS.");
-#endif
-    } else if (strings_equal(argv[i],"-stream")) {
-      /* write data as ASCII streams */
-      stream=1;
-    } else if (strings_equal(argv[i],"-sub")) {
-      /* shorthand for -nobaseline -stream -d x */
-      stream=1;
-      baseline=0;
-      i++;
-      if (strcspn(".",argv[i])) {
-	npulses=atoi(argv[i]);
-      } else {
-	dump_time=atof(argv[i]);
-      }
-    } else if (strings_equal(argv[i],"-nobaseline")) {
-      /* processing correlation functions so don't subtract baseline */
-      baseline=0;
-    } else if (file_exists(argv[i])) {
-      /* get and open file for input */
-      strcpy(inpfile,argv[i]);
-      input=open_file(inpfile,"rb");
-      opened_input=1;
-    } else if (help_required(argv[i])) {
-      fold_help();
-      exit(0);
-    } else {
-	/* unknown argument passed down - stop! */
-	fold_help();
-	sprintf(string,"unknown argument (%s) passed to %s",argv[i],argv[0]);
-	error_message(string);
-    }
-    i++;
-  }
-
-  /* get appropriate calibration factor from SEFD and baseline */
-  if (sefd != 0.0 && userbase != 0.0) jyfactor=sefd/userbase;
-
-  /* multiply folding period by user-supplied factor */
-  if (folding_period != -1.0) folding_period*=pfactor;
-
-  /* check start and end phase of pulse */
-  if (phase_start >= phase_finish) 
-    error_message("silly pulse phases selected!");
-
-  /* check npulses versus dump_time */
-  if (npulses < 0) error_message("npulses < 0!");
-  if ((npulses > 0) && (dump_time > 0.0)) 
-    error_message("can't have npulses AND dumptime defined!");
-
-  /* check for folding period still set to zero - if so, look for polyco.dat */
-  if (folding_period == 0.0) {
-    strcpy(polyco_file,"polyco.dat");
-    if (file_exists(polyco_file)) {
-      folding_period=-1.0;
-    } else {
-      error_message("folding period not specified and no polyco.dat found!");
-    }
-  }
-
-  if (!opened_input) {
-    /* no input file selected, use standard input */
-    input=stdin;
-    strcpy(inpfile,"stdin");
-  }
-
-  /* read in the header parameters from the input stream */
-  if (!(headersize=read_header(input))) 
-    error_message("could not read header parameters!");
-
-  if (acceleration != 0.0) {
-    tobs=tsamp*(double)nsamples(inpfile,headersize,nbits,nifs,nchans);
-    if (tobs <= 0.0) error_message("could not get sensible observation time");
-  }
-
-  /* override the header */
-  if (newmjd!=0.0) tstart=newmjd;
-
-  if (!opened_output) {
-    /* no output file selected, use standard output */
-    output=stdout;
-    strcpy(outfile,"stdout");
-  }
-
-  /* open the raw data file and establish its origin and header pars */
-  switch(data_type) {
-  case 1: 
-  case 2:
-  case 6:
-    open_log("fold.monitor");
-    folded_profiles=fold_data();
-    break;
-  default:
-    error_message("input data is of unknown origin!!!");
-  }
-
-  write_profiles(folded_profiles,nbins,nchans,nifs,output);
-  if (stream) fprintf(output,"#DONE\n");
-
-  /* all done, update and close logfile */
-  update_log("finished");
-  close_log();
-  i=0;
-#ifdef PSRFITS
-  if (psrfits) fits_close_file(fits,&i);
-#endif
-  exit(0);
-}
diff --git a/filterbank-gmrt/fold.h b/filterbank-gmrt/fold.h
deleted file mode 100644
index a277080..0000000
--- a/filterbank-gmrt/fold.h
+++ /dev/null
@@ -1,30 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-FILE *input, *output, *logfile;
-char  inpfile[80], outfile[80];
-
-/* global variables describing the operating mode */
-int binary, ascii, asciipol, totalpower, stream, headerless, 
-  baseline, multiple, psrfits;
-
-char polyco_file[80];
-
-double folding_period, tsamp_user, dump_time, phase_start, phase_finish;
-double acceleration,tobs;
-int accumulate, nbins, npulses;
-float *folded_profiles, jyfactor, userbase;
-
-/* global variables describing the data */
-#include "header.h"
-double time_offset, skip_time, read_time;
-
-/* list of subroutines and functions */
-#include "sigproc.h"
-
-#ifdef PSRFITS
-/* Define CFITS file pointer - global- defined in fitsio.h */
-#include "fitsio.h"
-fitsfile *fits;
-#endif
diff --git a/filterbank-gmrt/fold_data.c b/filterbank-gmrt/fold_data.c
deleted file mode 100644
index e0f9a31..0000000
--- a/filterbank-gmrt/fold_data.c
+++ /dev/null
@@ -1,256 +0,0 @@
-#include "fold.h"
-/* folds incoming blocks of data */
-/* modified 28 May 2001 to fix phase counting [JMC]
-   Former:
-		turn = tsec/psec;
-		phase = turn - floor(turn);
-   This doesn't work for binaries with fastly changing periods!
-   Instead of using integrated time, need to use differential
-   time / period.
-   New:
-
-		turn += tsmp / psec;
-		phase = turn - floor(turn);	
-*/
-double tsec, tsmp, tsta, tlas, psec, turn, phase, window, pfld, pfld0, tadd;
-double dump_last; /* added by MAM Nov 2004 - to write out dumps at exact
-		     time values, rather than to the nearest pulse */
-long int pulsecount;
-
-/* set override flags to be OFF! - used only for depolyco.c */
-int poly_override=0;
-double override_f0=0.0;
-
-float  *fold_data() /* includefile */
-{
-  float *data, *prof, *temp, *base, *cntp, *cntt, *samps;
-  char string[80];
-  FILE *pfile;
-  long int tempcount, bytes_to_skip;
-  int ibin,lbin,i,s,c,n,nread,nsamps,newbaseline,pupd,prfidx,datidx,blocksize;
-  struct POLYCO polyco;
-  double kappa, speed_of_light=299792458.0;
-  /* 
-     initialise folding variables (all double precision):
-     tsec - elapsed time in seconds
-     tsta - elapsed time at start of first bin 
-     turn - number of pulse turns
-     phase - phase of sample
-     window - phase range selected by user (default=1.0)
-     tsmp - sample time in seconds (including WAPP dead time)
-     psec - folding period in seconds
-     pfld - mean folding period over the whole scan in second
-  */
-  lbin=-1;
-  newbaseline=1;
-  pulsecount=tempcount=dump_last=0;
-  tsta=tsec=tadd=turn=0.0;
-  tsmp=tsamp;			
-  window=phase_finish-phase_start;
-  kappa=0.0;
-
-  /* add arbitrary time offset to start time */
-  tstart+=time_offset/86400.0;
-
-  /* skip forward in the time series if need be */
-  if (skip_time > 0.0) {
-    tstart+=skip_time/86400.0;
-    bytes_to_skip=(long)(skip_time/tsamp)*(long)(nbits*nifs*nchans/8);
-    /*fprintf(stderr,"%ld %lf %d %d %d\n",
-      bytes_to_skip,skip_time,nbits,nifs,nchans);*/
-    if (fseek(input,bytes_to_skip,SEEK_CUR)) 
-      error_message("skip error - check time value of -sk option");
-  }
-  if (read_time==0.0) read_time=1.0e32;
-  
-  /* allow the user to override sample time in the header from command line */
-  if (tsamp_user > 0.0) tsmp=tsamp_user*1.0e-6;
-
-  /* folding: acceleration; a polyco file; a .top file or from command line */
-  if (acceleration != 0.0) {
-    /* normalization for midpoint as reference */
-    kappa=folding_period/1000.0/(1.0+acceleration*tobs/2.0/speed_of_light);
-    pfld=psec=kappa;
-    pupd=1;
-  } else if (folding_period == -1.0) {
-    pfile=open_file(polyco_file,"r");
-    if (!read_polycoset(pfile,&polyco)) {
-      /* it's a .top file - read period directly */
-      rewind(pfile);
-      fscanf(pfile,"%lf",&folding_period);
-      pfld=psec=folding_period/1000.0;
-      pupd=0;
-    } else {
-      /* it's a polyco - get nearest set and prodceed */
-      get_nearest_polyco(polyco_file,tstart,&polyco); 
-      pfld=psec=polyco_period(tstart,polyco);
-      pupd=1;
-    }
-    fclose(pfile);
-  } else {  
-    /* use period from command line */
-    pfld=psec=folding_period/1000.0;
-    pupd=0;
-  }
-  pfld0=psec;
-  /* if user has not specified bins make them phase_window/tsmp */
-  if (nbins<1) nbins=(int) (window*psec/tsmp);
-
-  /* current EPN format has maximum bin restriction (1k) */
-  if (!ascii && !stream && nbins>1024) nbins=1024;
-
-  /* work out nearest number of pulses for time dumps */ 
- /* if (dump_time > 0.0) npulses = (int) rint(dump_time/psec); */ 
-
-  /* allocate space for the data and profiles */
-  blocksize=nifs*512*nchans;
-  data=(float *) malloc(blocksize*sizeof(float));
-  prof=(float *) malloc(nifs*nbins*nchans*sizeof(float));
-  cntp=(float *) malloc(nbins*sizeof(float));
-  temp=(float *) malloc(nifs*nbins*nchans*sizeof(float));
-  cntt=(float *) malloc(nbins*sizeof(float));
-  base=(float *) malloc(nifs*nchans*sizeof(float));
-
-  /* initialize baseline array */
-  for (i=0; i<nifs*nchans; i++) base[i]=0.0;
-
-  /* initialize profile arrays */
-  for (i=0; i<nbins*nchans*nifs; i++) prof[i]=temp[i]=0.0;
-
-  /* initialize bin counts */
-  for (i=0; i<nbins; i++) cntt[i]=cntp[i]=0.0;
-
-  while ((nread=read_block(input,nbits,data,blocksize))>0
-	 && (tsec<read_time) ) {
-
-    /* number of samples to process in this block */
-    nsamps=nread/nchans/nifs;
-
-    if (newbaseline && baseline) {
-      samps=(float *) malloc(nsamps*sizeof(float));
-      for (i=0; i<nsamps; i++) samps[i]=0.0;
-      /* calculate a base line to subtract from this subintegration */
-      for (i=0; i<nifs; i++) {
-	n=i*nchans;
-	for (c=0; c<nchans; c++) {
-	  for (s=0; s<nsamps; s++) samps[s]=data[c+n+s*nchans*nifs];
-	  base[n+c]=nrselect(nsamps/2,nsamps,samps-1);
-	}
-      }
-      newbaseline=0;
-      free(samps);
-    }
-    /* update the period if necessary and send out log */
-    if (pupd) {
-      if (acceleration != 0.0) {
-	pfld=psec=kappa*(1.0+acceleration*tsec/speed_of_light);
-      } else {
-	get_nearest_polyco(polyco_file,tstart+tsec/86400.0,&polyco); 
-	pfld=psec=polyco_period(tstart+tsec/86400.0,polyco);
-      }
-    }
-    sprintf(string,"time:%.1fsP(fold):%.10fs",tsec, psec);
-    update_log(string);
-
-    /* main folding loop */
-    for (s=0; s<nsamps; s++) {
-
-      /* calculate phase of each sample */
-      /* turn=tsec/psec; */
-      phase=turn-floor(turn);
-
-      /* process this sample only if within selected window */
-      if ( (phase >= phase_start) && (phase <= phase_finish) ) {
-	
-	ibin=nbins*((phase-phase_start)/window);
-
-	if ( (ibin-lbin) < 0 ) pulsecount++;
-
-	cntp[ibin]+=1.0;
-	cntt[ibin]+=1.0;
-	
-	/* loop over IFs adding sample into appropriate phase bin */
-	for (i=0; i<nifs; i++) {
-	  n=i*nchans;
-	  /* loop over channels */
-	  for (c=0; c<nchans; c++) {
-	    prfidx=n*nbins+c*nbins+ibin;
-	    datidx=c+n+s*nchans*nifs;
-	    prof[prfidx]+=data[datidx]-base[n+c];
-	    temp[prfidx]+=data[datidx]-base[n+c];
-	  }
-	}
-      }
-
-      /* if user requested profile-dump mode - see if this is a new pulse */
-      if (npulses > 0) {
-	if ( (ibin-lbin) < 0 ) {
-	  if ((pulsecount) && !(pulsecount%npulses)) {
-	    /* normalize prof by counts */
-	    norm_prof(temp,cntt,nbins,nifs,nchans);
-	    /* 
-	       dump out the profile and prepare period for start of next dump
-	       added use of temporary variable to keep track of the pulses
-	       integrated within this sub-integration (drl - jul 2, 2004)
-	    */
-	    pulsecount-=tempcount;
-	    write_profiles(temp,nbins,nchans,nifs,output);
-	    pulsecount+=tempcount;
-	    tempcount=pulsecount;
-            pfld0=psec;
-	    if (accumulate) {
-	      denorm_prof(temp,cntt,nbins,nifs,nchans);
-	    } else {
-	      /* initialize subint profile and subint counts */
-	      for (i=0; i<nbins*nchans*nifs; i++) temp[i]=0.0;
-	      for (i=0; i<nbins; i++) cntt[i]=0.0;
-	    }
-	    /* set flag to get new baseline for next subintegration */
-	    newbaseline=1;
-	    /* OLD WAY (wrong!) 
-		update start time based on number of pulses added 
-	    tsta+=psec*(double)npulses; */
-	    /* NEW WAY (right!)
-		update start time based on number of samples since start */
-	    tsta+=tsec-dump_last;
-	    dump_last = tsec;
-	  }
-	}
-      }
-  
-      if (dump_time > 0) {
-	 if ((tsec-dump_last) > dump_time) {
-	   norm_prof(temp,cntt,nbins,nifs,nchans);
-	   write_profiles(temp,nbins,nchans,nifs,output);
-	   pfld0=psec; 
-	   if (accumulate) {
-	     denorm_prof(temp,cntt,nbins,nifs,nchans);
-	   } else {
-	     /* initialize subint profile and subint counts */
-	     for (i=0; i<nbins*nchans*nifs; i++) temp[i]=0.0;
-	     for (i=0; i<nbins; i++) cntt[i]=0.0;
-	   }
-	   /* set flag to get new baseline for next subintegration */
-	   newbaseline=1; 
-	   /* update start time based on number of samples since start */
-	   tsta+=tsec-dump_last;
-	   dump_last = tsec;
-        }
-      } 
-
-      lbin=ibin; /* keep track of last bin number */
-
-      /* update elapsed time counter */
-      tsec+=tsmp;
-      turn += tsmp/psec;
-    }
-  }
-
-  /* normalize prof by counts */
-  norm_prof(prof,cntp,nbins,nifs,nchans);
-
-  /* free arrays and return folded profile(s) */
-  free(data); free(base); free(temp);
-  tsta=0.0;
-  return prof;
-}
diff --git a/filterbank-gmrt/fold_header.c b/filterbank-gmrt/fold_header.c
deleted file mode 100644
index b8cfd0c..0000000
--- a/filterbank-gmrt/fold_header.c
+++ /dev/null
@@ -1,24 +0,0 @@
-#include "fold.h"
-
-void fold_header() /* includefile */
-{
-  send_string("HEADER_START");
-  send_int("data_type",3);
-  if (!strings_equal(source_name,"")) {
-    send_string("source_name");
-    send_string(source_name);
-  }
-  send_int("machine_id",machine_id);
-  send_int("telescope_id",telescope_id);
-  send_coords(src_raj,src_dej,az_start,za_start);
-  send_int("nbits",32);
-  send_int("nifs",nifs);
-  send_double("fch1",fch1);
-  send_double("foff",foff);
-  send_double("tstart",tstart);
-  if (npuls>0) send_long("npuls",npuls);
-  send_int("nchans",nchans);
-  send_int("nbins",nbins);
-  send_double("period",folding_period/1000.0);
-  send_string("HEADER_END");
-}
diff --git a/filterbank-gmrt/foldsignals.csh b/filterbank-gmrt/foldsignals.csh
deleted file mode 100755
index 831ea31..0000000
--- a/filterbank-gmrt/foldsignals.csh
+++ /dev/null
@@ -1,224 +0,0 @@
-###############################################################################
-#
-# foldsignals - script to dedisperse and fold signals obtained from SEEK
-#
-# The script first creates a list of signals by running "best" (with user
-# specified s/n threshold). Then, for each one, it attempts to optimize the
-# search period by folding over different trial periods within +/- one 
-# fourier bin of the search period. The best period is judged to be the 
-# resulting profile with the biggest "bump" which is measured by its rms.
-#
-###############################################################################
-set dedisperse = $bin/dedisperse
-set fold       = $bin/fold
-set grey       = $bin/grey
-set decimate   = $bin/decimate
-set header     = $bin/header
-set quickplot  = $bin/quickplot
-set reader     = $bin/reader
-set best       = $bin/best
-set ntrials    = 64
-set nbands     = 8
-set nsubints   = 8
-set snmin      = 8
-set nfold      = 999
-set userbins   = 0
-set usercand   = 0
-set listonly   = 0
-###############################################################################
-set nargs = `echo $argv | wc -w`
-if ($nargs == 0) then
-    echo ""
-    echo "foldsignals - script to dedisperse and fold signals from SEEK"
-    echo ""
-    echo "usage: foldsignals stem -{options}"
-    echo ""
-    echo "options:"
-    echo ""
-    echo "-nbands n      - number of sub-bands in output plot (def=8)"
-    echo "-ntrials n     - number of trial periods to try (def=64)"
-    echo "-nsubints n    - number of sub-integrations in output plot (def=8)"
-    echo "-snmin s       - miniumum signal-to-noise ratio (def=8)"
-    echo "-nbins n       - number of bins in output profile (def=P/tsamp)"
-    echo "-ncand n       - process only candidate number n (def=all)"
-    echo "-listonly      - just list the candidates from best"
-    echo ""
-    exit
-endif
-if ($nargs > 1) then
-    set i = 2
-    while ($i <= $nargs) 
-        if ("$argv[$i]" == "-listonly") then
-           set listonly = 1
-	endif
-        if ("$argv[$i]" == "-nbands") then
-	   @ j = $i + 1
-           set nbands = $argv[$j]
-	endif
-        if ("$argv[$i]" == "-ntrials") then
-	   @ j = $i + 1
-           set ntrials = $argv[$j]
-	endif
-        if ("$argv[$i]" == "-ncand") then
-	   @ j = $i + 1
-           set usercand = $argv[$j]
-	endif
-        if ("$argv[$i]" == "-nbins") then
-	   @ j = $i + 1
-           set userbins = $argv[$j]
-	endif
-	if ("$argv[$i]" == "-nsubints") then
-	   @ j = $i + 1
-           set nsubints = $argv[$j]
-	endif
-	if ("$argv[$i]" == "-snmin") then
-	   @ j = $i + 1
-           set snmin = $argv[$j]
-	endif
-	if ("$argv[$i]" == "-nfold") then
-	   @ j = $i + 1
-           set nfold = $argv[$j]
-	   set snmin = 5.0
-	endif
-	@ i++
-    end
-endif
-set stem = $argv[1]
-if (! -e $stem.prd) then
-    echo "$1 not found...."
-    exit
-endif
-if (! -e $stem.fil) then
-    echo "filterbank file $stem.fil not found...."
-    exit
-endif
-###############################################################################
-set cal = `$header $stem.fil -date`
-set obstime = `header $stem.fil -tobs`
-set ra = `$header $stem.fil -src_raj`
-set de = `$header $stem.fil -src_dej`
-set coords = "$ra$de"
-set nchans = `$header $stem.fil -nchans`
-set fch1 = `$header $stem.fil -fch1`
-set foff = `$header $stem.fil -foff`
-set fmid = `echo "$fch1+$foff*($nchans/2)" | bc -l`
-set chan = `echo $foff | awk '{if ($1<0) {print -1.0*$1} else {print $1}}'`
-set tsamp = `$header $stem.fil -tsamp`  
-###############################################################################
-if (-e $stem.1.ps.gz) rm -f $stem*.ps.gz
-if (-e $stem.001.fld) rm -f $stem*.fld
-$best $stem.prd -p -F$fmid -C$chan -s$snmin -z > /dev/null
-set ncands = `cat $stem.lis | wc -l`
-if ($nfold < 999) then
-  echo "Filterbank file: $stem.fil Top $nfold signals from the search:"
-else
-  echo "Filterbank file: $stem.fil $ncands signals found with S/N > $snmin..."
-endif    
-echo "------------------------------------------------------------"
-echo " Period (ms)    S/N     DM   DMID Nhit Fold P/Ptop    Ptop/P"
-echo "------------------------------------------------------------"
-cat $stem.lis | head -$nfold
-echo "------------------------------------------------------------"
-if ($listonly == 1) exit
-set cand = 0
-echo "Folding signal:" | awk '{printf "%s ",$0}'
-foreach period (`awk '{print $1}' $stem.lis`)
-  set dmidx = `grep $period $stem.lis | awk '{print $4}'`
-  set dmval = `grep $period $stem.lis | awk '{print $3}'`
-  set snr   = `grep $period $stem.lis | awk '{print $2}'`
-  @ cand++
-  if (($usercand > 0) && ($cand != $usercand)) goto next
-  if ($cand > $nfold) goto done
-  set srch  = sus$cand.sum
-  echo $cand | awk '{printf "%s ",$0}'
-  if (! -e $dmidx.sub) then
-        $dedisperse $stem.fil -d $dmval -f $fch1 -b $nbands > $dmidx.sub
-        $dedisperse $dmidx.sub -d 0 > $dmidx.tim
-  endif
-  set candfile = `echo "$stem $cand" | awk '{printf "%s.%03d.fld",$1,$2}'`
-  echo "--------------------------------------------------------------" \
-    >> $candfile
-  echo "Signal number: $cand Period: $period ms DM: $dmval S/N: $snr" \
-    >> $candfile
-  if ($userbins <= 0) then
-  set nbins = `echo "(1000.0*$period/$tsamp)"| bc -l | awk '{if ($1>128.0) print 128; if ($1<128.0) print int($1)}'`
-  else
-  set nbins = $userbins
-  endif
-  set fsearch = `echo 1000.0/$period | bc -l`
-  set delta_f = `echo 1.0/$obstime | bc -l`
-  set pfldmin = `echo "1000.0/($fsearch+$delta_f)" | bc -l`
-  set pfldmax = `echo "1000.0/($fsearch-$delta_f)" | bc -l`
-  if ($ntrials != 0) then
-    set delta_p = `echo "($pfldmax-$pfldmin)/$ntrials.0" | bc -l`
-  endif
-  set p_trial = $pfldmin
-  set bestrms = 0.0
-  set bestprd = $period
-  set i = 0
-  while ($i < $ntrials)
-    $fold $dmidx.tim -p $p_trial -n $nbins | tail -$nbins \
-	  | awk '{print $2}' >! test.profile
-    set rms     = `cat test.profile|awk '{ssq+=$1*$1;print sqrt(ssq)}'|tail -1`
-    set result  = `echo "$rms $bestrms" | awk '{if ($1>$2) print "YES"}'`
-    if ($result == "YES") then
-	set bestrms = $rms
-	set bestprd = $p_trial
-    endif
-    set p_trial = `echo "($p_trial+$delta_p)" | bc -l`
-    @ i++
-  end
-  rm -f test.profile
-  set period =  $bestprd
-  # now fold the data using the best period and produce the plot
-  set tsub = `echo "$obstime/$nsubints"| bc -l | awk '{printf "%.5f", $1}'`
-  $fold $dmidx.tim -p $period -d $tsub -n $nbins -epn >subints.epn
-  $grey subints.epn | awk '{print substr($0,16)}' >> $candfile
-  $fold $dmidx.sub -p $period -n $nbins -epn > subbands.epn
-  $decimate $dmidx.tim -T 1024 | $reader >! timeseries
-  echo "SEEK search output for" >! asciiheader
-  set tel = `$header $stem.fil -telescope`
-  set mac = `$header $stem.fil -machine`
-  set frame = `$header $stem.fil -frame`
-  set nbits = `$header $stem.fil -nbits`
-  echo "$tel $mac $frame data" >> asciiheader
-  echo $stem.$cand >> asciiheader
-  echo $coords >> asciiheader
-  $header $stem.fil -tstart | awk '{printf "%.5f\n", $1}' >> asciiheader
-  echo $cal  >> asciiheader
-  echo "$fch1+($nchans*$foff)/2."|bc -l|awk '{printf "%.1f\n",$1}'>>asciiheader
-  echo "($nchans*$foff)"         |bc -l|awk '{printf "%.1f\n",$1}'>>asciiheader
-  echo $fch1 >> asciiheader
-  echo $foff >> asciiheader
-  echo $nchans >> asciiheader
-  echo $nbits >> asciiheader
-  echo $tsamp  >> asciiheader
-  echo $obstime >> asciiheader
-  echo $period >> asciiheader
-  echo $dmval >> asciiheader
-  set psf = `$quickplot $srch greyscale`
-  rm -f $srch
-  next:
-end
-###############################################################################
-done:
-echo "DONE!"
-echo "--------------------------------------------------------------" >! $stem.txt
-echo " Period (ms)    S/N     DM   DMID Nhit Fold P/Ptop    Ptop/P" >>$stem.txt
-echo "--------------------------------------------------------------" >>$stem.txt
-cat $stem.lis | head -$nfold                                        >>$stem.txt
-cat $stem.*.fld                                             >> $stem.txt
-echo "--------------------------------------------------------------" >>$stem.txt
-###############################################################################
-cleanup:
-rm -f *.top *.frq *.monitor *.tim *.sub *.log *.bst *.sum grey *FFT* *FFA*
-rm -f $stem sus* 
-rm -f *core* *.fld *.lis 
-rm -f asciiheader sub*.epn timeseries
-rm -f $stem
-gzip -f *.ps
-echo "ASCII output in file: $stem.txt"
-echo "The corresponding plot files are:"
-ls $stem*.ps.gz
-exit
-###############################################################################
diff --git a/filterbank-gmrt/formspec.f b/filterbank-gmrt/formspec.f
deleted file mode 100644
index a61313d..0000000
--- a/filterbank-gmrt/formspec.f
+++ /dev/null
@@ -1,38 +0,0 @@
-c==========================================================================
-      subroutine formspec(npf,nf1)
-c==========================================================================
-      implicit none
-c
-c     Forms the power spectrum from the real and imaginary
-c     parts ffted array series(ntim) (see seek.inc)
-c
-      include 'seek.inc'
-      include 'csamp.inc'
-      integer npf,nf1
-      integer i,j
-      real arl,ail,a1,a2,ar,ai,anf
-
-      anf=series(2)**2
-      arl=0.0
-      ail=0.0
-      do i=1,2*nf1
-         series(i)=0.0
-      enddo
-
-      npf=ntim/2
-      do j=1,npf-1
-        ar=series(2*j+1)
-        ai=series(2*j+2)
-        a1=ar**2+ai**2
-        a2=((ar-arl)**2+(ai-ail)**2)/2.
-        samp(j)=sqrt(max(a1,a2))
-        arl=ar
-        ail=ai
-      enddo
-      samp(npf)=0.0
-c      ar=sqrt(anf)
-c      a1=anf
-c      a2=((ar-arl)**2 + ail**2)/2.
-c      samp(npf)=sqrt(max(a1,a2))
-      end
-c==========================================================================
diff --git a/filterbank-gmrt/freq.f b/filterbank-gmrt/freq.f
deleted file mode 100644
index c8620cb..0000000
--- a/filterbank-gmrt/freq.f
+++ /dev/null
@@ -1,28 +0,0 @@
-c=============================================================================
-      real*8 function freq(tsamp,npf,fold,k)
-c=============================================================================
-c
-c     Returns the fluctuation frequency (Hz) of bin k in the Fourier
-c     spectrum having npf points. Tsamp is the sampling interval
-c     of the corresponding time domain data (seconds), whilst fold
-c     refers to 1 plus the number of harmonic sums that have produced
-c     the present spectrum. e.g fold=1 -> refers to the raw spectrum
-c     fold=5 refers to 4 harmonic sums (16 harmonics).
-c
-      real*8 tsamp
-      integer npf,fold,k
-      freq=real(k)/(2.0*tsamp*npf*2.0**(fold-1))
-      end
-c=============================================================================
-      integer function fbin(tsamp,npf,fold,freq)
-c=============================================================================
-c
-c     Just the mathematical inverse of freq. Returns the bin number for
-c     a given frequency.
-c      
-      real*8 tsamp
-      integer npf,fold
-      real freq
-      fbin=real(freq)*(2.0*real(tsamp)*npf*2.0**(fold-1))
-      end
-c=============================================================================
diff --git a/filterbank-gmrt/fshift_prof.c b/filterbank-gmrt/fshift_prof.c
deleted file mode 100644
index c376a91..0000000
--- a/filterbank-gmrt/fshift_prof.c
+++ /dev/null
@@ -1,37 +0,0 @@
-#include <stdio.h>
-#include <math.h>
-#include <stdlib.h>
-#define NMAX 8192  /* Need a 2-d array */
-#define PI 3.1415926
-#define TWOPI 6.2831852
-/* 
-   shift a profile located in the memory position *profile by the
-   correct phase = fshift. nbins is the total number of bins. 
-   Note that this is a frequency-domain rotation!
-*/
-void fshift_prof(float *profile, int nbins, double fshift) /* includefile */
-{
-  float profout[NMAX][2],*amp,*pha;
-  float pha1;
-  int i,j,nh;
-  int forward=1,back=-1,complex=0,real=1;
-
-  nh = nbins/2;
-  amp=(float *) malloc((nh+1) * sizeof(float));
-  pha=(float *) malloc((nh+1) * sizeof(float));
-
-  cprofc(profile,nbins,amp,pha);
-  pha1 = fshift*TWOPI;
-  for(i=1;i<nh;i++)
-    pha[i] = fmod((pha[i] + i*pha1),TWOPI);
-  uncprofc(amp,pha,nbins,&profout[0][0]);
-  for(i=0;i<nbins;i++)
-    for(j=0;j<2;j++)
-      profout[i][j] /= nbins;
-  ffft_(&profout[0][0],&nbins,&back,&complex);
-  for(i=0;i<nbins;i++)
-    profile[i] = profout[i][0]/2.;
-
-  free(amp);
-  free(pha);
-}
diff --git a/filterbank-gmrt/getddis.f b/filterbank-gmrt/getddis.f
deleted file mode 100644
index 503ffe4..0000000
--- a/filterbank-gmrt/getddis.f
+++ /dev/null
@@ -1,37 +0,0 @@
-c==============================================================================
-      subroutine getddis(llog,filename,nchan,dmidx)
-c==============================================================================
-      implicit none
-      include 'time.inc'
-      integer dmidx, lun,nsrec,nchan,i,j,k,l,llog
-      parameter(nsrec=4096)
-      byte ddat(nsrec) 
-      character filename*(*), uprow*3
-c==============================================================================
-      uprow = char(27)//'[A'
-      write(llog,*) 'Reading DMIDX:',dmidx,'...'
-      call glun(lun)
-      open(lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=nsrec)
-      i=dmidx
-      j=0
-      k=0
-      l=0
-      write(llog,*)
-      do while(k.lt.npts)
-        read(lun,rec=i,err=1) (ddat(j),j=1,nsrec)
-        do j=1,nsrec
-          k=k+1
-          series(k)=ddat(j)
-        enddo
-        i=i+nchan
-        l=l+1
-        if (mod(l,8).eq.0) write(llog,*) uprow,'Read Rec.#:',l
-      enddo
- 1    close(lun)
-      write(llog,*) uprow,'Read',l,' records.'
-      ntim=k
-      end
-c==============================================================================
-
-
diff --git a/filterbank-gmrt/getmjd.f b/filterbank-gmrt/getmjd.f
deleted file mode 100644
index d116d47..0000000
--- a/filterbank-gmrt/getmjd.f
+++ /dev/null
@@ -1,99 +0,0 @@
-c==============================================================================
-      subroutine getmjd(mjdnow)
-c==============================================================================
-c
-c     Returns, to the nearest second, the MJD at the time of
-c     calling this routine by using the ship's clock.
-c
-c     Should be millenium proof but, quite frankly, I don't give a damn!
-c
-c     Creation date: 98/04/30 (dunc@mpifr-bonn.mpg.de)
-c      
-c==============================================================================
-c      
-      implicit none
-      double precision mjdnow
-      integer yy,mm,dd,hh,mi,ss,j
-      call clock(yy,mm,dd,hh,mi,ss)
-      yy=yy+1900
-      if (yy.lt.1998) yy=yy+100 ! Millenium check
-      call sla_cldj(yy,mm,dd,mjdnow,j)
-      mjdnow=mjdnow+real(hh)/24.0+real(mi)/1440.0+real(ss)/86400.0
-      end
-c==============================================================================
-      SUBROUTINE sla_CLDJ (IY, IM, ID, DJM, J)
-*+
-*     - - - - -
-*      C L D J
-*     - - - - -
-*
-*  Gregorian Calendar to Modified Julian Date
-*
-*  Given:
-*     IY,IM,ID     int    year, month, day in Gregorian calendar
-*
-*  Returned:
-*     DJM          dp     modified Julian Date (JD-2400000.5) for 0 hrs
-*     J            int    status:
-*                           0 = OK
-*                           1 = bad year   (MJD not computed)
-*                           2 = bad month  (MJD not computed)
-*                           3 = bad day    (MJD computed)
-*
-*  The year must be -4699 (i.e. 4700BC) or later.
-*
-*  The algorithm is derived from that of Hatcher 1984
-*  (QJRAS 25, 53-55).
-*
-*  P.T.Wallace   Starlink   December 1985
-*-
-
-      IMPLICIT NONE
-
-      INTEGER IY,IM,ID
-      DOUBLE PRECISION DJM
-      INTEGER J
-
-*  Month lengths in days
-      INTEGER MTAB(12)
-      DATA MTAB/31,28,31,30,31,30,31,31,30,31,30,31/
-
-
-
-*  Preset status
-      J=0
-
-*  Validate year
-      IF (IY.LT.-4699) THEN
-         J=1
-      ELSE
-
-*     Validate month
-         IF (IM.GE.1.AND.IM.LE.12) THEN
-
-*        Allow for leap year
-            IF (MOD(IY,4).EQ.0) THEN
-               MTAB(2)=29
-            ELSE
-               MTAB(2)=28
-            END IF
-            IF (MOD(IY,100).EQ.0.AND.MOD(IY,400).NE.0)
-     :         MTAB(2)=28
-
-*        Validate day
-            IF (ID.LT.1.OR.ID.GT.MTAB(IM)) J=3
-
-*        Modified Julian Date
-               DJM=DBLE((1461*(IY-(12-IM)/10+4712))/4
-     :                  +(306*MOD(IM+9,12)+5)/10
-     :                  -(3*((IY-(12-IM)/10+4900)/100))/4
-     :                  +ID-2399904)
-
-*        Bad month
-         ELSE
-            J=2
-         END IF
-
-      END IF
-
-      END
diff --git a/filterbank-gmrt/getrmea.f b/filterbank-gmrt/getrmea.f
deleted file mode 100644
index 3a7b06b..0000000
--- a/filterbank-gmrt/getrmea.f
+++ /dev/null
@@ -1,116 +0,0 @@
-c==============================================================================
-      subroutine getrmed(data,ndat,nrun,rmed,ncal)
-c==============================================================================
-c
-c     Calculates the running median for nrun points of the array data(1:ndat)
-c
-c     data    - r4  - data array
-c     ndat    - i4  - number of data points
-c     nrun    - i4  - number of points to average
-c      
-c     rmed    - r4  - array to store running mean
-c     ncal    - i4  - number of means calculated
-c
-c     Created: November 1997 (dunc@mpifr-bonn.mpg.de)
-c
-c==============================================================================
-c     
-      implicit none
-      integer ndat,nrun,ncal
-      real data(*),rmed(*)
-c
-c     Local variables
-c      
-      integer i,j,k,nmax
-      parameter (nmax=8192)
-      real tmp(nmax)
-      integer idx(nmax)
-      if (nrun.gt.nmax) stop 'getrmed: array size limit reached!'
-c
-c     Initialise...
-c      
-      j=0
-      k=0
-c
-c     Main loop
-c      
-      do i=1,ndat
-        j=j+1
-        tmp(j)=data(i)
-        if (j.eq.nrun) then
-  	   call indexxf77(nrun,tmp,idx)
-           k=k+1
-	   rmed(k)=tmp(idx(nrun/2))
-           j=0
-        endif
-      enddo
-c
-c     Pass back number of calculations
-c      
-      ncal=k
-      end
-c
-c     That's all folks!
-c      
-c==============================================================================
-      subroutine getrmea(data,ndat,nrun,rmea,ncal)
-c==============================================================================
-c
-c     Calculates the running mean for nrun points of the array data(1:ndat)
-c
-c     data    - r4  - data array
-c     ndat    - i4  - number of data points
-c     nrun    - i4  - number of points to average
-c      
-c     rmea    - r4  - array to store running mean
-c     ncal    - i4  - number of means calculated
-c
-c     Created: November 1997 (dunc@mpifr-bonn.mpg.de)
-c
-c==============================================================================
-c     
-      implicit none
-      integer ndat,nrun,ncal
-      real data(*),rmea(*)
-c
-c     Local variables
-c      
-      integer i,j,k,l
-      real sum
-c
-c     Initialise...
-c      
-      j=0
-      k=0
-      l=0
-      sum=0.0
-c
-c     Main loop
-c      
-      do i=1,ndat
-        if (data(i).ne.0.0) then
-          l=l+1
-          sum=sum+data(i)
-        endif
-        j=j+1
-        if (j.eq.nrun) then
-           k=k+1
-           if (l.gt.0) then
-             rmea(k)=sum/real(l)
-           else
-             rmea(k)=0.0
-           endif
-           sum=0.0
-           j=0
-           l=0
-        endif
-      enddo
-c
-c     Pass back number of calculations
-c      
-      ncal=k
-      end
-c
-c     That's all folks!
-c      
-c==============================================================================
diff --git a/filterbank-gmrt/getrrms.f b/filterbank-gmrt/getrrms.f
deleted file mode 100644
index c5dda9f..0000000
--- a/filterbank-gmrt/getrrms.f
+++ /dev/null
@@ -1,82 +0,0 @@
-c==============================================================================
-      subroutine getrrms(data,ndat,rmea,nrun,rrms)
-c==============================================================================
-c
-c     Calculates the running rms of the data in the array data(1:ndat) after
-c     subtracting off its running mean contained in the array rmea(1:nrun).
-c      
-c     This calculation AVOIDS rfi/psr spikes which bias the overall rms.
-c      
-c     data    - r4  - data array
-c     ndat    - i4  - number of data points
-c     rmea    - r4  - array to store running mean
-c     nrun    - i4  - number of points to average
-c      
-c     rrms    - r4  - array to store running rms      
-c
-c     Created: November 1997 (dunc@mpifr-bonn.mpg.de)
-c
-c==============================================================================
-c     
-      implicit none
-      real data(*),rmea(*),rrms(*)
-      integer ndat,nrun
-c
-c     Local variables...
-c      
-      logical zap,spike
-      integer i,j,k,l
-      real sumsq,rms,mean,lastgood
-c
-c     Initialise...
-c      
-      j=0
-      k=0
-      l=0
-      sumsq=0.0
-      rms=0.0
-      mean=rmea(1)
-      lastgood=1.0
-c
-c     Main loop
-c      
-      do i=1,ndat
-c
-c       Check whether data point has been zapped i.e. it is exactly 0.0
-c         
-        zap=data(i).eq.0.0
-c
-c       Watch out for any remaining spikes >3 sigma (e.g. pulsars!)
-c        
-        spike=mean.ne.0.0.and.data(i).gt.mean+rms*3.0
-c
-c       Update running sum of squares if this not a zapped point or spike
-c        
-        if ((.not.zap).and.(.not.spike)) then
-          l=l+1
-          sumsq=sumsq+(data(i)-mean)*(data(i)-mean)
-        endif
-        j=j+1
-c
-c       Calculate rms if required sum reached...
-c        
-        if (j.eq.nrun) then
-           k=k+1
-           mean=rmea(k)
-           if (l.gt.0) then
-             rrms(k)=sqrt(sumsq/real(l))
-             lastgood=rrms(k)
-           else
-             rrms(k)=lastgood
-           endif
-           rms=rrms(k)
-           sumsq=0.0
-           j=0
-           l=0
-        endif
-      enddo
-      end
-c
-c     That's all folks!
-c      
-c==============================================================================
diff --git a/filterbank-gmrt/gleancands.c b/filterbank-gmrt/gleancands.c
deleted file mode 100644
index 6ffd0ef..0000000
--- a/filterbank-gmrt/gleancands.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/*****************************************************************************
-                             GLEANCANDS.C
-
-  This program looks at the best file and eliminates 100 Hz and harmonic 
-  candidates. It also compares candidates with a standard birdie file 
-  and finally produces an output file with remaining valid candidates. 
-  The program also produces DM curves for these.
-
-  BCJ 22/03/2007
-******************************************************************************/
-
-#include <stdio.h>
-#include <string.h>
-
-
-int main(int argc, char *argv[])
-{
-int       i, ibird;
-int       nbird;
-
-float     birdie[500];
-
-char      line[500];
-
-FILE      *fbest, fbirdie;
-
-
-  fbest = fopen( argv[1], "r" );
-  if ( argc == 3 ) 
-    {
-      fbirdie = fopen( argv[1], "r" );
-      while ( !feof(fbirdie) ) 
-	{
-	  fscanf( fbirdie, "%f", &birdie[i++]);
-	}
-      nbird = i;
-      fclose(fbirdie);
-    }
-
-  while( !feof(fbest) )
-    {
-      fscanf( fbest, "%s", line );
-      
-
-read best file
-skip text till first cand
-if first cand not 100 Hz check 100 Hz flag
-if not text if not harmonic if not birdie if not 100 Hz flag check against 
-                     100 Hz if not write out
-				     else write out
-else skip text
-till eof
-
-
-  fclose( fbest);
-  return(0);
-} 
diff --git a/filterbank-gmrt/glun.f b/filterbank-gmrt/glun.f
deleted file mode 100644
index 847faf5..0000000
--- a/filterbank-gmrt/glun.f
+++ /dev/null
@@ -1,35 +0,0 @@
-c==============================================================================
-C nicked from pgplot
-C*GRGLUN -- get a Fortran logical unit number (Sun/Convex-UNIX)
-C+
-      SUBROUTINE GLUN(LUN)
-      INTEGER LUN
-C
-C Get an unused Fortran logical unit number. 
-C Returns a Logical Unit Number that is not currently opened.
-C After GRGLUN is called, the unit should be opened to reserve
-C the unit number for future calls.  Once a unit is closed, it
-C becomes free and another call to GRGLUN could return the same
-C number.  Also, GRGLUN will not return a number in the range 1-9
-C as older software will often use these units without warning.
-C
-C Arguments:
-C  LUN    : receives the logical unit number, or -1 on error.
-C--
-C 12-Feb-1989 [AFT/TJP].
-C DRL adapted to subroutine GLUN for use with stand-alone software
-C 16-Jul-1993 @ JB
-c==============================================================================
-      INTEGER I
-      LOGICAL QOPEN
-C---
-      DO 10 I=99,10,-1
-          INQUIRE (UNIT=I,  OPENED=QOPEN)
-          IF (.NOT.QOPEN) THEN
-              LUN = I
-              RETURN
-          END IF
-   10 CONTINUE
-C none left
-      STOP 'RAN OUT OF LUNs!' 
-      END
diff --git a/filterbank-gmrt/gmrt2fb.c b/filterbank-gmrt/gmrt2fb.c
deleted file mode 100644
index 5c15f80..0000000
--- a/filterbank-gmrt/gmrt2fb.c
+++ /dev/null
@@ -1,57 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-*/
-#include "filterbank.h"
-void gmrt2fb(FILE *input, FILE *output) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[256];
-  unsigned short ur[256];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[256];
-  r=opened=0;
-  c=256;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c--]= ((junk) & 32767);
-    if (c==0) {
-      r++;
-      if (r>10) {
-	for (c=1;c<=256;c++) {
-	  ur[c-1]=result[c];
-	  uc[c-1]=128+((double)result[c]-mean);
-	}
-	ur[0]=ur[1]=ur[254]=ur[255]=uc[0]=uc[1]=uc[254]=uc[255]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),256,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),256,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean */
-	for (c=1;c<=256;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=256;
-    }
-  }
-}
diff --git a/filterbank-gmrt/gmrt2fbgsb32512.c b/filterbank-gmrt/gmrt2fbgsb32512.c
deleted file mode 100644
index 52ba731..0000000
--- a/filterbank-gmrt/gmrt2fbgsb32512.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-*/
-#include "filterbank.h"
-void gmrt2fbgsb32512(FILE *input, FILE *output) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[512];
-  unsigned short ur[512];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[512];
-  r=opened=0;
-  c=512;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c--]= ((junk));
-    if (c==0) {
-      r++;
-      if (r>10) {
-	for (c=1;c<=512;c++) {
-	  ur[c-1]=result[c];
-	  uc[c-1]=128+((double)result[c]-mean);
-	}
-	ur[0]=ur[1]=ur[510]=ur[511]=0;
-	uc[0]=uc[1]=uc[510]=uc[511]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),512,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),512,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean */
-	for (c=1;c<=512;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=512;
-    }
-  }
-}
diff --git a/filterbank-gmrt/gmrt2fbgwbf.c b/filterbank-gmrt/gmrt2fbgwbf.c
deleted file mode 100644
index 04e27bd..0000000
--- a/filterbank-gmrt/gmrt2fbgwbf.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-*/
-#include "filterbank.h"
-void gmrt2fbgwbf(FILE *input, FILE *output, int nch) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[16384];
-  unsigned short ur[16384];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[16384];
-  r=opened=0;
-  c=nch;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c--]= ((junk));
-    if (c==0) {
-      r++;
-      if (r>10) {
-	for (c=1;c<=nch;c++) {
-	  ur[c-1]=result[c];
-	  uc[c-1]=128+((double)result[c]-mean);
-	}
-//	for(c=0; c<100 ; c++)
-//	  {
-//	    ur[c] = 0;
-//	    uc[c]=0;
-//	  }
-//	for(c=nch-100; c<nch ; c++)
-//	  {
-//	    ur[c] = 0;
-//	    uc[c]=0;
-//	  }
-//	ur[0]=ur[1]=ur[nch]=ur[511]=0;
-//	uc[0]=uc[1]=uc[510]=uc[511]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),nch,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),nch,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean 
-           BCJ Modified 19-12-15 use these samples for ur, but not 
-           for uc where calculate mean */
-	for (c=1;c<=nch;c++)  ur[c-1]=result[c];
-//	for(c=0; c<100 ; c++)	    ur[c] = 0;
-//	for(c=nch-100; c<nch ; c++)	    ur[c] = 0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),nch,output);
-	for (c=0;c<nch;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=nch;
-    }
-  }
-}
diff --git a/filterbank-gmrt/gmrt2fbgwbr.c b/filterbank-gmrt/gmrt2fbgwbr.c
deleted file mode 100644
index adf8c51..0000000
--- a/filterbank-gmrt/gmrt2fbgwbr.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-*/
-#include "filterbank.h"
-void gmrt2fbgwbr(FILE *input, FILE *output, int nch) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[16384];
-  unsigned short ur[16384];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[16384];
-  r=opened=0;
-  c=0;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c++]= ((junk));
-    if (c==nch) {
-      r++;
-      if (r>10) {
-	for (c=0;c<nch;c++) {
-	  ur[c]=result[c];
-	  uc[c]=128+((double)result[c]-mean);
-	}
-//	for(c=0; c<100 ; c++)
-//	  {
-//	    ur[c] = 0;
-//	    uc[c]=0;
-//	  }
-//	for(c=nch-100; c<nch ; c++)
-//	  {
-//	    ur[c] = 0;
-//	    uc[c]=0;
-//	  }
-//	ur[0]=ur[1]=ur[nch]=ur[511]=0;
-//	uc[0]=uc[1]=uc[510]=uc[511]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),nch,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),nch,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean 
-           BCJ Modified 19-12-15 use these samples for ur, but not 
-           for uc where calculate mean */
-	for (c=0;c<nch;c++)  ur[c]=result[c];
-//	for(c=0; c<100 ; c++)	    ur[c] = 0;
-//	for(c=nch-100; c<nch ; c++)	    ur[c] = 0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),nch,output);
-	for (c=0;c<nch;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=0;
-    }
-  }
-}
diff --git a/filterbank-gmrt/gmrt2fblsb.c b/filterbank-gmrt/gmrt2fblsb.c
deleted file mode 100644
index 05c6e77..0000000
--- a/filterbank-gmrt/gmrt2fblsb.c
+++ /dev/null
@@ -1,68 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-
-   Modified to handle LSB data         bcj 20-01-2007
-*/
-#include "filterbank.h"
-void gmrt2fblsb(FILE *input, FILE *output) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[256];
-  unsigned short ur[256];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[256];
-  r=opened=0;
-  c=0;
-//  c=256;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c++]= ((junk) & 32767);
-//    result[c--]= ((junk) & 32767);
-    if (c==256) {
-//    if (c==0) {
-      r++;
-      if (r>10) {
-	for (c=0;c<256;c++) {
-	  ur[c]=result[c];
-	  uc[c]=128+((double)result[c]-mean);
-	}
-//	for (c=1;c<=256;c++) {
-//	  ur[c-1]=result[c];
-//	  uc[c-1]=128+((double)result[c]-mean);
-//	}
-	ur[0]=ur[1]=ur[254]=ur[255]=uc[0]=uc[1]=uc[254]=uc[255]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),256,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),256,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean */
-	for (c=0;c<256;c++) {
-//	for (c=1;c<=256;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=0;
-//      c=256;
-    }
-  }
-}
diff --git a/filterbank-gmrt/gmrt2fbusblsb.c b/filterbank-gmrt/gmrt2fbusblsb.c
deleted file mode 100644
index 8bc1bba..0000000
--- a/filterbank-gmrt/gmrt2fbusblsb.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/* 
-   gmrt2fb - converts GMRT search-mode data into "filterbank" data 
-   adapted from f77 code gmrt2fb. This version produces identical
-   16-bit data to the f77 version but also has a new 8-bit option
-   which subtracts a mean from the data and writes the result as an
-   unsigned character. The resulting output is centred on 128. This
-   appears to be just as good as the 16-bit mode. drl-July-20-2005
-*/
-#include "filterbank.h"
-void gmrt2fbusblsb(FILE *input, FILE *output) /* includefile*/
-{
-  double mean,sum,num;
-  short junk,result[512];
-  unsigned short ur[512];
-  int c,r,opened;
-  char string[80];
-  unsigned char uc[512];
-  r=opened=0;
-  c=512;
-  sum=num=0.0;
-  while (!ferror(input)) {
-    if ( (fread(&junk,2,1,input)) != 1) return;
-    result[c--]= ((junk) & 32767);
-    if (c==0) {
-      r++;
-      if (r>10) {
-	for (c=1;c<=512;c++) {
-	  ur[c-1]=result[c];
-	  uc[c-1]=128+((double)result[c]-mean);
-	}
-	ur[0]=ur[1]=ur[254]=ur[255]=ur[256]=ur[257]=ur[510]=ur[511]=0;
-	uc[0]=uc[1]=uc[254]=uc[255]=uc[256]=uc[257]=uc[510]=uc[511]=0;
-	if (obits==16) 
-	  fwrite(ur,sizeof(short),512,output);
-	if (obits==8)
-	  fwrite(uc,sizeof(char),512,output);
-      } else {
-	/* for some reason, the first 10 samples were not
-           used in the f77 code, so repeat that here but
-           use these samples to calculate a mean */
-	for (c=1;c<=512;c++) {
-	  sum+=result[c];
-	  num+=1.0;
-	}
-	mean=sum/num;
-      }
-      if (r%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",r*tsamp);
-	update_log(string);
-      }
-      c=512;
-    }
-  }
-}
diff --git a/filterbank-gmrt/grey.f b/filterbank-gmrt/grey.f
deleted file mode 100644
index 923a762..0000000
--- a/filterbank-gmrt/grey.f
+++ /dev/null
@@ -1,228 +0,0 @@
-c==============================================================================
-      program gray
-c==============================================================================
-c
-c  This program plots EPN records to the standard output in a pseudo-grey
-c  scale style suitable for viewing on a simple terminal with no graphic
-c  capabilities.
-c
-c  Last modified 98/04/28 - writes out ASCII array of the grey scale for plot
-c
-c  dunc@mpifr-bonn.mpg.de
-c
-c==============================================================================
-      
-      implicit none
-
-      include 'epnhdr.inc'
-      real tmp(maxbin)
-      integer nepnrec,nrec,nscr,nplt,step,next,nbins,nch,ichan,lun,istat
-      integer narg, lfil,i,j,nskip, nread,iargc,ln,nc,hh,mm,nborg,binmax
-      double precision date,ss
-      logical chflag(maxblk),first,centre,help
-      data first/.true./
-      real*8 t1,tsub
-      real dmin,dmax,rmsfac,grey(80),prmax
-      parameter (nscr=60,nc=10)
-      character*1 gry(nc),cprof(maxblk)*80,option*80
-c
-c     Here are the characters in increasing order of intensity...
-c      
-       gry(1)=' '
-       gry(2)=' '
-       gry(3)=' '
-       gry(4)=','
-       gry(5)=':'
-       gry(6)='o'
-       gry(7)='*'
-       gry(8)='@'
-       gry(9)='$'
-      gry(10)='#'
-      rmsfac=0.0
-c
-c     Prompt user if silly/no options entered...
-c      
-      narg=iargc()
-      help=.false.
-      if (narg.lt.1) then
-         call glun(lun)
-         open(unit=lun,file='file',status='old',iostat=istat)
-         if (istat.eq.0) then
-            read(lun,'(a)') filename
-            close(lun)
-         else
-            help=.true.
-         endif
-      endif
-         
-      if (help) then
-      write(*,'('' GREY : A program to greyplot EPN data.'')')
-         write(*,'('' No options were specified!'')')
-         write(*,'('' usage: plotg [filename] <options>'')')
-         write(*,'('' N.B. Input file must be in EPN format!!'')')
-	 write(*,'('' -r: set start record number (def=1)'')')
-	 write(*,'('' -s: set min=0 & max=n*rms (def=autoscale)'')')
-	 write(*,'('' -c: centres profile to first record (optional)'')')
-         write(*,'('' Comments/Bugs etc. -> dunc@mpifr-bonn.mpg.de'')')
-         stop 
-      else
-         if (narg.ge.1) call getarg(1,filename)
-         lfil=index(filename,'.ser')-1
-         if (lfil.eq.0) lfil=index(filename,'.dis')-1
-         if (lfil.gt.0) filename=filename(1:lfil)
-         lfil=index(filename,' ')-1
-	 if (index(filename,'.epn').eq.0) then
-	   filename=filename(1:lfil)//'.epn'
-	   lfil=lfil+4
-         endif
-         nrec=nepnrec(filename)
-         if (nrec.eq.0) then 
-           write(*,'('' EPN file: '',a,'' not found!'')')
-     &     filename(1:lfil)
-           stop
-         endif
-      endif
-c
-c     Read the first record to find out the number of channels...
-c      
-      padout=.false.
-      readwri=-1
-      recno=1
-      call rwepn(filename, readwri, recno, padout)
-      t1=tstart(1)
-      recno=2
-      call rwepn(filename, readwri, recno, padout)
-      tsub=tstart(1)-t1
-c
-c     Set up default values...
-c      
-      nskip=0
-      nread=0
-      recno=0
-      do i=1,maxblk
-         chflag(i)=.false.
-      enddo
-      chflag(1)=.true.
-      centre=.false.
-      binmax=0
-c
-c     Read optional extras from the standard input if necessary...
-c      
-      if (narg.ge.2) then
-         do i=2,narg
-  	   call getarg(i,option)
-           if (index(option,'-r').gt.0) then
-              read(option(3:),'(i5)') recno
-              recno=recno-1
-              if (recno.lt.0) recno=0
-           else if (index(option,'-s').gt.0) then
-              read(option(3:),'(f8.2)')rmsfac
-           else if (index(option,'-c').gt.0) then
-              centre=.true.
-           else if (index(option,'-S').gt.0) then
-              read(option(3:),*) binmax
-           endif
-         enddo
-      endif
-c
-c     Main loop
-c
-      call glun(lun)
-      open(lun,file='grey',status='unknown')
-      do while(recno.ne.-999)
-
-        recno=recno+1
-        call rwepn(filename, readwri, recno, padout)
-        date=epoch+tstart(1)/8.64e10
-        call dattim(date,hh,mm,ss)
-        ln=index(cname,' ')-1
-        nch=0
-
-        if (first.and.centre) then
-           binmax=0
-           prmax=-1.0e32
-           do i=1,nbin
-              if (rawdata(1,i).gt.prmax) then
-                 prmax=rawdata(1,i)
-                 binmax=i
-              endif
-           enddo
-           binmax=nbin/2-binmax
-        endif
-        
-        do ichan=1,npol
-        if (chflag(ichan)) then
-
-        nch=nch+1
-        do i=1,nbin
-           tmp(i)=0.0
-        enddo
-        nplt=nscr
-        step=nbin/nscr
-        if (step.lt.1) step=1
-        next=step
-        j=1
-        do i=1,nbin
-           tmp(j)=tmp(j)+rawdata(ichan,i)
-           if (i.eq.next) then
-              j=j+1
-              next=next+step
-           endif
-        enddo
-        nbins=j-1
-
-        if (nbins.gt.nscr) nbins=nscr
-
-c        if (centre) call sprof(tmp,nbins,binmax)
-        if (binmax.ne.0) call sprof(tmp,nbins,binmax)
-
-        dmin=+1.0e32
-        dmax=-1.0e32
-
-        do i=1,nbins
-           dmax=max(tmp(i),dmax)
-           dmin=min(tmp(i),dmin)
-        enddo
-
-        if (rmsfac.gt.0.) then
-          dmin=0.0
-          dmax=rmsfac*rms(ichan)
-        endif
-        cprof(nch)=' '
-
-        do i=1,nbins
-          j=(tmp(i)-dmin)/(dmax-dmin)*nc+1
-          if (j.gt.nc) j=nc
-	  if (j.lt.1) j=1
-          cprof(nch)(i:i)=gry(j)
-          grey(i)=tmp(i)
-        enddo
-
-        nborg=nbins
-        do while(nbins+nborg.lt.nscr)
-           do i=1,nborg
-              cprof(nch)(nbins+i:nbins+i)=cprof(nch)(i:i)
-              grey(nbins+i)=grey(i)
-           enddo
-           nbins=nbins+nborg
-        enddo
-
-        endif
-        enddo
-        if (recno.ne.-999) then
-        write(*,'('' |'',i4.4,''|'',i2.2,'':'',i2.2,'':'',i2.2,
-     &  ''|'',a,''|'')')
-     &   recno,hh,mm,int(ss),cprof(1)(1:nbins)
-        if (first) then
-C           write(lun,'(x,a72)') history
-           write(lun,*)
-           write(lun,*) nbins,1.0/real(nborg),real(tsub)/1.0e6/60.0
-           first=.false.
-        endif
-        write(lun,*) (grey(i),i=1,nbins)
-        endif
-      enddo
-      close(lun)
-c      write(*,*)1.0e6*real(papp(1)**2.0)/real(date*86400.0)/real(nbins),
-c     &           ' us error in period would cause a drift of one bin...'
-      end
diff --git a/filterbank-gmrt/head.inc b/filterbank-gmrt/head.inc
deleted file mode 100644
index e34c53f..0000000
--- a/filterbank-gmrt/head.inc
+++ /dev/null
@@ -1,37 +0,0 @@
-c==============================================================================
-c Definition of the header variables in the time series files.
-c==============================================================================
-c
-      real*8 tsamp   ! sampling time (seconds)
-      common /head/ tsamp
-      integer nchans,channo,maxchans  ! number of filterbank channels
-      parameter(maxchans=4)
-      real skyfreq
-      common /fbank/ nchans,skyfreq(maxchans),channo
-      real refdm     ! reference DM for time series
-      common /dmref/ refdm
-      real refac     ! reference acceleration for time series (m/s/s)
-      real refad     ! reference adot for time series (cm/s/s/s)
-      common /accn/ refac,refad
-      character*80 filename,header,facc
-      integer lst
-      common /datafile/ filename,header,lst,facc
-      integer dmidx
-      common /dmindex/ dmidx
-      character*80 zapfile,maskfile(5)
-      integer nmasks
-      common /zapfname/ zapfile,maskfile,nmasks
-      real fbrute
-      common /brutal/ fbrute
-      integer rfac
-      common /rebinfac/ rfac
-      real    skp
-      common /skipfac/ skp
-      integer tsize
-      common /transform/ tsize
-      logical dumpraw
-      common /rawspec/ dumpraw
-      logical noise
-      common /test/ noise
-c
-c==============================================================================
diff --git a/filterbank-gmrt/head_parse.c b/filterbank-gmrt/head_parse.c
deleted file mode 100644
index 69a42e1..0000000
--- a/filterbank-gmrt/head_parse.c
+++ /dev/null
@@ -1,325 +0,0 @@
-
-int wapp_incfile_length;
-#include <stdio.h>
-#include <fcntl.h>
-#include <string.h>
-#include <strings.h>
-
-void head_input( char *, int *, int );
-int linecount = 1;
-
-#define YY_INPUT(buf,result,max) head_input(buf,&result,max)
-#include "mkheaderlex.c"
-
-#include "key.h"
-
-
-struct HEADERP *yacc_input = NULL;
-
-/* this routine is not re-entrant, (because of yyparse and yacc_input) */
-
-struct HEADERP *head_parse( file )
-char *file;
-{
-  int fd, count, ret;
-  unsigned char byte;
-  struct HEADERKEY *key;
-  struct HEADERP *h;
-  char temp[2048];
-
-  if( (fd = open( file, O_RDWR, 0 ) ) <0 ) {
-    if( (fd = open( file, O_RDONLY, 0 ) ) <0 ) {
-      perror(file);
-      return(NULL);
-    }
-  }
-
-  if((ret = read( fd, temp, 2048)) != 2048 ) {
-    close(fd);
-    return(NULL);
-  }
-
-  temp[2047] = 0;
-
-  if( !strstr( temp, "struct WAPP_HEADER" ) ) {
-    close(fd);
-    return(NULL);
-  }
-    
-  count = 2048;
-  while( (ret = read( fd, &byte, 1)) == 1 ) {
-    if( byte == 0 )
-      break;
-    count++;
-  }
-  wapp_incfile_length=count;
-
-  if( ret < 0) {
-    close(fd);
-    return(NULL);
-  }
-
-  h = ( struct HEADERP *)malloc( sizeof(struct HEADERP));
-  bzero( h, sizeof(struct HEADERP));
-
-  h->offset = count+1;
-  h->fd = fd;
-  h->buf = (char *)malloc( h->offset);
-  lseek(fd, 0, SEEK_SET);
-  read(fd, h->buf, h->offset );
-
-  yacc_input = h;
-
-  while(yyparse()); /* use yacc to parse the header */
-  yyparse();
-
-  if( !(h->headlen = count_size(h))) {
-    close_parse(h);
-    return(NULL);
-  }
-  h->header = (void *)malloc( h->headlen );
-  if( read( fd, h->header, h->headlen ) != h->headlen ) {
-    perror("read header");
-    close_parse(h);
-    return(NULL);
-  }
-
-  key = h->head;
-  count = 0;
-  while( key ) {
-    key->len = key_sizes(key->type);
-    key->offset = count;
-    count  += key->len* key->alen;
-    key = key->next;
-  }
-
-  return(h);
-}
-
-count_size(h)
-struct HEADERP *h;
-{
-  struct HEADERKEY *k;
-  int count;
-
-  k = h->head;
-  count = 0;
-  while(k) {
-    count += key_sizes(k->type)*k->alen;
-    k = k->next;
-  }
-  return(count);
-}
-
-int key_sizes(type)
-int type;
-{
-  switch( type ) {
-    case INTEGER:
-      return sizeof(int);
-    case LONG:
-      return sizeof(long);
-    case LONGLONG:
-      return sizeof(long long);
-    case DOUBLE:
-      return sizeof(double);
-    case FLOAT:
-      return sizeof(float);
-    case CHARSTAR:
-      return sizeof(char);
-    case BYTE:
-      return sizeof(unsigned char);
-    default:
-      printf("key_sizes error, bad type %d\n", type );
-      return 0;
-  }
-}
-
-int find_hdrval( h, name, hdrval )
-struct HEADERP *h;
-char *name;
-struct HEADERVAL *hdrval;
-{
-  struct HEADERKEY *key;
-
-  key = h->head;
-  while( key ) {
-    if( strcmp( name, key->name ) == 0 )
-      break;
-    key = key->next;
-  }
-
-  if( key ) {
-    if( hdrval ) {
-      hdrval->value = (void *)((unsigned char *)h->header + key->offset);
-      hdrval->key = key;
-    }
-  } else if( hdrval ) {
-    bzero( hdrval, sizeof(struct HEADERVAL));
-  }
-
-  return(!key);
-}
-
-int set_hdrval( h, name, data, ix )
-struct HEADERP *h;
-char *name;
-void *data;
-int ix;
-{
-  struct HEADERVAL val;
-  void *value;
-
-  if( find_hdrval( h, name, &val ) )
-    return(-1);
-
-  if( val.key->alen == 1 )
-    ix = 0;
-
-  if( ix >= val.key->alen )
-    return(-1);
-
-  value = (char *)val.value + val.key->len*ix;
-
-  bcopy( data, value, val.key->len );
-  return(0);
-}
-
-int write_hdr( h )
-struct HEADERP *h;
-{
-  lseek( h->fd, h->offset, SEEK_SET );
-  if( write( h->fd, h->header, h->headlen ) != h->headlen ) {
-    perror("write_hdr write");
-    return(-1);
-  }
-  return(0);
-}
-
-ignore()
-{ 
-}
-
-
-struct HEADERKEY *new_header()
-{
-  struct HEADERKEY *p;
-  extern struct HEADERP *yacc_input;
-
-  p = (struct HEADERKEY *)malloc( sizeof(struct HEADERKEY));
-  bzero( p, sizeof(struct HEADERKEY));
-
-  if( !yacc_input->head  )
-    yacc_input->head = p;
-
-  if( yacc_input->tail )
-    yacc_input->tail->next = p;
-
-  yacc_input->tail = p;
-  return(p);
-}
-
-add_notchar(v, name)
-int v;
-char *name;
-{
-  
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  if ( v == CHARSTAR )
-    p->type = BYTE;
-  else
-    p->type = v;
-  p->alen = 1;
-}
-
-
-add_array(v, name, sz)
-int v;
-char *name, *sz;
-{
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  if ( v == CHARSTAR )
-    p->type = BYTE;
-  else
-    p->type = v;
-  if( sz )
-    p->alen = atoi(sz);
-  else
-    p->alen = 1;
-}
-
-
-comment(p)
-char *p;
-{
-  free(p);
-}
-
-add_char(name, sz)
-char *name, *sz;
-{
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  p->type = CHARSTAR;
-  if( sz )
-    p->alen = atoi(sz);
-  else
-    p->alen = 1;
-}
-
-got_construct( name )
-char *name;
-{
-  /* printf("got construct\n"); */
-}
-
-
-void head_input( buf, result, max )
-char *buf;
-int *result;
-int max;
-{
-  extern struct HEADERP *yacc_input;  
-  int ct;
-
-  ct = yacc_input->offset -  yacc_input->yacc_offset;
-  if( ct <=0 ) {
-    *buf = 0;
-    *result = 0;
-    return;
-  }
-  if( ct < max ) {
-    bcopy( &yacc_input->buf[yacc_input->yacc_offset], buf, ct );
-    yacc_input->yacc_offset = yacc_input->offset;
-    *result = ct;
-  } else { 
-    bcopy( &yacc_input->buf[yacc_input->yacc_offset], buf, max );
-    yacc_input->yacc_offset += max;
-    *result = max;
-  }
-}
-
-close_parse( h )
-struct HEADERP *h;
-{
-  struct HEADERKEY *key, *fr;
-
-  close(h->fd);
-
-  key = h->head;
-  while( key ) {
-    fr = key;
-    key = key->next;
-    free(fr);
-  }
-  
-  free(h->buf);
-  free(h->header);
-  free(h);
-}
-
diff --git a/filterbank-gmrt/header.c b/filterbank-gmrt/header.c
deleted file mode 100644
index 68b5d8e..0000000
--- a/filterbank-gmrt/header.c
+++ /dev/null
@@ -1,315 +0,0 @@
-/*
-   header - show header parameters in a data file
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include "header.h"
-#include "sigproc.h"
-int wapp_header_size, wapp_incfile_length;
-int nbins;
-	double period;
-main(int argc, char *argv[]) 
-{
-	FILE *fileptr;
-	char filename[80],*telescope,*backend,*datatype,message[80],unit[16];
-	int i,j,year,month,day,check,rah,ram,ded,dem;
-	double ras,des,frac,tobs;
-	char sra[6],sde[6],decsign;
-	int raw,uth,utm,uts;
-	long long numsamps,datasize,headersize;
-
-	int writeobsdbline;
-
-	fileptr=stdin;
-	strcpy(filename,"stdin");
-	strcpy(rawdatafile,"stdin");
-	pulsarcentric=barycentric=0;
-
-	writeobsdbline=0;
-
-	if (argc>1) {
-		print_version(argv[0],argv[1]);
-		if (help_required(argv[1])) {
-			header_help();
-			exit(0);
-		} else if (file_exists(argv[1])) {
-			strcpy(filename,argv[1]);
-			fileptr=open_file(filename,"rb");
-		} else if (!file_exists(argv[1]) && (strncmp(argv[1],"-",1) !=0)) {
-			sprintf(message,"Data file: %s not found...\n",argv[1]);
-			error_message(message);
-			exit(1);
-		}
-	}
-
-
-	if (!(headersize=read_header(fileptr))) {
-		rewind(fileptr);
-		if ((raw=typeof_inputdata(fileptr,filename))) {
-			data_type=0;
-			switch (raw) {
-				case 1:
-					headersize=32768;
-					break;
-				case 5:
-					headersize=32768;
-					break;
-				case 3:
-					headersize=wapp_header_size+wapp_incfile_length;
-					break;
-				default:
-					break;
-			}
-		} else {
-			error_message("could not read header parameters!");
-			exit(1);
-		}
-	}
-
-	/* attempt to find number of bytes of data and number of samples */
-	if (!strings_equal(filename,"stdin")) {
-		datasize=sizeof_file(filename)-headersize;
-		numsamps=nsamples(filename,headersize,nbits,nifs,nchans);
-	} else if (!strings_equal(rawdatafile,"stdin")) {
-		datasize=sizeof_file(rawdatafile)-headersize;
-		numsamps=nsamples(rawdatafile,headersize,nbits,nifs,nchans);
-	} else {
-		datasize=numsamps=0;
-	}
-
-	telescope=telescope_name(telescope_id);
-	backend=backend_name(machine_id);
-	datatype=data_category(data_type);
-
-	if (argc>2) {
-		check=1;
-		i=2;
-	} else if ((argc>1) && strings_equal(filename,"stdin")) {
-		check=1;
-		i=1;
-	} else {
-		check=0;
-	}
-
-	angle_split(src_raj,&rah,&ram,&ras);
-	if (ras<10.0) {
-		sprintf(sra,"0%.1f",ras);
-	} else {
-		sprintf(sra,"%.1f",ras);
-	}
-
-	angle_split(src_dej,&ded,&dem,&des);
-	if (src_dej > 0.0) 
-		decsign = '+';
-	else 
-		decsign = '-';
-	if (des<10.0) {
-		sprintf(sde,"0%.1f",des);
-	} else {
-		sprintf(sde,"%.1f",des);
-	}
-
-	cal(tstart,&year,&month,&day);
-
-	if (check) {
-		/* check command-line parameters */ 
-		while (i<argc) {
-			if (strings_equal(argv[i],"-telescope")) {
-				puts(telescope);
-			} else if (strings_equal(argv[i],"-obsdb")) {
-				writeobsdbline=1;
-			} else if (strings_equal(argv[i],"-machine")) {
-				puts(backend);
-			} else if (strings_equal(argv[i],"-source_name")) {
-				puts(source_name);
-			} else if (strings_equal(argv[i],"-scan_number")) {
-				puti(scan_number);
-			} else if (strings_equal(argv[i],"-datatype")) {
-				puts(datatype);
-			} else if (strings_equal(argv[i],"-frame")) {
-				if (pulsarcentric) 
-					puts("pulsarcentric");
-				else if (barycentric) 
-					puts("barycentric");
-				else 
-					puts("topocentric");
-			} else if (strings_equal(argv[i],"-barycentric")) {
-				puti(barycentric);
-			} else if (strings_equal(argv[i],"-pulsarcentric")) {
-				puti(pulsarcentric);
-			} else if (strings_equal(argv[i],"-data_type")) {
-				puti(data_type);
-			} else if (strings_equal(argv[i],"-headersize")) {
-				printf("%d\n",headersize);
-			} else if (strings_equal(argv[i],"-datasize")) {
-				printf("%lld\n",datasize);
-			} else if (strings_equal(argv[i],"-nsamples")) {
-				printf("%lld\n",numsamps);
-			} else if (strings_equal(argv[i],"-tobs")) {
-				printf("%f\n",(double)numsamps*tsamp);
-			} else if (strings_equal(argv[i],"-az_start")) {
-				printf("%f\n",az_start);
-			} else if (strings_equal(argv[i],"-za_start")) {
-				printf("%f\n",za_start);
-			} else if (strings_equal(argv[i],"-fch1")) {
-				printf("%.3f\n",fch1);
-			} else if (strings_equal(argv[i],"-bandwidth")) {
-				printf("%.3f\n",fabs(foff)*(double)nchans);
-			} else if (strings_equal(argv[i],"-fmid")) {
-				printf("%.3f\n",fch1+foff*nchans/2);
-			} else if (strings_equal(argv[i],"-foff")) {
-				printf("%f\n",foff);
-			} else if (strings_equal(argv[i],"-refdm")||strings_equal(argv[i],"-dm")) {
-				printf("%f\n",refdm);
-			} else if (strings_equal(argv[i],"-nchans")) {
-				printf("%d\n",nchans);
-			} else if (strings_equal(argv[i],"-tstart")) {
-				printf("%.12f\n",tstart);
-			} else if (strings_equal(argv[i],"-frequencies")) {
-				for (j=0; j<nchans; j++) printf("%f\n",frequency_table[j]);
-			} else if (strings_equal(argv[i],"-mjd")) {
-				printf("%d\n",(int)floor(tstart));
-			} else if (strings_equal(argv[i],"-date")) {
-				printf("%4d/%02d/%02d\n",year,month,day);
-			} else if (strings_equal(argv[i],"-utstart")) {
-				frac=tstart-floor(tstart);
-				uth=(int) floor(24.0*frac);
-				frac-=(double)uth/24.0;
-				utm=(int) floor(1440.0*frac);
-				frac-=(double)utm/1440.0;
-				uts=(int) floor(86400.0*frac);
-				printf("%02d:%02d:%02d\n",uth,utm,uts);
-			} else if (strings_equal(argv[i],"-tsamp")) {
-				printf("%.5f\n",tsamp*1.0e6);
-			} else if (strings_equal(argv[i],"-nbits")) {
-				printf("%d\n",nbits);
-			} else if (strings_equal(argv[i],"-nifs")) {
-				printf("%d\n",nifs);
-			} else if (strings_equal(argv[i],"-src_raj")) {
-				printf("%02d:%02d:%s\n",rah,ram,sra);
-			} else if (strings_equal(argv[i],"-src_dej")) {
-				printf("%c%02d:%02d:%s\n",decsign,abs(ded),dem,sde);
-			} else {
-				header_help();
-				sprintf(message,"unknown argument (%s) passed to header",argv[i]);
-				error_message(message);
-			}
-			i++;
-		}
-		/* if we are doing a obs line do this... otherwise continue normaly
-		 * MK 2006, for the MM survey bookkeeping.
-		 */
-
-
-		if(writeobsdbline){
-			printf("%s ",source_name);
-                        printf("%3.3lf %3.3lf ",gal_l,gal_b);
-			printf("%s ",filename);
-                        printf("%5.3lf %6.6lf ",header_tobs,tstart);
-			printf("%6.3lf %6.3lf ",src_raj,src_dej);
-                        printf("%5.3lf %3.3lf ",raw_fch1,raw_foff);
-			printf("%d %d %5.3lf",nbeams,nchans,tsamp*1000);
-			printf("\n");
-
-		}
-
-		exit(0);
-	}
-
-
-	/* no command-line flags were specified - display full output */
-
-	printf("Data file                        : %s\n",filename);
-	printf("Header size (bytes)              : %d\n",headersize);
-	if (datasize) 
-		printf("Data size (bytes)                : %lld\n",datasize);
-	if (pulsarcentric) 
-		printf("Data type                        : %s (pulsarcentric)\n",datatype);
-	else if (barycentric) 
-		printf("Data type                        : %s (barycentric)\n",datatype);
-	else
-		printf("Data type                        : %s (topocentric)\n",datatype);
-
-	printf("Telescope                        : %s\n",telescope);
-	printf("Datataking Machine               : %s\n",backend);
-
-
-	if (!strings_equal(source_name,"")) 
-		printf("Source Name                      : %s\n",source_name);
-	if (src_raj != 0.0) 
-		printf("Source RA (J2000)                : %02d:%02d:%s\n",rah,ram,sra);
-	if (src_dej != 0.0)
-		printf("Source DEC (J2000)               : %c%02d:%02d:%s\n",
-				decsign,abs(ded),dem,sde);
-	if ((az_start != 0.0) && (az_start != -1.0))
-		printf("Start AZ (deg)                   : %f\n",az_start);
-	if ((za_start != 0.0) && (za_start != -1.0))
-		printf("Start ZA (deg)                   : %f\n",za_start);
-
-	switch (data_type) {
-		case 0:
-		case 1:
-			if ((fch1==0.0) && (foff==0.0)) {
-				printf("Highest frequency channel (MHz)  : %f\n",
-						frequency_table[0]);
-				printf("Lowest frequency channel  (MHz)  : %f\n",
-						frequency_table[nchans-1]);
-			} else {
-				printf("Frequency of channel 1 (MHz)     : %f\n",fch1);
-				printf("Channel bandwidth      (MHz)     : %f\n",foff); 
-				printf("Number of channels               : %d\n",nchans);
-				printf("Number of beams                  : %d\n",nbeams);
-				printf("Beam number                      : %d\n",ibeam); 
-			}
-			break;
-		case 2:
-			nchans=1;
-			printf("Reference DM (pc/cc)             : %f\n",refdm);
-			printf("Reference frequency    (MHz)     : %f\n",fch1);
-			break;
-		case 3:
-			if (refdm > 0.0)
-				printf("Reference DM (pc/cc)             : %f\n",refdm);
-			printf("Frequency of channel 1 (MHz)     : %f\n",fch1);
-			printf("Channel bandwidth      (MHz)     : %f\n",foff); 
-			printf("Number of channels               : %d\n",nchans);
-			printf("Number of phase bins             : %d\n",nbins);
-			printf("Folding period  (s)              : %.12f\n",period);
-			break;
-		case 6:
-			printf("Reference DM (pc/cc)             : %f\n",refdm);
-			printf("Frequency of channel 1 (MHz)     : %f\n",fch1);
-			printf("Channel bandwidth      (MHz)     : %f\n",foff); 
-			printf("Number of channels               : %d\n",nchans);
-			break;
-	}
-
-	printf("Time stamp of first sample (MJD) : %.12f\n",tstart);
-	printf("Gregorian date (YYYY/MM/DD)      : %4d/%02d/%02d\n",year,month,day);
-
-	if (data_type != 3) 
-		printf("Sample time (us)                 : %.5f\n",tsamp*1.0e6); 
-
-	if (datasize && data_type != 3) {
-		printf("Number of samples                : %lld\n",numsamps);
-		tobs=(double)numsamps*tsamp;
-		strcpy(unit,"(seconds)   ");
-		if (tobs>60.0) {
-			tobs/=60.0;
-			strcpy(unit,"(minutes)   ");
-			if (tobs>60.0) {
-				tobs/=60.0;
-				strcpy(unit,"(hours)     ");
-				if (tobs>24.0) {
-					tobs/=24.0;
-					strcpy(unit,"(days)      ");
-				}
-			}
-		}
-		printf("Observation length %s  : %.1f\n",unit,tobs);
-	}
-	printf("Number of bits per sample        : %d\n",nbits);
-	printf("Number of IFs                    : %d\n",nifs);
-	exit(0);
-}
diff --git a/filterbank-gmrt/header.h b/filterbank-gmrt/header.h
deleted file mode 100644
index 437f9f2..0000000
--- a/filterbank-gmrt/header.h
+++ /dev/null
@@ -1,18 +0,0 @@
-/* global variables describing the data */
-char rawdatafile[80], source_name[80];
-int machine_id, telescope_id, data_type, nchans, nbits, nifs, scan_number,
-  barycentric,pulsarcentric; /* these two added Aug 20, 2004 DRL */
-double tstart,mjdobs,tsamp,fch1,foff,refdm,az_start,za_start,src_raj,src_dej;
-double gal_l,gal_b,header_tobs,raw_fch1,raw_foff;
-int nbeams, ibeam;
-/* added 20 December 2000    JMC */
-double srcl,srcb;
-double ast0, lst0;
-long wapp_scan_number;
-char project[8];
-char culprits[24];
-double analog_power[2];
-
-/* added frequency table for use with non-contiguous data */
-double frequency_table[4096]; /* note limited number of channels */
-long int npuls; /* added for binary pulse profile format */
diff --git a/filterbank-gmrt/help.c b/filterbank-gmrt/help.c
deleted file mode 100644
index 823b7e8..0000000
--- a/filterbank-gmrt/help.c
+++ /dev/null
@@ -1,324 +0,0 @@
-/* help.c - on-line synopsis for each program called via "programname help" */
-int help_required(char *string) /* includefile */
-{
-  if (strings_equal(string,"help")) return(1);
-  if (strings_equal(string,"HELP")) return(1);
-  if (strings_equal(string,"-help")) return(1);
-  if (strings_equal(string,"-HELP")) return(1);
-  if (strings_equal(string,"--help")) return(1);
-  if (strings_equal(string,"--HELP")) return(1);
-  if (strings_equal(string,"-h")) return(1);
-  if (strings_equal(string,"-H")) return(1);
-  if (strings_equal(string,"--h")) return(1);
-  if (strings_equal(string,"--H")) return(1);
-  return(0);
-}
-void blanker_help() /*includefile*/
-{
-  puts("");
-  puts("blanker - blanks out pulses from a time series");
-  puts("");
-  puts("usage: blanker {timfile} -{options}");
-  puts("");
-  puts("timfile     - the name of the time series to be read");
-  puts("-p polyco   - name of polyco file to use (def=polyco.dat)");
-  puts("-s startphi - starting pulse phase to blank (0->1)");
-  puts("-f finisphi - final pulse phase to blank (0->1)");
-  puts("");
-}
-void depolyco_help() /*includefile*/
-{
-  puts("");
-  puts("depolyco - resample a time series to either barycentric or pulsarcentric frames");
-  puts("");
-  puts("usage: depolyco {timfile} {polycofile} -{options}");
-  puts("");
-  puts("timfile     - the name of the time series to be read");
-  puts("polycofile  - the name of the polyco file for the pulsarcentric case");
-  puts("-singlebyte - write output as unsigned characters (def=floats)");
-  puts("-raj        - use different RA (J2000; hh:mm:ss.s) than header");
-  puts("-decj       - use different DEC (J2000; dd:mm:ss.s) than header");
-  puts("-verbose    - write out TEMPO information to stderr (def=quiet)");
-  puts("");
-  puts("N.B. no polyco file implies barycentric correction to be applied");
-  puts("");
-}
-void barycentre_help() /*includefile*/
-{
-  puts("");
-  puts("barycentre - refer a datafile to a frame at rest wrt the solar system barycentre");
-  puts("");
-  puts("usage: barycentre inputfile -{options} > outputfile");
-  puts("");
-  puts("inputfile   - the name of the filterbank/time series file");
-  puts("-mypolyco   - take user-defined polyco.bar file (def=create one)");
-  puts("-verbose    - write out barycentre information to stderr (def=quiet)");
-  puts("");
-}
-void profile_help() /*includefile*/
-{
-  puts("");
-  puts("profile - produce ASCII or pseudo grey-scale displays of folded data");
-  puts("");
-  puts("usage: profile {filename} -{options}");
-  puts("");
-  puts("options:");
-  puts("");
-  puts("   filename - profile file (def=stdin)");
-  puts("-p fraction - set max value to fraction of peak (def=1.0)");
-  puts("-frequency  - label grey-scale profiles in frequency (def=time)");
-  puts("");
-}
-void bandpass_help() /*includefile*/
-{
-  puts("");
-  puts("bandpass - outputs the pass band from a filterbank file\n");
-  puts("usage: bandpass {filename} -{options}\n");
-  puts("options:\n");
-  puts("   filename - filterbank data file (def=stdin)");
-  puts("-d numdumps - number of dumps to average over (def=all)");
-  puts("-t dumptime - number of seconds to average over (def=all)");
-  puts("");
-}
-void decimate_help() /*includefile*/
-{
-  puts("");
-  puts("decimate - reduce time and/or frequency resolution of filterbank data\n");
-  puts("usage: decimate {filename} -{options}\n");
-  puts("options:\n");
-  puts("   filename - filterbank data file (def=stdin)");
-  puts("-c numchans - number of channels to add (def=all)");
-  puts("-t numsamps - number of time samples to add (def=none)");
-  puts("-T numsamps - (alternative to -t) specify number of output time samples");
-  puts("-n numbits  - specify output number of bits (def=input)");
-  puts("-headerless - do not broadcast resulting header (def=broadcast)");
-  puts("");
-}
-void dedisperse_help() /*includefile*/
-{
-  puts("");
-  puts("dedisperse  - form time series from filterbank data or profile from folded data\n");
-  puts("usage: dedisperse {filename} -{options}\n");
-  puts("options:\n");
-  puts("   filename - full name of the raw data file to be read (def=stdin)");
-  puts("-d dm2ddisp - set DM value to dedisperse at (def=0.0)");
-  puts("-b numbands - set output number of sub-bands (def=1)");
-  puts("-B num_bits - set output number of bits (def=32)");
-  puts("-o filename - output file name (def=stdout)");
-  puts("-c minvalue - clip samples > minvalue*rms (def=noclip)");
-  puts("-f reffreq  - dedisperse relative to refrf MHz (def=topofsubband)");
-  puts("-F newfreq  - correct header value of centre frequency to newfreq MHz (def=header value)");
-  puts("-n num_bins - set number of bins if input is profile (def=input)");
-  puts("-i filename - read list of channels to ignore from a file (def=none)");
-  puts("-p np1 np2  - add profile numbers np1 thru np2 if multiple WAPP dumps (def=all)");
-  puts("-j Jyfactor - multiply dedispersed data by Jyfactor to convert to Jy");
-  puts("-J Jyf1 Jyf2 - multiply dedispersed data by Jyf1 and Jyf2 to convert to Jy (use only for two-polarization data)");
-  puts("-wappinvert - invert WAPP channel order (when using LSB data) (def=USB)");
-  puts("-wappoffset - assume wapp fsky between two middle channels (for pre-52900 data ONLY)");
-  puts("-swapout    - perform byte swapping on output data (def=native)");
-  puts("-nobaseline - don't subtract baseline from the data (def=subtract)");
-  puts("-sumifs     - sum 2 IFs when creating the final profile (def=don't)");
-  puts("-headerless - write out data without any header info");
-  puts("-epn        - write profiles in EPN format (def=ASCII)");
-  puts("-asciipol   - write profiles in ASCII format for polarization package");
-  puts("-stream     - write profiles as ASCII streams with START/STOP boundaries");
-  puts("");
-}
-void dedispersecal_help() /*includefile*/
-{
-  puts("");
-  puts("dedispersecal  - form time series from filterbank data or profile from folded data\n");
-  puts("usage: dedispersecal {filename} -{options}\n");
-  puts("options:\n");
-  puts("   filename - full name of the raw data file to be read (def=stdin)");
-  puts("-d dm2ddisp - set DM value to dedisperse at (def=0.0)");
-  puts("-b numbands - set output number of sub-bands (def=1)");
-  puts("-B num_bits - set output number of bits (def=32)");
-  puts("-o filename - output file name (def=stdout)");
-  puts("-c minvalue - clip samples > minvalue*rms (def=noclip)");
-  puts("-f reffreq  - dedisperse relative to refrf MHz (def=topofsubband)");
-  puts("-F newfreq  - correct header value of centre frequency to newfreq MHz (def=header value)");
-  puts("-n num_bins - set number of bins if input is profile (def=input)");
-  puts("-i filename - read list of channels to ignore from a file (def=none)");
-  puts("-p np1 np2  - add profile numbers np1 thru np2 if multiple WAPP dumps (def=all)");
-  puts("-j Jyfactor - multiply dedispersed data by Jyfactor from a file to convert to Jy");
-  puts("-J Jyf1 Jyf2 - multiply dedispersed data by Jyf1 and Jyf2 to convert to Jy (use only for two-polarization data)");
-  puts("-wappinvert - invert WAPP channel order (when using LSB data) (def=USB)");
-  puts("-wappoffset - assume wapp fsky between two middle channels (for pre-52900 data ONLY)");
-  puts("-swapout    - perform byte swapping on output data (def=native)");
-  puts("-nobaseline - don't subtract baseline from the data (def=subtract)");
-  puts("-sumifs     - sum 2 IFs when creating the final profile (def=don't)");
-  puts("-headerless - write out data without any header info");
-  puts("-epn        - write profiles in EPN format (def=ASCII)");
-  puts("-asciipol   - write profiles in ASCII format for polarization package");
-  puts("-stream     - write profiles as ASCII streams with START/STOP boundaries");
-  puts("");
-}
-void fake_help() /*includefile*/
-{
-  puts("");
-  puts("fake - produce fake filterbank format data for testing downstream code\n");
-  puts("usage: fake -{options}\n");
-  puts("options:\n");
-  puts("-period   p - period of fake pulsar in ms (def=random)");
-  puts("-width    w - pulse width in percent (def=4)");
-  puts("-snrpeak  s - signal-to-noise ratio of single pulse (def=1.0)");
-  puts("-dm       d - dispersion measure of fake pulsar (def=random)");
-  puts("-nbits    b - number of bits per sample (def=4)");
-  puts("-nchans   n - number of filterbank channels (def=128)");
-  puts("-tsamp    t - sampling time in us (def=80)");
-  puts("-tobs     t - observation time in s (def=10)");
-  puts("-tstart   t - MJD time stamp of first sample (def=50000.0)");
-  puts("-nifs     n - number of IFs (def=1)");
-  puts("-fch1     f - frequency of channel 1 in MHz (def=433.968)");
-  puts("-foff     f - channel bandwidth in MHz (def=0.062)");
-  puts("-seed     s - seed for Numerical Recipes ran1 (def=seconds since midnight)");
-  puts("-nosmear    - do not add in dispersion/sampling smearing (def=add)");
-  puts("-swapout    - perform byte swapping on output data (def=native)");
-  puts("-evenodd    - even channels=1 odd channels=0 (def=noise+signal)");
-  puts("-headerless - do not write header info at start of file (def=header)");
-  puts("");
-  puts("binary options:\n");
-  puts("-binary     - create binary system");
-  puts("-bper       - orbital period in hours (def=10.0)");  
-  puts("-becc       - eccentricity (def=0.0, circular)");
-  puts("-binc       - inclination in degrees (def=90.0)");
-  puts("-bomega     - longitude of periastron in degrees (def= 0.0)");
-  puts("-bphase     - starting orbital phase (number between 0 and 1, def=0.0)");
-  puts("-bpmass     - pulsar mass in solar units (def=1.4))");
-  puts("-bcmass     - companion mass in solar units (def=5.0)");
-  puts("");
-}
-void filterbank_help() /*includefile*/
-{
-  puts("");
-  puts("filterbank - convert raw pulsar-machine data to filterbank format\n");
-  puts("usage: filterbank <rawdatafile1> .... <rawdatafileN> -{options}\n");
-  puts("rawdatafile - raw data file (recognized machines: WAPP, PSPM, OOTY)");
-  puts("\noptions:\n");
-  puts("-o filename - output file containing filterbank data (def=stdout)");
-  puts("-s skiptime - skip the first skiptime (s) of data (def=0.0)");
-  puts("-r readtime - read readtime (s) of data (def=all)");
-  puts("-i IFstream - write IFstream (IFstream=1,2,3,4)");
-  puts("-n nbits    - write n-bit numbers (def=input format)");
-  puts("-c minvalue - clip DM=0 samples > mean+minvalue*sigma (def=noclip)");
-  puts("-swapout    - perform byte swapping on output data (def=native)");
-  puts("-floats     - write floating-point numbers (equal to -n 32)");
-  puts("-sumifs     - sum IFs 1+2 to form total-power data");
-  puts("-headerfile - write header parameters to an ASCII file (head)");
-  puts("-headeronly - write ONLY binary header parameters");
-  puts("\noptions for correlator (currently WAPP) data:\n");
-  puts("-hamming    - apply Hamming window before FFT (def=nowindow)");
-  puts("-hanning    - apply Hanning window before FFT (def=nowindow)");
-  puts("-novanvleck - don't do van Vleck correction before FFT (def=doit)");
-  puts("-invert     - invert the band after FFT (def=noinversion)");
-  puts("-zerolag    - write just the zero-lag value for each IF");
-  puts("-rawcfs     - write raw correlation functions (novanvleck)");
-  puts("-corcfs     - write corrected correlation functions (vanvleck)");
-  puts("");
-}
-void fold_help() /*includefile*/
-{
-  puts("");
-  puts("fold - fold filterbank channels/time series data\n");
-
-  puts("usage: fold {filename} -{options}\n");
-  puts("options:\n");
-  puts("   filename - full name of the raw data file to be read (def=stdin)");
-  puts("-o out_file - output file for pulse profile data (def=stdout)");
-  puts("-p fold_prd - period to fold (ms) or polyco file (def=polyco.dat)");
-  puts("-a accelern - fold using constant acceleration (def=0 m/s/s)");
-  puts("-f p_factor - multiply the period by p_factor (def=1.0)");
-  puts("-m m_factor - output multiple profiles (STREAM only; def=1)");
-  puts("-n num_bins - number of bins in folded profile(s) (def=window/tsamp)");
-  puts("-d time/num - dump profiles every time s or num pulses (def=nodumps)");
-  puts("-t samptime - hard-wire the sampling time (us) (def=header)");
-  puts("-l phaseval - phase value (turns) of left edge of pulse (def=0.0)");
-  puts("-r phaseval - phase value (turns) of right edge of pulse (def=1.0)");
-  puts("-j Jyfactor - multiply all profiles by Jyfactor to convert to Jy");
-  puts("-b baseline - subtract baseline from all profiles (def=autobase)");
-  puts("-dt timeoff - add a time offset in seconds to tstart (def=0.0)");
-  puts("-sk skiptim - skip the first skiptim s before folding (def=0.0)");
-  puts("-re readtim - read and fold only readtim s of data (def=ALL)");
-  puts("-ascii      - write profiles as ASCII numbers (this is the default)");
-  puts("-epn        - write profiles in EPN format (def=ASCII)");
-  puts("-acc        - write out accumulated profiles (def=subints)");
-  puts("-bin        - write profiles in SIGPROC binary format (def=ASCII)");
-  puts("-sub subint - shorthand for -nobaseline -stream -d subint.0");
-  puts("-psrfits    - write profiles in PSRFITS format (def=ASCII)");
-  puts("-totalpower - sum polarizations 1+2 before writing (def=nosumming)");
-  puts("-asciipol   - write profiles in JMCs ASCII format for polarization");
-  puts("-stream     - write profiles as ASCII streams with START/STOP bounds");
-  puts("-nobaseline - don't subtract baseline from profiles (def=subtract)");
-  puts("");
-}
-
-void tune_help() /*includefile*/
-{ 
-	puts("");
-	puts("tune - fine tune a period in a time series by stacking sub-integration");
-	puts("");
-	puts("usage: tune {filename} -{options}\n");
-	puts("options:\n");
-	puts("   filename - full name of the raw data file to be read (def=stdin)");
-
-	puts("-p fold_prd - center period to fold (ms) or polyco file (def=polyco.dat)");
-	puts("-a accelern - center acceleration to fold (def=0 m/s/s)");
-	puts("-f p_factor - multiply the period by p_factor (def=1.0)");
-	puts("-n num_bins - max number of bins in folded profile(s) (def=64)");
-	puts("-t samptime - hard-wire the sampling time (us) (def=header)");
-/*	I don't think these work anymore MJK
-
-	puts("-dt timeoff - add a time offset in seconds to tstart (def=0.0)");
-	puts("-sk skiptim - skip the first skiptim s before folding (def=0.0)");
-	puts("-re readtim - read and fold only readtim s of data (def=ALL)");*/
-	puts("-sub subint - Number of subints to use (def=128)");
-	puts("-quikgray   - plot data using pdm-style quikgray code (def=pggray)");
-	puts("-useaccn    - Do an acceleration search *Experimental* (def=don't)");
-        puts("-usejerk    - Do an acceleration search *Experimental* (def=don't)");
-	puts("-pf pfactor - divide the period search range by this number (def=1)");
-        puts("-af afactor - divide the accel search range by this number (def=1)");
-        puts("-jf jfactor - divide the jerk search range by this number (def=1)");
-	puts("-format fmt - set the output format, standard PGPLOT formats (def=/xserv)");
-	puts("-jreaper f  - write out ascii based output to file f (def=don't)");
-	puts("-bestfile f - read the 'best' summery file for candidate info (def=don't)");
-	puts("");
-}
-
-void header_help() /*includefile*/
-{
-  puts("");
-  puts("header  - examine header parameters of filterbank data\n");
-  puts("usage: header {filename} -{options}\n");
-  puts("filename is the filterbank data file (def=stdin)\n");
-  puts("options:\n");
-  puts("-telescope   - return telescope name");
-  puts("-machine     - return datataking machine name");
-  puts("-source_name - return source name");
-  puts("-fch1        - return frequency of channel 1 in MHz");
-  puts("-foff        - return channel bandwidth in MHz");
-  puts("-nchans      - return number of channels");
-  puts("-tstart      - return time stamp of first sample (MJD)");
-  puts("-tsamp       - return sample time (us)");
-  puts("-nbits       - return number of bits per sample");
-  puts("-nifs        - return number of IF channels");
-  puts("-headersize  - return header size in bytes");
-  puts("-datasize    - return data size in bytes if known");
-  puts("-nsamples    - return number of samples if known");
-  puts("-tobs        - return length of observation if known (s)");
-  puts("");
-}
-void reader_help() /*includefile*/
-{
-  puts("");
-  puts("reader  - look at filterbank data in ASCII format\n");
-  puts("usage: reader {filename} -{options}\n");
-  puts("filename is the filterbank data file (def=stdin)\n");
-  puts("options:\n");
-  puts("-c        c - output only frequency channel c (1...nchans) (def=all)");
-  puts("-i        i - output only IF channel i (1...nifs) (def=all)");
-  puts("-numerate   - precede each dump with sample number (def=time)");
-  puts("-noindex    - do not precede each dump with number/time");
-  puts("-stream     - produce a stream of numbers with START/STOP boundaries");
-  puts("");
-}
diff --git a/filterbank-gmrt/help.csh b/filterbank-gmrt/help.csh
deleted file mode 100755
index c2b4ac8..0000000
--- a/filterbank-gmrt/help.csh
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/csh
-# updates help files for inclusion in LaTeX manual
-set program = `echo $1 | awk -F/ '{print $NF}'`
-echo "\begin{verbatim}" >! $program.help
-echo "% $program help" >> $program.help
-$1 help >> $program.help
-# strip off the last (blank) line of the help file 
-set nlines = `cat $program.help | wc -l`
-@ nlines = $nlines - 1
-head -$nlines $program.help >! $program.temp
-mv $program.temp $program.help
-echo "\end{verbatim}" >> $program.help
-chmod 666 $program.help
diff --git a/filterbank-gmrt/histmax.f b/filterbank-gmrt/histmax.f
deleted file mode 100644
index 1bd526f..0000000
--- a/filterbank-gmrt/histmax.f
+++ /dev/null
@@ -1,83 +0,0 @@
-c==============================================================================
-	real function histmax(ndata, data, datmin, datmax, nbin)
-c==============================================================================
-c
-c	This function returns the maximum binheight in the array "data"
-c	having "ndata" items for binning over the range "datmin" -> "datmax"
-c       "nbin" signifies the number of bins to be used.
-c
-c       Last modified Mon Apr 19 1999 (dunc@naic.edu) -> Took old histmax
-c       Binning routine is now called seperately by histmax.
-c
-c==============================================================================
-c
-	implicit none
-	integer ndata
-	real data (ndata), datmin, datmax
-	integer nbin, ibin
-	integer num(256)
-c
-c       Get the bin values - now packaged into seperate routine...
-c
-	call histval(ndata,data,datmin,datmax,nbin,num)
-c
-c       Find the maximum value
-c
-	histmax = 0
-	do ibin=1,nbin
-	  histmax = max(histmax,real(num(ibin)))
-	end do
-c
-c       Increase it by 10% for plot scaling...
-c
-	histmax = histmax * 1.1
-c
-c       Job Done!
-c
-	end
-c==============================================================================
-	subroutine histval(ndata, data, datmin, datmax, nbin, binval)
-c==============================================================================
-c
-c	This subroutine returns the binned values for a data set passed down
-c       in the real*4 array "data(ndata)" [i.e. ndata items]. The binning
-c       is carried out for "nbin" bins defined between "datmin" and "datmax".
-c       The binned values are returned in the integer*4 array "binval(ndata)"
-c
-c       Created Mon Apr 19 1999 (dunc@naic.edu) -> Adapted from old histmax
-c
-c==============================================================================
-c
-	implicit none
-c
-c       Variables passed down
-c
-	integer ndata
-	real data (ndata), datmin, datmax
-c
-c       Returned
-c
-	integer binval(256)
-c
-c       Local variables...
-c
-	integer nbin, ibin, i
-c
-c       First, Zero the bin values
-c
-	do ibin=1,nbin
-	  binval(ibin) = 0
-	end do
-c
-c       Now bin the data...
-c
-	do i =1,ndata
-	  ibin = (data(i)-datmin)/(datmax-datmin)*nbin+1
-	  if (ibin.ge.1.and.ibin.le.nbin) binval(ibin)=binval(ibin)+1
-	end do
-c
-c       Job Done!
-c
-	end
-c
-c==============================================================================
diff --git a/filterbank-gmrt/hunt.csh b/filterbank-gmrt/hunt.csh
deleted file mode 100755
index 00c07d1..0000000
--- a/filterbank-gmrt/hunt.csh
+++ /dev/null
@@ -1,36 +0,0 @@
-###############################################################################
-#
-# hunt - script to dedisperse and search data using seek over a given DM range
-#
-# The script requires a filterbank file with the raw data and a "dmlist" file
-# which is an ASCII list of the trial DMs to use in the search.
-#
-###############################################################################
-set dedisperse = $bin/dedisperse
-set seek       = $bin/seek
-set source = $1
-if ($source == "") then
-	echo "usage: hunt filestem (option)"
-	exit
-endif
-if (! -e $source.fil) then
-	echo "Filterbank file: $source.fil not found..."	
-	exit
-endif
-if (! -e dmlist) then
-	echo "File dmlist with DM ranges not found..."
-	exit
-endif
-###############################################################################
-echo "Hunting file $source.fil for periodicities... check back here later!"
-echo "DM:" | awk '{printf "%s ", $1}'
-set append = ""
-foreach dm (`cat dmlist`)
-	echo $dm | awk '{printf "%s ", $1}'
-	$dedisperse $source.fil -d $dm > $source.tim
-	$seek $source.tim $append -z $2 -pulse -pzero> /dev/null
-	set append = "-A"
-end
-echo DONE
-exit
-###############################################################################
diff --git a/filterbank-gmrt/ignored_channels.c b/filterbank-gmrt/ignored_channels.c
deleted file mode 100644
index 3955abe..0000000
--- a/filterbank-gmrt/ignored_channels.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-int *ignored_channels(char *filename, int nchans) /*includefile*/
-{
-  int i,idx,*ignore;
-  FILE *ignfile;
-  
-  /* allocate space for ignore array and initialize */
-  ignore = (int *) malloc(nchans * sizeof(int));
-  for (i=0;i<nchans;i++) ignore[i]=0;
-
-  /* read list of ignored channel numbers from file */
-  ignfile=open_file(filename,"r");
-  while (1) {
-    fscanf(ignfile,"%d",&idx);
-    if (feof(ignfile)) break;
-    idx--;
-    if ( (idx >= 0) && (idx < nchans) ) ignore[idx]=1;
-  }
-  close(ignfile);
-
-  return(ignore);
-}
diff --git a/filterbank-gmrt/include.csh b/filterbank-gmrt/include.csh
deleted file mode 100755
index 17f981d..0000000
--- a/filterbank-gmrt/include.csh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/csh
-# This script updates the include file sigproc.h for the sigproc library
-set v = `awk '{print $1}' version.history | tail -2 | head -1`
-echo "/* sigproc.h: Automatically generated include file for sigproc-$v */" \
-	                              >! sigproc.h
-echo \#include \<stdlib.h\>           >> sigproc.h
-echo \#include \<string.h\>           >> sigproc.h
-echo \#include \"polyco.h\"           >> sigproc.h
-echo \#include \"epn.h\"              >> sigproc.h
-echo \#include \"version.h\"          >> sigproc.h
-grep includefile *.c | awk -F"/*" '{print $1";"}' \
-	| awk -F: '{print $2}' | sort >> sigproc.h
-chmod 666 sigproc.h
-exit
diff --git a/filterbank-gmrt/indexx.c b/filterbank-gmrt/indexx.c
deleted file mode 100644
index 71e213e..0000000
--- a/filterbank-gmrt/indexx.c
+++ /dev/null
@@ -1,72 +0,0 @@
-#define NRANSI 
-#include "nrutil.h"
-#define SWAP(a,b) itemp=(a);(a)=(b);(b)=itemp;
-#define M 7
-#define NSTACK 50
-
-void indexx(unsigned long n, float arr[], unsigned long indx[]) /*includefile*/
-{
-	unsigned long i,indxt,ir=n,itemp,j,k,l=1;
-	int jstack=0,*istack;
-	float a;
-
-	istack=ivector(1,NSTACK);
-	for (j=1;j<=n;j++) indx[j]=j;
-	for (;;) {
-		if (ir-l < M) {
-			for (j=l+1;j<=ir;j++) {
-				indxt=indx[j];
-				a=arr[indxt];
-				for (i=j-1;i>=1;i--) {
-					if (arr[indx[i]] <= a) break;
-					indx[i+1]=indx[i];
-				}
-				indx[i+1]=indxt;
-			}
-			if (jstack == 0) break;
-			ir=istack[jstack--];
-			l=istack[jstack--];
-		} else {
-			k=(l+ir) >> 1;
-			SWAP(indx[k],indx[l+1]);
-			if (arr[indx[l+1]] > arr[indx[ir]]) {
-				SWAP(indx[l+1],indx[ir])
-			}
-			if (arr[indx[l]] > arr[indx[ir]]) {
-				SWAP(indx[l],indx[ir])
-			}
-			if (arr[indx[l+1]] > arr[indx[l]]) {
-				SWAP(indx[l+1],indx[l])
-			}
-			i=l+1;
-			j=ir;
-			indxt=indx[l];
-			a=arr[indxt];
-			for (;;) {
-				do i++; while (arr[indx[i]] < a);
-				do j--; while (arr[indx[j]] > a);
-				if (j < i) break;
-				SWAP(indx[i],indx[j])
-			}
-			indx[l]=indx[j];
-			indx[j]=indxt;
-			jstack += 2;
-			if (jstack > NSTACK) nrerror("NSTACK too small in indexx.");
-			if (ir-i+1 >= j-l) {
-				istack[jstack]=ir;
-				istack[jstack-1]=i;
-				ir=j-1;
-			} else {
-				istack[jstack]=j-1;
-				istack[jstack-1]=l;
-				l=i;
-			}
-		}
-	}
-	free_ivector(istack,1,NSTACK);
-}
-#undef M
-#undef NSTACK
-#undef SWAP
-#undef NRANSI
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
diff --git a/filterbank-gmrt/indexxf77.f b/filterbank-gmrt/indexxf77.f
deleted file mode 100644
index fb5c68d..0000000
--- a/filterbank-gmrt/indexxf77.f
+++ /dev/null
@@ -1,46 +0,0 @@
-C from numerical recipes
-      SUBROUTINE INDEXXF77(N,ARRIN,INDX)
-      DIMENSION ARRIN(N),INDX(N)
-      if (n.eq.1) then
-	indx(1)=1
-        return
-      endif
-      DO 11 J=1,N
-         INDX(J)=J
- 11   CONTINUE
-      L=N/2+1
-      IR=N
- 10   CONTINUE
-      IF(L.GT.1)THEN
-         L=L-1
-         INDXT=INDX(L)
-         Q=ARRIN(INDXT)
-      ELSE
-         INDXT=INDX(IR)
-         Q=ARRIN(INDXT)
-         INDX(IR)=INDX(1)
-         IR=IR-1
-         IF(IR.EQ.1)THEN
-            INDX(1)=INDXT
-            RETURN
-         ENDIF
-      ENDIF
-      I=L
-      J=L+L
- 20   IF(J.LE.IR)THEN
-         IF(J.LT.IR)THEN
-            IF(ARRIN(INDX(J)).LT.ARRIN(INDX(J+1)))J=J+1
-         ENDIF
-         IF(Q.LT.ARRIN(INDX(J)))THEN
-            INDX(I)=INDX(J)
-            I=J
-            J=J+J
-         ELSE
-            J=IR+1
-         ENDIF
-         GO TO 20
-      ENDIF
-      INDX(I)=INDXT
-      GO TO 10
-	write(*,*) 'hello there'
-      END
diff --git a/filterbank-gmrt/inv_cerf.c b/filterbank-gmrt/inv_cerf.c
deleted file mode 100644
index b97edeb..0000000
--- a/filterbank-gmrt/inv_cerf.c
+++ /dev/null
@@ -1,14 +0,0 @@
-#include <math.h>
-/* Approximation for Inverse Complementary Error Function */
-double inv_cerf(double input) /* includefile */
-{
-    static double numerator_const[3] = {1.591863138,-2.442326820,0.37153461};
-    static double denominator_const[3] = {1.467751692,-3.013136362,1.0};
-    double temp_data,temp_data_srq,erf_data;
-    erf_data = 1.0-input;
-    temp_data = (erf_data*erf_data - 0.5625);
-    temp_data_srq = temp_data*temp_data;
-    temp_data = (erf_data)*(numerator_const[0]+(temp_data*numerator_const[1])+(temp_data_srq*numerator_const[2]))/
-(denominator_const[0]+(temp_data*denominator_const[1])+(temp_data_srq*denominator_const[2]));
-    return(temp_data);
-}
diff --git a/filterbank-gmrt/key.h b/filterbank-gmrt/key.h
deleted file mode 100644
index 9207f7b..0000000
--- a/filterbank-gmrt/key.h
+++ /dev/null
@@ -1,32 +0,0 @@
-
-#ifndef CHARSTAR
-#include "y.tab.h" /* pull in the defs for the "type" enum */
-#endif
-
-struct HEADERKEY {
-  void *next;
-  char *name;
-  int offset;
-  int type;
-  int len;  /* length of data element */
-  int alen; /* array length */
-};
-
-struct HEADERVAL {
-  void *value;
-  struct HEADERKEY *key;
-};
-
-struct HEADERP {
-  struct HEADERKEY *head;
-  struct HEADERKEY *tail;
-  char *buf;       /* ascii C header declaration */
-  int offset;      /* len of buf ( offset to start of generic head in file */
-  void *header;    /* pointer to instance of generic header */
-  int headlen;     /* len of generic header */
-  int fd;          /* file des */
-  int yacc_offset; /* last returned by head_input */
-};
-
-struct HEADERP *head_parse(char *);
-extern struct HEADERKEY headerkey[];
diff --git a/filterbank-gmrt/length.f b/filterbank-gmrt/length.f
deleted file mode 100644
index 2311ef1..0000000
--- a/filterbank-gmrt/length.f
+++ /dev/null
@@ -1,46 +0,0 @@
-c     DECK LENGTH
-c     
-c     
-c     
-c     
-c     RETURNS THE LENGTH OF 'STRING' EXCLUDING ANY TRAILING SPACES.
-c     
-      integer function length(string)
-      implicit none
-      character string*(*)
-c     
-c     OBTAIN THE LOCATION OF THE LAST NON-SPACE CHARACTER.
-c     
-      integer ilen,i
-c     search for the first null
-      ilen = len(string)
-c     use the position of the first null
-      do 1 i = ilen, 1, -1
-c     
-c     LENGTH FOUND.
-c     
-         if (string(i:i) .ne. char(32) .and.
-     &       string(i:i).ne.char(0)) then
-            length = i
-            return 
-         end if
-c     
-c     STRING IS ALL SPACES OR ZERO LENGTH.
-c     
-    1 continue
-      length = 0
-c     
-c     END OF INTEGER FUNCTION LENGTH.
-c     
-      return 
-      end
-
-
-
-
-
-
-
-
-
-
diff --git a/filterbank-gmrt/libsigproc_linux.a b/filterbank-gmrt/libsigproc_linux.a
deleted file mode 100644
index 8d0ee21..0000000
Binary files a/filterbank-gmrt/libsigproc_linux.a and /dev/null differ
diff --git a/filterbank-gmrt/longnam.h b/filterbank-gmrt/longnam.h
deleted file mode 100644
index 4e34f2c..0000000
--- a/filterbank-gmrt/longnam.h
+++ /dev/null
@@ -1,535 +0,0 @@
-#ifndef _LONGNAME_H
-#define _LONGNAME_H
-
-#define fits_parse_input_url ffiurl
-#define fits_parse_rootname ffrtnm
-#define fits_parse_output_url ffourl
-#define fits_parse_extspec  ffexts
-#define fits_parse_extnum   ffextn
-#define fits_parse_binspec  ffbins
-#define fits_parse_binrange ffbinr
-#define fits_parse_range    ffrwrg
-#define fits_open_memfile   ffomem
-#define fits_open_file      ffopen
-#define fits_open_data      ffdopn
-#define fits_open_table     fftopn
-#define fits_open_image     ffiopn
-#define fits_reopen_file    ffreopen
-#define fits_create_file    ffinit
-#define fits_create_memfile ffimem
-#define fits_create_template fftplt
-#define fits_flush_file     ffflus
-#define fits_flush_buffer   ffflsh
-#define fits_close_file     ffclos
-#define fits_delete_file    ffdelt
-#define fits_file_name      ffflnm
-#define fits_file_mode      ffflmd
-#define fits_url_type       ffurlt
-
-#define fits_get_version    ffvers
-#define fits_uppercase      ffupch
-#define fits_get_errstatus  ffgerr
-#define fits_write_errmsg   ffpmsg
-#define fits_write_errmark  ffpmrk
-#define fits_read_errmsg    ffgmsg
-#define fits_clear_errmsg   ffcmsg
-#define fits_clear_errmark  ffcmrk
-#define fits_report_error   ffrprt
-#define fits_compare_str    ffcmps
-#define fits_test_keyword   fftkey
-#define fits_test_record    fftrec
-#define fits_null_check     ffnchk
-#define fits_make_keyn      ffkeyn
-#define fits_make_nkey      ffnkey
-#define fits_get_keyclass   ffgkcl
-#define fits_get_keytype    ffdtyp
-#define fits_parse_value    ffpsvc
-#define fits_get_keyname    ffgknm
-#define fits_parse_template ffgthd
-#define fits_ascii_tform    ffasfm
-#define fits_binary_tform   ffbnfm
-#define fits_get_tbcol      ffgabc
-#define fits_get_rowsize    ffgrsz
-#define fits_get_col_display_width    ffgcdw
-
-#define fits_write_record       ffprec
-#define fits_write_key          ffpky
-#define fits_write_key_unit     ffpunt
-#define fits_write_comment      ffpcom
-#define fits_write_history      ffphis 
-#define fits_write_date         ffpdat
-#define fits_get_system_time    ffgstm
-#define fits_get_system_date    ffgsdt
-#define fits_date2str           ffdt2s
-#define fits_time2str           fftm2s
-#define fits_str2date           ffs2dt
-#define fits_str2time           ffs2tm
-#define fits_write_key_longstr  ffpkls
-#define fits_write_key_longwarn ffplsw
-#define fits_write_key_null     ffpkyu
-#define fits_write_key_str      ffpkys
-#define fits_write_key_log      ffpkyl
-#define fits_write_key_lng      ffpkyj
-#define fits_write_key_fixflt   ffpkyf
-#define fits_write_key_flt      ffpkye
-#define fits_write_key_fixdbl   ffpkyg
-#define fits_write_key_dbl      ffpkyd
-#define fits_write_key_fixcmp   ffpkfc
-#define fits_write_key_cmp      ffpkyc
-#define fits_write_key_fixdblcmp ffpkfm
-#define fits_write_key_dblcmp   ffpkym
-#define fits_write_key_triple   ffpkyt
-#define fits_write_tdim         ffptdm
-#define fits_write_keys_str     ffpkns
-#define fits_write_keys_log     ffpknl
-#define fits_write_keys_lng     ffpknj
-#define fits_write_keys_fixflt  ffpknf
-#define fits_write_keys_flt     ffpkne
-#define fits_write_keys_fixdbl  ffpkng
-#define fits_write_keys_dbl     ffpknd
-#define fits_copy_key           ffcpky
-#define fits_write_imghdr       ffphps
-#define fits_write_grphdr       ffphpr
-#define fits_write_atblhdr      ffphtb
-#define fits_write_btblhdr      ffphbn
-#define fits_write_key_template ffpktp
-
-#define fits_get_hdrspace      ffghsp
-#define fits_get_hdrpos        ffghps
-#define fits_movabs_key        ffmaky
-#define fits_movrel_key        ffmrky
-#define fits_find_nextkey      ffgnxk
-
-#define fits_read_record       ffgrec
-#define fits_read_card         ffgcrd
-#define fits_read_key_unit     ffgunt
-#define fits_read_keyn         ffgkyn
-#define fits_read_key          ffgky
-#define fits_read_keyword      ffgkey
-#define fits_read_key_str      ffgkys
-#define fits_read_key_log      ffgkyl
-#define fits_read_key_lng      ffgkyj
-#define fits_read_key_flt      ffgkye
-#define fits_read_key_dbl      ffgkyd
-#define fits_read_key_cmp      ffgkyc
-#define fits_read_key_dblcmp   ffgkym
-#define fits_read_key_triple   ffgkyt
-#define fits_read_key_longstr  ffgkls
-#define fits_read_tdim         ffgtdm
-#define fits_decode_tdim       ffdtdm
-#define fits_read_keys_str     ffgkns
-#define fits_read_keys_log     ffgknl
-#define fits_read_keys_lng     ffgknj
-#define fits_read_keys_flt     ffgkne
-#define fits_read_keys_dbl     ffgknd
-#define fits_read_imghdr       ffghpr
-#define fits_read_atblhdr      ffghtb
-#define fits_read_btblhdr      ffghbn
-#define fits_hdr2str           ffhdr2str
-
-#define fits_update_card       ffucrd
-#define fits_update_key        ffuky
-#define fits_update_key_null   ffukyu
-#define fits_update_key_str    ffukys
-#define fits_update_key_longstr    ffukls
-#define fits_update_key_log    ffukyl
-#define fits_update_key_lng    ffukyj
-#define fits_update_key_fixflt ffukyf
-#define fits_update_key_flt    ffukye
-#define fits_update_key_fixdbl ffukyg
-#define fits_update_key_dbl    ffukyd
-#define fits_update_key_fixcmp ffukfc
-#define fits_update_key_cmp    ffukyc
-#define fits_update_key_fixdblcmp ffukfm
-#define fits_update_key_dblcmp ffukym
-
-#define fits_modify_record     ffmrec
-#define fits_modify_card       ffmcrd
-#define fits_modify_name       ffmnam
-#define fits_modify_comment    ffmcom
-#define fits_modify_key_null   ffmkyu
-#define fits_modify_key_str    ffmkys
-#define fits_modify_key_longstr    ffmkls
-#define fits_modify_key_log    ffmkyl
-#define fits_modify_key_lng    ffmkyj
-#define fits_modify_key_fixflt ffmkyf
-#define fits_modify_key_flt    ffmkye
-#define fits_modify_key_fixdbl ffmkyg
-#define fits_modify_key_dbl    ffmkyd
-#define fits_modify_key_fixcmp ffmkfc
-#define fits_modify_key_cmp    ffmkyc
-#define fits_modify_key_fixdblcmp ffmkfm
-#define fits_modify_key_dblcmp ffmkym
-
-#define fits_insert_record     ffirec
-#define fits_insert_card       ffikey
-#define fits_insert_key_null   ffikyu
-#define fits_insert_key_str    ffikys
-#define fits_insert_key_longstr    ffikls
-#define fits_insert_key_log    ffikyl
-#define fits_insert_key_lng    ffikyj
-#define fits_insert_key_fixflt ffikyf
-#define fits_insert_key_flt    ffikye
-#define fits_insert_key_fixdbl ffikyg
-#define fits_insert_key_dbl    ffikyd
-#define fits_insert_key_fixcmp ffikfc
-#define fits_insert_key_cmp    ffikyc
-#define fits_insert_key_fixdblcmp ffikfm
-#define fits_insert_key_dblcmp ffikym
-
-#define fits_delete_key     ffdkey
-#define fits_delete_record  ffdrec
-#define fits_get_hdu_num    ffghdn
-#define fits_get_hdu_type   ffghdt
-#define fits_get_hduaddr    ffghad
-#define fits_get_hduoff     ffghof
-
-#define fits_get_img_param  ffgipr
-#define fits_get_img_type   ffgidt
-#define fits_get_img_equivtype   ffgiet
-#define fits_get_img_dim    ffgidm
-#define fits_get_img_size   ffgisz
-
-#define fits_movabs_hdu     ffmahd
-#define fits_movrel_hdu     ffmrhd
-#define fits_movnam_hdu     ffmnhd
-#define fits_get_num_hdus   ffthdu
-#define fits_create_img     ffcrim
-#define fits_create_tbl     ffcrtb
-#define fits_create_hdu     ffcrhd
-#define fits_insert_img     ffiimg
-#define fits_insert_atbl    ffitab
-#define fits_insert_btbl    ffibin
-#define fits_resize_img     ffrsim
-#define fits_delete_hdu     ffdhdu
-#define fits_copy_hdu       ffcopy
-#define fits_copy_file      ffcpfl
-#define fits_copy_header    ffcphd
-#define fits_copy_data      ffcpdt
-
-#define fits_set_hdustruc   ffrdef
-#define fits_set_hdrsize    ffhdef
-#define fits_write_theap    ffpthp
-
-#define fits_encode_chksum  ffesum
-#define fits_decode_chksum  ffdsum
-#define fits_write_chksum   ffpcks
-#define fits_update_chksum  ffupck
-#define fits_verify_chksum  ffvcks
-#define fits_get_chksum     ffgcks
-
-#define fits_set_bscale     ffpscl
-#define fits_set_tscale     fftscl
-#define fits_set_imgnull    ffpnul
-#define fits_set_btblnull   fftnul
-#define fits_set_atblnull   ffsnul
-
-#define fits_get_colnum     ffgcno
-#define fits_get_colname    ffgcnn
-#define fits_get_coltype    ffgtcl
-#define fits_get_eqcoltype  ffeqty
-#define fits_get_num_rows   ffgnrw
-#define fits_get_num_cols   ffgncl
-#define fits_get_acolparms  ffgacl
-#define fits_get_bcolparms  ffgbcl
-
-#define fits_iterate_data   ffiter
-
-#define fits_read_grppar_byt  ffggpb
-#define fits_read_grppar_sbyt  ffggpsb
-#define fits_read_grppar_usht  ffggpui
-#define fits_read_grppar_ulng  ffggpuj
-#define fits_read_grppar_sht  ffggpi
-#define fits_read_grppar_lng  ffggpj
-#define fits_read_grppar_lnglng  ffggpjj
-#define fits_read_grppar_int  ffggpk
-#define fits_read_grppar_uint  ffggpuk
-#define fits_read_grppar_flt  ffggpe
-#define fits_read_grppar_dbl  ffggpd
-
-#define fits_read_pix         ffgpxv
-#define fits_read_pixnull     ffgpxf
-#define fits_read_img         ffgpv
-#define fits_read_imgnull     ffgpf
-#define fits_read_img_byt     ffgpvb
-#define fits_read_img_sbyt     ffgpvsb
-#define fits_read_img_usht     ffgpvui
-#define fits_read_img_ulng     ffgpvuj
-#define fits_read_img_sht     ffgpvi
-#define fits_read_img_lng     ffgpvj
-#define fits_read_img_lnglng     ffgpvjj
-#define fits_read_img_uint     ffgpvuk
-#define fits_read_img_int     ffgpvk
-#define fits_read_img_flt     ffgpve
-#define fits_read_img_dbl     ffgpvd
-
-#define fits_read_imgnull_byt ffgpfb
-#define fits_read_imgnull_sbyt ffgpfsb
-#define fits_read_imgnull_usht ffgpfui
-#define fits_read_imgnull_ulng ffgpfuj
-#define fits_read_imgnull_sht ffgpfi
-#define fits_read_imgnull_lng ffgpfj
-#define fits_read_imgnull_lnglng ffgpfjj
-#define fits_read_imgnull_uint ffgpfuk
-#define fits_read_imgnull_int ffgpfk
-#define fits_read_imgnull_flt ffgpfe
-#define fits_read_imgnull_dbl ffgpfd
-
-#define fits_read_2d_byt      ffg2db
-#define fits_read_2d_sbyt     ffg2dsb
-#define fits_read_2d_usht      ffg2dui
-#define fits_read_2d_ulng      ffg2duj
-#define fits_read_2d_sht      ffg2di
-#define fits_read_2d_lng      ffg2dj
-#define fits_read_2d_lnglng      ffg2djj
-#define fits_read_2d_uint      ffg2duk
-#define fits_read_2d_int      ffg2dk
-#define fits_read_2d_flt      ffg2de
-#define fits_read_2d_dbl      ffg2dd
-
-#define fits_read_3d_byt      ffg3db
-#define fits_read_3d_sbyt      ffg3dsb
-#define fits_read_3d_usht      ffg3dui
-#define fits_read_3d_ulng      ffg3duj
-#define fits_read_3d_sht      ffg3di
-#define fits_read_3d_lng      ffg3dj
-#define fits_read_3d_lnglng      ffg3djj
-#define fits_read_3d_uint      ffg3duk
-#define fits_read_3d_int      ffg3dk
-#define fits_read_3d_flt      ffg3de
-#define fits_read_3d_dbl      ffg3dd
-
-#define fits_read_subset      ffgsv
-#define fits_read_subset_byt  ffgsvb
-#define fits_read_subset_sbyt  ffgsvsb
-#define fits_read_subset_usht  ffgsvui
-#define fits_read_subset_ulng  ffgsvuj
-#define fits_read_subset_sht  ffgsvi
-#define fits_read_subset_lng  ffgsvj
-#define fits_read_subset_lnglng  ffgsvjj
-#define fits_read_subset_uint  ffgsvuk
-#define fits_read_subset_int  ffgsvk
-#define fits_read_subset_flt  ffgsve
-#define fits_read_subset_dbl  ffgsvd
-
-#define fits_read_subsetnull_byt ffgsfb
-#define fits_read_subsetnull_sbyt ffgsfsb
-#define fits_read_subsetnull_usht ffgsfui
-#define fits_read_subsetnull_ulng ffgsfuj
-#define fits_read_subsetnull_sht ffgsfi
-#define fits_read_subsetnull_lng ffgsfj
-#define fits_read_subsetnull_lnglng ffgsfjj
-#define fits_read_subsetnull_uint ffgsfuk
-#define fits_read_subsetnull_int ffgsfk
-#define fits_read_subsetnull_flt ffgsfe
-#define fits_read_subsetnull_dbl ffgsfd
-
-#define fits_compress_img fits_comp_img
-#define fits_decompress_img fits_decomp_img
-
-#define fits_read_col        ffgcv
-#define fits_read_colnull    ffgcf
-#define fits_read_col_str    ffgcvs
-#define fits_read_col_log    ffgcvl
-#define fits_read_col_byt    ffgcvb
-#define fits_read_col_sbyt    ffgcvsb
-#define fits_read_col_usht    ffgcvui
-#define fits_read_col_ulng    ffgcvuj
-#define fits_read_col_sht    ffgcvi
-#define fits_read_col_lng    ffgcvj
-#define fits_read_col_lnglng    ffgcvjj
-#define fits_read_col_uint    ffgcvuk
-#define fits_read_col_int    ffgcvk
-#define fits_read_col_flt    ffgcve
-#define fits_read_col_dbl    ffgcvd
-#define fits_read_col_cmp    ffgcvc
-#define fits_read_col_dblcmp ffgcvm
-#define fits_read_col_bit    ffgcx
-#define fits_read_col_bit_usht ffgcxui
-#define fits_read_col_bit_uint ffgcxuk
-
-#define fits_read_colnull_str    ffgcfs
-#define fits_read_colnull_log    ffgcfl
-#define fits_read_colnull_byt    ffgcfb
-#define fits_read_colnull_sbyt    ffgcfsb
-#define fits_read_colnull_usht    ffgcfui
-#define fits_read_colnull_ulng    ffgcfuj
-#define fits_read_colnull_sht    ffgcfi
-#define fits_read_colnull_lng    ffgcfj
-#define fits_read_colnull_lnglng    ffgcfjj
-#define fits_read_colnull_uint    ffgcfuk
-#define fits_read_colnull_int    ffgcfk
-#define fits_read_colnull_flt    ffgcfe
-#define fits_read_colnull_dbl    ffgcfd
-#define fits_read_colnull_cmp    ffgcfc
-#define fits_read_colnull_dblcmp ffgcfm
-
-#define fits_read_descript ffgdes
-#define fits_read_descripts ffgdess
-#define fits_read_tblbytes    ffgtbb
-
-#define fits_write_grppar_byt ffpgpb
-#define fits_write_grppar_sbyt ffpgpsb
-#define fits_write_grppar_usht ffpgpui
-#define fits_write_grppar_ulng ffpgpuj
-#define fits_write_grppar_sht ffpgpi
-#define fits_write_grppar_lng ffpgpj
-#define fits_write_grppar_lnglng ffpgpjj
-#define fits_write_grppar_uint ffpgpuk
-#define fits_write_grppar_int ffpgpk
-#define fits_write_grppar_flt ffpgpe
-#define fits_write_grppar_dbl ffpgpd
-
-#define fits_write_pix        ffppx
-#define fits_write_pixnull    ffppxn
-#define fits_write_img        ffppr
-#define fits_write_img_byt    ffpprb
-#define fits_write_img_sbyt    ffpprsb
-#define fits_write_img_usht    ffpprui
-#define fits_write_img_ulng    ffppruj
-#define fits_write_img_sht    ffppri
-#define fits_write_img_lng    ffpprj
-#define fits_write_img_lnglng    ffpprjj
-#define fits_write_img_uint    ffppruk
-#define fits_write_img_int    ffpprk
-#define fits_write_img_flt    ffppre
-#define fits_write_img_dbl    ffpprd
-
-#define fits_write_imgnull     ffppn
-#define fits_write_imgnull_byt ffppnb
-#define fits_write_imgnull_sbyt ffppnsb
-#define fits_write_imgnull_usht ffppnui
-#define fits_write_imgnull_ulng ffppnuj
-#define fits_write_imgnull_sht ffppni
-#define fits_write_imgnull_lng ffppnj
-#define fits_write_imgnull_lnglng ffppnjj
-#define fits_write_imgnull_uint ffppnuk
-#define fits_write_imgnull_int ffppnk
-#define fits_write_imgnull_flt ffppne
-#define fits_write_imgnull_dbl ffppnd
-
-#define fits_write_img_null ffppru
-#define fits_write_null_img ffpprn
-
-#define fits_write_2d_byt   ffp2db
-#define fits_write_2d_sbyt   ffp2dsb
-#define fits_write_2d_usht   ffp2dui
-#define fits_write_2d_ulng   ffp2duj
-#define fits_write_2d_sht   ffp2di
-#define fits_write_2d_lng   ffp2dj
-#define fits_write_2d_lnglng   ffp2djj
-#define fits_write_2d_uint   ffp2duk
-#define fits_write_2d_int   ffp2dk
-#define fits_write_2d_flt   ffp2de
-#define fits_write_2d_dbl   ffp2dd
-
-#define fits_write_3d_byt   ffp3db
-#define fits_write_3d_sbyt   ffp3dsb
-#define fits_write_3d_usht   ffp3dui
-#define fits_write_3d_ulng   ffp3duj
-#define fits_write_3d_sht   ffp3di
-#define fits_write_3d_lng   ffp3dj
-#define fits_write_3d_lnglng   ffp3djj
-#define fits_write_3d_uint   ffp3duk
-#define fits_write_3d_int   ffp3dk
-#define fits_write_3d_flt   ffp3de
-#define fits_write_3d_dbl   ffp3dd
-
-#define fits_write_subset  ffpss
-#define fits_write_subset_byt  ffpssb
-#define fits_write_subset_sbyt  ffpsssb
-#define fits_write_subset_usht  ffpssui
-#define fits_write_subset_ulng  ffpssuj
-#define fits_write_subset_sht  ffpssi
-#define fits_write_subset_lng  ffpssj
-#define fits_write_subset_lnglng  ffpssjj
-#define fits_write_subset_uint  ffpssuk
-#define fits_write_subset_int  ffpssk
-#define fits_write_subset_flt  ffpsse
-#define fits_write_subset_dbl  ffpssd
-
-#define fits_write_col         ffpcl
-#define fits_write_col_str     ffpcls
-#define fits_write_col_log     ffpcll
-#define fits_write_col_byt     ffpclb
-#define fits_write_col_sbyt     ffpclsb
-#define fits_write_col_usht     ffpclui
-#define fits_write_col_ulng     ffpcluj
-#define fits_write_col_sht     ffpcli
-#define fits_write_col_lng     ffpclj
-#define fits_write_col_lnglng     ffpcljj
-#define fits_write_col_uint     ffpcluk
-#define fits_write_col_int     ffpclk
-#define fits_write_col_flt     ffpcle
-#define fits_write_col_dbl     ffpcld
-#define fits_write_col_cmp     ffpclc
-#define fits_write_col_dblcmp  ffpclm
-#define fits_write_col_null    ffpclu
-#define fits_write_col_bit     ffpclx
-
-#define fits_write_colnull ffpcn
-#define fits_write_colnull_str ffpcns
-#define fits_write_colnull_log ffpcnl
-#define fits_write_colnull_byt ffpcnb
-#define fits_write_colnull_sbyt ffpcnsb
-#define fits_write_colnull_usht ffpcnui
-#define fits_write_colnull_ulng ffpcnuj
-#define fits_write_colnull_sht ffpcni
-#define fits_write_colnull_lng ffpcnj
-#define fits_write_colnull_lnglng ffpcnjj
-#define fits_write_colnull_uint ffpcnuk
-#define fits_write_colnull_int ffpcnk
-#define fits_write_colnull_flt ffpcne
-#define fits_write_colnull_dbl ffpcnd
-
-#define fits_write_descript  ffpdes
-#define fits_compress_heap   ffcmph
-#define fits_test_heap   fftheap
-
-#define fits_write_tblbytes  ffptbb
-#define fits_insert_rows  ffirow
-#define fits_delete_rows  ffdrow
-#define fits_delete_rowrange ffdrrg
-#define fits_delete_rowlist ffdrws
-#define fits_insert_col   fficol
-#define fits_insert_cols  fficls
-#define fits_delete_col   ffdcol
-#define fits_copy_col     ffcpcl
-#define fits_modify_vector_len  ffmvec
-
-#define fits_read_img_coord ffgics
-#define fits_read_tbl_coord ffgtcs
-#define fits_pix_to_world ffwldp
-#define fits_world_to_pix ffxypx
-
-#define fits_get_image_wcs_keys ffgiwcs
-#define fits_get_table_wcs_keys ffgtwcs
-
-#define fits_find_rows          fffrow
-#define fits_find_first_row     ffffrw
-#define fits_find_rows_cmp      fffrwc
-#define fits_select_rows        ffsrow
-#define fits_calc_rows          ffcrow
-#define fits_calculator         ffcalc
-#define fits_calculator_rng     ffcalc_rng
-#define fits_test_expr          fftexp
-
-#define fits_create_group       ffgtcr 
-#define fits_insert_group       ffgtis 
-#define fits_change_group       ffgtch 
-#define fits_remove_group       ffgtrm 
-#define fits_copy_group         ffgtcp 
-#define fits_merge_groups       ffgtmg 
-#define fits_compact_group      ffgtcm 
-#define fits_verify_group       ffgtvf 
-#define fits_open_group         ffgtop 
-#define fits_add_group_member   ffgtam 
-#define fits_get_num_members    ffgtnm 
-
-#define fits_get_num_groups     ffgmng 
-#define fits_open_member        ffgmop 
-#define fits_copy_member        ffgmcp 
-#define fits_transfer_member    ffgmtf 
-#define fits_remove_member      ffgmrm
-
-#endif
diff --git a/filterbank-gmrt/lookup.c b/filterbank-gmrt/lookup.c
deleted file mode 100644
index 93f5941..0000000
--- a/filterbank-gmrt/lookup.c
+++ /dev/null
@@ -1,120 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-/* 
-## help on pspm_chans
-## int *pspm_chans - returns pointer to a look-up table ordering PSPM channels
-## 
-## variables passed down:
-## 
-## int nchans - the number of PSPM channels
-## 
-## see Brian Cadwell's PhD thesis p. 118 for rationale behind the ordering
-## 
-## Last modified: Mar 27, 2001 (dunc@naic.edu)
-## help end
-*/
-int *pspm_chans(int nchans) /* includefile */
-{
-  int i,j,k, *table;
-  table=(int *) malloc(nchans*sizeof(int));
-  i=0;
-  for (j=nchans/4;j>=1;j--) for (k=4;k>0;k--) table[i++]=j*4-k;
-  return (table);
-}
-
-#include "bpphdr.h"
-static int dfb_chan_lookup[MAXREGS][NIBPERREG] = {
-  {4, 0, 4, 0},
-  {5, 1, 5, 1},
-  {6, 2, 6, 2}, 
-  {7, 3, 7, 3},
-  {4, 0, 4, 0},
-  {5, 1, 5, 1},
-  {6, 2, 6, 2},
-  {7, 3, 7, 3}
-};
-  
-/* This takes care of byte swap in outreg_b */
-static float sideband_lookup[MAXREGS][NIBPERREG] = {
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {-1.0, -1.0, +1.0, +1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0},
-  {+1.0, +1.0, -1.0, -1.0}
-};
-
-double fch1,foff,fmid;
-int nifs, nchans;
-
-int  *bpp_chans(double bw, int mb_start_addr, int mb_end_addr, int mb_start_brd, int mb_end_brd, int *cb_id, double *aib_los, float *dfb_sram_freqs, double rf_lo) /* includefile */
-{
-  int i, n=0, dfb_chan, logical_brd, regid, bid, nibble, *table;
-  double  f_aib, u_or_l, f_sram, fc;
-  float *fmhz;
-  unsigned long *nridx;
-  double rf_lo_mhz;
-
-  nchans = (mb_end_addr/2-mb_start_addr/2+1)*(mb_end_brd-mb_start_brd+1)*4;
-  fmhz   = (float *) malloc(nchans*sizeof(float));
-  table  = (int *)   malloc(nchans*sizeof(int));
-  nridx  = (unsigned long *) malloc(nchans*sizeof(unsigned long));
-  if (-1.e6<rf_lo && rf_lo<1.e6) 
-    rf_lo_mhz = rf_lo;
-  else
-    rf_lo_mhz = rf_lo/1.e6;
-
-  /* 
-     Loop over (16-bit) regs per board. divide by 2's are to make them 
-     word addresses instead of byte addresses so we can index with them.
-     Normal modes will be regid = 0..3, 0..7, or 4..7 
-  */
-
-  for (regid=mb_start_addr/2; regid<=mb_end_addr/2; regid++)
-    /* Loop over each board */
-    for (bid=mb_start_brd;bid<=mb_end_brd;bid++) {
-      /* Now find which LOGICAL CB we are reading */
-      logical_brd = -1;
-      for (i=0; i<MAXNUMCB; i++) {
-        if (bid == cb_id[i]) {
-	  logical_brd = i;
-	  break;
-        }
-      }
-      if (logical_brd == -1) error_message("bpp_chan - logical_brd not found");
-      /* Assumes cabling so that LO0 feeds MF0,1 which feeds leftmost CB! */
-      f_aib = aib_los[logical_brd];
-      /* Loop over 4 nibbles per reg */
-      for (nibble=0; nibble<4; nibble++) {
-        dfb_chan = dfb_chan_lookup[regid][nibble];
-        u_or_l = sideband_lookup[regid][nibble];
-        f_sram = dfb_sram_freqs[dfb_chan];
-        fc = f_aib + f_sram + u_or_l * bw/4.0;
-	if (rf_lo_mhz<1.e4) /* below 10 GHz LSB; above 10 GHz USB */
-	  fmhz[n++]=rf_lo_mhz+800-fc/1.0e6;
-	else
-	  fmhz[n++]=rf_lo_mhz+fc/1.0e6;
-      }
-    }
-
-  /* produce lookup table which gives channels in order of descending freq */
-  indexx(96,fmhz-1,nridx-1);
-  if (nchans==192) {
-    nifs=2;
-    indexx(96,fmhz+96-1,nridx+96-1);
-    for (i=96; i<192; i++) 
-      nridx[i] += 96;
-  }
-  n=nchans;
-  for (i=0;i<nchans;i++) 
-    table[i]=nridx[--n]-1;    
-  nchans/=nifs;
-  fmid=0.5*(fmhz[table[0]]+fmhz[table[95]]);
-  fch1=fmhz[table[0]];
-  foff=fch1-fmhz[table[1]];
-  free(fmhz);
-  free(nridx);
-  return(table);
-}
diff --git a/filterbank-gmrt/machine2prf.c b/filterbank-gmrt/machine2prf.c
deleted file mode 100644
index 0096eb1..0000000
--- a/filterbank-gmrt/machine2prf.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
-## help on machine2prf
-## machine2prf - read and dedisperse pre-folded data from various machines
-## 
-## passed down:
-## 
-## FILE *input  - pointer to raw data
-## FILE *output - pointer to output device/file
-## 
-## dedispersed profiles are converted into either ASCII or EPN format. This
-## routine is called from the dedisperse program. Type "dedisperse help" for
-## a synopsis of the various command-line options. Currently supported machines
-## are: PSPM, WAPP and BPP. Reading of headers is done in "typeof_inputdata.c"
-## 
-## see also:
-## 
-## dedisperse.c typof_intputdata.c 
-## 
-## last modified: Mar 27, 2001 (dunc@naic.edu)
-## help end
-*/
-
-#include "dedisperse.h"
-#include "pspmhdr.h"
-PSPM_TIMING_HEADER pspm_timing;
-#include "wapp_header.h"
-struct WAPP_HEADER *wapp;
-struct WAPP_HEADER head;
-#include "bpphdr.h"
-BPP_TIMING_HEADER bpp_timing;
-double fmid;
-double period;
-int nbins;
-void machine2prf(FILE *input, FILE *output) /* includefile */
-{
-  int i,b,c,dayno,day=0,month=0,year=0,subscan=0,scanno=0,nprds,nchans0;
-  int *chtab,*ignore;
-  unsigned long *iprofile;
-  char  *telname,*catref,*bibref,*paflag,*timflag,*srcname;
-  double dm,rm,*chanfreq,pra,pde,df;
-  double phase,psrfreq,phase0;
-  float *profile,opos,offset=0.0,scale=1.0,rms=0.0;
-  struct EPN epn;
-
-  if (data_type == 3) {
-    /* SIGPROC binary profile format */
-    wapp_off=0;
-    srcname=source_name;
-    fmid=fch1+fabs(foff)/2.0+foff*((float)nchans)/2.0;
-    foff=fabs(foff);
-    profile = (float *) malloc(sizeof(float)*nifs*nchans*nbins);
-    fread(profile,sizeof(float),nifs*nchans*nbins,input);
-    mjdobs=floor(tstart);
-    tstart=(tstart-mjdobs)*86400.0;
-    phase=0.0;
-    nprds=npuls;
-    dm=0.0;
-  } else {
-    /* set up header variables and read in data depending on the machine */
-    switch (machine_id) {
-    case 1:
-      /* PSPM data */
-      wapp_off=0;
-      fmid=pspm_timing.freq; 
-      foff=0.062;
-      df=7.68;
-      nbins=pspm_timing.num_phase_bins;
-      nchans=pspm_timing.num_chans;
-      period=pspm_timing.psr_period;
-      read_aoscan(pspm_timing.scan_num, &dayno, &year, &subscan);
-      dm = pspm_timing.psr_dm;
-      chtab=pspm_chans(nchans);
-      profile=pspm_prof(input,nbins,nchans,chtab);
-      nifs=1;
-      nprds=pspm_timing.num_periods;
-      srcname=pspm_timing.psr_name+3;
-      pra=pspm_timing.psmon_ra;
-      pde=pspm_timing.psmon_dec;
-      break;
-    case 2:
-      /* WAPP data */
-      fmid=wapp->cent_freq;
-      if(fcorrect>0.) fmid = fcorrect;
-      foff=-(1-2*wapp_inv)*wapp->bandwidth/wapp->num_lags;
-      df=wapp->bandwidth;
-      nbins=wapp->nbins;
-      nchans=wapp->num_lags;
-      nifs=wapp->nifs;
-      period=1.0/wapp->psr_f0[0];
-      dm = wapp->psr_dm;
-      nprds=1;
-      pra=wapp->src_ra;
-      pde=wapp->src_dec;
-/*      if(profnum2 > 1000) profnum2 = wapp_ndumps; */
-      profile=wapp_prof(nbins,nchans,nifs,profnum1,profnum2);
-      srcname=wapp->src_name;
-/*      tstart += profnum1*wapp->dumptime; */
-      if((fabs(period-0.040))>0.001) { /* not a cal scan */
-	phcalc(mjdobs,tstart,&phase0,&psrfreq,wapp->rphase,wapp->psr_f0,
-	       wapp->poly_tmid,wapp->coeff,wapp->num_coeffs);
-	tstart += wapp->dumptime/2.;
-      /* Actually midpoint, not start, of combined dumps */
-        tstart += (profnum1+profnum2)/2.*wapp->dumptime;
-        phcalc(mjdobs,tstart,&phase,&psrfreq,wapp->rphase,wapp->psr_f0,
-               wapp->poly_tmid,wapp->coeff,wapp->num_coeffs); 
-        period = 1./psrfreq;
-/*	printf("Phases 1: %f %f\n",phase, phase0); */
-        phase -= phase0;  /* first sample went into bin 0 */
-/*	printf("Phases 2: %f %f\n",phase, phase0);  */
-        while (phase < 0.) phase += 1.;
-      }
-      break;
-    case 4:
-      /* BPP data */
-      nbins=bpp_timing.num_phase_bins;
-      nchans=bpp_timing.num_chans;
-      period=bpp_timing.psr_period;
-      read_aoscan(bpp_timing.scan_num, &dayno, &year, &subscan);
-      dm = bpp_timing.psr_dm; 
-      chtab=bpp_chans(bpp_timing.bandwidth,bpp_timing.mb_start_address,
-		      bpp_timing.mb_end_address,bpp_timing.mb_start_board,
-		      bpp_timing.mb_end_board,bpp_timing.cb_id,
-		      bpp_timing.aib_los,bpp_timing.dfb_sram_freqs,
-		      bpp_timing.rf_lo);
-      df=foff*nchans;
-      profile=pspm_prof(input,nbins,nchans,chtab);
-      nifs=1;
-      nprds=bpp_timing.num_periods;
-      srcname=bpp_timing.psr_name+3;
-      pra=pde=0.0;
-      break;
-    default:
-      error_message("unknown machine!");
-      break;
-    }
-  }
-
-  /* user can specify a DM to dedisperse at (default is to value in header) */
-  if (usrdm) dm=userdm;
-
-  /* user can specify number of bins in output profiles (decimation) */
-  if (userbins==0) userbins=nbins;
-
-  /* set up number of dedisperse subbands (default is 1) */
-  if (nbands==0) nbands=nchans;
-
-  /* save starting number of channels */
-  nchans0=nchans;
-
-  /* calculate sky frequency of each channel */
-  /*  chanfreq=chan_freqs(fmid,fabs(foff),nchans); */
-  chanfreq=chan_freqs(fmid,foff,nchans,wapp_off);
-
-  /* zero any profiles that are in the ignored list of channels */
-  if (file_exists(ignfile)) {
-    ignore=ignored_channels(ignfile,nchans);
-  } else {
-    ignore=(int *) malloc(nchans*sizeof(int));
-    for (i=0;i<nchans;i++) ignore[i]=0;
-  }
-
-  /* check to see if reference frequency has been flagged at the command line*/
-  if (refrf == -1.0) refrf=fmid; /* use mid frequency if this is the case */
-
-  /* dedisperse profiles if requested and scale by Jyfactors if two-pol data */
-  if (dm>0.0) 
-    prof_ddis(profile,nbins,nchans,nbands,nifs,chanfreq,period,dm,refrf,jyf1,jyf2);
-
-  /* sum profiles to form subbands if requested */
-  if (nbands<nchans) prof_sumc(profile,nbins,nbands,&nchans,nifs,ignore);
-
-  /* decimate profiles if requested */
-  if (nbins>userbins) prof_adds(profile,&nbins,nchans,nifs,nbins/userbins);
-  
-  /* sum IFs if requested -- this alters nifs to 1 */
-  if (sumifs) prof_sumifs(profile,nbins,nchans,&nifs);
-
-  /* subtract baseline (median of each profile) if requested */
-  if (baseline) {
-    prof_sbas(srcname,profile,nbins,nchans,nifs); 
-  } else {
-    /* no baseline subtraction but normalise by number of periods/channels
-       to get units in terms of the digitization range (e.g. 0-15 PSPM) */
-    for (i=0;i<nbins*nchans*nifs;i++) profile[i]/=(float)nchans0*nprds/nbands;
-  }
-
-  /* set up sampling time (us) for output profile (nbins may be different) */
-  tsamp=1.0e6*period/nbins;
-
-  /* multiply outgoing profiles by single Jansky calibration factor if supplied */
-  if (jyfactor != 1.0) for (i=0;i<nbins*nifs*nchans;i++) profile[i]*=jyfactor;
-
-  if (ascii && !stream) {
-    /* ascii output format requested */
-    for (i=0;i<nifs;i++) {
-      for (c=0;c<nchans;c++) {
-	if (!headerless) 
-        fprintf(output,"# %.1f %.7f %.10f %d %.3f %.3f %d %c %d %s %.8f\n",
-        (float)mjdobs,tstart,period,nprds,chanfreq[c],dm,nbins,tempo_site(telescope_id),subscan,
-        srcname,phase);
-	for (b=0;b<nbins;b++) 
-	  fprintf(output,"%d %f\n",b,profile[c*nbins*nifs+i*nbins+b]);
-      }
-    }
-  } else if (asciipol) {
-    /* write profiles in format for Jim's polarization code */
-    for (b=0;b<nbins;b++) 
-      for (i=0;i<nifs;i++)
-	for (c=0;c<nchans;c++) 
-	 fprintf(output,"%d %d %d %f\n",b,i,c,profile[c*nbins*nifs+i*nbins+b]);
-  } else if (stream) {
-    for (i=0;i<nifs;i++) {
-      for (c=0;c<nchans;c++) {
-	fprintf(output,"#START %d %f %f\n",nbins,tstart,chanfreq[c]);
-	for (b=0;b<nbins;b++) {
-	 fprintf(output,"%d %f\n",b,profile[c*nbins*nifs+i*nbins+b]);
-	}
-	fprintf(output,"#STOP\n");
-      }
-    }
-    fprintf(output,"#DONE\n");
-  } else {
-    /* EPN format requested - set up some general EPN variables */
-    sprintf(epn.history,"%s %s timing-mode data reduced using dedisperse",
-	    telescope_name(telescope_id),backend_name(machine_id));
-    while (strlen(epn.history)<65) strcat(epn.history," ");
-    strcpy(epn.jname,srcname);
-    strcpy(epn.cname,srcname);
-    epn.pbar=period;
-    epn.dm=dm;
-    epn.rm=0.0;
-    strcpy(epn.catref,"none");
-    strcpy(epn.bibref,"none");
-    epn.raj=pra;
-    epn.dec=pde;
-    strcpy(epn.telname,telescope_name(telescope_id));
-    epn.epoch=(float)mjdobs;
-    epn.opos=0.0;
-    epn.paflag=' ';
-    epn.timflag='U';
-    epn.xtel=0.0;
-    epn.ytel=0.0;
-    epn.ztel=0.0;
-    epn.day=0;
-    epn.month=0;
-    epn.year=year;
-    epn.scanno=scanno;
-    epn.subscan=subscan;
-    epn.npol=nifs;
-    epn.nfreq=nchans;
-    epn.nbins=nbins;
-    epn.tbin=1.0e6*period/(double)nbins;
-    epn.nint=0;
-    epn.ncal=0;
-    epn.lcal=0;
-    epn.tres=epn.tbin;
-    epn.fluxflag='U';
-    epn.navg=nchans0/nbands;
-    strcpy(epn.uf,"MHz ");
-    epn.df=df;
-    df/=(double)nbands;
-    epn.df=df*1000.0;
-    strcpy(epn.ud,"kHz ");
-    if (epn.df>=10000.0) {
-      epn.df/=1000.0;
-      strcpy(epn.ud,"MHz ");
-    }
-    epn.tstart=tstart;
-    epn.iprofile=(unsigned long *) malloc(epn.nbins*sizeof(long));
-    /* loop over IFs and channels writing an EPN record foreach profile */
-    for (i=0;i<nifs;i++) {
-      strcpy(epn.idfield,"I");
-      for (c=0;c<nchans;c++) {
-	epn.f0=fch1-foff*c;
-	epn.nband=c+1;
-	epn.papp=period;
-	scale_prof(profile,nbins,epn.iprofile,&epn.scale,&epn.offset); 
-	epn.rms=0.0;
-	write_epn(output,epn);
-	profile+=nbins;
-      }
-    }
-  }
-}
diff --git a/filterbank-gmrt/makedmlist.tcl b/filterbank-gmrt/makedmlist.tcl
deleted file mode 100644
index bfca50b..0000000
--- a/filterbank-gmrt/makedmlist.tcl
+++ /dev/null
@@ -1,40 +0,0 @@
-###############################################################################
-# MAKEDMLIST - a tcl script to make a list of DMs given a filterbank file.....
-###############################################################################
-set file [lindex $argv 0]
-if {[llength $argv] > 1} {
-	set dmmin [lindex $argv 1]
-} else {
-	set dmmin 0.0
-}
-if {[llength $argv] > 2} {
-	set dmmax [lindex $argv 2]
-} else {
-	set dmmax 100.0
-}
-if ![file exists $file] {
-	puts "usage: makedmlist name_of_filterbank_file (dmmin) (dmmax)"
-	puts "DM minimum and maximum ranges are optional (0-100 is default)"
-	exit
-}
-set tsamp [expr [exec header $file -tsamp]/1000.0]
-set nchan [exec header $file -nchans]
-set fcent [exec header $file -fmid]
-set bw    [exec header $file -bandwidth]
-set j 0
-set dm 0.0
-while {1} {
-  for {set i 1} {[expr $i<=$nchan]} {incr i} {
-        set n [expr $i.0-1.0]
-        set dm [format %.1f [expr 1.205e-7*$n*$tsamp*pow($fcent,3.0)/$bw]]
-        if {[expr $dm > $dmmax]} {
-                foreach dm [lsort -real -increasing -unique $dmlist] {
-                        if {$dm > $dmmin} {puts $dm}
-                }
-                exit
-        }
-        lappend dmlist $dm
-  }
-  set tsamp [expr $tsamp*2.0]
-  incr j
-}
diff --git a/filterbank-gmrt/makedummy.csh b/filterbank-gmrt/makedummy.csh
deleted file mode 100644
index 24da878..0000000
--- a/filterbank-gmrt/makedummy.csh
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/csh
-# makes a dummy TEMPO par and tim file to for depolyco
-if ($1 == "") then
-    echo "usage: makedummy timfile"
-    exit
-endif
-
-set parfile = "0000+0000.par"
-echo "PSR 0000+0000" >! $parfile
-header $1 -src_raj | awk '{print "RAJ "$1}'       >> $parfile
-header $1 -src_dej | awk '{print "DECJ "$1}'      >> $parfile
-header $1 -tsamp   | awk '{print "F0  "1.0e6/$1}' >> $parfile
-header $1 -tstart  | awk '{print "PEPOCH "$1}'    >> $parfile
-echo "DM 0.0"                                     >> $parfile
diff --git a/filterbank-gmrt/makefile b/filterbank-gmrt/makefile
deleted file mode 100644
index 1c798fa..0000000
--- a/filterbank-gmrt/makefile
+++ /dev/null
@@ -1,391 +0,0 @@
-###############################################################################
-# "makefile" for SIGPROC - the generic pulsar signal processing software 
-# Report any problems compiling to drl@jb.man.ac.uk
-# YOU SHOULD NOT NORMALLY HAVE TO CHANGE ANYTHING IN THIS FILE !!!!!!!!!!!!!
-###############################################################################
-include makefile.$(OSTYPE)
-CC = $(CCC) $(DFITS) $(DFFTW) -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64
-FC = $(F77) -ffixed-form -ffixed-line-length-132
-###############################################################################
-LIB = libsigproc_$(OSTYPE).a
-LIBOBJECTS = \
-$(LIB)(add_channels.o) \
-$(LIB)(add_samples.o) \
-$(LIB)(aliases.o) \
-$(LIB)(angle_split.o) \
-$(LIB)(aoftm.o) \
-$(LIB)(bandfactors.o) \
-$(LIB)(bit.o) \
-$(LIB)(bpp2fb.o) \
-$(LIB)(cel2gal.o) \
-$(LIB)(chan_freqs.o) \
-$(LIB)(close_log.o)   \
-$(LIB)(decimate_data.o) \
-$(LIB)(decimate_header.o) \
-$(LIB)(dedisperse_data.o) \
-$(LIB)(dedispersecal_data.o) \
-$(LIB)(dedisperse_header.o) \
-$(LIB)(deg2dms.o) \
-$(LIB)(dmdelay.o) \
-$(LIB)(dmshift.o) \
-$(LIB)(error_message.o) \
-$(LIB)(fetch_hdrval.o) \
-$(LIB)(ffreq.o) \
-$(LIB)(file_exists.o) \
-$(LIB)(filterbank_header.o) \
-$(LIB)(fold_header.o) \
-$(LIB)(fold_data.o) \
-$(LIB)(gmrt2fb.o) \
-$(LIB)(gmrt2fblsb.o) \
-$(LIB)(gmrt2fbusblsb.o) \
-$(LIB)(gmrt2fbgsb32512.o) \
-$(LIB)(gmrt2fbgwbr.o) \
-$(LIB)(gmrt2fbgwbf.o) \
-$(LIB)(help.o) \
-$(LIB)(ignored_channels.o) \
-$(LIB)(inv_cerf.o) \
-$(LIB)(indexx.o) \
-$(LIB)(lookup.o) \
-$(LIB)(machine2prf.o) \
-$(LIB)(mjd.o) \
-$(LIB)(norm_prof.o) \
-$(LIB)(np2.o) \
-$(LIB)(nrselect.o) \
-$(LIB)(nrutil.o) \
-$(LIB)(nrsort.o) \
-$(LIB)(nsamples.o) \
-$(LIB)(ooty2fb.o) \
-$(LIB)(open_file.o) \
-$(LIB)(open_log.o)   \
-$(LIB)(pack_unpack.o) \
-$(LIB)(phcalc.o) \
-$(LIB)(process.o) \
-$(LIB)(print_version.o) \
-$(LIB)(prof_adds.o) \
-$(LIB)(prof_ddis.o) \
-$(LIB)(prof_sbas.o) \
-$(LIB)(prof_sumc.o) \
-$(LIB)(prof_sumifs.o) \
-$(LIB)(pspm_decode.o) \
-$(LIB)(pspm_prof.o) \
-$(LIB)(pspm_tstart.o) \
-$(LIB)(pspm2fb.o) \
-$(LIB)(put.o) \
-$(LIB)(pulse.o) \
-$(LIB)(random.o) \
-$(LIB)(read_aoscan.o) \
-$(LIB)(read_block.o) \
-$(LIB)(read_header.o) \
-$(LIB)(read_polyco.o) \
-$(LIB)(recipes.o) \
-$(LIB)(scaledata.o) \
-$(LIB)(scale_prof.o) \
-$(LIB)(scamp2fb.o) \
-$(LIB)(send_stuff.o) \
-$(LIB)(shift_prof.o) \
-$(LIB)(fshift_prof.o) \
-$(LIB)(cprofc.o) \
-$(LIB)(ffft.o) \
-$(LIB)(sizeof_file.o) \
-$(LIB)(slalib.o) \
-$(LIB)(ssm.o) \
-$(LIB)(submean.o) \
-$(LIB)(submedian.o) \
-$(LIB)(swap_bytes.o) \
-$(LIB)(strings_equal.o) \
-$(LIB)(typeof_inputdata.o) \
-$(LIB)(update_log.o)   \
-$(LIB)(uttime.o)   \
-$(LIB)(vanvleck.o) \
-$(LIB)(vmin.o) \
-$(LIB)(vmax.o) \
-$(LIB)(wappcorrect.o) \
-$(LIB)(wapp_prof.o) \
-$(LIB)(write_profiles.o)   \
-$(LIB)(write_epn.o) \
-$(LIB)(y.tab.o) \
-$(LIB)(rwepn.o) \
-$(LIB)(epnpack.o) \
-$(LIB)(sprof.o) \
-$(LIB)(readsus.o)  $(LIB)(fftdata.o)  $(LIB)(resample.o)    \
-             $(LIB)(minmax.o)   $(LIB)(rdfbtab.o) \
-             $(LIB)(getrmea.o)  $(LIB)(getrrms.o)  $(LIB)(dosearch.o)    \
-             $(LIB)(freq.o)    $(LIB)(slfit.o) $(LIB)(readtim.o) \
-             $(LIB)(readdat.o)  $(LIB)(glun.o)        \
-             $(LIB)(writeepn.o) $(LIB)(indexxf77.o)   $(LIB)(writespec.o)   \
-             $(LIB)(readspec.o) $(LIB)(zapit.o)    $(LIB)(histmax.o)     \
-             $(LIB)(baseline.o) $(LIB)(sumhrm.o)   $(LIB)(formspec.o)    \
-             $(LIB)(rebin.o)    $(LIB)(singlepulse.o) \
-             $(LIB)(short.o)    $(LIB)(length.o)      \
-             $(LIB)(quikgray.o) $(LIB)(smooth.o)      \
-             $(LIB)(spcsnr.o)   $(LIB)(clock.o)   $(LIB)(getmjd.o)      \
-             $(LIB)(timer.o)    $(LIB)(seekin.o)      \
-             $(LIB)(seekinnew.o) $(LIB)(accspec.o) $(LIB)(dosearchnew.o) \
-             $(LIB)(single_ch.o) $(LIB)(getddis.o)  $(LIB)(rdhead.o)      \
-             $(LIB)(whiten.o)   $(LIB)(select.o)   $(LIB)(zap_birdies.o) \
-             $(LIB)(open_files.o) $(LIB)(write_pulses.o) \
-             $(LIB)(thresh_1d.o)
-###############################################################################
-all: library programs scripts 
-
-programs: filterbank fake header bandpass reader decimate \
-	dedisperse fold polyco2period profile flux splice barycentre \
-	seek best step postproc grey mask csearch polyco depolyco tune \
-	chaninfo seeknew dedispersecal
-
-scripts: monitor quicklook polyco makedmlist foldsignals hunt accn ahunt
-
-sigproc.h : *.c
-	./include.csh
-
-library : sigproc.h $(LIBOBJECTS)
-
-filterbank  : library filterbank.o head_parse.o wapp2fb.o 
-	$(CC) -o $(BIN)/filterbank filterbank.o  $(LIB) $(LFFTW) -lm
-	rm -f filterbank.o
-
-extract  : extract.o library 
-	$(CC) -o $(BIN)/extract extract.o  $(LIB) -lm
-	rm -f extract.o
-
-fake  : fake.o library 
-	$(CC) -o $(BIN)/fake fake.o  $(LIB) -lm
-	rm -f fake.o
-
-tune  : tune.o library
-	$(CC)  -c tune.c 
-	$(F77) -o $(BIN)/tune tune.o $(LIB) -lm $(LFITS) $(LPGPLOT)
-	rm -f tune.o
-flatten  : flatten.o library 
-	$(CC) -o $(BIN)/flatten flatten.o  $(LIB) -lm $(LFITS)
-	rm -f flatten.o
- 
-clip  : clip.o library 
-	$(CC) -o $(BIN)/clip clip.o  $(LIB) -lm $(LFITS)
-	rm -f clip.o
-downsample  : downsample.o library 
-	$(CC) -o $(BIN)/downsample downsample.o  $(LIB) -lm $(LFITS)
-	rm -f downsample.o
-
-
-
-fold  : fold.o library 
-	$(CC) -o $(BIN)/fold fold.o  $(LIB) -lm $(LFITS)
-	rm -f fold.o
-
-profile  : profile.o library 
-	$(CC) -o $(BIN)/profile profile.o  $(LIB) -lm
-	rm -f profile.o
-
-flux  : flux.o library 
-	$(CC) -o $(BIN)/flux flux.o  $(LIB) -lm
-	rm -f flux.o
-
-header  : header.o library
-	$(CC) -o $(BIN)/header header.o $(LIB) -lm
-	rm -f header.o
-
-bandpass  : bandpass.o library
-	$(CC) -o $(BIN)/bandpass bandpass.o  $(LIB) -lm
-	rm -f bandpass.o
-
-reader  : reader.o library
-	$(CC) -o $(BIN)/reader reader.o $(LIB) -lm
-	rm -f reader.o
-
-splitter  : splitter.o library
-	$(CC) -o $(BIN)/splitter splitter.o $(LIB) -lm
-	rm -f splitter.o
-
-snrdm  : snrdm.o library
-	$(CC) -o $(BIN)/snrdm snrdm.o $(LIB) -lm
-	rm -f snrdm.o
-
-decimate  : decimate.o library
-	$(CC) -o $(BIN)/decimate decimate.o $(LIB) -lm
-	rm -f decimate.o
-
-splice  : splice.o library
-	$(CC) -o $(BIN)/splice splice.o $(LIB) -lm
-	rm -f splice.o
-
-dice  : dice.o library
-	$(CC) -o $(BIN)/dice dice.o $(LIB) -lm
-	rm -f dice.o
-
-depolyco  : depolyco.o library 
-	$(CC) -o $(BIN)/depolyco depolyco.o $(LIB) -lm  $(LFITS) $(LFFTW)
-	rm -f depolyco.o
-
-blanker  : blanker.o library 
-	$(CC) -o $(BIN)/blanker blanker.o $(LIB) -lm 
-	rm -f blanker.o
-
-barycentre  : barycentre.o library 
-	$(CC) -o $(BIN)/barycentre barycentre.o $(LIB) -lm  $(LFITS) $(LFFTW)
-	rm -f barycentre.o
-
-dedisperse  : dedisperse.o library
-	$(CC) -o $(BIN)/dedisperse dedisperse.o $(LIB) -lm $(SUNLM)
-	rm -f dedisperse.o
-
-dedispersecal  : dedispersecal.o library
-	$(CC) -o $(BIN)/dedispersecal dedispersecal.o $(LIB) -lm $(SUNLM)
-	rm -f dedispersecal.o
-
-tree  : tree.o library
-	$(CC) -o $(BIN)/tree tree.o $(LIB) -lm $(SUNLM)
-	rm -f tree.o
-
-polyco2period  : polyco2period.o library
-	$(CC) -o $(BIN)/polyco2period polyco2period.o $(LIB) -lm $(LFITS)
-	rm -f polyco2period.o
-
-monitor :
-	./mkmonitor.csh > $(BIN)/monitor
-	chmod +x $(BIN)/monitor
-
-pgplotter: pgplotter.o library
-	$(CC) -c pgplotter.c
-	$(F77) -o $(BIN)/pgplotter pgplotter.o $(LIB) $(LPGPLOT) -lm
-
-polyco :
-	echo "#!`which tclsh`" >  $(BIN)/polyco
-	cat polyco.tcl         >> $(BIN)/polyco
-	chmod +x $(BIN)/polyco
-
-makedmlist :
-	echo "#!`which tclsh`" >             $(BIN)/makedmlist
-	cat makedmlist.tcl     >>            $(BIN)/makedmlist
-	chmod +x $(BIN)/makedmlist
-
-quicklook :
-	echo "#!`which csh`" >               $(BIN)/quicklook
-	cat quicklook.csh    >>              $(BIN)/quicklook
-	chmod +x $(BIN)/quicklook
-
-foldsignals :
-	echo "#!`which csh`" >            $(BIN)/foldsignals
-	echo "set bin        = $(BIN)" >> $(BIN)/foldsignals
-	cat foldsignals.csh            >> $(BIN)/foldsignals
-	chmod +x $(BIN)/foldsignals
-
-seek : seek.o library
-	$(LINK.f) -o $(BIN)/seek seek.o $(LIB) 
-	rm -f seek.o
-
-seeknew : seeknew.o library
-	$(LINK.f) -o $(BIN)/seeknew seeknew.o $(LIB) 
-	rm -f seeknew.o
-
-best : best.o library
-	$(LINK.f) -o $(BIN)/best best.o $(LIB) $(LPGPLOT)
-	rm -f best.o
-
-mask : mask.o library
-	$(LINK.f) -o $(BIN)/mask mask.o $(LIB) $(LPGPLOT)
-	rm -f mask.o
-
-grey : grey.o library
-	$(LINK.f) -o $(BIN)/grey grey.o $(LIB) $(LPGPLOT)
-	rm -f grey.o
-
-chaninfo : chaninfo.o 
-	$(LINK.f) -o $(BIN)/chaninfo chaninfo.o
-	rm -f chaninfo.o
-
-step : step.o 
-	$(LINK.f) -o $(BIN)/step step.o
-	rm -f step.o
-
-postproc : postproc.o 
-	$(LINK.f) -o $(BIN)/postproc postproc.o
-	rm -f postproc.o
-
-hunt :
-	echo "#!`which csh`" >             $(BIN)/hunt
-	echo "set bin        = $(BIN)"  >> $(BIN)/hunt
-	cat hunt.csh                    >> $(BIN)/hunt
-	chmod +x $(BIN)/hunt
-
-ahunt :
-	echo "#!`which csh`" >             $(BIN)/ahunt
-	echo "set bin        = $(BIN)"  >> $(BIN)/ahunt
-	cat ahunt.csh                    >> $(BIN)/ahunt
-	chmod +x $(BIN)/ahunt
-
-csearch :
-	echo "#!`which csh`" >             $(BIN)/csearch
-	echo "set bin        = $(BIN)"  >> $(BIN)/csearch
-	cat csearch.csh                 >> $(BIN)/csearch
-	chmod +x $(BIN)/csearch
-
-accn :
-	echo "#!`which csh`" >             $(BIN)/accn
-	echo "set bin        = $(BIN)"  >> $(BIN)/accn
-	cat accn.csh                    >> $(BIN)/accn
-	chmod +x $(BIN)/accn
-
-makedummy :
-	cp makedummy.csh $(BIN)/makedummy
-	chmod +x $(BIN)/makedummy
-
-quickplot : quickplot.o 
-	$(F77) -o $(BIN)/quickplot quickplot.o $(LPGPLOT)
-
-plotpulses : plotpulses.o 
-	$(F77) -o $(BIN)/plotpulses plotpulses.o $(LPGPLOT)
-
-head_parse.o: head_parse.c mkheaderlex.c
-	$(CC) -I. -I/opt/local/include -D$(OSTYPE) -c head_parse.c
-	ar rv $(LIB) head_parse.o
-	rm -f head_parse.o
-
-wapp2fb.o: wapp2fb.c 
-	$(CC) -I. -D$(OSTYPE) -c wapp2fb.c
-	ar rv $(LIB) wapp2fb.o
-	rm -f wapp2fb.o
-
-alfa2fb.o: alfa2fb.c 
-	$(CC) -I. -D$(OSTYPE) -c alfa2fb.c
-	ar rv $(LIB) alfa2fb.o
-	rm -f alfa2fb.o
-
-y.tab.c: mkheader.y
-	yacc -vdt mkheader.y
-
-mkheaderlex.c: mkheader.l y.tab.c
-	lex -t mkheader.l >mkheaderlex.c
-
-clean :
-	rm -f $(LIB) *~ *.o sigproc.h \
-	sigproc.aux sigproc.dvi sigproc.log sigproc.ps sigproc.toc \
-	sigproc.idx sigproc.ilg sigproc.ind
-
-help :
-	./help.csh $(BIN)/filterbank
-	./help.csh $(BIN)/fake
-	./help.csh $(BIN)/header
-	./help.csh $(BIN)/bandpass
-	./help.csh $(BIN)/reader
-	./help.csh $(BIN)/decimate
-	./help.csh $(BIN)/splice
-	./help.csh $(BIN)/dedisperse
-	./help.csh $(BIN)/fold
-	./help.csh $(BIN)/profile
-	./help.csh $(BIN)/flux
-	./help.csh $(BIN)/polyco
-	./help.csh $(BIN)/barycentre
-	./help.csh $(BIN)/quicklook
-
-documentation: help
-	latex sigproc
-	makeindex sigproc
-	latex sigproc
-	latex sigproc
-	dvips sigproc -o sigproc.ps
-
-#export :
-#	./exporter.csh
-
-###############################################################################
diff --git a/filterbank-gmrt/makefile.linux b/filterbank-gmrt/makefile.linux
deleted file mode 100644
index 6b5705e..0000000
--- a/filterbank-gmrt/makefile.linux
+++ /dev/null
@@ -1,16 +0,0 @@
-# makefile.linux - your system-specific makefile for SIGPROC
-BIN = /home/abhimanyu/Work/TIFR/Research/pinta/filterbank-gmrt/filterbank/src/bin
-# edit this by hand if you want to change the C compiler options
-CCC = gcc -O2
-F77 = gfortran
-# The following optional libraries need to be edited by hand...
-LPGPLOT = -L/home/abhimanyu/Pulsar/pgplot -lpgplot -lcpgplot -L/usr/X11R6/lib -lX11
-#LFITS = -L/usr/local/src/cfitsio -lcfitsio
-#LFFTW = -L/usr/local/lib/ -lfftw3 -lfftw3f
-SUNLM = 
-ifneq ($(origin LFITS), undefined)
-	DFITS = -DPSRFITS
-endif
-ifneq ($(origin LFFTW), undefined)
-	DFFTW = -DFFTW
-endif
diff --git a/filterbank-gmrt/mask.f b/filterbank-gmrt/mask.f
deleted file mode 100644
index d12418d..0000000
--- a/filterbank-gmrt/mask.f
+++ /dev/null
@@ -1,113 +0,0 @@
-      program mask
-      implicit none
-      include 'vers.inc'
-      integer mp,mc,nbins
-      parameter(mp=2**25,mc=20,nbins=128)
-      integer binval(nbins)
-      real fbin(mp),samp(mp),smin,smax,lo,hi,thresh,histmax,hmax
-      real dm,ac
-      real*8 tsamp,freq
-      integer narg,iargc,fold,npf,i,lun
-      character*80 comline,title,fname
-      logical plotit
-
-      thresh=0.0
-      lo=0.0
-      hi=0.0
-      fold=0
-      title='Raw Spectrum'
-      plotit=.true.
-      lun=-999
-
-      narg=iargc()
-      if (narg.gt.0) then
-        call getarg(1,fname)
-	do i=2,narg
-	  call getarg(i,comline)
-	  if (comline(1:2).eq.'-t') read(comline(3:),*) thresh
-	  if (comline(1:2).eq.'-l') read(comline(3:),*) lo
-	  if (comline(1:2).eq.'-h') read(comline(3:),*) hi
-	  if (comline(1:2).eq.'-f') plotit=.false.
-	enddo
-      else
-         write(*,*)
-         write(*,*) 'MASK: ',version
-         write(*,*) 'Produces a spectral mask for use by SEEK'
-         write(*,*)
-         write(*,*)'usage: mask <SPECTRUM_FILE> -{options}'
-         write(*,*)
-         write(*,*)'The spectrum file is produced by running find -s'
-         write(*,*)'This program is usually run on fold1.spc'
-         write(*,*)
-         write(*,*)'Available options are:'
-         write(*,*)
-         write(*,*)'-f: write the spectral mask to file "mask.out"'
-         write(*,*)
-         write(*,*)'-l[f_hz]: lowest frequency to consider (def=0)'
-         write(*,*)'-h[f_hz]: highest frequency to consider (def=Nyqst)'
-         write(*,*)'-t[ampl]: amplitude threshold to mask'
-         write(*,*)
-         write(*,*)'Options given as: mask fold1.spc -t10'
-         write(*,*) 
-         stop
-      endif
-
-      call readspec(fname,fold,samp,dm,ac,tsamp,npf)
-      write(*,*) 'Npts:',npf
-
-      if (lo.eq.0.0) lo=real(freq(tsamp,npf,fold,1))
-      if (hi.eq.0.0) hi=real(freq(tsamp,npf,fold,npf))
-      do i=1,npf
-         fbin(i)=real(freq(tsamp,npf,fold,i))
-      enddo
-
-      if (thresh.gt.0.0) write(*,*) 'Masking S/N-threshold:',thresh
-      write(*,*) 'Fmin:',lo,' Hz'
-      write(*,*) 'Fmax:',hi,' Hz'
-
-      if (.not.plotit) then
-	call glun(lun)
-	open(unit=lun,file='mask.out',status='unknown')
-      endif
-      do i=1,npf
-         if (fbin(i).ge.lo.and.fbin(i).le.hi.and.abs(samp(i)).gt.thresh
-     &      .and.thresh.ne.0.0) then
-            if (lun.ne.-999) write(lun,*) i,fbin(i),samp(i)
-            samp(i)=0.0
-         endif
-      enddo
-
-      if (.not.plotit) then
-	write(*,*) '"mask.out" file created'
-	stop
-      endif
-
-      call pgbegin(0,'?',1,1)
-      call pgscf(2)
-      call pgsch(1.5)
-      call pgvport(0.15,0.85,0.15,0.85)
-      call pgadvance
-
-      call minmax(samp,npf,smin,smax)
-      call pgwindow(lo,hi,0.0,smax*1.1)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgline(npf,fbin,samp)
-
-      call pgend
-      stop
-      call pgask(.true.)
-      call pgadvance
-      smin=0.0
-c      smax=3.0e5
-c      smax=4.0e4
-      hmax=histmax(npf,samp,smin,smax,nbins)
-      call histval(npf,samp,smin,smax,nbins,binval)
-      do i=1,nbins
-         write(55,*) i,binval(i)
-      enddo
-      call pgwindow(smin,smax,0.0,hmax)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pghist(npf,samp,smin,smax,nbins,1)
-      
-      call pgend
-      end
diff --git a/filterbank-gmrt/minmax.f b/filterbank-gmrt/minmax.f
deleted file mode 100644
index 2877584..0000000
--- a/filterbank-gmrt/minmax.f
+++ /dev/null
@@ -1,10 +0,0 @@
-      subroutine minmax(data,n,dmin,dmax)
-      integer i,n
-      real data(n),dmin,dmax
-      dmin=+1.0e32
-      dmax=-1.0e32
-      do i=1,n
-      dmin=min(dmin,data(i))
-      dmax=max(dmax,data(i))
-      enddo
-      end
diff --git a/filterbank-gmrt/mjd.c b/filterbank-gmrt/mjd.c
deleted file mode 100644
index 6749cc8..0000000
--- a/filterbank-gmrt/mjd.c
+++ /dev/null
@@ -1,31 +0,0 @@
-/* some wrappers for slalib routine calls */
-#include <stdio.h>
-#include "slalib.h"
-#include "slamac.h"
-#include "sigproc.h"
-double mjd(int year, int month, int day) /*includefile*/
-{
-  double djm;
-  int j;
-  char message[80];
-  slaCaldj(year,month,day,&djm,&j);
-  if (j==0) return (djm);
-  sprintf(message,"slaCaldj could not process %d %d %d",year,month,day);
-  error_message(message);
-}
-void cal(double djm, int *year, int *month, int *day) /*includefile*/
-{
-  int iymdf[4],j;
-  char message[80];
-  slaDjcal(1,djm,iymdf,&j);
-  if (j==0) {
-    *year=iymdf[0];
-    *month=iymdf[1];
-    *day=iymdf[2];
-    return;
-  } else {
-    sprintf(message,"slaDjcal could not process MJD: %f",djm);
-    error_message(message);
-  }
-}
-
diff --git a/filterbank-gmrt/mkheader.c b/filterbank-gmrt/mkheader.c
deleted file mode 100644
index aee1214..0000000
--- a/filterbank-gmrt/mkheader.c
+++ /dev/null
@@ -1,510 +0,0 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-static int yygrowstack();
-#define YYPREFIX "yy"
-#line 2 "mkheader.y"
-
-/*
- * Cactus File @(#)mkgs.y	1.2
- *         SID 1.2
- *        Date 8/6/96
- */
-
-#include <stdio.h>
-#include <ctype.h>
-
-#line 14 "mkheader.y"
-typedef union {
-         char *var;
-         int tok;
-       } YYSTYPE;
-#line 33 "y.tab.c"
-#define YYERRCODE 256
-#define STRUCT 257
-#define LBRACE 258
-#define RBRACE 259
-#define SEMI 260
-#define LB 261
-#define RB 262
-#define DOUBLE 263
-#define INTEGER 264
-#define LONG 265
-#define LONGLONG 266
-#define FLOAT 267
-#define SHORT 268
-#define UNSIGNED 269
-#define CHARSTAR 270
-#define BYTE 271
-#define VAR 272
-#define COMMENT 273
-const short yylhs[] = {                                        -1,
-    0,    0,    0,    0,    1,    4,    4,    5,    5,    5,
-    5,    5,    5,    5,    2,    2,    2,    3,    3,    3,
-    3,    3,    3,
-};
-const short yylen[] = {                                         2,
-    0,    2,    2,    2,    6,    2,    1,    1,    6,    3,
-    6,    9,    7,    4,    1,    2,    2,    1,    1,    1,
-    1,    1,    1,
-};
-const short yydefred[] = {                                      1,
-    0,    3,    0,    4,    2,    0,    0,    0,   18,   22,
-   20,   21,   19,   23,    0,    0,    8,    0,   15,    0,
-    7,    0,   17,   16,    0,    0,    0,    6,    0,    0,
-   10,    0,    5,   14,    0,    0,    0,    0,    0,    0,
-    0,    9,   11,    0,   13,    0,    0,   12,
-};
-const short yydgoto[] = {                                       1,
-    5,   18,   19,   20,   21,
-};
-const short yysindex[] = {                                      0,
- -256,    0, -269,    0,    0, -253, -241, -242,    0,    0,
-    0,    0,    0,    0, -230, -233,    0, -229,    0, -255,
-    0, -228,    0,    0, -216, -254, -214,    0, -240, -225,
-    0, -224,    0,    0, -223, -243, -231, -212, -209, -219,
- -208,    0,    0, -218,    0, -207, -204,    0,
-};
-const short yyrindex[] = {                                      0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,
-};
-const short yygindex[] = {                                      0,
-    0,    0,   38,    0,   37,
-};
-#define YYTABLESIZE 57
-const short yytable[] = {                                       2,
-    3,    8,    6,   27,    7,   31,   32,    9,   10,   11,
-   12,   13,   14,   15,   16,    8,    4,   17,   39,   34,
-   35,    9,   10,   11,   12,   13,   14,   15,   16,   22,
-   40,   17,    9,   10,   11,   12,   13,   14,   25,   23,
-   43,   44,   26,   29,   30,   33,   36,   37,   38,   41,
-   42,   45,   24,   46,   47,   48,   28,
-};
-const short yycheck[] = {                                     256,
-  257,  257,  272,  259,  258,  260,  261,  263,  264,  265,
-  266,  267,  268,  269,  270,  257,  273,  273,  262,  260,
-  261,  263,  264,  265,  266,  267,  268,  269,  270,  272,
-  262,  273,  263,  264,  265,  266,  267,  268,  272,  270,
-  260,  261,  272,  272,  261,  260,  272,  272,  272,  262,
-  260,  260,   15,  272,  262,  260,   20,
-};
-#define YYFINAL 1
-#ifndef YYDEBUG
-#define YYDEBUG 0
-#endif
-#define YYMAXTOKEN 273
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"STRUCT","LBRACE","RBRACE","SEMI",
-"LB","RB","DOUBLE","INTEGER","LONG","LONGLONG","FLOAT","SHORT","UNSIGNED",
-"CHARSTAR","BYTE","VAR","COMMENT",
-};
-const char * const yyrule[] = {
-"$accept : list",
-"list :",
-"list : list construct",
-"list : list error",
-"list : list COMMENT",
-"construct : STRUCT VAR LBRACE vars RBRACE SEMI",
-"vars : vars line",
-"vars : line",
-"line : COMMENT",
-"line : CHARSTAR VAR LB VAR RB SEMI",
-"line : notchar VAR SEMI",
-"line : notchar VAR LB VAR RB SEMI",
-"line : notchar VAR LB VAR RB LB VAR RB SEMI",
-"line : STRUCT VAR VAR LB VAR RB SEMI",
-"line : STRUCT VAR VAR SEMI",
-"notchar : typepp",
-"notchar : UNSIGNED typepp",
-"notchar : UNSIGNED CHARSTAR",
-"typepp : DOUBLE",
-"typepp : FLOAT",
-"typepp : LONG",
-"typepp : LONGLONG",
-"typepp : INTEGER",
-"typepp : SHORT",
-};
-#endif
-#if YYDEBUG
-#include <stdio.h>
-#endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
-#else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
-#else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
-#endif
-#endif
-#define YYINITSTACKSIZE 200
-int yydebug;
-int yynerrs;
-int yyerrflag;
-int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
-YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-#line 85 "mkheader.y"
-
-yyerror(s)
-char *s;
-{
-  extern int linecount;
-
-  fprintf( stderr, "%s at line %d\n", s, linecount );
-}
-
-yywrap() { return(1); }
-#line 188 "y.tab.c"
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
-{
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
-    return 0;
-}
-
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
-
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
-#endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
-
-int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
-{
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
-
-    if ((yys = getenv("YYDEBUG")))
-    {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
-    }
-#endif
-
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
-
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
-
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
-    {
-        if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-    }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
-#endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
-    }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-        yyn = yytable[yyn];
-        goto yyreduce;
-    }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
-#endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
-    {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
-    }
-    else
-    {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
-    }
-yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
-    {
-case 2:
-#line 32 "mkheader.y"
-{ got_construct(yyvsp[0].var); }
-break;
-case 3:
-#line 34 "mkheader.y"
-{ yyerrok; yyclearin; YYACCEPT; }
-break;
-case 5:
-#line 39 "mkheader.y"
-{ yyval.var = yyvsp[-4].var; }
-break;
-case 8:
-#line 47 "mkheader.y"
-{ comment(yyvsp[0].var); }
-break;
-case 9:
-#line 49 "mkheader.y"
-{ add_char(yyvsp[-4].var, yyvsp[-2].var ); }
-break;
-case 10:
-#line 51 "mkheader.y"
-{ add_notchar( yyvsp[-2].tok, yyvsp[-1].var); }
-break;
-case 11:
-#line 53 "mkheader.y"
-{ add_array(yyvsp[-5].tok, yyvsp[-4].var, yyvsp[-2].var); }
-break;
-case 12:
-#line 55 "mkheader.y"
-{ printf( "/* skipping %s */\n", yyvsp[-7].var );}
-break;
-case 13:
-#line 57 "mkheader.y"
-{ printf( "/* skipping struct array %s %s */\n", yyvsp[-5].var, yyvsp[-4].var );}
-break;
-case 15:
-#line 62 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 16:
-#line 64 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 17:
-#line 66 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 18:
-#line 70 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 19:
-#line 72 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 20:
-#line 74 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 21:
-#line 76 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 22:
-#line 78 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 23:
-#line 80 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-#line 455 "y.tab.c"
-    }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
-        {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
-#endif
-        }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
-    }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
-#endif
-    if (yyssp >= yysslim && yygrowstack())
-    {
-        goto yyoverflow;
-    }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
-}
diff --git a/filterbank-gmrt/mkheader.l b/filterbank-gmrt/mkheader.l
deleted file mode 100644
index dd86587..0000000
--- a/filterbank-gmrt/mkheader.l
+++ /dev/null
@@ -1,34 +0,0 @@
-%{
-#include "y.tab.h"
-#define SKIP(x) if( cf ) return( x )
-extern int linecount;
-int cf = 1;
-double atof();
-%}
-%%
-struct                    { SKIP(STRUCT);   }
-int                       { yylval.tok = INTEGER; SKIP(INTEGER);  }
-long                      { yylval.tok = LONG;    SKIP(LONG);     }
-long[ \t]+long            { yylval.tok = LONGLONG;  SKIP(LONGLONG);     }
-double                    { yylval.tok = DOUBLE;  SKIP(DOUBLE);   }
-float                     { yylval.tok = FLOAT;   SKIP(FLOAT);    }
-char                      { yylval.tok = CHARSTAR; SKIP(CHARSTAR); }
-short                     { SKIP(SHORT); }
-unsigned                  { SKIP(UNSIGNED); }
-\;                        { SKIP(SEMI); }
-\{                        { SKIP(LBRACE); }
-\}                        { SKIP(RBRACE); }
-\[                        { SKIP(LB); }
-\]                        { SKIP(RB); }
-\/\*[^\n]+\*\/                { yylval.var = (char *)malloc( strlen(yytext)+1);
-                            strcpy( yylval.var, yytext);cf=1;return( COMMENT );}
-\/\*[^*]*\n               { cf = 0; linecount++; }
-\*\/                      { cf = 1; }
-extern.*\n                { linecount++; /* ignore */ }
-[ \t]                     { ; /* ignore */ }
-[A-Za-z0-9_*]+ { yylval.var = (char *)malloc( strlen(yytext)+1);
-                       strcpy( yylval.var, yytext );SKIP( VAR );}
-\#.*\n              { linecount++; /* ignore */ }
-[\n]               { linecount++; ignore(); /* ignore */ }
-[^ ]              { SKIP( yytext[0] ); }
-%%
diff --git a/filterbank-gmrt/mkheader.y b/filterbank-gmrt/mkheader.y
deleted file mode 100644
index a44b132..0000000
--- a/filterbank-gmrt/mkheader.y
+++ /dev/null
@@ -1,94 +0,0 @@
-%{
-
-/*
- * Cactus File @(#)mkgs.y	1.2
- *         SID 1.2
- *        Date 8/6/96
- */
-
-#include <stdio.h>
-#include <ctype.h>
-
-%}
-
-%union {
-         char *var;
-         int tok;
-       }
-
-%start list
-%token STRUCT LBRACE RBRACE SEMI LB RB 
-%token <tok> DOUBLE INTEGER LONG LONGLONG FLOAT SHORT UNSIGNED CHARSTAR BYTE
-%token <var> VAR COMMENT
-
-%type <var> construct
-%type <tok> notchar
-%type <tok> typepp
-
-%%
-
-list :
-     | list construct
-       { got_construct($2); }
-     | list error 
-        { yyerrok; yyclearin; YYACCEPT; }
-     | list COMMENT 
-     ;
-
-construct : STRUCT VAR LBRACE vars RBRACE SEMI
-       { $$ = $2; }
-      ;
-
-vars : vars line 
-     | line
-     ;
-
-line : COMMENT
-       { comment($1); }
-     | CHARSTAR VAR LB VAR RB SEMI
-       { add_char($2, $4 ); }
-     | notchar VAR SEMI
-       { add_notchar( $1, $2); }
-     | notchar VAR LB VAR RB SEMI
-       { add_array($1, $2, $4); }
-     | notchar VAR LB VAR RB LB VAR RB SEMI
-       { printf( "/* skipping %s */\n", $2 );}
-     | STRUCT VAR VAR LB VAR RB SEMI
-       { printf( "/* skipping struct array %s %s */\n", $2, $3 );}
-     | STRUCT VAR VAR SEMI
-     ;
-
-notchar: typepp
-         { $$ = $1; };
-       | UNSIGNED typepp
-         { $$ = $2; };
-       | UNSIGNED CHARSTAR
-         { $$ = $2; };
-       ;
-
-typepp: DOUBLE
-         { $$ = $1; };
-       | FLOAT
-         { $$ = $1; };
-       | LONG
-         { $$ = $1; };
-       | LONGLONG
-         { $$ = $1; };
-       | INTEGER
-         { $$ = $1; };
-       | SHORT
-         { $$ = $1; };
-       ;
-
-
-%%
-
-yyerror(s)
-char *s;
-{
-  extern int linecount;
-
-  fprintf( stderr, "%s at line %d\n", s, linecount );
-}
-
-yywrap() { return(1); }
diff --git a/filterbank-gmrt/mkheaderlex.c b/filterbank-gmrt/mkheaderlex.c
deleted file mode 100644
index 0d1ca21..0000000
--- a/filterbank-gmrt/mkheaderlex.c
+++ /dev/null
@@ -1,1935 +0,0 @@
-
-#line 3 "<stdout>"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
-
-#endif /* ! C99 */
-
-#endif /* ! FLEXINT_H */
-
-/* begin standard C++ headers. */
-
-/* TODO: this is always defined, so inline it */
-#define yyconst const
-
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
-#else
-#define yynoreturn
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
- */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin  )
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
-#define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern int yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-    
-    #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	int yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	int yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = NULL; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static int yy_n_chars;		/* number of characters read into yy_ch_buf */
-int yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = NULL;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart ( FILE *input_file  );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size  );
-void yy_delete_buffer ( YY_BUFFER_STATE b  );
-void yy_flush_buffer ( YY_BUFFER_STATE b  );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state ( void );
-
-static void yyensure_buffer_stack ( void );
-static void yy_load_buffer_state ( void );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file  );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len  );
-
-void *yyalloc ( yy_size_t  );
-void *yyrealloc ( void *, yy_size_t  );
-void yyfree ( void *  );
-
-#define yy_new_buffer yy_create_buffer
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-typedef flex_uint8_t YY_CHAR;
-
-FILE *yyin = NULL, *yyout = NULL;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-int yylineno = 1;
-
-extern char *yytext;
-#ifdef yytext_ptr
-#undef yytext_ptr
-#endif
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state ( void );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  );
-static int yy_get_next_buffer ( void );
-static void yynoreturn yy_fatal_error ( const char* msg  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-#define YY_NUM_RULES 24
-#define YY_END_OF_BUFFER 25
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static const flex_int16_t yy_accept[83] =
-    {   0,
-        0,    0,   25,   23,   19,   22,   19,   23,   20,   23,
-       20,   10,   13,   14,   20,   20,   20,   20,   20,   20,
-       20,   20,   11,   12,    0,   21,   20,   17,    0,   20,
-       20,   20,   20,   20,   20,   20,   20,   20,    0,   16,
-        0,   20,   20,   20,   20,    2,   20,   20,   20,   20,
-        0,    0,    7,   20,   20,   20,    3,   20,   20,   20,
-       15,   20,   20,    6,    0,    8,   20,   20,    5,   20,
-        0,    1,   20,    0,   18,   20,    0,   20,    0,    9,
-        4,    0
-    } ;
-
-static const YY_CHAR yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    4,    1,    1,    5,    1,    1,    1,    1,    1,
-        1,    6,    1,    1,    1,    1,    7,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    9,    1,
-        1,    1,    1,    1,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
-       10,    1,   11,    1,    8,    1,   12,   13,   14,   15,
-
-       16,   17,   18,   19,   20,    8,    8,   21,    8,   22,
-       23,    8,    8,   24,   25,   26,   27,    8,    8,   28,
-        8,    8,   29,    1,   30,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static const YY_CHAR yy_meta[31] =
-    {   0,
-        1,    1,    2,    1,    1,    3,    4,    4,    1,    1,
-        1,    4,    4,    4,    4,    4,    4,    4,    4,    4,
-        4,    4,    4,    4,    4,    4,    4,    4,    1,    1
-    } ;
-
-static const flex_int16_t yy_base[90] =
-    {   0,
-        0,    0,  148,  211,  211,  211,  211,  144,  139,  139,
-      137,  211,  211,  211,   24,   25,   26,   28,   29,   27,
-       33,   31,  211,  211,  140,  211,  135,  211,   36,   34,
-       30,   37,   38,   40,   48,   49,   51,   53,   59,  138,
-      134,   57,   60,   61,   62,  132,   64,   69,   72,   76,
-       78,  135,  130,   73,   79,   80,   88,   81,   84,   82,
-      130,   94,   90,  125,  100,  123,   98,  101,  115,  124,
-       97,  110,  102,  113,  211,  154,   93,  104,   96,  106,
-      211,  211,  184,  186,  190,  194,  198,  202,  206
-    } ;
-
-static const flex_int16_t yy_def[90] =
-    {   0,
-       82,    1,   82,   82,   82,   82,   82,   83,   84,   82,
-       84,   82,   82,   82,   84,   84,   84,   84,   84,   84,
-       84,   84,   82,   82,   83,   82,   84,   82,   85,   84,
-       84,   84,   84,   84,   84,   84,   84,   84,   85,   86,
-       87,   84,   84,   84,   84,   84,   84,   84,   84,   84,
-       87,   86,   84,   84,   84,   84,   84,   84,   84,   84,
-       87,   84,   84,   84,   82,   84,   84,   84,   84,   88,
-       82,   84,   84,   89,   82,   88,   82,   84,   82,   84,
-       82,    0,   82,   82,   82,   82,   82,   82,   82
-    } ;
-
-static const flex_int16_t yy_nxt[242] =
-    {   0,
-        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
-       14,   11,   11,   15,   16,   17,   18,   11,   11,   19,
-       20,   11,   11,   11,   21,   11,   22,   11,   23,   24,
-       82,   82,   82,   82,   82,   82,   82,   82,   40,   82,
-       82,   41,   30,   82,   82,   42,   82,   31,   33,   35,
-       34,   36,   38,   32,   82,   82,   43,   82,   37,   82,
-       45,   40,   44,   82,   51,   46,   82,   82,   82,   47,
-       82,   48,   54,   56,   49,   82,   55,   50,   82,   82,
-       53,   57,   82,   51,   61,   82,   82,   82,   82,   65,
-       82,   65,   58,   62,   82,   60,   82,   67,   59,   68,
-
-       82,   65,   63,   65,   82,   64,   66,   82,   82,   69,
-       82,   70,   82,   81,   79,   75,   82,   78,   80,   77,
-       71,   82,   73,   72,   74,   74,   75,   74,   74,   82,
-       74,   82,   74,   74,   74,   51,   82,   40,   82,   51,
-       40,   82,   26,   82,   29,   28,   26,   82,   82,   82,
-       82,   82,   74,   74,   74,   74,   75,   74,   74,   82,
-       74,   82,   74,   74,   74,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   74,   74,   25,   25,   25,   25,   27,   27,
-       39,   39,   39,   39,   52,   52,   82,   52,   41,   82,
-
-       41,   41,   76,   76,   76,   76,   74,   74,   74,   74,
-        3,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82
-    } ;
-
-static const flex_int16_t yy_chk[242] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-       15,   16,   17,   20,   18,   19,   31,   22,   29,   21,
-       30,   29,   15,   32,   33,   30,   34,   16,   18,   20,
-       19,   21,   22,   17,   35,   36,   31,   37,   21,   38,
-       33,   39,   32,   42,   39,   34,   43,   44,   45,   35,
-       47,   36,   43,   45,   37,   48,   44,   38,   49,   54,
-       42,   47,   50,   51,   51,   55,   56,   58,   60,   57,
-       59,   57,   48,   54,   57,   50,   63,   59,   49,   60,
-
-       62,   65,   55,   65,   67,   56,   58,   68,   73,   62,
-       78,   63,   80,   79,   77,   74,   72,   73,   78,   71,
-       65,   69,   68,   67,   70,   70,   70,   70,   70,   66,
-       70,   64,   70,   70,   70,   61,   53,   52,   46,   41,
-       40,   27,   25,   11,   10,    9,    8,    3,    0,    0,
-        0,    0,   70,   70,   76,   76,   76,   76,   76,    0,
-       76,    0,   76,   76,   76,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,   76,   76,   83,   83,   83,   83,   84,   84,
-       85,   85,   85,   85,   86,   86,    0,   86,   87,    0,
-
-       87,   87,   88,   88,   88,   88,   89,   89,   89,   89,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82,   82,   82,   82,   82,   82,   82,   82,   82,   82,
-       82
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "mkheader.l"
-#line 2 "mkheader.l"
-#include "y.tab.h"
-#define SKIP(x) if( cf ) return( x )
-extern int linecount;
-int cf = 1;
-double atof();
-#line 525 "<stdout>"
-#line 526 "<stdout>"
-
-#define INITIAL 0
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals ( void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy ( void );
-
-int yyget_debug ( void );
-
-void yyset_debug ( int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra ( void );
-
-void yyset_extra ( YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in ( void );
-
-void yyset_in  ( FILE * _in_str  );
-
-FILE *yyget_out ( void );
-
-void yyset_out  ( FILE * _out_str  );
-
-			int yyget_leng ( void );
-
-char *yyget_text ( void );
-
-int yyget_lineno ( void );
-
-void yyset_lineno ( int _line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap ( void );
-#else
-extern int yywrap ( void );
-#endif
-#endif
-
-#ifndef YY_NO_UNPUT
-    
-    static void yyunput ( int c, char *buf_ptr  );
-    
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * );
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-static int yyinput ( void );
-#else
-static int input ( void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
-#define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		int n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
-    
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state(  );
-		}
-
-	{
-#line 8 "mkheader.l"
-
-#line 745 "<stdout>"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-yy_match:
-		do
-			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 83 )
-					yy_c = yy_meta[yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 211 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 9 "mkheader.l"
-{ SKIP(STRUCT);   }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 10 "mkheader.l"
-{ yylval.tok = INTEGER; SKIP(INTEGER);  }
-	YY_BREAK
-case 3:
-YY_RULE_SETUP
-#line 11 "mkheader.l"
-{ yylval.tok = LONG;    SKIP(LONG);     }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 12 "mkheader.l"
-{ yylval.tok = LONGLONG;  SKIP(LONGLONG);     }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 13 "mkheader.l"
-{ yylval.tok = DOUBLE;  SKIP(DOUBLE);   }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 14 "mkheader.l"
-{ yylval.tok = FLOAT;   SKIP(FLOAT);    }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 15 "mkheader.l"
-{ yylval.tok = CHARSTAR; SKIP(CHARSTAR); }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 16 "mkheader.l"
-{ SKIP(SHORT); }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 17 "mkheader.l"
-{ SKIP(UNSIGNED); }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 18 "mkheader.l"
-{ SKIP(SEMI); }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 19 "mkheader.l"
-{ SKIP(LBRACE); }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 20 "mkheader.l"
-{ SKIP(RBRACE); }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 21 "mkheader.l"
-{ SKIP(LB); }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 22 "mkheader.l"
-{ SKIP(RB); }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 23 "mkheader.l"
-{ yylval.var = (char *)malloc( strlen(yytext)+1);
-                            strcpy( yylval.var, yytext);cf=1;return( COMMENT );}
-	YY_BREAK
-case 16:
-/* rule 16 can match eol */
-YY_RULE_SETUP
-#line 25 "mkheader.l"
-{ cf = 0; linecount++; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 26 "mkheader.l"
-{ cf = 1; }
-	YY_BREAK
-case 18:
-/* rule 18 can match eol */
-YY_RULE_SETUP
-#line 27 "mkheader.l"
-{ linecount++; /* ignore */ }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 28 "mkheader.l"
-{ ; /* ignore */ }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 29 "mkheader.l"
-{ yylval.var = (char *)malloc( strlen(yytext)+1);
-                       strcpy( yylval.var, yytext );SKIP( VAR );}
-	YY_BREAK
-case 21:
-/* rule 21 can match eol */
-YY_RULE_SETUP
-#line 31 "mkheader.l"
-{ linecount++; /* ignore */ }
-	YY_BREAK
-case 22:
-/* rule 22 can match eol */
-YY_RULE_SETUP
-#line 32 "mkheader.l"
-{ linecount++; ignore(); /* ignore */ }
-	YY_BREAK
-case 23:
-/* rule 23 can match eol */
-YY_RULE_SETUP
-#line 33 "mkheader.l"
-{ SKIP( yytext[0] ); }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 34 "mkheader.l"
-ECHO;
-	YY_BREAK
-#line 929 "<stdout>"
-case YY_STATE_EOF(INITIAL):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_c_buf_p);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap(  ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-	} /* end of user's declarations */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = (yytext_ptr);
-	int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr) - 1);
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			int num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				int new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc( (void *) b->yy_ch_buf,
-							 (yy_size_t) (b->yy_buf_size + 2)  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	yy_state_type yy_current_state;
-	char *yy_cp;
-    
-	yy_current_state = (yy_start);
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 83 )
-				yy_c = yy_meta[yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	int yy_is_jam;
-    	char *yy_cp = (yy_c_buf_p);
-
-	YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 83 )
-			yy_c = yy_meta[yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 82);
-
-		return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_UNPUT
-
-    static void yyunput (int c, char * yy_bp )
-{
-	char *yy_cp;
-    
-    yy_cp = (yy_c_buf_p);
-
-	/* undo effects of setting up yytext */
-	*yy_cp = (yy_hold_char);
-
-	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-		{ /* need to shift things up to make room */
-		/* +2 for EOB chars. */
-		int number_to_move = (yy_n_chars) + 2;
-		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
-					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		char *source =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
-
-		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			*--dest = *--source;
-
-		yy_cp += (int) (dest - source);
-		yy_bp += (int) (dest - source);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
-
-		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
-			YY_FATAL_ERROR( "flex scanner push-back overflow" );
-		}
-
-	*--yy_cp = (char) c;
-
-	(yytext_ptr) = yy_bp;
-	(yy_hold_char) = *yy_cp;
-	(yy_c_buf_p) = yy_cp;
-}
-
-#endif
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			int offset = (int) ((yy_c_buf_p) - (yytext_ptr));
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart( yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap(  ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE );
-	}
-
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file );
-	yy_load_buffer_state(  );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state(  );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2)  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer( b, file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf  );
-
-	yyfree( (void *) b  );
-}
-
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer( b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state(  );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state(  );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state(  );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return NULL;
-
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer( b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (const char * yystr )
-{
-    
-	return yy_scan_bytes( yystr, (int) strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n;
-	int i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer( buf, n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yynoreturn yy_fatal_error (const char* msg )
-{
-			fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-    
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-int yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param _line_number line number
- * 
- */
-void yyset_lineno (int  _line_number )
-{
-    
-    yylineno = _line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param _in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  _in_str )
-{
-        yyin = _in_str ;
-}
-
-void yyset_out (FILE *  _out_str )
-{
-        yyout = _out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  _bdebug )
-{
-        yy_flex_debug = _bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = NULL;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = NULL;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = NULL;
-    yyout = NULL;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n )
-{
-		
-	int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s )
-{
-	int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-			return malloc(size);
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-		
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return realloc(ptr, size);
-}
-
-void yyfree (void * ptr )
-{
-			free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 34 "mkheader.l"
-
-
diff --git a/filterbank-gmrt/mkmonitor.csh b/filterbank-gmrt/mkmonitor.csh
deleted file mode 100755
index 8a372c5..0000000
--- a/filterbank-gmrt/mkmonitor.csh
+++ /dev/null
@@ -1,20 +0,0 @@
-#!/bin/sh
-cat << END
-#!/bin/sh
-if [ \$# -gt 0 ]
-then
-	option=\$1
-else 
-	option='on'
-
-fi
-if [ \$option != "on" ] 
-then
-	touch monitor.stop
-	exit
-fi
-rm -f *.monitor
-$PWD/monitor.tk &
-exit
-END
-exit
diff --git a/filterbank-gmrt/monitor.tk b/filterbank-gmrt/monitor.tk
deleted file mode 100755
index 66c317d..0000000
--- a/filterbank-gmrt/monitor.tk
+++ /dev/null
@@ -1,223 +0,0 @@
-#!/bin/sh
-# the next line restarts using wish \
-exec wish "$0" "$@"
-#
-# MONITOR - a Tcl/Tk widget to check and display log output from programs
-#
-###############################################################################
-proc getfilestems {directory extension} {
-#
-#   Return a list of file stems residing in a particular directory
-#
-###############################################################################
-
-	if [catch {set rawlist [glob "$directory/*.$extension"]}] {
-	  return none
-	}
-	set endlist ""
-	foreach item $rawlist {
-		set file [file tail $item]
-		set trim [file rootname $file]
-		set endlist "$endlist $trim"
-	}
-	return $endlist
-}
-###############################################################################
-proc newframe {framename} {
-#
-#   Define and pack a new frame into the parent window using fill and expand
-#   The frame is assumed (as is standard practice) to be called .parent.frame
-#
-###############################################################################
-
-    # get the name of the parent assuming tha above convention
-    set parent [parentname $framename]
-
-    # define the new frame
-    frame $framename
-
-    # pack it into its parent using fill and expand
-    pack  $framename -fill x -expand yes -in $parent -fill both
-}
-###############################################################################
-proc packin {framename args} {
-#
-#   Define and pack into a frame any number of pre-defined widgets in $args
-#
-###############################################################################
-
-    foreach widget $args {
-	pack $widget -in $framename -fill both -expand yes -side left 
-    }
-
-}
-###############################################################################
-proc parentname {widgetname} {
-#
-#   Return the parent for a Tk widget assuming a name of the form .parent.name
-#
-###############################################################################
-
-    set parent ".[lindex [split $widgetname "."] 1]"
-
-    # check for case where the root window is the parent
-    if {$parent == $widgetname} {set parent .} 
-
-    return $parent
-}
-###############################################################################
-proc yesno {title question} {
-#
-#   Pops up a yes/no dialog box for a given question and returns 1 for a yes
-#
-###############################################################################
-
-    return [tk_dialog .really $title $question \
-	    warning 1 {No!} {Yes}]
-}
-###############################################################################
-proc center_window {w} {
-    wm withdraw $w
-    update idletasks
-    set x [expr [winfo screenwidth $w]/2 - [winfo reqwidth $w]/2 \
-	    - [winfo vrootx $w]]
-    set y [expr [winfo screenheight $w]/2 - [winfo reqheight $w]/2 \
-	    - [winfo vrooty $w]]
-    wm geom $w +$x+$y
-    wm deiconify $w
-}
-proc poll_directory {} {
-    global monitor_directory monitor_files monitor_pipe withdrawn
-
-    # abort if user has created a monitor.stop file
-    if [file exists $monitor_directory/monitor.stop] {
-	catch {exec rm -f $monitor_directory/monitor.running}
-	catch {exec rm -f $monitor_directory/monitor.stop}
-	exit
-    }
-
-    after 1000 poll_directory
-
-    # check contents of the directory
-    set monitor_files [getfilestems $monitor_directory monitor]
-
-    if {$monitor_files == "none"} {
-	foreach program [array names monitor_pipe] {
-	    close_pipe $program
-	    unset monitor_pipe($program)
-	}
-	withdraw 
-	return
-    }
-
-    # open a new frame and pipe for each program found
-    foreach program $monitor_files {
-	set frame ".$program"
-	if ![winfo exists $frame] {
-	    make_smon $program
-	    open_pipe $program
-	}
-    }
-
-    if {$withdrawn} {
-	activate
-    }
-}
-proc elapsed_time {program} {
-    global elapsed
-    if ![winfo exists ".$program"] {return}
-    after 1000 elapsed_time $program
-    incr elapsed($program)
-    ".$program.time" configure -text $elapsed($program)
-}
-proc make_smon {program} {
-    global FONT elapsed
-    set elapsed($program) 0
-    newframe ".$program"
-    label     ".$program.name" -font $FONT -text $program -fg blue 
-    label     ".$program.lab1" -font $FONT -text "input:"
-    label     ".$program.file" -font $FONT -fg red
-    label     ".$program.lab2" -font $FONT -text "status:"
-    label     ".$program.stat" -font $FONT -fg red
-    label     ".$program.lab3" -font $FONT -text "output:"
-    label     ".$program.outp" -font $FONT -fg red
-    label     ".$program.lab4" -font $FONT -text "elapsed time:"
-    label     ".$program.time" -font $FONT -fg red 
-    label     ".$program.lab5" -font $FONT -text "s"
-    packin   ".$program" ".$program.name" \
-	     ".$program.lab1" ".$program.file" \
-             ".$program.lab2" ".$program.stat" \
-	     ".$program.lab3" ".$program.outp" \
-	     ".$program.lab4" ".$program.time" ".$program.lab5"
-}
-proc kill_smon {program} {
-    foreach widget [winfo children ".$program"] {
-	catch {destroy $widget}
-    }
-    catch {destroy ".$program"}
-}
-proc open_pipe {program} {
-    global monitor_directory monitor_pipe
-    set filename "$monitor_directory/$program.monitor"
-
-    if ![file exists $filename] {
-	kill_smon $program
-	return
-    }
-    set monitor_pipe($program) [open "| tail -1f $filename" r+]
-    fileevent $monitor_pipe($program) readable [list monitor_event $program]
-}
-proc close_pipe {program} {
-    global monitor_pipe elapsed
-    catch {exec kill -9 [pid $monitor_pipe($program)]}
-    catch {close $monitor_pipe($program)}
-    #set elapsed($program) 1
-}
-proc monitor_event {program} {
-    global monitor_pipe monitor_directory elapsed
-    if [catch {gets $monitor_pipe($program) buffer}] {return}
-    if {!$elapsed($program)} {elapsed_time $program}
-    ".$program.file" configure -text [lindex $buffer 1]
-    ".$program.stat" configure -text [lindex $buffer 3]
-    ".$program.outp" configure -text [lindex $buffer 5]
-    if {[lindex $buffer 3] == "finished"} {
-	close_pipe $program
-	exec rm -f "$monitor_directory/$program.monitor"
-	after 10000 kill_smon $program
-    }
-}
-proc withdraw {} {
-    global withdrawn
-    set withdrawn 1
-    wm withdraw .
-}
-proc activate {} {
-    global withdrawn env
-    set withdrawn 0
-    wm geometry . +0+0
-    #wm title . "SIGPROC monitor for programs running in $env(PWD)"
-    wm title . "SIGPROC monitor"
-    wm deiconify .
-}
-set FONT "-adobe-helvetica-medium-r-normal-*-*-180-75-75-*-*-*-*"
-option add *background #ffe4c4
-option add *activebackground #eed5b7
-# establish the directory wher monitor will look for the .monitor files
-if ![info exists env(MONITOR)] {
-    set monitor_directory ./
-} else {
-    set monitor_directory $env(MONITOR)
-}
-withdraw
-if [file exists $monitor_directory/monitor.running] {
-	puts "a monitor program is already running from this directory..."
-	exit
-}
-if [catch {exec date > $monitor_directory/monitor.running}] {
-	puts "error occured while creating monitor.running file"
-	exit
-}
-if [file exists $monitor_directory/monitor.stop] {
-	exec rm -f $monitor_directory/monitor.stop	
-}
-poll_directory
diff --git a/filterbank-gmrt/newfind.c b/filterbank-gmrt/newfind.c
deleted file mode 100644
index abf6374..0000000
--- a/filterbank-gmrt/newfind.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
-  FIND - a program to find periodic signals in a noisy time series. 
-*/
-#include "find.h"
-
-main(int argc, char *argv[])
-{
-  FILE *fileptr;
-  int i,numsamps,nfft,nspc,headersize,binmin;
-  float *data, *amplitude, ar, ai, arl, ail, a1, a2;
-  double frequency, pmax=9.99999;
-
-  fileptr=open_file(argv[1],"rb");
-
-  if (!(headersize=read_header(fileptr))) {
-    error_message("could not read header parameters!");
-    exit(1);
-  }
-
-  numsamps=nsamples(argv[1],headersize,nbits,nifs,nchans);
-  nfft=(int)pow(2.0,(double)np2(numsamps));
-  nspc=nfft/2;
-  data=(float *) malloc(sizeof(float)*numsamps);
-  
-  printf("#Reading in %d samples from file: %s...\n",numsamps,argv[1]);
-  if ((read_block(fileptr,nbits,data,numsamps)) != numsamps) {
-    error_message("error reading data");
-  }
-
-  printf("#Performing 2^%d point FFT...\n",np2(numsamps));
-  realft(data-1,(unsigned long) nfft,1);
-
-  printf("#Forming amplitude spectrum...\n");
-  amplitude=(float *) malloc(nspc*sizeof(float));
-  binmin=fbin(tsamp,nspc,1,1.0/pmax);
-  ar=ai=arl=ail=a1=a2=0.0;
-  for (i=0;i<nspc;i++) {
-    if (i<binmin) 
-      amplitude[i]=0.0;
-    else {
-      ar=data[2*i];
-      ai=data[2*i+1];
-      a1=ar*ar+ai*ai;
-      a2=0.5*((ar-arl)*(ar-arl)+(ai-ail)*(ai-ail));
-      amplitude[i]=(a1>a2)?a1:a2;
-      arl=ar;
-      ail=ai;
-    }
-    /*printf("%f %f\n",ffreq(tsamp,nspc,1,i+1),amplitude[i]);*/
-  }
-  free(data);
-
-}
diff --git a/filterbank-gmrt/newprog b/filterbank-gmrt/newprog
deleted file mode 100644
index e467ccf..0000000
--- a/filterbank-gmrt/newprog
+++ /dev/null
@@ -1,29 +0,0 @@
-strings_equal.c
-header.h
-read_header.c = > reads header into global bvalue
-
-correct header in these globals
-
-filterbank.h
-send_stuff.c
-filterbank_header.c => write as filterbank header 
-
-A
-read_block.c to modify to read data for different nbits and write data 
-output after identifying and reversing channel. Read function is same, but 
-write function is just fwrite. instead of float block integer etc 
-is used, nread should be all channels of one sample.
-
-invert the order of the channel
-
-write data fwrite with proper bits as per the header
-B
-
-A to B in a loop till the end of file
-
-sigproc.h
-
-error_message.c
-
-pack_unpack.c
-open_file.c
diff --git a/filterbank-gmrt/norm_prof.c b/filterbank-gmrt/norm_prof.c
deleted file mode 100644
index 93f3134..0000000
--- a/filterbank-gmrt/norm_prof.c
+++ /dev/null
@@ -1,30 +0,0 @@
-/* normalize prof by counts */
-void norm_prof(float *prof, float *cnt, int nbins, int nifs, int nchans) /*includefile*/
-{
-  int i,s,c,n;
-  float tmp;
-
-  for (s=0; s<nbins; s++) {
-    tmp=1.0;
-    if(cnt[s] != 0.0) tmp=cnt[s];
-    for (i=0; i<nifs; i++) {
-      n=i*nchans;
-      for (c=0; c<nchans; c++) prof[(n+c)*nbins+s] /= tmp;
-    }
-  }
-}
-/* denormalize prof by counts */
-void denorm_prof(float *prof, float *cnt, int nbins, int nifs, int nchans) /*includefile*/
-{
-  int i,s,c,n;
-  float tmp;
-
-  for (s=0; s<nbins; s++) {
-    tmp=1.0;
-    if(cnt[s] != 0.0) tmp=cnt[s];
-    for (i=0; i<nifs; i++) {
-      n=i*nchans;
-      for (c=0; c<nchans; c++) prof[(n+c)*nbins+s] *= tmp;
-    }
-  }
-}
diff --git a/filterbank-gmrt/np2.c b/filterbank-gmrt/np2.c
deleted file mode 100644
index 4412045..0000000
--- a/filterbank-gmrt/np2.c
+++ /dev/null
@@ -1,8 +0,0 @@
-/* np2 - returns the nearest power of two number to the integer passed down */
-#include<math.h>
-int np2(int n) /*includefile*/
-{
-  int p=0;
-  while( pow(2.0,(double)p) < n) p++;
-  return(p-1);
-}
diff --git a/filterbank-gmrt/npts.inc b/filterbank-gmrt/npts.inc
deleted file mode 100644
index 18ae440..0000000
--- a/filterbank-gmrt/npts.inc
+++ /dev/null
@@ -1,8 +0,0 @@
-c==============================================================================
-c Maximum number of points possible in the time series.
-c==============================================================================
-c
-      integer npts ! maximum size available
-      parameter(npts=2**25)
-c
-c==============================================================================
diff --git a/filterbank-gmrt/nr.h b/filterbank-gmrt/nr.h
deleted file mode 100644
index d76dc62..0000000
--- a/filterbank-gmrt/nr.h
+++ /dev/null
@@ -1,890 +0,0 @@
-#ifndef _NR_H_
-#define _NR_H_
-
-#ifndef _FCOMPLEX_DECLARE_T_
-typedef struct FCOMPLEX {float r,i;} fcomplex;
-#define _FCOMPLEX_DECLARE_T_
-#endif /* _FCOMPLEX_DECLARE_T_ */
-
-#ifndef _ARITHCODE_DECLARE_T_
-typedef struct {
-	unsigned long *ilob,*iupb,*ncumfq,jdif,nc,minint,nch,ncum,nrad;
-} arithcode;
-#define _ARITHCODE_DECLARE_T_
-#endif /* _ARITHCODE_DECLARE_T_ */
-
-#ifndef _HUFFCODE_DECLARE_T_
-typedef struct {
-	unsigned long *icod,*ncod,*left,*right,nch,nodemax;
-} huffcode;
-#define _HUFFCODE_DECLARE_T_
-#endif /* _HUFFCODE_DECLARE_T_ */
-
-#include <stdio.h>
-
-#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */
-
-void addint(double **uf, double **uc, double **res, int nf);
-void airy(float x, float *ai, float *bi, float *aip, float *bip);
-void amebsa(float **p, float y[], int ndim, float pb[],	float *yb,
-	float ftol, float (*funk)(float []), int *iter, float temptr);
-void amoeba(float **p, float y[], int ndim, float ftol,
-	float (*funk)(float []), int *iter);
-float amotry(float **p, float y[], float psum[], int ndim,
-	float (*funk)(float []), int ihi, float fac);
-float amotsa(float **p, float y[], float psum[], int ndim, float pb[],
-	float *yb, float (*funk)(float []), int ihi, float *yhi, float fac);
-void anneal(float x[], float y[], int iorder[], int ncity);
-double anorm2(double **a, int n);
-void arcmak(unsigned long nfreq[], unsigned long nchh, unsigned long nradd,
-	arithcode *acode);
-void arcode(unsigned long *ich, unsigned char **codep, unsigned long *lcode,
-	unsigned long *lcd, int isign, arithcode *acode);
-void arcsum(unsigned long iin[], unsigned long iout[], unsigned long ja,
-	int nwk, unsigned long nrad, unsigned long nc);
-void asolve(unsigned long n, double b[], double x[], int itrnsp);
-void atimes(unsigned long n, double x[], double r[], int itrnsp);
-void avevar(float data[], unsigned long n, float *ave, float *var);
-void balanc(float **a, int n);
-void banbks(float **a, unsigned long n, int m1, int m2, float **al,
-	unsigned long indx[], float b[]);
-void bandec(float **a, unsigned long n, int m1, int m2, float **al,
-	unsigned long indx[], float *d);
-void banmul(float **a, unsigned long n, int m1, int m2, float x[], float b[]);
-void bcucof(float y[], float y1[], float y2[], float y12[], float d1,
-	float d2, float **c);
-void bcuint(float y[], float y1[], float y2[], float y12[],
-	float x1l, float x1u, float x2l, float x2u, float x1,
-	float x2, float *ansy, float *ansy1, float *ansy2);
-void beschb(double x, double *gam1, double *gam2, double *gampl,
-	double *gammi);
-float bessi(int n, float x);
-float bessi0(float x);
-float bessi1(float x);
-void bessik(float x, float xnu, float *ri, float *rk, float *rip,
-	float *rkp);
-float bessj(int n, float x);
-float bessj0(float x);
-float bessj1(float x);
-void bessjy(float x, float xnu, float *rj, float *ry, float *rjp,
-	float *ryp);
-float bessk(int n, float x);
-float bessk0(float x);
-float bessk1(float x);
-float bessy(int n, float x);
-float bessy0(float x);
-float bessy1(float x);
-float beta(float z, float w);
-float betacf(float a, float b, float x);
-float betai(float a, float b, float x);
-float bico(int n, int k);
-void bksub(int ne, int nb, int jf, int k1, int k2, float ***c);
-float bnldev(float pp, int n, long *idum);
-float brent(float ax, float bx, float cx,
-	float (*f)(float), float tol, float *xmin);
-void broydn(float x[], int n, int *check,
-	void (*vecfunc)(int, float [], float []));
-void bsstep(float y[], float dydx[], int nv, float *xx, float htry,
-	float eps, float yscal[], float *hdid, float *hnext,
-	void (*derivs)(float, float [], float []));
-void caldat(long julian, int *mm, int *id, int *iyyy);
-void chder(float a, float b, float c[], float cder[], int n);
-float chebev(float a, float b, float c[], int m, float x);
-void chebft(float a, float b, float c[], int n, float (*func)(float));
-void chebpc(float c[], float d[], int n);
-void chint(float a, float b, float c[], float cint[], int n);
-float chixy(float bang);
-void choldc(float **a, int n, float p[]);
-void cholsl(float **a, int n, float p[], float b[], float x[]);
-void chsone(float bins[], float ebins[], int nbins, int knstrn,
-	float *df, float *chsq, float *prob);
-void chstwo(float bins1[], float bins2[], int nbins, int knstrn,
-	float *df, float *chsq, float *prob);
-void cisi(float x, float *ci, float *si);
-void cntab1(int **nn, int ni, int nj, float *chisq,
-	float *df, float *prob, float *cramrv, float *ccc);
-void cntab2(int **nn, int ni, int nj, float *h, float *hx, float *hy,
-	float *hygx, float *hxgy, float *uygx, float *uxgy, float *uxy);
-void convlv(float data[], unsigned long n, float respns[], unsigned long m,
-	int isign, float ans[]);
-void copy(double **aout, double **ain, int n);
-void correl(float data1[], float data2[], unsigned long n, float ans[]);
-void cosft(float y[], int n, int isign);
-void cosft1(float y[], int n);
-void cosft2(float y[], int n, int isign);
-void covsrt(float **covar, int ma, int ia[], int mfit);
-void crank(unsigned long n, float w[], float *s);
-void cyclic(float a[], float b[], float c[], float alpha, float beta,
-	float r[], float x[], unsigned long n);
-void daub4(float a[], unsigned long n, int isign);
-float dawson(float x);
-float dbrent(float ax, float bx, float cx,
-	float (*f)(float), float (*df)(float), float tol, float *xmin);
-void ddpoly(float c[], int nc, float x, float pd[], int nd);
-int decchk(char string[], int n, char *ch);
-void derivs(float x, float y[], float dydx[]);
-float df1dim(float x);
-void dfour1(double data[], unsigned long nn, int isign);
-void dfpmin(float p[], int n, float gtol, int *iter, float *fret,
-	float (*func)(float []), void (*dfunc)(float [], float []));
-float dfridr(float (*func)(float), float x, float h, float *err);
-void dftcor(float w, float delta, float a, float b, float endpts[],
-	float *corre, float *corim, float *corfac);
-void dftint(float (*func)(float), float a, float b, float w,
-	float *cosint, float *sinint);
-void difeq(int k, int k1, int k2, int jsf, int is1, int isf,
-	int indexv[], int ne, float **s, float **y);
-void dlinmin(float p[], float xi[], int n, float *fret,
-	float (*func)(float []), void (*dfunc)(float [], float[]));
-double dpythag(double a, double b);
-void drealft(double data[], unsigned long n, int isign);
-void dsprsax(double sa[], unsigned long ija[], double x[], double b[],
-	unsigned long n);
-void dsprstx(double sa[], unsigned long ija[], double x[], double b[],
-	unsigned long n);
-void dsvbksb(double **u, double w[], double **v, int m, int n, double b[],
-	double x[]);
-void dsvdcmp(double **a, int m, int n, double w[], double **v);
-void eclass(int nf[], int n, int lista[], int listb[], int m);
-void eclazz(int nf[], int n, int (*equiv)(int, int));
-float ei(float x);
-void eigsrt(float d[], float **v, int n);
-float elle(float phi, float ak);
-float ellf(float phi, float ak);
-float ellpi(float phi, float en, float ak);
-void elmhes(float **a, int n);
-float erfcc(float x);
-float erff(float x);
-float erffc(float x);
-void eulsum(float *sum, float term, int jterm, float wksp[]);
-float evlmem(float fdt, float d[], int m, float xms);
-float expdev(long *idum);
-float expint(int n, float x);
-float f1(float x);
-float f1dim(float x);
-float f2(float y);
-float f3(float z);
-float factln(int n);
-float factrl(int n);
-void fasper(float x[], float y[], unsigned long n, float ofac, float hifac,
-	float wk1[], float wk2[], unsigned long nwk, unsigned long *nout,
-	unsigned long *jmax, float *prob);
-void fdjac(int n, float x[], float fvec[], float **df,
-	void (*vecfunc)(int, float [], float []));
-void fgauss(float x, float a[], float *y, float dyda[], int na);
-void fill0(double **u, int n);
-void fit(float x[], float y[], int ndata, float sig[], int mwt,
-	float *a, float *b, float *siga, float *sigb, float *chi2, float *q);
-void fitexy(float x[], float y[], int ndat, float sigx[], float sigy[],
-	float *a, float *b, float *siga, float *sigb, float *chi2, float *q);
-void fixrts(float d[], int m);
-void fleg(float x, float pl[], int nl);
-void flmoon(int n, int nph, long *jd, float *frac);
-float fmin(float x[]);
-void four1(float data[], unsigned long nn, int isign);
-void fourew(FILE *file[5], int *na, int *nb, int *nc, int *nd);
-void fourfs(FILE *file[5], unsigned long nn[], int ndim, int isign);
-void fourn(float data[], unsigned long nn[], int ndim, int isign);
-void fpoly(float x, float p[], int np);
-void fred2(int n, float a, float b, float t[], float f[], float w[],
-	float (*g)(float), float (*ak)(float, float));
-float fredin(float x, int n, float a, float b, float t[], float f[], float w[],
-	float (*g)(float), float (*ak)(float, float));
-void frenel(float x, float *s, float *c);
-void frprmn(float p[], int n, float ftol, int *iter, float *fret,
-	float (*func)(float []), void (*dfunc)(float [], float []));
-void ftest(float data1[], unsigned long n1, float data2[], unsigned long n2,
-	float *f, float *prob);
-float gamdev(int ia, long *idum);
-float gammln(float xx);
-float gammp(float a, float x);
-float gammq(float a, float x);
-float gasdev(long *idum);
-void gaucof(int n, float a[], float b[], float amu0, float x[], float w[]);
-void gauher(float x[], float w[], int n);
-void gaujac(float x[], float w[], int n, float alf, float bet);
-void gaulag(float x[], float w[], int n, float alf);
-void gauleg(float x1, float x2, float x[], float w[], int n);
-void gaussj(float **a, int n, float **b, int m);
-void gcf(float *gammcf, float a, float x, float *gln);
-float golden(float ax, float bx, float cx, float (*f)(float), float tol,
-	float *xmin);
-void gser(float *gamser, float a, float x, float *gln);
-void hpsel(unsigned long m, unsigned long n, float arr[], float heap[]);
-void hpsort(unsigned long n, float ra[]);
-void hqr(float **a, int n, float wr[], float wi[]);
-void hufapp(unsigned long index[], unsigned long nprob[], unsigned long n,
-	unsigned long i);
-void hufdec(unsigned long *ich, unsigned char *code, unsigned long lcode,
-	unsigned long *nb, huffcode *hcode);
-void hufenc(unsigned long ich, unsigned char **codep, unsigned long *lcode,
-	unsigned long *nb, huffcode *hcode);
-void hufmak(unsigned long nfreq[], unsigned long nchin, unsigned long *ilong,
-	unsigned long *nlong, huffcode *hcode);
-void hunt(float xx[], unsigned long n, float x, unsigned long *jlo);
-void hypdrv(float s, float yy[], float dyyds[]);
-fcomplex hypgeo(fcomplex a, fcomplex b, fcomplex c, fcomplex z);
-void hypser(fcomplex a, fcomplex b, fcomplex c, fcomplex z,
-	fcomplex *series, fcomplex *deriv);
-unsigned short icrc(unsigned short crc, unsigned char *bufptr,
-	unsigned long len, short jinit, int jrev);
-unsigned short icrc1(unsigned short crc, unsigned char onech);
-unsigned long igray(unsigned long n, int is);
-void iindexx(unsigned long n, long arr[], unsigned long indx[]);
-void indexx(unsigned long n, float arr[], unsigned long indx[]);
-void interp(double **uf, double **uc, int nf);
-int irbit1(unsigned long *iseed);
-int irbit2(unsigned long *iseed);
-void jacobi(float **a, int n, float d[], float **v, int *nrot);
-void jacobn(float x, float y[], float dfdx[], float **dfdy, int n);
-long julday(int mm, int id, int iyyy);
-void kendl1(float data1[], float data2[], unsigned long n, float *tau, float *z,
-	float *prob);
-void kendl2(float **tab, int i, int j, float *tau, float *z, float *prob);
-void kermom(double w[], double y, int m);
-void ks2d1s(float x1[], float y1[], unsigned long n1,
-	void (*quadvl)(float, float, float *, float *, float *, float *),
-	float *d1, float *prob);
-void ks2d2s(float x1[], float y1[], unsigned long n1, float x2[], float y2[],
-	unsigned long n2, float *d, float *prob);
-void ksone(float data[], unsigned long n, float (*func)(float), float *d,
-	float *prob);
-void kstwo(float data1[], unsigned long n1, float data2[], unsigned long n2,
-	float *d, float *prob);
-void laguer(fcomplex a[], int m, fcomplex *x, int *its);
-void lfit(float x[], float y[], float sig[], int ndat, float a[], int ia[],
-	int ma, float **covar, float *chisq, void (*funcs)(float, float [], int));
-void linbcg(unsigned long n, double b[], double x[], int itol, double tol,
-	 int itmax, int *iter, double *err);
-void linmin(float p[], float xi[], int n, float *fret,
-	float (*func)(float []));
-void lnsrch(int n, float xold[], float fold, float g[], float p[], float x[],
-	 float *f, float stpmax, int *check, float (*func)(float []));
-void load(float x1, float v[], float y[]);
-void load1(float x1, float v1[], float y[]);
-void load2(float x2, float v2[], float y[]);
-void locate(float xx[], unsigned long n, float x, unsigned long *j);
-void lop(double **out, double **u, int n);
-void lubksb(float **a, int n, int *indx, float b[]);
-void ludcmp(float **a, int n, int *indx, float *d);
-void machar(int *ibeta, int *it, int *irnd, int *ngrd,
-	int *machep, int *negep, int *iexp, int *minexp, int *maxexp,
-	float *eps, float *epsneg, float *xmin, float *xmax);
-void matadd(double **a, double **b, double **c, int n);
-void matsub(double **a, double **b, double **c, int n);
-void medfit(float x[], float y[], int ndata, float *a, float *b, float *abdev);
-void memcof(float data[], int n, int m, float *xms, float d[]);
-int metrop(float de, float t);
-void mgfas(double **u, int n, int maxcyc);
-void mglin(double **u, int n, int ncycle);
-float midexp(float (*funk)(float), float aa, float bb, int n);
-float midinf(float (*funk)(float), float aa, float bb, int n);
-float midpnt(float (*func)(float), float a, float b, int n);
-float midsql(float (*funk)(float), float aa, float bb, int n);
-float midsqu(float (*funk)(float), float aa, float bb, int n);
-void miser(float (*func)(float []), float regn[], int ndim, unsigned long npts,
-	float dith, float *ave, float *var);
-void mmid(float y[], float dydx[], int nvar, float xs, float htot,
-	int nstep, float yout[], void (*derivs)(float, float[], float[]));
-void mnbrak(float *ax, float *bx, float *cx, float *fa, float *fb,
-	float *fc, float (*func)(float));
-void mnewt(int ntrial, float x[], int n, float tolx, float tolf);
-void moment(float data[], int n, float *ave, float *adev, float *sdev,
-	float *var, float *skew, float *curt);
-void mp2dfr(unsigned char a[], unsigned char s[], int n, int *m);
-void mpadd(unsigned char w[], unsigned char u[], unsigned char v[], int n);
-void mpdiv(unsigned char q[], unsigned char r[], unsigned char u[],
-	unsigned char v[], int n, int m);
-void mpinv(unsigned char u[], unsigned char v[], int n, int m);
-void mplsh(unsigned char u[], int n);
-void mpmov(unsigned char u[], unsigned char v[], int n);
-void mpmul(unsigned char w[], unsigned char u[], unsigned char v[], int n,
-	int m);
-void mpneg(unsigned char u[], int n);
-void mppi(int n);
-void mprove(float **a, float **alud, int n, int indx[], float b[],
-	float x[]);
-void mpsad(unsigned char w[], unsigned char u[], int n, int iv);
-void mpsdv(unsigned char w[], unsigned char u[], int n, int iv, int *ir);
-void mpsmu(unsigned char w[], unsigned char u[], int n, int iv);
-void mpsqrt(unsigned char w[], unsigned char u[], unsigned char v[], int n,
-	int m);
-void mpsub(int *is, unsigned char w[], unsigned char u[], unsigned char v[],
-	int n);
-void mrqcof(float x[], float y[], float sig[], int ndata, float a[],
-	int ia[], int ma, float **alpha, float beta[], float *chisq,
-	void (*funcs)(float, float [], float *, float [], int));
-void mrqmin(float x[], float y[], float sig[], int ndata, float a[],
-	int ia[], int ma, float **covar, float **alpha, float *chisq,
-	void (*funcs)(float, float [], float *, float [], int), float *alamda);
-void newt(float x[], int n, int *check,
-	void (*vecfunc)(int, float [], float []));
-void odeint(float ystart[], int nvar, float x1, float x2,
-	float eps, float h1, float hmin, int *nok, int *nbad,
-	void (*derivs)(float, float [], float []),
-	void (*rkqs)(float [], float [], int, float *, float, float,
-	float [], float *, float *, void (*)(float, float [], float [])));
-void orthog(int n, float anu[], float alpha[], float beta[], float a[],
-	float b[]);
-void pade(double cof[], int n, float *resid);
-void pccheb(float d[], float c[], int n);
-void pcshft(float a, float b, float d[], int n);
-void pearsn(float x[], float y[], unsigned long n, float *r, float *prob,
-	float *z);
-void period(float x[], float y[], int n, float ofac, float hifac,
-	float px[], float py[], int np, int *nout, int *jmax, float *prob);
-void piksr2(int n, float arr[], float brr[]);
-void piksrt(int n, float arr[]);
-void pinvs(int ie1, int ie2, int je1, int jsf, int jc1, int k,
-	float ***c, float **s);
-float plgndr(int l, int m, float x);
-float poidev(float xm, long *idum);
-void polcoe(float x[], float y[], int n, float cof[]);
-void polcof(float xa[], float ya[], int n, float cof[]);
-void poldiv(float u[], int n, float v[], int nv, float q[], float r[]);
-void polin2(float x1a[], float x2a[], float **ya, int m, int n,
-	float x1, float x2, float *y, float *dy);
-void polint(float xa[], float ya[], int n, float x, float *y, float *dy);
-void powell(float p[], float **xi, int n, float ftol, int *iter, float *fret,
-	float (*func)(float []));
-void predic(float data[], int ndata, float d[], int m, float future[], int nfut);
-float probks(float alam);
-void psdes(unsigned long *lword, unsigned long *irword);
-void pwt(float a[], unsigned long n, int isign);
-void pwtset(int n);
-float pythag(float a, float b);
-void pzextr(int iest, float xest, float yest[], float yz[], float dy[],
-	int nv);
-float qgaus(float (*func)(float), float a, float b);
-void qrdcmp(float **a, int n, float *c, float *d, int *sing);
-float qromb(float (*func)(float), float a, float b);
-float qromo(float (*func)(float), float a, float b,
-	float (*choose)(float (*)(float), float, float, int));
-void qroot(float p[], int n, float *b, float *c, float eps);
-void qrsolv(float **a, int n, float c[], float d[], float b[]);
-void qrupdt(float **r, float **qt, int n, float u[], float v[]);
-float qsimp(float (*func)(float), float a, float b);
-float qtrap(float (*func)(float), float a, float b);
-float quad3d(float (*func)(float, float, float), float x1, float x2);
-void quadct(float x, float y, float xx[], float yy[], unsigned long nn,
-	float *fa, float *fb, float *fc, float *fd);
-void quadmx(float **a, int n);
-void quadvl(float x, float y, float *fa, float *fb, float *fc, float *fd);
-float ran0(long *idum);
-float ran1(long *idum);
-float ran2(long *idum);
-float ran3(long *idum);
-float ran4(long *idum);
-void rank(unsigned long n, unsigned long indx[], unsigned long irank[]);
-void ranpt(float pt[], float regn[], int n);
-void ratint(float xa[], float ya[], int n, float x, float *y, float *dy);
-void ratlsq(double (*fn)(double), double a, double b, int mm, int kk,
-	double cof[], double *dev);
-double ratval(double x, double cof[], int mm, int kk);
-float rc(float x, float y);
-float rd(float x, float y, float z);
-void realft(float data[], unsigned long n, int isign);
-void rebin(float rc, int nd, float r[], float xin[], float xi[]);
-void red(int iz1, int iz2, int jz1, int jz2, int jm1, int jm2, int jmf,
-	int ic1, int jc1, int jcf, int kc, float ***c, float **s);
-void relax(double **u, double **rhs, int n);
-void relax2(double **u, double **rhs, int n);
-void resid(double **res, double **u, double **rhs, int n);
-float revcst(float x[], float y[], int iorder[], int ncity, int n[]);
-void reverse(int iorder[], int ncity, int n[]);
-float rf(float x, float y, float z);
-float rj(float x, float y, float z, float p);
-void rk4(float y[], float dydx[], int n, float x, float h, float yout[],
-	void (*derivs)(float, float [], float []));
-void rkck(float y[], float dydx[], int n, float x, float h,
-	float yout[], float yerr[], void (*derivs)(float, float [], float []));
-void rkdumb(float vstart[], int nvar, float x1, float x2, int nstep,
-	void (*derivs)(float, float [], float []));
-void rkqs(float y[], float dydx[], int n, float *x,
-	float htry, float eps, float yscal[], float *hdid, float *hnext,
-	void (*derivs)(float, float [], float []));
-void rlft3(float ***data, float **speq, unsigned long nn1,
-	unsigned long nn2, unsigned long nn3, int isign);
-float rofunc(float b);
-void rotate(float **r, float **qt, int n, int i, float a, float b);
-void rsolv(float **a, int n, float d[], float b[]);
-void rstrct(double **uc, double **uf, int nc);
-float rtbis(float (*func)(float), float x1, float x2, float xacc);
-float rtflsp(float (*func)(float), float x1, float x2, float xacc);
-float rtnewt(void (*funcd)(float, float *, float *), float x1, float x2,
-	float xacc);
-float rtsafe(void (*funcd)(float, float *, float *), float x1, float x2,
-	float xacc);
-float rtsec(float (*func)(float), float x1, float x2, float xacc);
-void rzextr(int iest, float xest, float yest[], float yz[], float dy[], int nv);
-void savgol(float c[], int np, int nl, int nr, int ld, int m);
-void score(float xf, float y[], float f[]);
-void scrsho(float (*fx)(float));
-float select(unsigned long k, unsigned long n, float arr[]);
-float selip(unsigned long k, unsigned long n, float arr[]);
-void shell(unsigned long n, float a[]);
-void shoot(int n, float v[], float f[]);
-void shootf(int n, float v[], float f[]);
-void simp1(float **a, int mm, int ll[], int nll, int iabf, int *kp,
-	float *bmax);
-void simp2(float **a, int n, int l2[], int nl2, int *ip, int kp, float *q1);
-void simp3(float **a, int i1, int k1, int ip, int kp);
-void simplx(float **a, int m, int n, int m1, int m2, int m3, int *icase,
-	int izrov[], int iposv[]);
-void simpr(float y[], float dydx[], float dfdx[], float **dfdy,
-	int n, float xs, float htot, int nstep, float yout[],
-	void (*derivs)(float, float [], float []));
-void sinft(float y[], int n);
-void slvsm2(double **u, double **rhs);
-void slvsml(double **u, double **rhs);
-void sncndn(float uu, float emmc, float *sn, float *cn, float *dn);
-double snrm(unsigned long n, double sx[], int itol);
-void sobseq(int *n, float x[]);
-void solvde(int itmax, float conv, float slowc, float scalv[],
-	int indexv[], int ne, int nb, int m, float **y, float ***c, float **s);
-void sor(double **a, double **b, double **c, double **d, double **e,
-	double **f, double **u, int jmax, double rjac);
-void sort(unsigned long n, float arr[]);
-void sort2(unsigned long n, float arr[], float brr[]);
-void sort3(unsigned long n, float ra[], float rb[], float rc[]);
-void spctrm(FILE *fp, float p[], int m, int k, int ovrlap);
-void spear(float data1[], float data2[], unsigned long n, float *d, float *zd,
-	float *probd, float *rs, float *probrs);
-void sphbes(int n, float x, float *sj, float *sy, float *sjp, float *syp);
-void splie2(float x1a[], float x2a[], float **ya, int m, int n, float **y2a);
-void splin2(float x1a[], float x2a[], float **ya, float **y2a, int m, int n,
-	float x1, float x2, float *y);
-void spline(float x[], float y[], int n, float yp1, float ypn, float y2[]);
-void splint(float xa[], float ya[], float y2a[], int n, float x, float *y);
-void spread(float y, float yy[], unsigned long n, float x, int m);
-void sprsax(float sa[], unsigned long ija[], float x[], float b[],
-	unsigned long n);
-void sprsin(float **a, int n, float thresh, unsigned long nmax, float sa[],
-	unsigned long ija[]);
-void sprspm(float sa[], unsigned long ija[], float sb[], unsigned long ijb[],
-	float sc[], unsigned long ijc[]);
-void sprstm(float sa[], unsigned long ija[], float sb[], unsigned long ijb[],
-	float thresh, unsigned long nmax, float sc[], unsigned long ijc[]);
-void sprstp(float sa[], unsigned long ija[], float sb[], unsigned long ijb[]);
-void sprstx(float sa[], unsigned long ija[], float x[], float b[],
-	unsigned long n);
-void stifbs(float y[], float dydx[], int nv, float *xx,
-	float htry, float eps, float yscal[], float *hdid, float *hnext,
-	void (*derivs)(float, float [], float []));
-void stiff(float y[], float dydx[], int n, float *x,
-	float htry, float eps, float yscal[], float *hdid, float *hnext,
-	void (*derivs)(float, float [], float []));
-void stoerm(float y[], float d2y[], int nv, float xs,
-	float htot, int nstep, float yout[],
-	void (*derivs)(float, float [], float []));
-void svbksb(float **u, float w[], float **v, int m, int n, float b[],
-	float x[]);
-void svdcmp(float **a, int m, int n, float w[], float **v);
-void svdfit(float x[], float y[], float sig[], int ndata, float a[],
-	int ma, float **u, float **v, float w[], float *chisq,
-	void (*funcs)(float, float [], int));
-void svdvar(float **v, int ma, float w[], float **cvm);
-void toeplz(float r[], float x[], float y[], int n);
-void tptest(float data1[], float data2[], unsigned long n, float *t, float *prob);
-void tqli(float d[], float e[], int n, float **z);
-float trapzd(float (*func)(float), float a, float b, int n);
-void tred2(float **a, int n, float d[], float e[]);
-void tridag(float a[], float b[], float c[], float r[], float u[],
-	unsigned long n);
-float trncst(float x[], float y[], int iorder[], int ncity, int n[]);
-void trnspt(int iorder[], int ncity, int n[]);
-void ttest(float data1[], unsigned long n1, float data2[], unsigned long n2,
-	float *t, float *prob);
-void tutest(float data1[], unsigned long n1, float data2[], unsigned long n2,
-	float *t, float *prob);
-void twofft(float data1[], float data2[], float fft1[], float fft2[],
-	unsigned long n);
-void vander(double x[], double w[], double q[], int n);
-void vegas(float regn[], int ndim, float (*fxn)(float [], float), int init,
-	unsigned long ncall, int itmx, int nprn, float *tgral, float *sd,
-	float *chi2a);
-void voltra(int n, int m, float t0, float h, float *t, float **f,
-	float (*g)(int, float), float (*ak)(int, int, float, float));
-void wt1(float a[], unsigned long n, int isign,
-	void (*wtstep)(float [], unsigned long, int));
-void wtn(float a[], unsigned long nn[], int ndim, int isign,
-	void (*wtstep)(float [], unsigned long, int));
-void wwghts(float wghts[], int n, float h,
-	void (*kermom)(double [], double ,int));
-int zbrac(float (*func)(float), float *x1, float *x2);
-void zbrak(float (*fx)(float), float x1, float x2, int n, float xb1[],
-	float xb2[], int *nb);
-float zbrent(float (*func)(float), float x1, float x2, float tol);
-void zrhqr(float a[], int m, float rtr[], float rti[]);
-float zriddr(float (*func)(float), float x1, float x2, float xacc);
-void zroots(fcomplex a[], int m, fcomplex roots[], int polish);
-
-#else /* ANSI */
-/* traditional - K&R */
-
-void addint();
-void airy();
-void amebsa();
-void amoeba();
-float amotry();
-float amotsa();
-void anneal();
-double anorm2();
-void arcmak();
-void arcode();
-void arcsum();
-void asolve();
-void atimes();
-void avevar();
-void balanc();
-void banbks();
-void bandec();
-void banmul();
-void bcucof();
-void bcuint();
-void beschb();
-float bessi();
-float bessi0();
-float bessi1();
-void bessik();
-float bessj();
-float bessj0();
-float bessj1();
-void bessjy();
-float bessk();
-float bessk0();
-float bessk1();
-float bessy();
-float bessy0();
-float bessy1();
-float beta();
-float betacf();
-float betai();
-float bico();
-void bksub();
-float bnldev();
-float brent();
-void broydn();
-void bsstep();
-void caldat();
-void chder();
-float chebev();
-void chebft();
-void chebpc();
-void chint();
-float chixy();
-void choldc();
-void cholsl();
-void chsone();
-void chstwo();
-void cisi();
-void cntab1();
-void cntab2();
-void convlv();
-void copy();
-void correl();
-void cosft();
-void cosft1();
-void cosft2();
-void covsrt();
-void crank();
-void cyclic();
-void daub4();
-float dawson();
-float dbrent();
-void ddpoly();
-int decchk();
-void derivs();
-float df1dim();
-void dfour1();
-void dfpmin();
-float dfridr();
-void dftcor();
-void dftint();
-void difeq();
-void dlinmin();
-double dpythag();
-void drealft();
-void dsprsax();
-void dsprstx();
-void dsvbksb();
-void dsvdcmp();
-void eclass();
-void eclazz();
-float ei();
-void eigsrt();
-float elle();
-float ellf();
-float ellpi();
-void elmhes();
-float erfcc();
-float erff();
-float erffc();
-void eulsum();
-float evlmem();
-float expdev();
-float expint();
-float f1();
-float f1dim();
-float f2();
-float f3();
-float factln();
-float factrl();
-void fasper();
-void fdjac();
-void fgauss();
-void fill0();
-void fit();
-void fitexy();
-void fixrts();
-void fleg();
-void flmoon();
-float fmin();
-void four1();
-void fourew();
-void fourfs();
-void fourn();
-void fpoly();
-void fred2();
-float fredin();
-void frenel();
-void frprmn();
-void ftest();
-float gamdev();
-float gammln();
-float gammp();
-float gammq();
-float gasdev();
-void gaucof();
-void gauher();
-void gaujac();
-void gaulag();
-void gauleg();
-void gaussj();
-void gcf();
-float golden();
-void gser();
-void hpsel();
-void hpsort();
-void hqr();
-void hufapp();
-void hufdec();
-void hufenc();
-void hufmak();
-void hunt();
-void hypdrv();
-fcomplex hypgeo();
-void hypser();
-unsigned short icrc();
-unsigned short icrc1();
-unsigned long igray();
-void iindexx();
-void indexx();
-void interp();
-int irbit1();
-int irbit2();
-void jacobi();
-void jacobn();
-long julday();
-void kendl1();
-void kendl2();
-void kermom();
-void ks2d1s();
-void ks2d2s();
-void ksone();
-void kstwo();
-void laguer();
-void lfit();
-void linbcg();
-void linmin();
-void lnsrch();
-void load();
-void load1();
-void load2();
-void locate();
-void lop();
-void lubksb();
-void ludcmp();
-void machar();
-void matadd();
-void matsub();
-void medfit();
-void memcof();
-int metrop();
-void mgfas();
-void mglin();
-float midexp();
-float midinf();
-float midpnt();
-float midsql();
-float midsqu();
-void miser();
-void mmid();
-void mnbrak();
-void mnewt();
-void moment();
-void mp2dfr();
-void mpadd();
-void mpdiv();
-void mpinv();
-void mplsh();
-void mpmov();
-void mpmul();
-void mpneg();
-void mppi();
-void mprove();
-void mpsad();
-void mpsdv();
-void mpsmu();
-void mpsqrt();
-void mpsub();
-void mrqcof();
-void mrqmin();
-void newt();
-void odeint();
-void orthog();
-void pade();
-void pccheb();
-void pcshft();
-void pearsn();
-void period();
-void piksr2();
-void piksrt();
-void pinvs();
-float plgndr();
-float poidev();
-void polcoe();
-void polcof();
-void poldiv();
-void polin2();
-void polint();
-void powell();
-void predic();
-float probks();
-void psdes();
-void pwt();
-void pwtset();
-float pythag();
-void pzextr();
-float qgaus();
-void qrdcmp();
-float qromb();
-float qromo();
-void qroot();
-void qrsolv();
-void qrupdt();
-float qsimp();
-float qtrap();
-float quad3d();
-void quadct();
-void quadmx();
-void quadvl();
-float ran0();
-float ran1();
-float ran2();
-float ran3();
-float ran4();
-void rank();
-void ranpt();
-void ratint();
-void ratlsq();
-double ratval();
-float rc();
-float rd();
-void realft();
-void rebin();
-void red();
-void relax();
-void relax2();
-void resid();
-float revcst();
-void reverse();
-float rf();
-float rj();
-void rk4();
-void rkck();
-void rkdumb();
-void rkqs();
-void rlft3();
-float rofunc();
-void rotate();
-void rsolv();
-void rstrct();
-float rtbis();
-float rtflsp();
-float rtnewt();
-float rtsafe();
-float rtsec();
-void rzextr();
-void savgol();
-void score();
-void scrsho();
-float select();
-float selip();
-void shell();
-void shoot();
-void shootf();
-void simp1();
-void simp2();
-void simp3();
-void simplx();
-void simpr();
-void sinft();
-void slvsm2();
-void slvsml();
-void sncndn();
-double snrm();
-void sobseq();
-void solvde();
-void sor();
-void sort();
-void sort2();
-void sort3();
-void spctrm();
-void spear();
-void sphbes();
-void splie2();
-void splin2();
-void spline();
-void splint();
-void spread();
-void sprsax();
-void sprsin();
-void sprspm();
-void sprstm();
-void sprstp();
-void sprstx();
-void stifbs();
-void stiff();
-void stoerm();
-void svbksb();
-void svdcmp();
-void svdfit();
-void svdvar();
-void toeplz();
-void tptest();
-void tqli();
-float trapzd();
-void tred2();
-void tridag();
-float trncst();
-void trnspt();
-void ttest();
-void tutest();
-void twofft();
-void vander();
-void vegas();
-void voltra();
-void wt1();
-void wtn();
-void wwghts();
-int zbrac();
-void zbrak();
-float zbrent();
-void zrhqr();
-float zriddr();
-void zroots();
-
-#endif /* ANSI */
-
-#endif /* _NR_H_ */
diff --git a/filterbank-gmrt/nrselect.c b/filterbank-gmrt/nrselect.c
deleted file mode 100644
index 6468606..0000000
--- a/filterbank-gmrt/nrselect.c
+++ /dev/null
@@ -1,44 +0,0 @@
-#define SWAP(a,b) temp=(a);(a)=(b);(b)=temp;
-float nrselect(unsigned long k, unsigned long n, float arr[]) /*includefile*/
-{
-	unsigned long i,ir,j,l,mid;
-	float a,temp;
-
-	l=1;
-	ir=n;
-	for (;;) {
-		if (ir <= l+1) {
-			if (ir == l+1 && arr[ir] < arr[l]) {
-				SWAP(arr[l],arr[ir])
-			}
-			return arr[k];
-		} else {
-			mid=(l+ir) >> 1;
-			SWAP(arr[mid],arr[l+1])
-			if (arr[l+1] > arr[ir]) {
-				SWAP(arr[l+1],arr[ir])
-			}
-			if (arr[l] > arr[ir]) {
-				SWAP(arr[l],arr[ir])
-			}
-			if (arr[l+1] > arr[l]) {
-				SWAP(arr[l+1],arr[l])
-			}
-			i=l+1;
-			j=ir;
-			a=arr[l];
-			for (;;) {
-				do i++; while (arr[i] < a);
-				do j--; while (arr[j] > a);
-				if (j < i) break;
-				SWAP(arr[i],arr[j])
-			}
-			arr[l]=arr[j];
-			arr[j]=a;
-			if (j >= k) ir=j-1;
-			if (j <= k) l=i;
-		}
-	}
-}
-#undef SWAP
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
diff --git a/filterbank-gmrt/nrsort.c b/filterbank-gmrt/nrsort.c
deleted file mode 100644
index 16d2cc5..0000000
--- a/filterbank-gmrt/nrsort.c
+++ /dev/null
@@ -1,69 +0,0 @@
-#define NRANSI
-#include "nrutil.h"
-#define SWAP(a,b) temp=(a);(a)=(b);(b)=temp;
-#define M 7
-#define NSTACK 50
-
-void nrsort(unsigned long n, float arr[]) /*includefile*/
-{
-	unsigned long i,ir=n,j,k,l=1;
-	int jstack=0,*istack;
-	float a,temp;
-
-	istack=ivector(1,NSTACK);
-	for (;;) {
-		if (ir-l < M) {
-			for (j=l+1;j<=ir;j++) {
-				a=arr[j];
-				for (i=j-1;i>=1;i--) {
-					if (arr[i] <= a) break;
-					arr[i+1]=arr[i];
-				}
-				arr[i+1]=a;
-			}
-			if (jstack == 0) break;
-			ir=istack[jstack--];
-			l=istack[jstack--];
-		} else {
-			k=(l+ir) >> 1;
-			SWAP(arr[k],arr[l+1])
-			if (arr[l+1] > arr[ir]) {
-				SWAP(arr[l+1],arr[ir])
-			}
-			if (arr[l] > arr[ir]) {
-				SWAP(arr[l],arr[ir])
-			}
-			if (arr[l+1] > arr[l]) {
-				SWAP(arr[l+1],arr[l])
-			}
-			i=l+1;
-			j=ir;
-			a=arr[l];
-			for (;;) {
-				do i++; while (arr[i] < a);
-				do j--; while (arr[j] > a);
-				if (j < i) break;
-				SWAP(arr[i],arr[j]);
-			}
-			arr[l]=arr[j];
-			arr[j]=a;
-			jstack += 2;
-			if (jstack > NSTACK) nrerror("NSTACK too small in sort.");
-			if (ir-i+1 >= j-l) {
-				istack[jstack]=ir;
-				istack[jstack-1]=i;
-				ir=j-1;
-			} else {
-				istack[jstack]=j-1;
-				istack[jstack-1]=l;
-				l=i;
-			}
-		}
-	}
-	free_ivector(istack,1,NSTACK);
-}
-#undef M
-#undef NSTACK
-#undef SWAP
-#undef NRANSI
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
diff --git a/filterbank-gmrt/nrutil.c b/filterbank-gmrt/nrutil.c
deleted file mode 100644
index 6d9e217..0000000
--- a/filterbank-gmrt/nrutil.c
+++ /dev/null
@@ -1,614 +0,0 @@
-#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */
-
-#include <stdio.h>
-#include <stddef.h>
-#include <stdlib.h>
-#define NR_END 1
-#define FREE_ARG char*
-
-void nrerror(char error_text[])
-/* Numerical Recipes standard error handler */
-{
-	fprintf(stderr,"Numerical Recipes run-time error...\n");
-	fprintf(stderr,"%s\n",error_text);
-	fprintf(stderr,"...now exiting to system...\n");
-	exit(1);
-}
-
-float *vector(long nl, long nh)
-/* allocate a float vector with subscript range v[nl..nh] */
-{
-	float *v;
-
-	v=(float *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(float)));
-	if (!v) nrerror("allocation failure in vector()");
-	return v-nl+NR_END;
-}
-
-int *ivector(long nl, long nh)
-/* allocate an int vector with subscript range v[nl..nh] */
-{
-	int *v;
-
-	v=(int *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(int)));
-	if (!v) nrerror("allocation failure in ivector()");
-	return v-nl+NR_END;
-}
-
-unsigned char *cvector(long nl, long nh)
-/* allocate an unsigned char vector with subscript range v[nl..nh] */
-{
-	unsigned char *v;
-
-	v=(unsigned char *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
-	if (!v) nrerror("allocation failure in cvector()");
-	return v-nl+NR_END;
-}
-
-unsigned long *lvector(long nl, long nh)
-/* allocate an unsigned long vector with subscript range v[nl..nh] */
-{
-	unsigned long *v;
-
-	v=(unsigned long *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(long)));
-	if (!v) nrerror("allocation failure in lvector()");
-	return v-nl+NR_END;
-}
-
-double *dvector(long nl, long nh)
-/* allocate a double vector with subscript range v[nl..nh] */
-{
-	double *v;
-
-	v=(double *)malloc((size_t) ((nh-nl+1+NR_END)*sizeof(double)));
-	if (!v) nrerror("allocation failure in dvector()");
-	return v-nl+NR_END;
-}
-
-float **matrix(long nrl, long nrh, long ncl, long nch)
-/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	float **m;
-
-	/* allocate pointers to rows */
-	m=(float **) malloc((size_t)((nrow+NR_END)*sizeof(float*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(float *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-double **dmatrix(long nrl, long nrh, long ncl, long nch)
-/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	double **m;
-
-	/* allocate pointers to rows */
-	m=(double **) malloc((size_t)((nrow+NR_END)*sizeof(double*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(double *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(double)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-int **imatrix(long nrl, long nrh, long ncl, long nch)
-/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	int **m;
-
-	/* allocate pointers to rows */
-	m=(int **) malloc((size_t)((nrow+NR_END)*sizeof(int*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(int *) malloc((size_t)((nrow*ncol+NR_END)*sizeof(int)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
-	long newrl, long newcl)
-/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
-{
-	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
-	float **m;
-
-	/* allocate array of pointers to rows */
-	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
-	if (!m) nrerror("allocation failure in submatrix()");
-	m += NR_END;
-	m -= newrl;
-
-	/* set pointers to rows */
-	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch)
-/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
-declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
-and ncol=nch-ncl+1. The routine should be called with the address
-&a[0][0] as the first argument. */
-{
-	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	float **m;
-
-	/* allocate pointers to rows */
-	m=(float **) malloc((size_t) ((nrow+NR_END)*sizeof(float*)));
-	if (!m) nrerror("allocation failure in convert_matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* set pointers to rows */
-	m[nrl]=a-ncl;
-	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh)
-/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
-{
-	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
-	float ***t;
-
-	/* allocate pointers to pointers to rows */
-	t=(float ***) malloc((size_t)((nrow+NR_END)*sizeof(float**)));
-	if (!t) nrerror("allocation failure 1 in f3tensor()");
-	t += NR_END;
-	t -= nrl;
-
-	/* allocate pointers to rows and set pointers to them */
-	t[nrl]=(float **) malloc((size_t)((nrow*ncol+NR_END)*sizeof(float*)));
-	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
-	t[nrl] += NR_END;
-	t[nrl] -= ncl;
-
-	/* allocate rows and set pointers to them */
-	t[nrl][ncl]=(float *) malloc((size_t)((nrow*ncol*ndep+NR_END)*sizeof(float)));
-	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
-	t[nrl][ncl] += NR_END;
-	t[nrl][ncl] -= ndl;
-
-	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
-	for(i=nrl+1;i<=nrh;i++) {
-		t[i]=t[i-1]+ncol;
-		t[i][ncl]=t[i-1][ncl]+ncol*ndep;
-		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
-	}
-
-	/* return pointer to array of pointers to rows */
-	return t;
-}
-
-void free_vector(float *v, long nl, long nh)
-/* free a float vector allocated with vector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_ivector(int *v, long nl, long nh)
-/* free an int vector allocated with ivector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_cvector(unsigned char *v, long nl, long nh)
-/* free an unsigned char vector allocated with cvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_lvector(unsigned long *v, long nl, long nh)
-/* free an unsigned long vector allocated with lvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_dvector(double *v, long nl, long nh)
-/* free a double vector allocated with dvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_matrix(float **m, long nrl, long nrh, long ncl, long nch)
-/* free a float matrix allocated by matrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch)
-/* free a double matrix allocated by dmatrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch)
-/* free an int matrix allocated by imatrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch)
-/* free a submatrix allocated by submatrix() */
-{
-	free((FREE_ARG) (b+nrl-NR_END));
-}
-
-void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch)
-/* free a matrix allocated by convert_matrix() */
-{
-	free((FREE_ARG) (b+nrl-NR_END));
-}
-
-void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
-	long ndl, long ndh)
-/* free a float f3tensor allocated by f3tensor() */
-{
-	free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
-	free((FREE_ARG) (t[nrl]+ncl-NR_END));
-	free((FREE_ARG) (t+nrl-NR_END));
-}
-
-#else /* ANSI */
-/* traditional - K&R */
-
-#include <stdio.h>
-#define NR_END 1
-#define FREE_ARG char*
-
-void nrerror(error_text)
-char error_text[];
-/* Numerical Recipes standard error handler */
-{
-	void exit();
-
-	fprintf(stderr,"Numerical Recipes run-time error...\n");
-	fprintf(stderr,"%s\n",error_text);
-	fprintf(stderr,"...now exiting to system...\n");
-	exit(1);
-}
-
-float *vector(nl,nh)
-long nh,nl;
-/* allocate a float vector with subscript range v[nl..nh] */
-{
-	float *v;
-
-	v=(float *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(float)));
-	if (!v) nrerror("allocation failure in vector()");
-	return v-nl+NR_END;
-}
-
-int *ivector(nl,nh)
-long nh,nl;
-/* allocate an int vector with subscript range v[nl..nh] */
-{
-	int *v;
-
-	v=(int *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(int)));
-	if (!v) nrerror("allocation failure in ivector()");
-	return v-nl+NR_END;
-}
-
-unsigned char *cvector(nl,nh)
-long nh,nl;
-/* allocate an unsigned char vector with subscript range v[nl..nh] */
-{
-	unsigned char *v;
-
-	v=(unsigned char *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(unsigned char)));
-	if (!v) nrerror("allocation failure in cvector()");
-	return v-nl+NR_END;
-}
-
-unsigned long *lvector(nl,nh)
-long nh,nl;
-/* allocate an unsigned long vector with subscript range v[nl..nh] */
-{
-	unsigned long *v;
-
-	v=(unsigned long *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(long)));
-	if (!v) nrerror("allocation failure in lvector()");
-	return v-nl+NR_END;
-}
-
-double *dvector(nl,nh)
-long nh,nl;
-/* allocate a double vector with subscript range v[nl..nh] */
-{
-	double *v;
-
-	v=(double *)malloc((unsigned int) ((nh-nl+1+NR_END)*sizeof(double)));
-	if (!v) nrerror("allocation failure in dvector()");
-	return v-nl+NR_END;
-}
-
-float **matrix(nrl,nrh,ncl,nch)
-long nch,ncl,nrh,nrl;
-/* allocate a float matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	float **m;
-
-	/* allocate pointers to rows */
-	m=(float **) malloc((unsigned int)((nrow+NR_END)*sizeof(float*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(float *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-double **dmatrix(nrl,nrh,ncl,nch)
-long nch,ncl,nrh,nrl;
-/* allocate a double matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	double **m;
-
-	/* allocate pointers to rows */
-	m=(double **) malloc((unsigned int)((nrow+NR_END)*sizeof(double*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(double *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(double)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-int **imatrix(nrl,nrh,ncl,nch)
-long nch,ncl,nrh,nrl;
-/* allocate a int matrix with subscript range m[nrl..nrh][ncl..nch] */
-{
-	long i, nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	int **m;
-
-	/* allocate pointers to rows */
-	m=(int **) malloc((unsigned int)((nrow+NR_END)*sizeof(int*)));
-	if (!m) nrerror("allocation failure 1 in matrix()");
-	m += NR_END;
-	m -= nrl;
-
-
-	/* allocate rows and set pointers to them */
-	m[nrl]=(int *) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(int)));
-	if (!m[nrl]) nrerror("allocation failure 2 in matrix()");
-	m[nrl] += NR_END;
-	m[nrl] -= ncl;
-
-	for(i=nrl+1;i<=nrh;i++) m[i]=m[i-1]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float **submatrix(a,oldrl,oldrh,oldcl,oldch,newrl,newcl)
-float **a;
-long newcl,newrl,oldch,oldcl,oldrh,oldrl;
-/* point a submatrix [newrl..][newcl..] to a[oldrl..oldrh][oldcl..oldch] */
-{
-	long i,j,nrow=oldrh-oldrl+1,ncol=oldcl-newcl;
-	float **m;
-
-	/* allocate array of pointers to rows */
-	m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));
-	if (!m) nrerror("allocation failure in submatrix()");
-	m += NR_END;
-	m -= newrl;
-
-	/* set pointers to rows */
-	for(i=oldrl,j=newrl;i<=oldrh;i++,j++) m[j]=a[i]+ncol;
-
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float **convert_matrix(a,nrl,nrh,ncl,nch)
-float *a;
-long nch,ncl,nrh,nrl;
-/* allocate a float matrix m[nrl..nrh][ncl..nch] that points to the matrix
-declared in the standard C manner as a[nrow][ncol], where nrow=nrh-nrl+1
-and ncol=nch-ncl+1. The routine should be called with the address
-&a[0][0] as the first argument. */
-{
-	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1;
-	float **m;
-
-	/* allocate pointers to rows */
-	m=(float **) malloc((unsigned int) ((nrow+NR_END)*sizeof(float*)));
-	if (!m)	nrerror("allocation failure in convert_matrix()");
-	m += NR_END;
-	m -= nrl;
-
-	/* set pointers to rows */
-	m[nrl]=a-ncl;
-	for(i=1,j=nrl+1;i<nrow;i++,j++) m[j]=m[j-1]+ncol;
-	/* return pointer to array of pointers to rows */
-	return m;
-}
-
-float ***f3tensor(nrl,nrh,ncl,nch,ndl,ndh)
-long nch,ncl,ndh,ndl,nrh,nrl;
-/* allocate a float 3tensor with range t[nrl..nrh][ncl..nch][ndl..ndh] */
-{
-	long i,j,nrow=nrh-nrl+1,ncol=nch-ncl+1,ndep=ndh-ndl+1;
-	float ***t;
-
-	/* allocate pointers to pointers to rows */
-	t=(float ***) malloc((unsigned int)((nrow+NR_END)*sizeof(float**)));
-	if (!t) nrerror("allocation failure 1 in f3tensor()");
-	t += NR_END;
-	t -= nrl;
-
-	/* allocate pointers to rows and set pointers to them */
-	t[nrl]=(float **) malloc((unsigned int)((nrow*ncol+NR_END)*sizeof(float*)));
-	if (!t[nrl]) nrerror("allocation failure 2 in f3tensor()");
-	t[nrl] += NR_END;
-	t[nrl] -= ncl;
-
-	/* allocate rows and set pointers to them */
-	t[nrl][ncl]=(float *) malloc((unsigned int)((nrow*ncol*ndep+NR_END)*sizeof(float)));
-	if (!t[nrl][ncl]) nrerror("allocation failure 3 in f3tensor()");
-	t[nrl][ncl] += NR_END;
-	t[nrl][ncl] -= ndl;
-
-	for(j=ncl+1;j<=nch;j++) t[nrl][j]=t[nrl][j-1]+ndep;
-	for(i=nrl+1;i<=nrh;i++) {
-		t[i]=t[i-1]+ncol;
-		t[i][ncl]=t[i-1][ncl]+ncol*ndep;
-		for(j=ncl+1;j<=nch;j++) t[i][j]=t[i][j-1]+ndep;
-	}
-
-	/* return pointer to array of pointers to rows */
-	return t;
-}
-
-void free_vector(v,nl,nh)
-float *v;
-long nh,nl;
-/* free a float vector allocated with vector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_ivector(v,nl,nh)
-int *v;
-long nh,nl;
-/* free an int vector allocated with ivector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_cvector(v,nl,nh)
-long nh,nl;
-unsigned char *v;
-/* free an unsigned char vector allocated with cvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_lvector(v,nl,nh)
-long nh,nl;
-unsigned long *v;
-/* free an unsigned long vector allocated with lvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_dvector(v,nl,nh)
-double *v;
-long nh,nl;
-/* free a double vector allocated with dvector() */
-{
-	free((FREE_ARG) (v+nl-NR_END));
-}
-
-void free_matrix(m,nrl,nrh,ncl,nch)
-float **m;
-long nch,ncl,nrh,nrl;
-/* free a float matrix allocated by matrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_dmatrix(m,nrl,nrh,ncl,nch)
-double **m;
-long nch,ncl,nrh,nrl;
-/* free a double matrix allocated by dmatrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_imatrix(m,nrl,nrh,ncl,nch)
-int **m;
-long nch,ncl,nrh,nrl;
-/* free an int matrix allocated by imatrix() */
-{
-	free((FREE_ARG) (m[nrl]+ncl-NR_END));
-	free((FREE_ARG) (m+nrl-NR_END));
-}
-
-void free_submatrix(b,nrl,nrh,ncl,nch)
-float **b;
-long nch,ncl,nrh,nrl;
-/* free a submatrix allocated by submatrix() */
-{
-	free((FREE_ARG) (b+nrl-NR_END));
-}
-
-void free_convert_matrix(b,nrl,nrh,ncl,nch)
-float **b;
-long nch,ncl,nrh,nrl;
-/* free a matrix allocated by convert_matrix() */
-{
-	free((FREE_ARG) (b+nrl-NR_END));
-}
-
-void free_f3tensor(t,nrl,nrh,ncl,nch,ndl,ndh)
-float ***t;
-long nch,ncl,ndh,ndl,nrh,nrl;
-/* free a float f3tensor allocated by f3tensor() */
-{
-	free((FREE_ARG) (t[nrl][ncl]+ndl-NR_END));
-	free((FREE_ARG) (t[nrl]+ncl-NR_END));
-	free((FREE_ARG) (t+nrl-NR_END));
-}
-
-#endif /* ANSI */
diff --git a/filterbank-gmrt/nrutil.h b/filterbank-gmrt/nrutil.h
deleted file mode 100644
index 07cb570..0000000
--- a/filterbank-gmrt/nrutil.h
+++ /dev/null
@@ -1,101 +0,0 @@
-#ifndef _NR_UTILS_H_
-#define _NR_UTILS_H_
-
-static float sqrarg;
-#define SQR(a) ((sqrarg=(a)) == 0.0 ? 0.0 : sqrarg*sqrarg)
-
-static double dsqrarg;
-#define DSQR(a) ((dsqrarg=(a)) == 0.0 ? 0.0 : dsqrarg*dsqrarg)
-
-static double dmaxarg1,dmaxarg2;
-#define DMAX(a,b) (dmaxarg1=(a),dmaxarg2=(b),(dmaxarg1) > (dmaxarg2) ?\
-        (dmaxarg1) : (dmaxarg2))
-
-static double dminarg1,dminarg2;
-#define DMIN(a,b) (dminarg1=(a),dminarg2=(b),(dminarg1) < (dminarg2) ?\
-        (dminarg1) : (dminarg2))
-
-static float maxarg1,maxarg2;
-#define FMAX(a,b) (maxarg1=(a),maxarg2=(b),(maxarg1) > (maxarg2) ?\
-        (maxarg1) : (maxarg2))
-
-static float minarg1,minarg2;
-#define FMIN(a,b) (minarg1=(a),minarg2=(b),(minarg1) < (minarg2) ?\
-        (minarg1) : (minarg2))
-
-static long lmaxarg1,lmaxarg2;
-#define LMAX(a,b) (lmaxarg1=(a),lmaxarg2=(b),(lmaxarg1) > (lmaxarg2) ?\
-        (lmaxarg1) : (lmaxarg2))
-
-static long lminarg1,lminarg2;
-#define LMIN(a,b) (lminarg1=(a),lminarg2=(b),(lminarg1) < (lminarg2) ?\
-        (lminarg1) : (lminarg2))
-
-static int imaxarg1,imaxarg2;
-#define IMAX(a,b) (imaxarg1=(a),imaxarg2=(b),(imaxarg1) > (imaxarg2) ?\
-        (imaxarg1) : (imaxarg2))
-
-static int iminarg1,iminarg2;
-#define IMIN(a,b) (iminarg1=(a),iminarg2=(b),(iminarg1) < (iminarg2) ?\
-        (iminarg1) : (iminarg2))
-
-#define SIGN(a,b) ((b) >= 0.0 ? fabs(a) : -fabs(a))
-
-#if defined(__STDC__) || defined(ANSI) || defined(NRANSI) /* ANSI */
-
-void nrerror(char error_text[]);
-float *vector(long nl, long nh);
-int *ivector(long nl, long nh);
-unsigned char *cvector(long nl, long nh);
-unsigned long *lvector(long nl, long nh);
-double *dvector(long nl, long nh);
-float **matrix(long nrl, long nrh, long ncl, long nch);
-double **dmatrix(long nrl, long nrh, long ncl, long nch);
-int **imatrix(long nrl, long nrh, long ncl, long nch);
-float **submatrix(float **a, long oldrl, long oldrh, long oldcl, long oldch,
-	long newrl, long newcl);
-float **convert_matrix(float *a, long nrl, long nrh, long ncl, long nch);
-float ***f3tensor(long nrl, long nrh, long ncl, long nch, long ndl, long ndh);
-void free_vector(float *v, long nl, long nh);
-void free_ivector(int *v, long nl, long nh);
-void free_cvector(unsigned char *v, long nl, long nh);
-void free_lvector(unsigned long *v, long nl, long nh);
-void free_dvector(double *v, long nl, long nh);
-void free_matrix(float **m, long nrl, long nrh, long ncl, long nch);
-void free_dmatrix(double **m, long nrl, long nrh, long ncl, long nch);
-void free_imatrix(int **m, long nrl, long nrh, long ncl, long nch);
-void free_submatrix(float **b, long nrl, long nrh, long ncl, long nch);
-void free_convert_matrix(float **b, long nrl, long nrh, long ncl, long nch);
-void free_f3tensor(float ***t, long nrl, long nrh, long ncl, long nch,
-	long ndl, long ndh);
-
-#else /* ANSI */
-/* traditional - K&R */
-
-void nrerror();
-float *vector();
-float **matrix();
-float **submatrix();
-float **convert_matrix();
-float ***f3tensor();
-double *dvector();
-double **dmatrix();
-int *ivector();
-int **imatrix();
-unsigned char *cvector();
-unsigned long *lvector();
-void free_vector();
-void free_dvector();
-void free_ivector();
-void free_cvector();
-void free_lvector();
-void free_matrix();
-void free_submatrix();
-void free_convert_matrix();
-void free_dmatrix();
-void free_imatrix();
-void free_f3tensor();
-
-#endif /* ANSI */
-
-#endif /* _NR_UTILS_H_ */
diff --git a/filterbank-gmrt/nsamples.c b/filterbank-gmrt/nsamples.c
deleted file mode 100644
index d4a495c..0000000
--- a/filterbank-gmrt/nsamples.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <math.h>
-long long sizeof_file(char name[]) ;
-long long nsamples(char *filename,int headersize, int nbits, int nifs, int nchans) /*includefile*/
-{
-  long long datasize,numsamps;
-  datasize=sizeof_file(filename)-headersize;
-  numsamps=(long long) (long double) (datasize)/ (((long double) nbits) / 8.0) 
-		 /(long double) nifs/(long double) nchans;
-  return(numsamps);
-}
diff --git a/filterbank-gmrt/old_wapp_header.h b/filterbank-gmrt/old_wapp_header.h
deleted file mode 100644
index 85b781f..0000000
--- a/filterbank-gmrt/old_wapp_header.h
+++ /dev/null
@@ -1,144 +0,0 @@
-/* 
-  RCS: $Id: wapp_header.h,v 1.8 2004/02/17 13:13:25 wapp Exp wapp $
-   wapp_head.h - header parameters for WAPP (Wideband Arecibo Pulsar Processor)
-   This structure (WAPP_HEADER) is based on the PSPM-style headers but has
-   been somewhat simplified to include just essential/relevant parameters. 
-*/
-
-#define HEADER_VERSION 7
-
-/* lagformat for wapp_header */
-
-#define INTLAGS   0   /* 16 bit integers - searching only      */
-#define LONGLAGS  1   /* 32 bit integers - searching only      */
-#define FLOATLAGS 2   /* 32 bit float ACF/CCFs folding only    */
-#define FLOATSPEC 3   /* 32 bit float fftd ACFs folding only   */
-#define BYTELAGS  4   /* 8 bit integers ACF/CCF searching only */
-#define NIBBLAGS  5   /* 4 bit integers ACF/CCF searching only */
-#define FOLD32    8   /* bit mask with FLOATLAGS and FLOATSPEC */
-                      /* if on 32 bit folding is turned on     */
-
-struct WAPP_HEADER {
-
-    long header_version; /* some integer that increments with each revision */
-    long header_size;    /* size (in bytes) of this header (nom =1024) */
-    char obs_type[24];   /* what kind of observation is this */
-                         /* PULSAR_SEARCH */
-                         /* PULSAR_FOLDING */
-                         /* SPECTRA_TOTALPOWER */
-/* 
-    The following are obtained from current telescope status display
-    note that start AST/LST are for reference purposes only and should 
-    not be taken as accurate time stamps. The time stamp can be derived
-    from the obs_date/start_time variables further down in the structure.
-*/
-    double src_ra;       /* requested ra J2000 (10000*hr+100*min+sec) */
-    double src_dec;      /* requested dec J2000 (10000*deg+100*min+sec) */
-    double start_az;     /* telescope azimuth at start of scan (deg) */
-    double start_za;     /* telescope zenith angle at start of scan (deg) */
-    double start_ast;    /* AST at start of scan (sec) */
-    double start_lst;    /* local siderial time at start of scan (sec) */
-/*  
-    In the following, anything not supplied/requested by the user
-    is assumed to be calculated by WAPP when it writes the header
-*/
-    double cent_freq;    /* user-supplied band center frequency (MHz) */
-    double obs_time;     /* user-requested length of this integration (s) */
-    double samp_time;    /* user-requested sample time (us) */
-    double wapp_time;    /* actual sample time (us) i.e. requested+dead time */
-    double bandwidth;    /* total bandwidth (MHz) for this observation */
-
-    long num_lags;       /* user-requested number of lags per dump per spect */
-    long scan_number;    /* built by WAPP from year+daynumber+3-digit-number */
-
-    char src_name[24];   /* user-supplied source name (usually pulsar name) */
-    char obs_date[24];   /* built by WAPP from yyyymmdd */
-    char start_time[24]; /* UT seconds after midnight (start on 1-sec tick) */
-    char project_id[24]; /* user-supplied AO proposal number (XYYYY) */
-    char observers[24];  /* observer(s) name(s) */
-
-    int nifs;            /* user-requested: number of IFs to be recorded     */
-    int level;           /* user-requested: 1 means 3-level; 2 mean 9-level  */
-    int sum;             /* user-requested: 1 means that data is sum of IFs  */
-    int freqinversion;   /* 1 band is inverted, else band is not inverted    */
-    long long timeoff;   /* number of reads between obs start and snap block */
-    int lagformat;       /* 0=16 bit uint lags , 1=32 bit uint lags          */
-                         /* 2=32 bit float lags, 3=32 bit float spectra      */
-    int lagtrunc;        /* if we truncate data (0 no trunc)                 */
-                         /* for 16 bit lagmux modes, selects which 16 bits   */
-                         /* of the 32 are included as data                   */
-                         /* 0 is bits 15-0 1,16-1 2,17-2...7,22-7            */
-    int firstchannel;    /* 0 when correlator channel a is first, 1 if b     */
-    int nbins;           /* number of time bins for pulsar folding mode      */
-                         /* doulbles as maxrecs for snap mode                */
-    int isfolding;       /* is folding selected                              */
-    int isalfa;          /* is ALFA selected                                 */
-    double dumptime;     /* folded integrations for this period of time      */
-    double power_analog[2];   /* Power measured by Analog Detector           */
-/*    
-    In the following, pulsar-specific information is recorded for use 
-    by folding programs e.g. the quick-look software. This is passed to 
-    WAPP by psrcontrol at the start of the observation. 
-
-    The apparent pulse phase and frequency at time "dt" minutes with
-    respect to the start of the observation are then calculated as:
-
-    phase = rphase + dt*60*f0 + coeff[0] + dt*coeff[1] + dt*dt*coeff[2] + ...
-    freq(Hz) = f0 + (1/60)*(coeff[1] + 2*dt*coeff[2] + 3*dt*dt*coeff[3] + ...)
-
-    where the C notation has been used (i.e. coeff[0] is first coefficient etc)
-    for details, see TEMPO notes (http://www.naic.edu/~pulsar/docs/tempo.txt)
-*/
-    double psr_dm;         /* pulsar's dispersion measure (cm-3 pc) */
-    double rphase[16];      /* reference phase of pulse (0-1) */
-    double psr_f0[16];      /* pulse frequency at reference epoch (Hz) */
-    double poly_tmid[16];   /* mid point of polyco in (MJD) modified Julian date */     
-    double coeff[192];     /* polynomial coefs made by TEMPO, 16 sets of 12 */
-    int num_coeffs[16];     /* number of coefficients */
-    char hostname[24];    /* ascii hostname of machine that took this data */
-    int fold_bits;        /* 0 if 16 bits (old default) 1 if 32 bit folding */
-    int iflo_flip;        /* consider entire iflo and determine flip */
-    int attena;           /* first board parallel port value */
-    int attenb;           /* second board parallel port value */
-
-/* add iflo data */
-
-    double syn1;      /* upstairs synthesizer freq Hz */
-    double synfrq[4]; /* downstairs synthesizers (Hz) */
-
-
-    unsigned char shcl;    /* true if receiver shutter closed */
-    unsigned char sbshcl;   /* true if Sband receiver shutter closed */
-
-    unsigned char rfnum;     /* position of the receiver selectror */
-    unsigned char zmnormal;  /* transfer switch to reverse channels, true normal */
-    unsigned char rfattn[2];  /* attenuator position */
-    unsigned char ifnum;      /* if selector, 1/300 2/750, 3/1500, 4/10GHz1500, 5-thru */
-    unsigned char ifattn[2];  /* IF attenuator positions */
-    unsigned char fiber;      /* true fi fiber is chosen (always the case) */
-    unsigned char ac2sw;      /* ac power to various instruments and other stuff */
-    unsigned char if750nb;    /* narrow band 750 filter selected */
-
-    unsigned char phbsig;     /* converter combiner signal phase adjust */
-    unsigned char hybrid;     /* converter combiner hybrid  */
-    unsigned char phblo;      /* convert combiner lo phase adjust */
-
-/* downstairs */
-
-    unsigned char xfnormal;   /* transfer switch true if normal */
-    unsigned char noise;      /* noise on */
-    unsigned char gain[2];    /* gain of downstairs amps */
-    unsigned char inpfrq;     /* input distributor position */
-    unsigned char mixer[4];   /* mixer source switches */
-    unsigned char vlbainp;    /* vlba input switch position */
-    unsigned char ampinp[4];  /* amplifier input source switches */
-    unsigned char extinp[4];  /* external input selector switches */
-    unsigned char syndest[4]; /* synthesizer destinations */
-    unsigned char calsrc;     /* cal source bit */
-
-    unsigned char vis30mhz;   /* greg 1 ch 0 */
-    unsigned char pwrmet;     /* power meter input switch */
-    unsigned char blank430;   /* 430 blanking on */
-    unsigned char fill[7];    /* fill */
-};
-
diff --git a/filterbank-gmrt/older_wapp_header.h b/filterbank-gmrt/older_wapp_header.h
deleted file mode 100644
index 70013f8..0000000
--- a/filterbank-gmrt/older_wapp_header.h
+++ /dev/null
@@ -1,96 +0,0 @@
-
-/* 
-  RCS: $Id: wapp_header.h,v 1.5 2001/10/17 12:38:13 wapp Exp wapp $
-   wapp_head.h - header parameters for WAPP (Wideband Arecibo Pulsar Processor)
-   This structure (WAPP_HEADER) is based on the PSPM-style headers but has
-   been somewhat simplified to include just essential/relevant parameters. 
-*/
-
-#define HEADER_VERSION 4
-
-/* lagformat for wapp_header */
-
-#define INTLAGS   0   /* 16 bit integers - searching only    */
-#define LONGLAGS  1   /* 32 bit integers - searching only    */
-#define FLOATLAGS 2   /* 32 bit float ACF/CCFs folding only  */
-#define FLOATSPEC 3   /* 32 bit float fftd ACFs folding only */
-
-struct WAPP_HEADER {
-
-    long header_version; /* some integer that increments with each revision */
-    long header_size;    /* size (in bytes) of this header (nom =1024) */
-    char obs_type[24];   /* what kind of observation is this */
-                         /* PULSAR_SEARCH */
-                         /* PULSAR_FOLDING */
-                         /* SPECTRA_TOTALPOWER */
-/* 
-    The following are obtained from current telescope status display
-    note that start AST/LST are for reference purposes only and should 
-    not be taken as accurate time stamps. The time stamp can be derived
-    from the obs_date/start_time variables further down in the structure.
-*/
-    double src_ra;       /* requested ra J2000 (10000*hr+100*min+sec) */
-    double src_dec;      /* requested dec J2000 (10000*deg+100*min+sec) */
-    double start_az;     /* telescope azimuth at start of scan (deg) */
-    double start_za;     /* telescope zenith angle at start of scan (deg) */
-    double start_ast;    /* AST at start of scan (sec) */
-    double start_lst;    /* local siderial time at start of scan (sec) */
-/*  
-    In the following, anything not supplied/requested by the user
-    is assumed to be calculated by WAPP when it writes the header
-*/
-    double cent_freq;    /* user-supplied band center frequency (MHz) */
-    double obs_time;     /* user-requested length of this integration (s) */
-    double samp_time;    /* user-requested sample time (us) */
-    double wapp_time;    /* actual sample time (us) i.e. requested+dead time */
-    double bandwidth;    /* total bandwidth (MHz) for this observation */
-
-    long num_lags;       /* user-requested number of lags per dump per spect */
-    long scan_number;    /* built by WAPP from year+daynumber+3-digit-number */
-
-    char src_name[24];   /* user-supplied source name (usually pulsar name) */
-    char obs_date[24];   /* built by WAPP from yyyymmdd */
-    char start_time[24]; /* UT seconds after midnight (start on 1-sec tick) */
-    char project_id[24]; /* user-supplied AO proposal number (XYYYY) */
-    char observers[24];  /* observer(s) name(s) */
-
-    int nifs;            /* user-requested: number of IFs to be recorded     */
-    int level;           /* user-requested: 1 means 3-level; 2 mean 9-level  */
-    int sum;             /* user-requested: 1 means that data is sum of IFs  */
-    int freqinversion;   /* 1 band is inverted, else band is not inverted    */
-    long long timeoff;   /* number of reads between obs start and snap block */
-    int lagformat;       /* 0=16 bit uint lags , 1=32 bit uint lags          */
-                         /* 2=32 bit float lags, 3=32 bit float spectra      */
-    int lagtrunc;        /* if we truncate data (0 no trunc)                 */
-                         /* for 16 bit lagmux modes, selects which 16 bits   */
-                         /* of the 32 are included as data                   */
-                         /* 0 is bits 15-0 1,16-1 2,17-2...7,22-7            */
-    int firstchannel;    /* 0 when correlator channel a is first, 1 if b     */
-    int nbins;           /* number of time bins for pulsar folding mode      */
-                         /* doulbles as maxrecs for snap mode                */
-    double dumptime;     /* folded integrations for this period of time      */
-    double power_analog[2];   /* Power measured by Analog Detector           */
-/*    
-    In the following, pulsar-specific information is recorded for use 
-    by folding programs e.g. the quick-look software. This is passed to 
-    WAPP by psrcontrol at the start of the observation. 
-
-    The apparent pulse phase and frequency at time "dt" minutes with
-    respect to the start of the observation are then calculated as:
-
-    phase = rphase + dt*60*f0 + coeff[0] + dt*coeff[1] + dt*dt*coeff[2] + ...
-    freq(Hz) = f0 + (1/60)*(coeff[1] + 2*dt*coeff[2] + 3*dt*dt*coeff[3] + ...)
-
-    where the C notation has been used (i.e. coeff[0] is first coefficient etc)
-    for details, see TEMPO notes (http://www.naic.edu/~pulsar/docs/tempo.txt)
-*/
-    double psr_dm;         /* pulsar's dispersion measure (cm-3 pc) */
-    double rphase[16];      /* reference phase of pulse (0-1) */
-    double psr_f0[16];      /* pulse frequency at reference epoch (Hz) */
-    double poly_tmid[16];   /* mid point of polyco in (MJD) modified Julian date
- */     
-    double coeff[192];     /* polynomial coefs made by TEMPO, 16 sets of 12 */
-    int num_coeffs[16];     /* number of coefficients */
-
-     /* this pads out the header to 2048 bytes */
-};
diff --git a/filterbank-gmrt/ooty.h b/filterbank-gmrt/ooty.h
deleted file mode 100644
index 851bc99..0000000
--- a/filterbank-gmrt/ooty.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* ooty header file information */
-
-#define BUFSZ		(256*1024)
-#define TAPE_BLOCKS	8
-#define	TAPERECSZ	(BUFSZ/TAPE_BLOCKS)
-
-#define	HDRSZ		2048
-#define DATASZ		(BUFSZ - HDRSZ)
-#define NOBUFS		11
-
-struct dBuf {
-  int	seq, owner, id, t_first,t_last ;
-  char    project[32];
-  char    spare[12];
-  char    hdr[HDRSZ-64];
-  char    data[DATASZ];
-} ;
-        
-
diff --git a/filterbank-gmrt/ooty2fb.c b/filterbank-gmrt/ooty2fb.c
deleted file mode 100644
index 2f1d51c..0000000
--- a/filterbank-gmrt/ooty2fb.c
+++ /dev/null
@@ -1,54 +0,0 @@
-/* ooty2fb - converts OOTY search-mode data into "filterbank" data */
-#include "filterbank.h"
-#define BUFSZ 4096
-void ooty2fb(FILE *input, FILE *output) /* includefile */
-{
-  unsigned char *gulp;
-  float realtime,*sample,sum;
-  char string[80];
-  int offset,s,i,j,k,doit,idump=0,nread,opened=0;
-  gulp = (unsigned char *) malloc(BUFSZ * sizeof(unsigned char));
-  sample = (float *) malloc(8*BUFSZ * sizeof(float));
-  while ( (nread=fread(gulp,1,BUFSZ,input)) != 0) {
-    for (i=0; i<nread; i++) gulp[i] = ~ gulp[i];
-    realtime=tsamp*idump;
-    if ((doit=process(realtime,start_time,final_time))==-1) break;
-    if (doit) {
-      switch (obits) {
-      case 32:
-	for (s=0; s<nread/32; s++) {
-	  offset=s*32;
-	  k=0;
-	  sum=0.0;
-	  for (i=0; i<32; i++) {
-	    for (j=1;j<=8;j++) {
-	      sample[k]=gulp[offset+i]&1;
-	      gulp[offset+i]>>=1;
-	      if (swapout) swap_float(&sample[k]);
-	      k++;
-	    }
-	  }
-	  fwrite(sample,sizeof(float),256,output);
-	  idump++;
-	}
-	break;
-      case 1:
-	fwrite(gulp,1,nread,output);
-	idump+=nread/32;
-	break;
-      }
-
-      /* open up logfile if need be */
-      if (idump%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",realtime);
-	update_log(string);
-      }
-    }
-
-  }
-  free(gulp);free(sample);
-}
diff --git a/filterbank-gmrt/open_file.c b/filterbank-gmrt/open_file.c
deleted file mode 100644
index 7701221..0000000
--- a/filterbank-gmrt/open_file.c
+++ /dev/null
@@ -1,10 +0,0 @@
-#include <stdio.h>
-FILE *open_file(char *filename, char *descriptor) /* includefile */
-{
-  FILE *fopen(), *fptr;
-  if ((fptr=fopen(filename,descriptor)) == NULL) {
-    fprintf(stderr,"Error in opening file: %s\n",filename);
-    exit(1);
-  }
-  return fptr;
-}
diff --git a/filterbank-gmrt/open_files.c b/filterbank-gmrt/open_files.c
deleted file mode 100644
index 82f760a..0000000
--- a/filterbank-gmrt/open_files.c
+++ /dev/null
@@ -1,48 +0,0 @@
-#include <errno.h>
-#include <fcntl.h>
-#include <malloc.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include "pulse.h"
-
-int open_files(char scrdsk[])
-{
-
-  char *outfile;
-  FILE *fd;
-  char dir1[132];
-
-  strcpy(dir1,scrdsk);
-
-  strcat(dir1,"/best_tmp"); 
- 
-  outfile=(char *)malloc(200);
-  sprintf(outfile, dir1);
- 
-  /*
-    Open output files for writing.
-    */
-
-  if ( (fd=fopen(outfile, "w")) == NULL ) 
-    {
-      if ( fprintf(stderr, "File open failed in write_pulses for\n") == EOF )
-	exit( EOF );
-      if ( fprintf(stderr, "%s\n", outfile) == EOF ) exit( EOF );
-      return( EOF );
-    }
-
-  fclose(fd);
-
-  if ( (fd=fopen(outfile, "w")) == NULL )
-    {
-      if ( fprintf(stderr, "File open failed in write_pulses for\n") == EOF )
-        exit( EOF );
-      if ( fprintf(stderr, "%s\n", outfile) == EOF ) exit( EOF );
-      return( EOF );
-    }
-
-   fclose(fd);
-}
diff --git a/filterbank-gmrt/open_log.c b/filterbank-gmrt/open_log.c
deleted file mode 100644
index 14f1908..0000000
--- a/filterbank-gmrt/open_log.c
+++ /dev/null
@@ -1,17 +0,0 @@
-/* 
-   open_log.c - checks for monitor.running and enables logging if it exists 
-   global variable logging mode is switched off otherwise so that update_log
-   and close_log routines will not do anything if no logging is required.
-*/
-#include <stdio.h>
-#include "sigproc.h"
-FILE *logfile;
-int logging_mode;
-void open_log(char *filename) /*includefile*/
-{
-  if (file_exists("monitor.running")) 
-    logging_mode=1;
-  else
-    logging_mode=0;
-  if (logging_mode) logfile=open_file(filename,"w");
-}
diff --git a/filterbank-gmrt/pack_unpack.c b/filterbank-gmrt/pack_unpack.c
deleted file mode 100644
index 8d70eff..0000000
--- a/filterbank-gmrt/pack_unpack.c
+++ /dev/null
@@ -1,20 +0,0 @@
-/* 
-   pack two integers into a single char containing two 4-bit words 
-   first integer passed (i) takes the lower four bits of the char,
-   whilst the second integer passed (j) takes the higher four bits.
-*/
-unsigned char charof2ints (int i, int j) /* includefile */
-{
-  return ( (j<<4)+i );
-}
-/*
-  reverse operation of the above routine - recovers original packed
-  integers from within a character. i - low ; j - high as above.
-*/
-#define HI4BITS 240
-#define LO4BITS   15
-void char2ints (unsigned char c, int *i, int *j) /* includefile */
-{
-  *i =  c & LO4BITS;
-  *j = (c & HI4BITS) >> 4;
-}
diff --git a/filterbank-gmrt/peak.f b/filterbank-gmrt/peak.f
deleted file mode 100644
index 922612d..0000000
--- a/filterbank-gmrt/peak.f
+++ /dev/null
@@ -1,504 +0,0 @@
-c=============================================================================
-      program peak 
-c=============================================================================
-c
-c     A program to find giant pulses in a noisy time series.  
-c
-c     Created: 98/11/28 (dunc@naic.edu)
-c     
-c     Modification history:
-c
-c     05/11/14 - (dunc) ressurected for use within SIGPROC
-c
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-      include 'peak.inc'
-      integer i,llog                         ! lun for file in quiet mode
-      call peakin(llog)                      ! command line inputs
-      call timstart(llog)                    ! fire up the ship's clock
-      call readdat(llog,pzero)                     ! read in the time series
-      call baseline(llog)    ! normalise time series
-      do i=1,nloop
-      call findpeak(llog,i)                  ! find peaks above snrmin
-      if (pout.or.xout) call plotpeak(llog,i)! make summary plot if required
-      if (i.lt.nloop) call halve(series,ntim)! halve time resolution if repeat
-      tsamp=tsamp*2.0
-      enddo
-      call timfinis(llog)                    ! stop the clock
-      end
-c=============================================================================
-c==============================================================================
-      subroutine findpeak(llog,iloop)
-c==============================================================================
-      implicit none
-      include 'seek.inc'
-      include 'peak.inc'
-      integer llog,i,j,k,l,m,n,o,p,nstart,nfinis,last,iloop
-      real prfsnr,pulse(nbins),rav
-
-      write(llog,*) 'Searching for peaks...',tsamp,ntim
-      nfound=0
-      last=-8
-      l=ntim/nsave
-      m=0
-      n=0
-      rav=0.0
-      if (wepn) call system('rm -f peak.epn')
-      i=0
-      do while(i.lt.ntim)
-         i=i+1
-         if (pout.or.xout) then
-            m=m+1
-            rav=rav+series(i)
-            if (m.eq.l) then
-               n=n+1
-               smoothed(n)=rav/real(l)
-               m=0
-               rav=0.0
-            endif
-         endif
-         if (series(i).gt.snrmin.and.(i-last).gt.8) then
-            nfound=nfound+1
-            p=i
-            do o=i,i+8
-               if (series(o).gt.series(p)) then
-                  p=o
-               endif
-            enddo
-            i=p
-            if (nfound.le.nsave) then
-               pulidx(nfound)=i
-               pulsnr(nfound)=series(i)
-            endif
-            last=i
-            if (wepn) then
-               nstart=max(1,i-nbins/2)
-               nfinis=nstart+nbins-1
-               k=0
-               do j=nstart,nfinis
-                  k=k+1
-                  pulse(k)=series(j)
-               enddo
-               call writeepn(pulse,nbins,1.0,refdm,1.0,1.0,
-     &         tsamp,0.0,tsamp*real(i)*1.0e6,'peak.epn',prfsnr,' pulse')
-            endif
-         endif
-      enddo
-
-      write(llog,*) 'Found',nfound,' peaks with S/N >',snrmin
-      call glun(i)
-      if (iloop.gt.1) facc='append'
-      open(unit=i,file='peak.sum',status='unknown',access=facc)
-      write(i,*) refdm,int(tsamp*1.0e6),nfound,snrmin
-      close(unit=i)
-
-      end
-c==============================================================================
-c=============================================================================
-      subroutine plotpeak(llog,iloop) 
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-      include 'peak.inc'
-      integer llog,i,j,k,l,m,idx(nsave),lun,ndisp,iloop,t,lout
-      real xmin,xmax,ymin,ymax,rtsamp,const,delt,frac,dm(nsave)
-      logical lexist
-      character*80 rank,csnr,text,user*8,comment,pwd,line
-
-c      call system('rm -f pwd')
-c      call system('/usr/bin/pwd > pwd')
-c      open(unit=10,file='pwd',status='old')
-c      read(10,'(a)') pwd
-c      close(unit=10)
-c      call system('rm -f pwd')
-
-      call getenv('PWD',pwd)
-      comment='Comments: __________________________________'
-      ndisp=5
-      if (nfound.lt.1) return
-      if (ndisp.gt.nfound) ndisp=nfound
-      
-      rtsamp=real(tsamp)
-
-      if (nloop.eq.1) then
-         text='peak.ps/ps'
-      else
-         write(text,'(''peak'',i1,''.ps/ps'')') iloop
-      endif 
-      if (pout) then
-         call pgbegin(0,text,1,1)
-      else
-         call pgbegin(0,'/xs',1,1)
-      endif
-      call pgvport(0.1,0.9,0.1,0.25)
-      call pgscf(2)
-      xmin=rtsamp
-      xmax=real(ntim)*rtsamp
-
-
-      ymin=1.e32
-      ymax=-ymin
-c      do i=1,nsave
-c         ymin=min(ymin,smoothed(i))
-c         ymax=max(ymax,smoothed(i))
-c      enddo
-c      do i=1,ntim
-c         ymin=min(ymin,series(i))
-c         ymax=max(ymax,series(i))
-c      enddo
-	ymin=-1.5
-	ymax=+1.5
-      call pgwindow(xmin,xmax,ymin,ymax*1.1)
-      call pgbox('bcnst',0.0,0,'bc',0.0,0)
-      call pglabel('Time (s)',' ',' ')
-
-      const=rtsamp*real(ntim)/nsave
-      call pgmove(xmin,smoothed(1))
-      do i=2,nsave
-         call pgdraw(real(i)*const,smoothed(i))
-      enddo
-
-      call pgsls(2)
-      call pgmove(xmin,0.0)
-      call pgdraw(xmax,0.0)
-      call pgsls(1)
-
-      call pgvport(0.1,0.9,0.275,0.425)
-      ymin=1.e32
-      ymax=-ymin
-      do i=1,ntim
-         ymin=min(ymin,series(i))
-         ymax=max(ymax,series(i))
-      enddo
-      ymin=snrmin-2
-
-      call pgbox('bc',0.0,0,'bc',0.0,0)
-      call pgwindow(xmin,xmax,ymin,ymax*1.1)
-      const=rtsamp
-      call pgmove(xmin,series(1))
-      do i=2,ntim
-         call pgdraw(real(i)*const,series(i))
-      enddo
-
-      call pgsls(2)
-      call pgmove(xmin,snrmin)
-      call pgdraw(xmax,snrmin)
-      call pgsls(1)
-
-c      do i=1,nsave
-c         ymin=min(ymin,smoothed(i))
-c         ymax=max(ymax,smoothed(i))
-c      enddo
-c
-c      call pgwindow(xmin,xmax,ymin,ymax*1.1)
-c
-c      const=rtsamp*real(ntim)/nsave
-c      call pgmove(xmin,smoothed(1))
-c      do i=2,nsave
-c         call pgdraw(real(i)*const,smoothed(i))
-c      enddo
-
-      call pgsch(0.7)
-      if (nfound.gt.1) then
-         call indexx(nfound,pulsnr,idx)
-      else
-         idx(1)=1
-      endif
-      j=0
-      do i=nfound,nfound-(ndisp-1),-1
-         j=j+1
-         write(rank,'(a,i1,a)') '(',j,')'
-         call pgtext(real(pulidx(idx(i)))*rtsamp,pulsnr(idx(i)),rank)
-      enddo
-
-	call glun(lout)
-	open(lout,file="peak.out",status="unknown")
-      do i=nfound,1,-1
-         write(lout,*) real(pulidx(idx(i)))*rtsamp+skp,pulsnr(idx(i))
-      enddo
-	close(lout)
-
-      call pgsch(0.6)
-      j=0
-      delt=0.8/real(ndisp)
-      do i=nfound,nfound-(ndisp-1),-1
-         j=j+1
-         call pgvport(0.1+delt*real(j-1),0.1+delt*real(j),0.45,0.6)
-         call pgwindow(0.0,1.0,0.0,1.0)
-         call pgbox('bc',0.0,0,'bc',0.0,0)
-         write(rank,'(a,i1,a)') '(',j,')'
-         call pgtext(0.05,0.9,rank)
-         write(csnr,'(a,f4.1)') 'S/N = ',pulsnr(idx(i))
-         call pgtext(0.2,0.9,csnr)
-         k=max(1,pulidx(idx(i))-nbins/2)
-         if (j.eq.1) then
-            xmin=1.0
-            xmax=real(nbins)
-            ymin=1.e32
-            ymax=-ymin
-            do l=k,k+nbins-1
-               ymin=min(ymin,series(l))
-               ymax=max(ymax,series(l))
-            enddo
-         endif
-         call pgwindow(xmin,xmax,ymin,ymax*1.15)
-         call pgmove(xmin,series(k))
-         m=1
-         do l=k+1,k+nbins-1
-            m=m+1
-            call pgdraw(real(m),series(l))
-         enddo
-         call pgsls(2)
-         call pgmove(xmin,0.0)
-         call pgdraw(xmax,0.0)
-         call pgsls(1)
-
-         
-      enddo
-
-      call pgvport(0.6,0.9,0.675,0.9)
-      inquire(file='pkdm.sum',exist=lexist)
-      
-      if (lexist) then
-         call glun(lun)
-         open(unit=lun,file='pkdm.sum',status='old')
-         xmin=1.e32
-         xmax=-xmin
-         ymin=1.e32
-         ymax=-ymin
-         t=nint(tsamp*1.0e6)
-         do i=1,nsave
-            read(lun,'(a)',end=1) line
-            if (iloop.eq.1) read(line,*) dm(i),idx(i)
-            if (iloop.eq.2) read(line,*) dm(i),j,idx(i)
-            if (iloop.eq.3) read(line,*) dm(i),j,j,idx(i)
-            if (iloop.eq.4) read(line,*) dm(i),j,j,j,idx(i)
-            if (iloop.eq.5) read(line,*) dm(i),j,j,j,j,idx(i)
-            xmin=min(xmin,dm(i))
-            xmax=max(xmax,dm(i))
-            ymin=min(ymin,real(idx(i)))
-            ymax=max(ymax,real(idx(i)))
-         enddo
- 1       j=i-1
-         close(unit=lun)
-         call pgwindow(xmin,xmax,ymin,ymax*1.1)
-         call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-         call pglabel('DM (cm\\u-3\\d pc)','N\\dTOT\\u',' ')
-         call pgmove(dm(1),real(idx(1)))
-         call pgpoint(1,dm(1),real(idx(1)),17)
-         do i=2,j
-            call pgdraw(dm(i),real(idx(i)))
-            call pgpoint(1,dm(i),real(idx(i)),17)
-         enddo
-      else
-         ymin=0.0
-         ymax=1.1
-         xmin=snrmin
-         xmax=pulsnr(idx(nfound))
-         call pgwindow(xmin*0.9,xmax*1.1,ymin,ymax)
-         call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-         call pglabel('S/N of detected pulse','N(>S/N)/N\\dTOT\\u',' ')
-         call pgsls(2)
-         call pgmove(snrmin,ymin)
-         call pgdraw(snrmin,ymax)
-         call pgsls(1)
-         k=nfound
-         do i=1,nfound
-            frac=real(k)/real(nfound)
-            call pgpoint(1,pulsnr(idx(i)),frac,17)
-            k=k-1
-         enddo
-      endif
-c
-c     Header info...
-c
-      call pgvport(0.1,0.5,0.5,0.9)
-      call pgwindow(0.0,1.0,0.0,1.0)
-c      call pgscf(4)
-      call pgsch(1.5)
-      call pgtext(0.0,0.9,'PEAK... Single Pulse Search')
-      call pgsch(0.8)
-      call pgscf(2)
-c      call pgtext(0.0,0.8,'File: '//filename(1:lst+1))
-      call pgtext(0.0,0.8,'File: '//pwd)
-      write(text,'(a,i4,6x,a,f6.1,a)')
-     &    'N\\dTOT\\u: ',nfound,
-     &    'DM: ',refdm,' cm\\u-3\\d pc'
-      call pgtext(0.0,0.7,text)
-
-      text=' '
-      call gruser(user,l)
-      call grdate(text,m)
-
-      call pgtext(0.0,0.5,comment)
-      call pgscf(3)
-      call pgtext(0.0,0.35,'Hunter ID: '//user//' Date:  '//text)
-
-      call pgend
-      
-      end 
-c=============================================================================
-
-
-      subroutine halve(data,npts)
-      implicit none
-      real data(*)
-      integer i,j,npts
-      real sum
-      sum=0.0
-      j=0
-      do i=1,npts
-         sum=sum+data(i)
-         if (mod(i,2).eq.0) then
-	    j=j+1
-            data(j)=sum/2.0
-            sum=0.0
-         endif
-      enddo
-      npts=npts/2
-      end
-C from numerical recipes
-      SUBROUTINE INDEXX(N,ARRIN,INDX)
-      DIMENSION ARRIN(N),INDX(N)
-      if (n.eq.1) then
-	indx(1)=1
-        return
-      endif
-      DO 11 J=1,N
-         INDX(J)=J
- 11   CONTINUE
-      L=N/2+1
-      IR=N
- 10   CONTINUE
-      IF(L.GT.1)THEN
-         L=L-1
-         INDXT=INDX(L)
-         Q=ARRIN(INDXT)
-      ELSE
-         INDXT=INDX(IR)
-         Q=ARRIN(INDXT)
-         INDX(IR)=INDX(1)
-         IR=IR-1
-         IF(IR.EQ.1)THEN
-            INDX(1)=INDXT
-            RETURN
-         ENDIF
-      ENDIF
-      I=L
-      J=L+L
- 20   IF(J.LE.IR)THEN
-         IF(J.LT.IR)THEN
-            IF(ARRIN(INDX(J)).LT.ARRIN(INDX(J+1)))J=J+1
-         ENDIF
-         IF(Q.LT.ARRIN(INDX(J)))THEN
-            INDX(I)=INDX(J)
-            I=J
-            J=J+J
-         ELSE
-            J=IR+1
-         ENDIF
-         GO TO 20
-      ENDIF
-      INDX(I)=INDXT
-      GO TO 10
-	write(*,*) 'hello there'
-      END
-c=============================================================================
-      subroutine peakin(llog) 
-c=============================================================================
-c
-c   Controls the command-line inputs to peak
-c
-      implicit none
-      include 'seek.inc'
-      include 'peak.inc'
-      integer narg,iargc,i,llog,p2
-      character*80 option
-
-      llog=6
-      wepn=.false.
-      pout=.false.
-      xout=.false.
-      snrmin=5.0
-      nloop=1
-      rfac=1
-      tsize=19
-      p2=nint(log10(real(npts))/log10(2.0))
-      dmidx=-1
-      facc='sequential'
-      skp=0
-
-      narg=iargc()
- 1    format(a)
-      if (narg.lt.1) then
-         write(*,*)
-         write(*,1)'peak - searches for giant pulses in time series'
-         write(*,*)
-         write(*,1)'usage: peak <INFILE> -{options}'
-         write(*,*)
-         write(*,1)'The input file may be a time series, or a set of'
-         write(*,1)'set of filterbank channels. The file suffix MUST,'
-         write(*,1)'however, be either ".tim", ".ser" or ".dis".'
-         write(*,*)
-         write(*,1)'options:'
-         write(*,*)
-         write(*,1)'-A: append output ASCII files if already exist'
-         write(*,1)'-q: quiet mode - all standard messages > peak.log'
-         write(*,1)'-e: write an EPN file "peak.epn" with the pulses'
-         write(*,1)'-p: write a PostScript plot summarising the search'
-         write(*,1)'-X: write an X-display plot summarising the search'
-         write(*,*)
-         write(*,1)'-l[loop]: analysis loop times, doubling tsamp'
-         write(*,1)'-s[smin]: set S/N threshold to smin (def=5.0)'
-         write(*,1)'-t[tlen]: fix time series length to 2**tlen points'
-         write(*,1)'-i[tsec]: ignore tsec seconds of data on reading'
-         write(*,*)
-         stop
-      endif
-
-      call getarg(1,filename)
-      
-      if (index(filename,'.ser').gt.0) then
-         lst=index(filename,'.ser')-1
-      else if (index(filename,'.tim').gt.0) then
-         lst=index(filename,'.tim')-1
-      else if (index(filename,'.dis').gt.0) then
-         lst=index(filename,'.dis')-1
-         dmidx=1
-      else
-         stop 'file type not recognized! Type peak for help.'
-      endif
-      
-      do i=2,narg
-        call getarg(i,option)
-        if (index(option,'-s').gt.0) then
-          read(option(3:),*) snrmin
-        else if (index(option,'-t').gt.0) then
-           read(option(3:),*) tsize
-        else if (index(option,'-i').gt.0) then
-          read(option(3:),*) skp
-        else if (index(option,'-l').gt.0) then
-          read(option(3:),*) nloop
-        else if (index(option,'-q').gt.0) then
-          call glun(llog)
-        else if (index(option,'-e').gt.0) then
-          wepn=.true.
-        else if (index(option,'-p').gt.0) then
-          pout=.true.
-        else if (index(option,'-X').gt.0) then
-          xout=.true.
-        else if (index(option,'-A').gt.0) then
-          facc='append'
-        else
-          write(*,*) 'WARNING.. command line option ',
-     &    option(1:index(option,' ')-1),' not recognized!!!'
-        endif
-      enddo
-      
-      if (llog.ne.6) open(unit=llog,file='peak.log',status='unknown',
-     &    access=facc)
-      write(llog,*)
-      write(llog,*) 'PEAK: ',version
-      end 
-c=============================================================================
diff --git a/filterbank-gmrt/peak.inc b/filterbank-gmrt/peak.inc
deleted file mode 100644
index 2a6762b..0000000
--- a/filterbank-gmrt/peak.inc
+++ /dev/null
@@ -1,22 +0,0 @@
-	logical wepn
-	common /wrepn/ wepn
-
-	real snrmin
-	common /snrth/ snrmin
-
-	logical pout,xout
-	common /psout/ pout,xout
-
-	integer nsave
-	parameter(nsave=1024)
-	real smoothed
-	common /smser/ smoothed(nsave)
-
-	integer pulidx,nfound,nloop
-	real    pulsnr
-	common /pulse/ nloop,nfound,pulidx(nsave),pulsnr(nsave)
-
-	integer nbins
-	parameter(nbins=128)
-
-	logical pzero
diff --git a/filterbank-gmrt/pgplotter.c b/filterbank-gmrt/pgplotter.c
deleted file mode 100644
index db9e7a6..0000000
--- a/filterbank-gmrt/pgplotter.c
+++ /dev/null
@@ -1,86 +0,0 @@
-/* 
-   pgplotter - a simple tool to plot SIGPROC streamed output with PGPLOT
-   now included as part of sigproc-3.0 onwards (14-Jan-2005 - drl@jb.man.ac.uk)
-
-   usage: fold ..... -stream | pgplotter
-*/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include "cpgplot.h"
-#include "sigproc.h"
-
-int verbose=0;
-int maxpts=4096;
-int get_stream(float *x, float *y) 
-{
-  float a,b;
-  int i,stream;
-  char line[80], key[80];
-
-  strcpy(line,"");
-  i=stream=0;
-  while (1) {
-    fgets(line,80,stdin);
-    sscanf(line,"%s",key);
-    if (!strcmp(key,"#DONE")) return(0);
-    if (!strcmp(key,"#STOP")) return(i);
-    if (stream) {
-      if (i >= maxpts) {
-	maxpts+=4096;
-	x = (float *) realloc(x,maxpts * sizeof(float));
-	y = (float *) realloc(y,maxpts * sizeof(float));
-      }
-      sscanf(line,"%f %f",&x[i],&y[i]);
-      i++;
-    }
-    if (!strcmp(key,"#START")) stream=1;
-  }
-}
-void minmax(float *data, int npts, float *datamin, float *datamax)
-{ 
-  int i; 
-  *datamin=data[0];
-  *datamax=data[0];
-  for (i=1; i<npts; i++) {
-    *datamin = (data[i] < *datamin) ? data[i] : *datamin;
-    *datamax = (data[i] > *datamax) ? data[i] : *datamax;
-  }
-}
-main(int argc, char *argv[])
-{
-  float *x, *y, xmin, xmax, ymin, ymax;
-  int i,npts,nx,ny;
-  char device[80];
-
-  x = (float *) malloc(maxpts * sizeof(float));
-  y = (float *) malloc(maxpts * sizeof(float));
-  xmin=xmax=ymin=ymax=0.0;
-  nx=ny=1;
-
-  if (argc>2) print_version(argv[0],argv[1]);
-
-  strcpy(device,"/xs");
-
-  if (argc>1) nx=atoi(argv[1]);
-  if (argc>2) ny=atoi(argv[2]);
-  if (argc>3) strcpy(device,argv[3]);
-
-  cpgbeg(0,device,nx,ny);
-  cpgsvp(0.15,0.85,0.15,0.85);
-  cpgsch(1.5);
-  cpgscf(2);
-  while (npts=get_stream(x,y)) {
-    if (verbose) printf("read %d points... (max %d)\n",npts,maxpts);
-    minmax(x,npts,&xmin,&xmax);
-    minmax(y,npts,&ymin,&ymax);
-    if (verbose) printf("xmin %f xmax %f ymin %f ymax %f\n",xmin,xmax,ymin,ymax);
-    cpgask(0);
-    cpgpage();
-    cpgswin(xmin,xmax,ymin,ymax);	
-    cpgbox("bcnst",0.0,0,"bcnst",0.0,0);
-    cpgline(npts,x,y);
-  }
-  cpgend();
-}
diff --git a/filterbank-gmrt/phcalc.c b/filterbank-gmrt/phcalc.c
deleted file mode 100644
index 1eccf38..0000000
--- a/filterbank-gmrt/phcalc.c
+++ /dev/null
@@ -1,64 +0,0 @@
-#include <math.h>
-#include <stdio.h>
-
-/*  Compute pulsar phase and frequency at time mjd0+mjd1/86400.  
-    Note that it would really be better to save the polyco MJDs 
-    as two doubles. */
-
-/* Hardwiring max sets of coefficients to 16 - this may need to change. */
-/* Hardwiring max coefficients to 12 - this may need to change. */
-
-#define MAXSETS 16
-#define MAXCOEFF 12
-
-void phcalc(double mjd0,double mjd1,double *phase,double *psrfreq,double *rphase,double *psr_f0,double *poly_tmid,double *coeff,int *num_coeff) /*includefile*/
-{
-  double dtmin,mjd;
-  int i,j;
-  int show;
-  double nblk;
-  static int icurr;
-
-  show = 0;
-
-  nblk = (poly_tmid[1]-poly_tmid[0])*1440.;
-  mjd = mjd0+mjd1/86400.;
-
-  icurr = -1;
-  *psrfreq = psr_f0[0];                     /* Default psrfreq */
-  for (j=0;j<MAXSETS;j++) {
-    dtmin = (mjd-poly_tmid[j])*1440.;  /* Time from center of this set*/
-    if (fabs(dtmin) <= nblk/2.) {
-      if(show) {
-	printf("Set %1d, %1d coeffs works: %f %f\n",j,num_coeff[j],poly_tmid[j],poly_tmid[j+1]);
-	for(i=0;i<num_coeff[j];i++) 
-	  printf("%1d %e\n",i,coeff[j*num_coeff[j]+i]);
-      }
-      *psrfreq = 0.;                    /* Compute psrfreq and phase from */
-      *phase = coeff[j*num_coeff[j]+num_coeff[j]-1];      /* the polynomial coeffs. */
-      if (show) printf("phase = %21.15e   :%21.15e\n",*phase,coeff[j*num_coeff[j]+num_coeff[j]-1]);  
-      for(i=num_coeff[j]-1;i>0;--i) {
-        *psrfreq = dtmin*(*psrfreq) + i*coeff[j*num_coeff[j]+i];
-        *phase = dtmin*(*phase) + coeff[j*num_coeff[j]+i-1];
-	if (show) printf("phase = %21.15e   :%21.15e\n",*phase,coeff[j*num_coeff[j]+i-1]); 
-      }
-
-      *psrfreq = psr_f0[j] + *psrfreq/60.;  /* Add in the DC terms and scale */
-      *phase += rphase[j]+dtmin*60.*psr_f0[j];
-      if (show) printf("phase = %21.15e   f0: %21.15e\n",*phase,psr_f0[j]);
-      *phase -= floor(*phase);
-      if ((*phase < 0.) || (*phase > 1.))
-        { printf("phase = %21.15f\n",*phase); exit(1); }
-      icurr = j;
-      break;
-    }
-  }
-  if (icurr == -1) {
-    printf("MJD %9.3f out of range (%9.3f to %9.3f)\n",
-         (mjd),poly_tmid[0]-nblk/2880.,poly_tmid[MAXSETS-1]+nblk/2880.);
-    *phase = -999.;
-    printf("isets = %d\n",MAXSETS);
-    exit(1);
-  }
-
-}
diff --git a/filterbank-gmrt/plotpulses.f b/filterbank-gmrt/plotpulses.f
deleted file mode 100644
index 9041c70..0000000
--- a/filterbank-gmrt/plotpulses.f
+++ /dev/null
@@ -1,149 +0,0 @@
-c==============================================================================
-      program plotpulses
-c==============================================================================
-      implicit none
-      character*80 stem,line,pgdev
-      integer lun,lst,npulses,width,idx,fft,maxp,i,narg,sym,
-     &	      nsnbins,ndms,maxdmhist
-      parameter(maxp=100000000)
-      real tsamp,dm(maxp),sn(maxp),mindm,maxdm,minsn,maxsn,mints,maxts,
-     &     time(maxp),thresh,snmid(10000),maxsnhist,snhist(10000),
-     &     maxdmhst,dmhist(10000),dmval(10000),peakdm
-c==============================================================================
-      narg=iargc()
-      if (narg.lt.1) then
-	 write(*,*)
-	 write(*,*) 'plotpulses - PGPLOT results of single pulse search'
-	 write(*,*)
-         write(*,*) 'usage: plotpulses filestem -s snmin -p pgdev'
-	 write(*,*)
-	 write(*,*) 'snmin - minimum s/n to display (def=5)'
-	 write(*,*) 'pgdev - pgplot device (def=/xs)'
-	 write(*,*)
-         stop
-      endif
-      call getarg(1,stem)
-      lst=index(stem,' ')-1
-      minsn=5
-      pgdev='/xs'
-      if (narg.gt.1) then	
-         i=2
-	 do while (i.le.narg)
-           call getarg(i,line)
-	   if (line.eq.'-s') then
-		i=i+1
-                call getarg(i,line)
-                read(line,*) minsn
-	   elseif (line.eq.'-p') then
-		i=i+1
-                call getarg(i,pgdev)
-	   endif
-	   i=i+1
-  	 enddo 
-      endif
-      i=0
-      lun=20
-      mints=1.0e32
-      maxts=-1.0e32
-      mindm=1.0e32
-      maxdm=-1.0e32
-      maxsn=0.0
-c==============================================================================
-      open(lun,file=stem(1:lst)//'.pls',status='unknown')
-      read(lun,'(a)') line
-      read(line(7:),*) tsamp
-      read(line(24:),*) thresh
-      do while(.true.)
-         i=i+1
-         read(lun,*,err=1,end=1) dm(i),width,idx,sn(i),fft
-         time(i)=idx*tsamp/1.0e6
-         mints=min(time(i),mints)
-         maxts=max(time(i),maxts)
-         mindm=min(dm(i),mindm)
-         maxdm=max(dm(i),maxdm)
-         maxsn=max(sn(i),maxsn)
-	 snhist(sn(i)-thresh)=snhist(sn(i)-thresh)+1
-      enddo
- 1    close(lun)
-      
-      npulses=i-1
-      nsnbins = maxsn-thresh
-      maxsnhist = 0
-      do i = 1, nsnbins
-         snmid(i) = thresh+(i-1)+0.5
-         if (snhist(i).ne.0) then
-            snhist(i) = log10(snhist(i))
-         else
-            snhist(i) =-0.5
-         endif
-	 if (snhist(i).gt.maxsnhist) maxsnhist = snhist(i)
-      end do
-
-      open(lun,file=stem(1:lst)//'.hst',status='unknown')
-
-      i = 0
-      do while(.true.)
-      i=i+1
-      read (lun,*,err=1,end=2) dmval(i), dmhist(i)
-      enddo
- 2    close(lun)
-
-      ndms = i-1
-      maxdmhist = 0
-      do i = 1, ndms
-         if (dmhist(i).gt.maxdmhist) then
-	     maxdmhist = dmhist(i)
-	     peakdm = dmval(i)
-	 endif
-      end do
-      write(line,100) npulses,maxsn,peakdm
- 100  format(i8,' events. max S/N =',f5.1,'. peak DM =',f7.1,
-     &       ' (cm\\u-3\\d pc)')
-c==============================================================================
-      call pgbegin(0,pgdev,1,1)
-      call pgscf(2)
-      call pgswin(0.0,1.0,0.0,1.0)
-      call pgtext(-0.02,1.0,'Results for '//stem(1:lst)
-     &      //' '//line)
-      call pgsvp(0.06, 0.31, 0.6, 0.87)
-      call pgswin(thresh,maxsn,log10(0.5),1.1*maxsnhist)
-      call pgsch(0.8)
-      call pgbox('bcnst',0.0,0,'bclnst',0.0,0)
-      call pgmtxt('B', 2.5, 0.5, 0.5, 'Signal-to-Noise')
-      call pgmtxt('L', 1.8, 0.5, 0.5, 'Number of Pulses')
-      call pgsch(1.0)
-      call pgbin(nsnbins,snmid,snhist,1)
-      call pgsvp(0.39, 0.64, 0.6, 0.87)
-      call pgswin(mindm-0.5,maxdm+0.5,0.0,1.1*maxdmhist)
-      call pgsch(0.8)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgmtxt('B', 2.5, 0.5, 0.5, 'DM (cm\\u-3\\d pc)')
-      call pgmtxt('L', 1.8, 0.5, 0.5, 'Number of Pulses')
-      call pgsch(1.0)
-      call pgbin(ndms,dmval,dmhist,1)
-      call pgsvp(0.72, 0.97, 0.6, 0.87)
-      call pgswin(mindm-0.5,maxdm+0.5,minsn,maxsn)
-      call pgsch(0.8)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgmtxt('B', 2.5, 0.5, 0.5, 'DM (cm\\u-3\\d pc)')
-      call pgmtxt('L', 1.8, 0.5, 0.5, 'Signal-to-Noise')
-      call pgpt(npulses,dm,sn,20)
-      call pgsvp(0.06, 0.97, 0.08, 0.52)
-      call pgswin(mints,maxts,mindm,maxdm)
-      call pgsch(0.8)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgmtxt('B',2.5,0.5,0.5,'Time (s)')
-      call pgmtxt('L',1.8,0.5,0.5,'DM (cm\\u-3\\d pc)')
-      do i=1,npulses
-         sym=20
-         if (sn(i).gt.5) sym=21
-         if (sn(i).gt.7) sym=22
-         if (sn(i).gt.9) sym=23
-         if (sn(i).gt.10) sym=24
-	 sym = (sn(i)-minsn)*0.5+20+0.5
-	 if (sym.gt.25) sym = 25
-         if (sn(i).gt.minsn) call pgpt1(time(i),dm(i),sym)
-      enddo
-      call pgend
-      end
-c==============================================================================
diff --git a/filterbank-gmrt/plotpulses.old.f b/filterbank-gmrt/plotpulses.old.f
deleted file mode 100644
index 80b1664..0000000
--- a/filterbank-gmrt/plotpulses.old.f
+++ /dev/null
@@ -1,63 +0,0 @@
-c==============================================================================
-      program plotpulses
-c==============================================================================
-      implicit none
-      character*80 stem,line
-      integer lun,lst,npulses,width,idx,fft,maxp,i,narg,sym
-      parameter(maxp=1000000)
-      real tsamp,dm(maxp),sn(maxp),mindm,maxdm,minsn,maxsn,mints,maxts,
-     &     time(maxp)
-c==============================================================================
-      narg=iargc()
-      if (narg.lt.2) then
-         write(*,*) 'usage: plotpulses filestem minsn'
-         stop
-      endif
-      call getarg(1,stem)
-      lst=index(stem,' ')-1
-      call getarg(2,line)
-      read(line,*) minsn
-      i=0
-      lun=20
-      mints=1.0e32
-      maxts=-1.0e32
-      mindm=1.0e32
-      maxdm=-1.0e32
-      maxsn=0.0
-c==============================================================================
-      open(lun,file=stem(1:lst)//'.pls',status='unknown')
-      read(lun,'(a)') line
-      read(line(7:),*) tsamp
-      do while(.true.)
-         i=i+1
-         read(lun,*,err=1,end=1) dm(i),width,idx,sn(i),fft
-         time(i)=idx*tsamp/1.0e6
-         mints=min(time(i),mints)
-         maxts=max(time(i),maxts)
-         mindm=min(dm(i),mindm)
-         maxdm=max(dm(i),maxdm)
-         maxsn=max(sn(i),maxsn)
-      enddo
- 1    close(lun)
-      
-      npulses=i-1
-      write(*,*) npulses,' events, DM range:',mindm,' ->',maxdm,
-     &           ' pc/cc .... max S/N',maxsn
-c==============================================================================
-      call pgbegin(0,'?',1,1)
-      call pgscf(2)
-      call pgswin(mints,maxts,mindm,maxdm)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pglab('Time (s)','DM (cm\\u-3\\d pc)',
-     &           'Single pulse plane for '//stem)
-      do i=1,npulses
-         sym=20
-         if (sn(i).gt.5) sym=21
-         if (sn(i).gt.7) sym=22
-         if (sn(i).gt.9) sym=23
-         if (sn(i).gt.10) sym=17
-         if (sn(i).gt.minsn) call pgpt1(time(i),dm(i),sym)
-      enddo
-      call pgend
-      end
-c==============================================================================
diff --git a/filterbank-gmrt/polyco.h b/filterbank-gmrt/polyco.h
deleted file mode 100644
index d04c988..0000000
--- a/filterbank-gmrt/polyco.h
+++ /dev/null
@@ -1,16 +0,0 @@
-struct POLYCO {
-  char psrname[80];
-  char date[80];
-  double utc;
-  double tmid;
-  double dm;
-  double doppler;
-  double lfrms;
-  double rphase;
-  double f0;
-  double fobs;
-  int span;
-  int obsno;
-  int nc;
-  double *coeff;
-} ;
diff --git a/filterbank-gmrt/polyco.tcl b/filterbank-gmrt/polyco.tcl
deleted file mode 100755
index 8d31ad7..0000000
--- a/filterbank-gmrt/polyco.tcl
+++ /dev/null
@@ -1,166 +0,0 @@
-###############################################################################
-# POLYCO: A Tcl script to generate a polyco.dat file by running TEMPO
-# Modification history...
-# 02/01/30 - changed to tcl script rather than expect (not always available)
-# 05/06/24 - added par option and strip of J in front of psrname if need be
-###############################################################################
-set timeout -1
-
-if { ! [ info exists env(TEMPO) ] } {
-  set env(TEMPO) /home/pulsar/tempo11
-}
-
-proc help {} {
-    global freq nspan ncoeff maxha site
-    puts ""
-    puts "polyco - a script to run TEMPO to generate a polyco.dat file"
-    puts ""
-    puts "usage: polyco psrname -{options}"
-    puts ""
-    puts "psrname   - name of the pulsar as it appears in tztot.dat"
-    puts ""
-    puts "-freq   f - frequency in MHz (def=$freq MHz)"
-    puts "-nspan  n - span of each polyco set in minutes (def=$nspan min)"
-    puts "-ncoeff n - number of coefficients in each polyco set (def=$ncoeff)"
-    puts "-maxha  h - maximum hour angle (def=$maxha hours)"
-    puts "-mjd    m - mjd to calculate for (def=today)"
-    puts "-mjds   s - starting mjd (def=today)"
-    puts "-mjdf   f - finishing mjd (def=today)"
-    puts "-par    p - specify parfile (def=tzpar area)"
-    puts "-site   s - specify site code or alias (def=$site)"
-    puts ""
-}
-set value 0
-set freq 1410
-set nspan 15
-set ncoeff 9
-set maxha 2
-set site Arecibo
-set par ""
-if {$argv == "" || $argv == "help"} {
-    help
-    exit
-}
-set psrname [string trimleft [lindex $argv 0] J]
-set mjds [set mjdf ""]
-foreach item [lrange $argv 1 end] {
-    if {!$value} {
-	set item [string range $item 1 end]
-	switch $item {
-	    freq     -
-	    nspan    -
-	    ncoeff   -
-	    maxha    -
-	    mjd      -
-	    mjds     -
-	    site     -
-	    par      -
-	    mjdf     {set value 1; set key $item}
-	    default  {help;puts "invalid key $item";exit}
-	}	
-    } else {
-	switch $key {
-	    freq      {set freq $item}
-	    nspan     {set nspan $item}
-	    ncoeff    {set ncoeff $item}
-	    maxha     {set maxha $item}
-	    mjds      {set mjds $item}
-	    mjdf      {set mjdf $item}
-	    site      {set site $item}
-	    par       {if [file exists $item] {set par  "-f $item"} else {puts "parameter file $item not found";exit}}
-	    mjd       {set mjds [expr $item-1]; set mjdf [expr $item+1]}
-	}
-	set value 0
-    }
-}
-if {$mjds != "" && $mjdf == ""} {set mjdf $mjds}
-if {$mjdf != "" && $mjds == ""} {set mjds $mjdf}
-switch [string tolower $site] {
-    gb -
-    gbt -
-    1 {set site 1}
-    quabbin -
-    2 {set site 2}
-    ao - 
-    arecibo -
-    3 {set site 3}
-    hobart -
-    4 {set site 4}
-    princeton -
-    5 {set site 5}
-    vla -
-    6 {set site 6}
-    parkes -
-    7 {set site 7}
-    lovell -
-    jodrell -
-    jb -
-    8 {set site 8}
-    torun -
-    torun32m -
-    9 {set site 9}
-    gb140ft -
-    a {set site a}
-    gb85ft -
-    b {set site b}
-    vlasite -
-    c {set site c}
-    bologna -
-    d {set site d}
-    most -
-    e {set site e}
-    nancay -
-    f {set site f}
-    effelsberg -
-    g {set site g}
-    kalyazin -
-    h {set site h}
-    fallbrook - 
-    i {set site i}
-    default {
-	help
-	puts "ERROR: site $site unknown!"
-	set obsysfile $env(TEMPO)/obsys.dat
-	if [file exists $obsysfile] {
-	    puts "consult $obsysfile"
-	}
-	exit
-    }
-}
-set file [open polyco.dat w]
-close $file
-set file [open tz.in w]
-puts $file "$site    2   30   9  1410" 
-puts $file ""
-puts $file ""
-puts $file "$psrname $nspan $ncoeff $maxha $freq"
-close $file
-set file [open tempo.old w]
-puts $file  "#!/bin/csh"
-puts $file  "tempo -z $par << END" 
-puts $file  "$mjds $mjdf"      
-puts $file  "END"      
-close $file
-exec chmod +x tempo.old
-catch {exec ./tempo.old}
-if ![file size polyco.dat] {
-    set file [open tempo.new w]
-    puts $file  "#!/bin/csh"
-    puts $file  "tempo -z << END" 
-    puts $file  "$mjds $mjdf"      
-    puts $file  "END"      
-    close $file
-    exec chmod +x tempo.new
-    catch {exec ./tempo.new}
-    if ![file size polyco.dat] {
-	puts "Error running TEMPO!"
-	puts "check files tz.in tempo.old tempo.new..."
-	exit
-    } else {
-	exec rm -f tempo.new
-    }
-}
-puts "TEMPO appears to have run successfully..."
-puts [exec ls -l polyco.dat]
-exec rm -f tz.in tempo.old
-exit
diff --git a/filterbank-gmrt/polyco2period.c b/filterbank-gmrt/polyco2period.c
deleted file mode 100644
index e4c3883..0000000
--- a/filterbank-gmrt/polyco2period.c
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-  polyco2period-calculates period for MJD specified on command line 
-*/
-#include "fold.h"
-#include <math.h>
-
-void polyco2period_help()
-{
-  puts("");
-  puts("polyco2period: returns period (sec) given mjd and polyco file");
-  puts("        usage: polyco2period mjd [-p polyco file name]\n");
-  puts("");
-}
-
-main (int argc, char *argv[])
-{
-  /* local variables */
-  int i,opened_input=0,opened_output=0;
-  char string[80];
-
-  double psec, phase, offset;
-  double polyco_period( double mjd, struct POLYCO polyco);
-  struct POLYCO polyco;
-
-  if (argc<2) {
-    polyco2period_help();
-    exit(0);
-  }
-	offset=0.0;
-
-  strcpy(polyco_file,"polyco.dat");
-
-  /* check the command line parameters */
-  i=2;
-  while (i<argc) {
-    if (strings_equal(argv[i],"-p")) {
-      i++;
-      if (file_exists(argv[i])) {
-	strcpy(polyco_file,argv[i]);
-	folding_period=-1.0;
-      }
-    } else if (strings_equal(argv[i],"-o")) {
-      i++;
-      offset=atof(argv[i]);
-    } else  {
-	/* unknown argument passed down - stop! */
-	polyco2period_help();
-	sprintf(string,"unknown argument (%s) passed to polyco2period",argv[i]);
-	error_message(string);
-    }
-    i++;
-  }
-
-  tstart=atof(argv[1])+offset/86400.0;
-  get_nearest_polyco(polyco_file,tstart,&polyco); 
-  psec=polyco_period(tstart,polyco);
-  phase=fabs(polyco_phase(tstart,polyco));
-  phase=phase-floor(phase);
-  printf("%12.9f (sec) for mjd = %18.12f Phase: %.12f\n", psec,tstart,phase);
-  exit(0);
-}
diff --git a/filterbank-gmrt/postproc.f b/filterbank-gmrt/postproc.f
deleted file mode 100644
index 215c953..0000000
--- a/filterbank-gmrt/postproc.f
+++ /dev/null
@@ -1,92 +0,0 @@
-c==============================================================================
-	program postproc
-c==============================================================================
-
-	parameter (maxdm = 2000, maxpulses=100000)
-
-	integer npulses_orig(maxdm), npulses(maxdm)
-  	real rms(maxdm), dm(maxdm), snr
-	integer index, ns, length(maxdm), ncandsmax, nsmax
-	integer iterate
-	real thresh
-	character command_line*80
-	
-	call getarg(1,command_line)
-	if (command_line.eq.'') then
-	   write(*,*) 'usage: postproc sample_time_in_seconds'
-	   stop
-	endif
-	read(command_line,*) samp_int
-
-	open (17,file='pulse_stats')
-	open (27,file='pulse_best')
-	open (37,file='dm.hist')
-
-	read (17,*) ncandsmax
-	read (17,*) thresh
-	read (17,*) nsmax
-	read (17,*) iterate
-
-	print *, 'thresh: ', thresh
-	print *, 'ncandsmax: ', ncandsmax
-	print *, 'iterate: ', iterate 
-	print *, 'nsmax: ', nsmax
-	i = 1
-
- 10	read (17,*,end=20) dm(i), npulses_orig(i), rms(i), length(i)
-	if (npulses_orig(i).lt.ncandsmax) then
-	   npulses(i) = npulses_orig(i)
-	else
-	   npulses(i) = ncandsmax
-	end if
-	if (i.gt.1) then
-	   write (37,*) i, 0, npulses_orig(i),
-     .			  npulses_orig(i),length(i),rms(i)
-	   write (37,*) i+1, 0,  npulses_orig(i),
-     .			 npulses_orig(i),length(i),rms(i)
-	else
-           write (37,*) i, 0, npulses_orig(i),
-     .			  npulses_orig(i),length(i),rms(i)
-           write (37,*) i+1, 0,  npulses_orig(i),
-     .			 npulses_orig(i),length(i),rms(i)
-	   length1 = length(i)
-	endif
-	i = i + 1
-	goto 10
-
- 20	close (17)
-	close (37)
-
-	ndm = i - 1
-	
-
-	open (17,file='dmlist')
-	open (37,file='best')
-	open (47,file='best.high')
-
-	write (17,*) ndm
-	timestart= 0.0
-
-	npulse = 0
-	do i = 1, ndm
-	   write (17,100) dm(i)
-	   do j = 1, npulses(i)
-	      read (27,*) ns, index, snr
-	      time = index*samp_int
-	      write (37,200) i-1, ns, index, snr, rms(i)
-	      if (time.ge.timestart.and.snr.ge.5)
-     .		 write (47,*) i-1, ns, time - timestart, snr
-	      npulse = npulse + 1
-	   end do
-	end do
-
- 100	format(f10.4)
- 200	format(i3,2x,i1,2x,i8,2x,f6.2,2x,2x,f7.5)
-
-	close (17)
-	close (27)
-	close (37)
-	close (47)
-
-	end
-c==============================================================================
diff --git a/filterbank-gmrt/prec_proto.h b/filterbank-gmrt/prec_proto.h
deleted file mode 100644
index ead22db..0000000
--- a/filterbank-gmrt/prec_proto.h
+++ /dev/null
@@ -1,31 +0,0 @@
-/* prec.c */
-double precess(double epoch_ra, double epoch_dec, double *ret_ra, double *ret_dec, double curtime, int src);
-int sla_preces(char *system, double ep0, double ep1, double *ra, double *dc);
-int sla_nut(double date, double rmatn[3][3]);
-int sla_nutc(double date, double *dpsi, double *deps, double *eps0);
-int sla_prec(double ep0, double ep1, double rmatp[3][3]);
-int sla_prenut(double epoch, double date, double rmatpn[3][3]);
-int sla_prebn(double bep0, double bep1, double rmatp[3][3]);
-double sla_dranrm(double angle);
-int sla_dcs2c(double a, double b, double v[3]);
-double sla_epj(double date);
-int sla_dmxm(double a[3][3], double b[3][3], double c[3][3]);
-int sla_deuler(char *order, double phi, double theta, double psi, double rmat[3][3]);
-int sla_dcc2s(double v[3], double *a, double *b);
-int sla_dmxv(double dm[3][3], double va[3], double vb[3]);
-int sla_addet(double rm, double dm, double eq, double *rc, double *dc);
-int sla_etrms(double ep, double ev[3]);
-int sla_fk45z(double r1950, double d1950, double bepoch, double *r2000, double *d2000);
-int sla_map(double rm, double dm, double pr, double pd, double px, double rv, double eq, double date, double *ra, double *da);
-int sla_mappa(double eq, double date, double amprms[21]);
-int sla_evp(double date, double deqx, double dvb[3], double dpb[3], double dvh[3], double dph[3]);
-int sla_dvn(double v[3], double uv[3], double *vm);
-int sla_mapqk(double rm, double dm, double pr, double pd, double px, double rv, double amprms[21], double *ra, double *da);
-double sla_epco(char *k0, char *k, double e);
-double sla_epj2d(double epj);
-double sla_epb2d(double epb);
-double sla_epb(double date);
-double sla_dvdv(double va[3], double vb[3]);
-double current_time(void);
-int isleap(int year);
-int dysize(int yr);
diff --git a/filterbank-gmrt/print_version.c b/filterbank-gmrt/print_version.c
deleted file mode 100644
index 16e2b10..0000000
--- a/filterbank-gmrt/print_version.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include "version.h"
-void print_version(char *program, char *argument) /*includefile*/
-{
-  if ( (strings_equal(argument,"version")) ||
-       (strings_equal(argument,"-version"))) {
-    printf("PROGRAM: %s is part of SIGPROC version: %.1f\n",program,SIGPROC_VERSION);
-    exit(0);
-  }
-}
diff --git a/filterbank-gmrt/process.c b/filterbank-gmrt/process.c
deleted file mode 100644
index 719fbef..0000000
--- a/filterbank-gmrt/process.c
+++ /dev/null
@@ -1,19 +0,0 @@
-/* do we need to process this record? 1=yes 0=no -1=break*/
-int process(float time, float start_time, float final_time) /* includefile */
-{
-  if (start_time == 0.0 && final_time == 0.0) {
-    return 1;
-  } else if (start_time == 0.0 && time <= final_time) {
-    return 1;
-  } else if (final_time == 0.0 && time >= start_time) {
-    return 1;
-  } else if (time >= start_time && time <= final_time) {
-    return 1;
-  } else if (final_time == 0.0 && time < start_time) {
-    return 0;
-  } else if (time >= final_time) {
-    return -1;
-  } else {
-    return 0;
-  }
-}
diff --git a/filterbank-gmrt/prof_adds.c b/filterbank-gmrt/prof_adds.c
deleted file mode 100644
index e8c2ed2..0000000
--- a/filterbank-gmrt/prof_adds.c
+++ /dev/null
@@ -1,17 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-void prof_adds(float *profile, int *nbins, int nchans, int nifs, int nadd)/*includefile*/
-{
-  int i,n=0;
-  float sum=0.0;
-  for (i=0;i<*nbins*nchans*nifs;i++) {
-    sum+=profile[i];
-    if ((i+1)%nadd==0) {
-      profile[n]=sum/(float)nadd;
-      sum=0.0;
-      n++;
-    }
-  }
-  *nbins/=nadd;
-}
-
diff --git a/filterbank-gmrt/prof_cent.c b/filterbank-gmrt/prof_cent.c
deleted file mode 100644
index bccba97..0000000
--- a/filterbank-gmrt/prof_cent.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* centres profiles in the entire dataset */
-#include <stdio.h>
-#include "sigproc.h"
-void prof_cent(float *profile, int nbins, int nchans) /*includefile*/
-{
-  int i,j,k,l,norg;
-  float *temp;
-  void centprof();
-
-  temp=vector(1,nbins);
-  k=l=0;
-  for (i=1;i<=nchans;i++) {
-    for (j=1;j<=nbins;j++) {
-      k++;
-      temp[j]=profile[k];
-    }
-    centprof(temp,nbins);
-    for (j=1;j<=nbins;j++) {
-      l++;
-      profile[l]=temp[j];
-    }
-  }
-  free_vector(temp,1,nbins);
-}
-
-/* centres a profile -- ie shifts it in phase so that peak is nbins/2 */
-void centprof(float *profile, int nbins)
-{
-  int i,j;
-  float prmax;
-  
-  prmax=profile[1];
-  j=1;
-  for (i=2;i<=nbins;i++) {
-    if (profile[i] > prmax) {
-      prmax=profile[i];
-      j=i;
-    }
-  }
-
-  shift_prof(profile,nbins,nbins/2-j);
-}
-
diff --git a/filterbank-gmrt/prof_ddis.c b/filterbank-gmrt/prof_ddis.c
deleted file mode 100644
index 9ef4094..0000000
--- a/filterbank-gmrt/prof_ddis.c
+++ /dev/null
@@ -1,43 +0,0 @@
-/* dedispserses profiles with respect to arbitrary sky frequency (MHz) */
-#include <stdio.h>
-#include "sigproc.h"
-int fftshift;
-void prof_ddis(float *profile, int nbins, int nchans, int nbands, int nifs, double *chanfreq,  double period, double dm, double reference_frequency, float jyf1, float jyf2) /* includefile */
-{
-  int b,i,j,c,cpb,ishift;
-  double freq,fshift;
-  float jyf[2];
-  cpb=nchans/nbands;
-  for (b=0;b<nbands;b++) {
-    for (c=b*cpb;c<(b+1)*cpb;c++) {
-      /* choose reference frequency for dedispersion */
-      if (reference_frequency<=0.0) 
-	freq=chanfreq[b*cpb];
-      else 
-	freq=reference_frequency;
-      /* calculate phase or bin shift for this channel */
-      fshift=dmdelay(freq,chanfreq[c],dm)/period;
-      ishift=dmdelay(freq,chanfreq[c],dm)/(period/nbins);
-      /* check for wrapping */
-      while (ishift < -nbins) ishift+=nbins;
-      while (ishift > +nbins) ishift-=nbins;
-      if (nbands>1)
-	chanfreq[b]=chanfreq[b*cpb];
-      else
-	chanfreq[c]=freq;
-      /* HACK! HACK! HACK!  Replace pol 0, bin 0 for Sept.1 2003 */
-      /*      profile[0] = profile[1];  */
-      jyf[0] = jyf1;
-      jyf[1] = jyf2;
-      for (i=0; i<nifs; i++) {
-	if (fftshift) 
-	  fshift_prof(profile,nbins,fshift); /* frequency-domain method */
-	else
-	  shift_prof(profile,nbins,ishift); /* bad old time-domain way! */
-	for(j=0;j<nbins;j++)
-          profile[j] *= jyf[i];
-	profile+=nbins;
-      }
-    }
-  }
-}
diff --git a/filterbank-gmrt/prof_sbas.c b/filterbank-gmrt/prof_sbas.c
deleted file mode 100644
index bbb9886..0000000
--- a/filterbank-gmrt/prof_sbas.c
+++ /dev/null
@@ -1,15 +0,0 @@
-/* subtracts a baseline from the entire data set */
-#include <stdio.h>
-#include "sigproc.h"
-void prof_sbas(char *srcname, float *profile, int nbins, int nchans, int nifs) /*includefile*/
-{
-  int i,j;
-  for (i=0;i<nchans*nifs;i++) {
-    if (strings_equal(srcname,"cal")) {
-      subcal(profile,nbins);
-    } else {
-      submedian(profile,nbins);
-    }
-    profile+=nbins;
-  }
-}
diff --git a/filterbank-gmrt/prof_sumc.c b/filterbank-gmrt/prof_sumc.c
deleted file mode 100644
index f31e6ad..0000000
--- a/filterbank-gmrt/prof_sumc.c
+++ /dev/null
@@ -1,40 +0,0 @@
-/* collapses nchannels down to a number of sub-bands */
-#include <stdio.h>
-#include <stdlib.h>
-void prof_sumc(float *profile, int nbins, int nbands, int *nchans, int nifs, int *ignore) /* includefile */
-{
-  int i,c,n,b,cpb,nc,m;
-  float *sub_band;
-
-  /* calculate number of channels in each sub-band (integer multiples only!) */
-  nc=*nchans;
-  cpb=nc/nbands;
-  if (nc != cpb*nbands) 
-    error_message("nchannels not integer multiple of number of sub-bands!");
-
-  /* create working array to hold one sub-band */
-  sub_band = (float *) malloc(nbins * sizeof(float));
-  for (n=0;n<nbins;n++) sub_band[n]=0.0;
-  m=0;
-  
-  for (b=0;b<nbands;b++) {
-    for (i=0;i<nifs;i++) {
-      /* sum over all channels to form the sub-band */
-      for (c=cpb*b; c<cpb*(b+1); c++) {
-	if (!ignore[c])
-	  for (n=0; n<nbins; n++) sub_band[n]+=profile[c*nbins*nifs+i*nbins+n];
-      }
-      /* copy subband to profile and clear for next sum */
-      for (n=0;n<nbins;n++) {
-	profile[m]=sub_band[n];
-	sub_band[n]=0.0;
-	m++;
-      } 
-    }
-  }
-  free(sub_band);
-  *nchans=nbands;
-}
-
-
-
diff --git a/filterbank-gmrt/prof_sumifs.c b/filterbank-gmrt/prof_sumifs.c
deleted file mode 100644
index fce3e62..0000000
--- a/filterbank-gmrt/prof_sumifs.c
+++ /dev/null
@@ -1,21 +0,0 @@
-/* sums IFs for the entire data set, sets nifs to 1 */
-#include <stdio.h>
-#include "sigproc.h"
-void prof_sumifs(float *profile, int nbins, int nchans, int *nifs) /*includefile*/
-{
-  int i,j,k;
-  float *tmpprof;
-
-  tmpprof = (float *) malloc(nchans * nbins * (*nifs) * sizeof(float));
-
-  for(i=0;i<nchans*nbins*(*nifs);i++) tmpprof[i] = profile[i];
-  k=0;
-  for(i=0;i<nchans;i++) 
-    for(j=0;j<nbins;j++) {
-      profile[k]=tmpprof[i*nbins*(*nifs)+j]+tmpprof[i*nbins*(*nifs)+nbins+j];
-      k++;
-    }
-  free(tmpprof);
-  *nifs = 1;
-
-}
diff --git a/filterbank-gmrt/profile.c b/filterbank-gmrt/profile.c
deleted file mode 100644
index 3a2285f..0000000
--- a/filterbank-gmrt/profile.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
-  profile - a program to produce quick ASCII/grey-scale plots of profiles
-  to the standard output. To use, simply fold a time series file and pipe
-  the output to this program. For profiles produced in regular prf format
-  an ASCII histogram is produced showing a 64-bin version of the profile.
-  For profiles produced with -stream option, a pseudo grey-scale output
-  is produced showing the profiles collapsed down to one line per profile.
-
-  Created April 9/10, 2002 - drl@jb.man.ac.uk
- */
-#include "profile.h"
-main(int argc, char **argv) 
-{
-  float tsec,fmhz,peak=1.0,sum,sumsq,sigma,sig2,mean,meansq,chi2,diff;
-  float *pcopy,n;
-  int hh,mm,i,j,row,dummy,mbins=64,obins,first=1,idx,nprof=1,display=0,rc2=0;
-  unsigned long *indx;
-  char line[240], hash, gry[10], message[80];
-
-  strcpy(gry,"   ,:o*@$#");
-  input=stdin;
-
-  if (argc > 1) {
-    print_version(argv[0],argv[1]);
-    if (help_required(argv[1])) {
-      profile_help();
-      exit(0);
-    }
-    i=1;
-    while (i<argc) {
-      if (file_exists(argv[i])) {
-	input=open_file(argv[i],"r");
-      } else if (strings_equal(argv[i],"-frequency")) {
-	display=1;
-      } else if (strings_equal(argv[i],"-chi2")) {
-	rc2=1;
-      } else if (strings_equal(argv[i],"-p")) {
-	peak=atof(argv[++i]);
-      } else {
-	sprintf(message,"command-line argument %s not recognized...",argv[i]);
-	error_message(message);
-      }
-      i++;
-    }
-  }
-
-  fgets(line,sizeof(line),input);
-  sscanf(line,"%c %lf %lf %lf %ld %lf %lf %d",&hash,
-	 &mjdobs,&tstart,&period,&np,&fch1,&refdm,&nbins);
-  if (nbins > 0) {
-    while (!feof(input)) {
-      profile=(float *) malloc(sizeof(float)*nbins);
-      for (i=0; i<nbins; i++) {
-	fscanf(input,"%d %f",&dummy,&profile[i]);
-      }
-      if (rc2) {
-	pcopy=(float *) malloc(sizeof(float)*nbins);
-	for (i=0;i<nbins;i++) pcopy[i]=profile[i];
-	indx=(unsigned long *) malloc(sizeof(unsigned long)*nbins);
-	indexx((unsigned long)nbins,pcopy,indx);
-	n=sum=sumsq=0.0;
-	for (i=0;i<nbins/2;i++) {
-	  j=indx[i];
-	  sum+=profile[j];
-	  sumsq+=profile[j]*profile[j];
-	  n+=1.0;
-	}
-	mean=sum/n;
-	meansq=sumsq/n;
-	sigma=sqrt(meansq-mean*mean);
-	sig2=sigma*sigma;
-	sumsq=0.0;
-	for (i=0;i<nbins;i++) {
-	  diff=profile[i]-mean;
-	  sumsq+=diff*diff;
-	}
-	chi2=sumsq/sig2/(float)(nbins-1);
-	printf("%f %f\n",period,chi2);
-	exit(0);
-      }
-      if (nbins>mbins) {
-	add_channels(profile,nbins,nbins/mbins);
-	nbins=mbins;
-      }
-      pmin=vmin(profile,nbins);
-      pmax=vmax(profile,nbins)*peak;
-      prng=pmax-pmin;
-      for (i=0; i<nbins; i++) profile[i]=19.0*(profile[i]-pmin)/prng+1.0;
-      for (row=20; row>=1; row--) {
-	for (i=0; i<nbins; i++) {
-	  if (profile[i]>=(float) row) 
-	    printf("#");
-	  else
-	    printf(" ");
-	}
-	printf("\n");
-      }
-      free(profile);
-      nbins=0;
-      fgets(line,sizeof(line),input);
-      fgets(line,sizeof(line),input);
-      sscanf(line,"%c %lf %lf %lf %ld %lf %lf %d",&hash,
-	 &mjdobs,&tstart,&period,&np,&fch1,&refdm,&nbins);
-      if (nbins<=0) break;
-    }
-  } else {
-    while (!feof(input)) {
-      sscanf(line,"#START %d %f %f",&nbins,&tsec,&fmhz);
-      if (nbins <=0) break;
-      profile=(float *) malloc(sizeof(float)*nbins);
-      for (i=0; i<nbins; i++) fscanf(input,"%d %f",&dummy,&profile[i]);
-      fgets(line,sizeof(line),input);
-      fgets(line,sizeof(line),input);
-      if (nbins>mbins) {
-	obins=nbins;
-	add_channels(profile,nbins,nbins/mbins);
-	nbins=mbins;
-      }
-      if (first) {
-	pmin=vmin(profile,nbins);
-	pmax=vmax(profile,nbins)*peak;
-	prng=pmax-pmin;
-	/*first=0;*/
-      }
-      if (display) {
-	printf("|%04d|%11.6f|",nprof,fmhz);
-      } else {
-	hh=(int) tsec/3600.0;
-	tsec-=(float) hh*3600.0;
-	mm=(int) tsec/60.0;
-	tsec-=(float) mm*60.0;
-	printf("|%04d|%02d:%02d:%02d|",nprof,hh,mm,(int)tsec);
-      }
-      for (i=0; i<nbins; i++) {
-	idx=(int) (9.0*(profile[i]-pmin)/prng);
-	if (idx<0) idx=0;
-	if (idx>9) idx=9;
-	putchar(gry[idx]);
-      }
-      puts("|");
-      free(profile);
-      fgets(line,sizeof(line),input);
-      nbins=0;
-      nprof++;
-    }
-  }
-}
diff --git a/filterbank-gmrt/profile.h b/filterbank-gmrt/profile.h
deleted file mode 100644
index 325088f..0000000
--- a/filterbank-gmrt/profile.h
+++ /dev/null
@@ -1,15 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-
-FILE *input;
-double period;
-long int np;
-int nbins,site;
-float *profile, pmin, pmax, prng;
-/* global variables describing the data */
-#include "header.h"
-
-/* list of subroutines and functions */
-#include "sigproc.h"
-
diff --git a/filterbank-gmrt/pspm2fb.c b/filterbank-gmrt/pspm2fb.c
deleted file mode 100644
index 01814f5..0000000
--- a/filterbank-gmrt/pspm2fb.c
+++ /dev/null
@@ -1,123 +0,0 @@
-/* pspm2fb - converts PSPM search-mode data into "filterbank" data */
-
-#include "filterbank.h"
-#include "pspmhdr.h"
-PSPM_SEARCH_HEADER pspm_search;
-
-void pspm2fb(FILE *input, FILE *output) /* includefile */
-{
-  FILE *fpou;
-  int np=0,ns,nc,c,s,nints,rawdata[PSPM_INT_BLOCK],idump,doit,swap_bytes;
-  int i,opened=0,drift;
-  float datablock[PSPM_REA_BLOCK],datablock2[PSPM_REA_BLOCK],sum,realtime;
-  unsigned char charblock[PSPM_REA_BLOCK],sample;
-  unsigned short shortblock[PSPM_REA_BLOCK];
-  char string[80];
-
-  /* establish whether this is drift-mode data */
-  if (pspm_search.HEADER_TYPE == 0) {
-	drift=1;
-  } else {
-	drift=0;
-  }
-  idump=0;
-
-  /* establish whether we need to swap bytes (PSPM is big endian) */
-  swap_bytes=little_endian();
-
-  /* shorthand for number of samples and channels in a datablock */
-  ns=PSPM_SAM_BLOCK;
-  nc=PSPM_NCH_BLOCK;
-
-  if (headerfile) {
-    /* write output ASCII header file */
-    fpou=open_file("head","w");  
-    fprintf(fpou,"Original PSPM file: %s\n",inpfile);
-    fprintf(fpou,"Sample time (us): %f\n",tsamp*1.0e6);
-    fprintf(fpou,"Number of samples/record: %d\n",ns);
-    fprintf(fpou,"Center freq (MHz): %f\n",fch1+(float)nchans*foff/2.0);
-    fprintf(fpou,"Channel band (kHz): %f\n",fabs(foff)*1000.0);
-    fprintf(fpou,"Number of channels/record: %d\n",nc);
-    fprintf(fpou,"Time stamp (MJD): %18.12f\n",tstart);
-    fprintf(fpou,"AZ at start: %f\n",az_start);
-    fprintf(fpou,"ZA at start: %f\n",za_start);
-    fprintf(fpou,"RA (J2000): %f\n",src_raj);
-    fprintf(fpou,"DEC (J2000):  %f\n",src_dej);
-    fclose(fpou);
-  }
-
-
-  /* main loop over each record of input data file*/
-  while (!feof(input)) {
-    /* this is the time at that start of the block */
-    realtime=tsamp*idump;
-    /* read in a record and unscramble the channels */
-    nints=fread(rawdata,sizeof(int),PSPM_INT_BLOCK,input);
-    if ( (doit=process(realtime,start_time,final_time)) == -1) break;
-    if (doit) {
-      /* about to process this record, update log */
-      np++;
-      if (np%10 == 0) {
-	if (!opened) {
-	  /* open up logfile */
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",realtime);
-	update_log(string);
-      }
-
-      if (swap_bytes) for (s=0;s<nints;s++) swap_int(&rawdata[s]);
-
-      /* unscramble the channels using Ingrid's C routine */
-      pspm_decode(rawdata,datablock);
-
-      /* if the -invert option was specified, flip the band */
-      i=0;
-      if (invert_band) {
-	for(s=0;s<ns;s++) {
-	  for (c=nc-1;c>=0;c--) {
-	    datablock2[i++]=datablock[s*nc+c];
-	  }
-	}
-        for(i=0;i<ns*nc;i++) 
-	    datablock[i]=datablock2[i];
-      }
-
-      realtime+=(float) ns * (float) tsamp; 
-      /* decide on how to write out data */
-      if (obits==32) {
-	/* user has requested floating point numbers in binary file */
-	if (swapout) for (s=0;s<ns*nc;s++) swap_float(&datablock[s]);
-	fwrite(datablock,sizeof(float),ns*nc,output);
-      } else if (obits==16) {
-	/* user has requested unsigned shorts in binary file */
-	float2short(datablock,ns*nc,0.0,15.0,shortblock);
-	if (swapout) for (s=0;s<ns*nc;s++) swap_short(&shortblock[s]);
-	fwrite(shortblock,sizeof(unsigned short),ns*nc,output);
-      } else if (obits==8) {
-	/* user has requested unsigned chars in binary file */
-	float2char(datablock,ns*nc,0.0,15.0,charblock);
-	fwrite(charblock,sizeof(unsigned char),ns*nc,output);
-      } else if (obits==4) {
-	/* default is to  write data out packed into character format */
-	float2four(datablock,ns*nc,0.0,15.0,charblock);
-	fwrite(charblock,sizeof(unsigned char),ns*nc/2,output);
-      } else if (obits==0) {
-	/* special mode to write out in different order for old ddsp program */
-	for (c=0;c<nc;c++) {
-	  for(s=0;s<ns;s++) {
-	    sample=(unsigned char)datablock[s*nc+c];
-	    fwrite(&sample,sizeof(unsigned char),1,output);
-	  }
-	}
-      } else { 
-	error_message("unknown bit format for writing");
-      }
-    }
-    /* update dumps read/processed */
-    idump+=ns;
-    /* break out if this is in drift-mode and we've read 9 beams */
-    if (drift && (idump == 4718592)) break;  
-  }
-}
diff --git a/filterbank-gmrt/pspm_decode.c b/filterbank-gmrt/pspm_decode.c
deleted file mode 100644
index 2734b6d..0000000
--- a/filterbank-gmrt/pspm_decode.c
+++ /dev/null
@@ -1,36 +0,0 @@
-#include <stdio.h>
-#include <math.h>
-
-/*  
-Based on decode.f.  Will unpack one 512-sample (= 32kb) block of PSPM
-search data and fill the 1-d array "tmparray" with:
-sample0 channel0, sample0 channel1,... sample0 channel127, sample1 channel0,...
-
-It might make more sense to keep nboards, maxsam, nchpb and nfreqs in a
-separate structure, but they're not all in PSPM_SEARCH_HEADER and therefore
-need to be hardwired somewhere.
-
-Ingrid Stairs Nov. 3, 1999 
-*/
-
-void pspm_decode(int *rawdata, float *tmparray) /* includefile */
-{
-
-  int i,j,k,l;
-  unsigned int packed;
-  int idx1,idx2;
-  int nboards = 16;
-  int maxsam = 512;
-  int nchpb = 8;
-  int nfreqs = 128;
-  int nbits[8] = {16,20,24,28,0,4,8,12};
- 
-  for(j=0;j<maxsam;j++) 
-    for(k=0;k<nboards;k++) {
-      idx1 = j*nboards+k;
-      idx2 = nfreqs-nchpb*k;
-      packed = rawdata[idx1];
-      for(l=0;l<nchpb;l++)
-	tmparray[nfreqs*j+idx2-l-1] = (float) ((packed >> nbits[l]) & 15);
-    }
-}
diff --git a/filterbank-gmrt/pspm_prof.c b/filterbank-gmrt/pspm_prof.c
deleted file mode 100644
index c457d97..0000000
--- a/filterbank-gmrt/pspm_prof.c
+++ /dev/null
@@ -1,42 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-/* read in header and profiles from timing data returns a pointer to the
-   profiles which are stacked in order of decreasing radio frequency */
-float *pspm_prof(FILE *input, int nbins, int nchans, int *table)/*includefile*/
-{
-  int swap_bytes,i,j,k,l;
-  unsigned long *rawdat;
-  float *profile;
- 
-  /* PSPM/BPP data are big endian -> must swap bytes if using little endian */
-  swap_bytes=little_endian();
- 
-  /* allocate space for raw and ordered data */
-  rawdat = (unsigned long *) malloc(nchans * nbins * sizeof(long));
-  profile = (float *) malloc(nbins * nchans * sizeof(float));
-
-  /* read in the profiles */
-  fread(rawdat,nbins*nchans*sizeof(unsigned long),1,input);
-
-  /* stack profiles in frequency order, swapping if necessary */
-  for (i=0;i<nchans;i++) {
-    k=table[i]*nbins;
-    l=i*nbins;
-    for (j=0;j<nbins;j++) {
-      if (swap_bytes) swap_long(&rawdat[k+j]);
-      profile[l+j]=rawdat[k+j];
-    }
-  }
-  free(rawdat);
-  return(profile);
-
-  for (i=0;i<nchans;i++) {
-    puts("#START");
-    k=i*nbins;
-    for (j=0;j<nbins;j++) {
-      printf("%f %f\n",(float)j,profile[k+j]);
-    }
-    puts("#STOP");
-  }
-  exit(0);
-}
diff --git a/filterbank-gmrt/pspm_tstart.c b/filterbank-gmrt/pspm_tstart.c
deleted file mode 100644
index 184db38..0000000
--- a/filterbank-gmrt/pspm_tstart.c
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
-## help on pspm_tstart 
-## double pspm_tstart - returns UT time stamp for the start of any PSPM scan
-##
-## variables passed down:
-##
-## long scan_num      - the scan number from the header
-## char *start_time   - the time stamp string from the header (HH:MM:SS)
-## double tick_offset - the tick offset from the header in us
-##
-## variables returned:
-## 
-## double mjdobs    - the MJD of the observations
-##
-## pspm_tstart returns the number of seconds since midnight for mjdobs
-##
-## this routine is designed to cope with the change in start time convention
-## (AST -> UT) written in the headers before and after Jan 1, 2000. Pre y2k,
-## all start times were in AST. Post y2k, all start times are in UT.
-##
-## Created on Mar 10, 2001 (dunc@naic.edu)
-## help end
-*/
-#include <stdio.h>
-#include "sigproc.h"
-double pspm_tstart(unsigned long scan_num, char *start_time, double tick_offset, double *mjdobs)/*includefile*/
-{
-  int dayno,year,scan,hh,mm,ss,seconds;
-  /* read in the aoscan to get dayno year and scan */
-  read_aoscan(scan_num, &dayno, &year, &scan);
-
-  /* get number of seconds since midnight */
-  sscanf(start_time,"%d:%d:%d",&hh,&mm,&ss);
-  seconds=hh*3600+mm*60+ss;
-
-  /* 
-     before y2k the start time was AST - add on 4 hours (14400 seconds) 
-     to convert to UT, checking for crossing midnight and new year during 
-     conversion and adjusting year, seconds and day number if necessary 
-  */
-  if (year<2000) {
-    seconds+=14400;
-    if (seconds>86400) {
-      seconds-=86400;
-      dayno++;
-    }
-    if (dayno>366) {
-      dayno=1;
-      year++;
-    }
-  }
-
-  /* form mjd based on jan 1 of current year plus number of days since then */
-  *mjdobs=mjd(year,1,1)+(double)(dayno-1);
-
-  /* return the start time in seconds */
-  return ((double)seconds + tick_offset*1.0e-6);
-}
diff --git a/filterbank-gmrt/pspmhdr.h b/filterbank-gmrt/pspmhdr.h
deleted file mode 100644
index 815e448..0000000
--- a/filterbank-gmrt/pspmhdr.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * timing mode header information.
- *
- * version 2 July 29, 1994
- */
-
-#define	PSPM_TIMING_HEADER_SIZE	(1<<15)	/* DO NOT CHANGE THIS		    */
-
-#define	PSPM_TIMING_HEADER_VERSION	2
-
-
-typedef struct {
-
-  double psr_period;
-  double samp_rate;
-  double psr_dm;
-  double psmon_az;
-  double psmon_za;
-  double psmon_ast;
-  double freq;                  /* Sky Frequency (MHz)                       */
-  double tick_offset;           /* delay from 10sec tick to start time (usec)*/
-  double ast_start;             /* AST start time -- seconds past midnight   */
-                                /* including the tick_offset measurement.    */
-  double length_of_integration; /* estimate that does NOT take into account  */
-                                /* the doppler corrections to samp_rate.     */
-				/* For true integration time, the polyco.dat */
-				/* entry appended on the end of the scan     */
-				/* must be consulted.			     */
-  long header_version;
-  long bit_mode;
-  long num_phase_bins;
-  unsigned long scan_num;
-  long tc;
-  long num_chans;
-  long num_periods;             /* exact number of pulse periods integrated  */
-  long sizeof_polyco;
-  long psmon_wrap;
-  long psmon_feed;
-  long psmon_daynumber;
-  long psmon_epoch;
-  char psr_name[12];
-  char psr_ra[12];
-  char psr_dec[12];
-  char date[12];
-  char start_time[12];
-  char even_word_boundary_filler[4];
-  double psmon_ra;
-  double psmon_dec;
-  double psmon_tolerance;
-  char filler[32544];
-  long UPDATE_DONE;
-  long HEADER_TYPE;
-
-} PSPM_TIMING_HEADER;
-
-
-#ifndef PSPM_HEADER_SIZE
-#define PSPM_HEADER_SIZE	(1<<15)
-#endif
-
-#define	DRIFT_TYPE	0
-#define	POINT_TYPE	2
-
-
-typedef struct {
-
-    double samp_rate;
-    double pasmon_az;
-    double pasmon_za;
-    double user_az;
-    double user_za;
-    double pasmon_lmst;		/* local mean siderial time in seconds */
-    double rf_freq;		/* Sky Frequency which is down converted to  */
-				/* IF frequency PSPM_IF (MHz)		     */
-    double tick_offset;
-    double bw;
-    double length_of_integration; /* some fixed number */
-    long header_version;
-    long scan_file_number;
-    long bit_mode;
-    unsigned long scan_num;
-    long tc;
-    long num_chans;
-    long pasmon_wrap;
-    long pasmon_feed;
-    long pasmon_daynumber;
-    long pasmon_ast;		/* hhmmss */
-    char psr_name[12];
-    char date[12];
-    char start_time[12];
-    long file_size;
-    long tape_num;
-    long tape_file_number;
-    char obs_group[12];
-    char even_word_boundary_filler[4];
-    double user_ra;		/* J2000 (10000.*hr+100.*min+sec)	    */
-    double user_dec;		/* J2000 (10000.*deg+100.*min+sec)	    */
-    double chan_first_freq;	/* IF center frequency of first channel (MHz)*/
-    double chan_spacing;	/* Spaceing between adjacent channel center */
-				/* frequencies (MHz)			    */
-    int	SIDEBAND;		/* sideband				    */
-    char filler[32536];
-    long BACKEND_TYPE;
-    long UPDATE_DONE;
-    long HEADER_TYPE;
-
-} PSPM_SEARCH_HEADER;
-
-#define PSPM_BYT_BLOCK 32768
-#define PSPM_INT_BLOCK PSPM_BYT_BLOCK/4
-#define PSPM_SAM_BLOCK 512
-#define PSPM_NCH_BLOCK 128
-#define PSPM_REA_BLOCK PSPM_SAM_BLOCK*PSPM_NCH_BLOCK
diff --git a/filterbank-gmrt/psrfits.c b/filterbank-gmrt/psrfits.c
deleted file mode 100644
index d046fbc..0000000
--- a/filterbank-gmrt/psrfits.c
+++ /dev/null
@@ -1,1165 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-/* cfitsio include file */
-#include "fitsio.h"
-
-/* Define CFITS file pointer - global- defined in fitsio.h */
-fitsfile *fits;
-int new_file = 0;
-
-/* hdu numbers */
-int dig_stats_hdu;
-int bpass_hdu;
-int last_scanhdr_hdu;
-int subint_hdu;
-
-
-/* BEGIN */
-
-int CDfits_open_file( char *filename )
-{
-  int sta;
-  int bitpix   =  8;
-  int naxis   =  0;
-  long *naxes;
-  
-  sta = 0;
-  /* Open file */
-  fits_create_file( &fits, filename, &sta );
-  /* Write primary header */
-  bitpix = 8;
-  naxis = 0;
-  fits_create_img( fits, bitpix, naxis, naxes, &sta );
-
-  /* Add first keywords */
-  fits_update_key( fits, TSTRING, "HDRVER", "1.19", "Header version", &sta);
-  fits_write_date( fits, &sta);
-
-  new_file = 1;
-  
-  
-  return( sta );
-  
-}
-
-
-int CDfits_write_scanhdr( void )
-{
-  int sta;
-  int i, j, k, m, n;
-  short int sj;
-  
-  double dx, dy, dz;
-  
-  long lk;
-    
-  int nrows, ncols;
-  long naxes[3];
-
-  char *ttype[4], *tform[4], *tunit[4];
-
-  char str[16], Istr[16], *qch, *rch, *sch, *tch;
-
-  int chan_inc, first_normal_group, npols, pol;
-      
-  float x;
-
-#undef POINT_PAR
-#ifdef POINT_PAR
-
-  float xa[12];
-
-#endif
-  
-  FILE *fp;
-  char filename[80];
-  
-#define GSTR_LEN 88
-  char gstr[GSTR_LEN];
-  char astr[80];
-  
-  void *pv;
-
-  char date_time[24];
-
-#define MAX_BLKS 20
-  char *pch[MAX_BLKS];
-  char site[MAX_BLKS][2];
-  short int nspan[MAX_BLKS];
-  short int ncoeff[MAX_BLKS];
-  double rfreq[MAX_BLKS];
-  double rmjd[MAX_BLKS];
-  double rphase[MAX_BLKS];
-  double lgfiterr[MAX_BLKS];
-  double f0[MAX_BLKS];
-#define MAX_COEFF 15
-  double coeff[MAX_BLKS][MAX_COEFF];
-
-
-  /* For Pulsar History BINTABLE */
- 
-  static char *PHtype[18] = {
-    "DATE_PRO","PROC_CMD","POL_TYPE","NPOL    ","NBIN    ","NBIN_PRD","TBIN    ","CTR_FREQ",
-    "NCHAN   ","CHAN_BW ","PAR_CORR","RM_CORR ","DEDISP  ","DDS_MTHD","SC_MTHD ","CAL_MTHD",
-    "CAL_FILE","RFI_MTHD"
-  };
-  
-  static char *PHform[18] = {
-    "24A     ","80A     ","8A      ","1I      ","1I      ","1I      ","1D      ","1D      ",
-    "1I      ","1D      ","1I      ","1I      ","1I      ","32A     ","32A     ","32A     ",
-    "32A     ","32A     "
-  };
-  
-  static char *PHunit[18] = {
-    "        ","        ","        ","        ","        ","        ","s       ","MHz     ",
-    "        ","MHz     ","        ","        ","        ","        ","        ","        ",
-    "        ","        "
-  };
-
-
-  /* For Pulsar Epmemeris BINTABLE */
-
-  static char *PEtype[56] = {
-    "DATE_PRO", "PROC_CMD", "EPHVER", "PSR_NAME", "RAJ", "DECJ", "PMRA", "PMDEC", 
-    "PX", "POSEPOCH", "IF0", "FF0", "F1", "F2", "F3", "PEPOCH",
-    "DM", "DM1", "RM", "BINARY", "T0", "PB", "A1", "OM", 
-    "OMDOT", "ECC", "PBDOT", "GAMMA", "SINI", "M2", "T0_2", "PB_2",
-    "A1_2", "OM_2", "ECC_2", "DTHETA", "XDOT", "EDOT", "TASC", "EPS1",
-    "EPS2", "START", "FINISH", "TRES", "NTOA", "CLK", "EPHEM", "TZRIMJD",
-    "TZRFMJD", "TZRFRQ", "TZRSITE", "GLEP_1", "GLPH_1", "GLF0_1", "GLF1_1", "GLF0D_1"
-  };
-  
-  static char *PEform[56] = {
-    "24A     ", "80A     ", "16A     ", "16A     ", "24A     ", "24A     ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1J      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "8A      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "1I      ", "12A     ", "12A     ", "1J      ",
-    "1D      ", "1D      ", "1A      ", "1D      ", "1D      ", "1D      ", "1D      ", "1D      "
-  };
-  
-  /* For Pulsar Polyco BINTABLE */
-
-  static char *PPtype[13] = {
-    "DATE_PRO", "POLYVER ", "NSPAN   ", "NCOEF   ", "NPBLK   ", "NSITE   ", "REF_FREQ", "PRED_PHS",
-    "REF_MJD ", "REF_PHS ", "REF_F0  ", "LGFITERR", "COEFF   "
-  };
-    
-  static char *PPform[13] = {
-    "24A     ", "16A     ", "1I      ", "1I      ", "1I      ", "1A      ", "1D      ", "1D      ",
-    "1D      ", "1D      ", "1D      ", "1D      ", "15D     ",
-  };
-
-  /* BEGIN */
-
-  sta = 0;
-
-  /* Get DateTime string - required in various BINTABLEs */
-  fits_get_system_time( date_time, &n, &sta );
-  
-  if( new_file ) {
-
-    /* Add required keywords to primary header */
-
-    /* fits_update_key( fits, TSTRING, "ORIGIN", "RNM", 
-       "Output class", &sta); */
-
-    fits_update_key( fits, TSTRING, "OBSERVER", header.observer, 
-		     "Observer name(s)", &sta);
-    fits_update_key( fits, TSTRING, "PROJID", supplhdr.project, 
-		     "Project name", &sta);
-    fits_update_key( fits, TSTRING, "TELESCOP", supplhdr.site_name,
-		     "Telescope name", &sta);
-    fits_update_key( fits, TDOUBLE, "ANT_X", &header.antenna[0].x,
-		     "[m] Antenna ITRF X-coordinate (D)", &sta);
-    fits_update_key( fits, TDOUBLE, "ANT_Y", &header.antenna[0].y,
-		     "[m] Antenna ITRF Y-coordinate (D)", &sta);
-    fits_update_key( fits, TDOUBLE, "ANT_Z", &header.antenna[0].z,
-		     "[m] Antenna ITRF Z-coordinate (D)", &sta);
-    fits_update_key( fits, TSTRING, "FRONTEND", supplhdr.frontend, 
-		     "Rx and feed ID", &sta);
-
-    fits_update_key( fits, TSTRING, "FD_POLN", supplhdr.polzn,
-		     "LIN or CIRC", &sta);
-    x = 0.0;
-    fits_update_key( fits, TFLOAT, "XPOL_ANG", &x,
-		     "[deg] Angle of X-probe wrt platform zero (E)", &sta);
-
-    fits_update_key( fits, TSTRING, "BACKEND", supplhdr.backend, 
-		     "Backend ID", &sta);
-    fits_update_key( fits, TSTRING, "BECONFIG", (*c_c).config_menu_name,
-		     "Backend configuration file name", &sta);
-
-    /* Basic cycle time for integration */
-    dx = (*c_c).integ_time / 1.0E06;
-    fits_update_key( fits, TDOUBLE, "TCYCLE", &dx,
-		     "[s] Correlator cycle time (D)", &sta);
-
-    /* Find the first normal group in band */
-    first_normal_group = -1;
-    i = (*c_c).band[0].first_group;
-    k = i + (*c_c).band[0].num_group - 1;
-    while( ( i <= k ) && ( first_normal_group < 0 ) ) {
-      if( (*c_c).product[ (*c_c).prod_group[i].first_prod ].type < POL_CAL_OFF ) {
-	first_normal_group = i;
-      }
-      i++;
-    }
-    if( first_normal_group < 0 ) first_normal_group = 0;
-
-    npols = (*c_c).prod_group[first_normal_group].num_prod;
-
-    /* Receiver channels - best guess */
-    if( npols == 1 ) nrcvr = 1;
-    else nrcvr = 2;
-    
-    fits_update_key( fits, TINT, "NRCVR", &nrcvr,
-		     "Number of receiver channels (I)", &sta);
-    fits_update_key( fits, TSTRING, "OBS_MODE", supplhdr.obsmode,
-		     "(PSR, CAL, SEARCH)", &sta);
-    /* fits_update_key( fits, TSTRING, "DATATYPE", "FOLD",
-                     "FOLD or DUMP", &sta);  */
-    fits_update_key( fits, TSTRING, "SRC_NAME", header.source,
-		     "Source or scan ID", &sta);
-    fits_update_key( fits, TSTRING, "COORD_MD", header.epoch,
-		     "Coordinate mode (J2000, Gal, Ecliptic, etc.)", &sta);
-
-    /* J2000 or B1950 */
-    if( header.epoch[0] == 'J' || header.epoch[0] == 'B') j = 0;
-    /* All others */
-    else j = 2;
-
-    rads_to_str( gstr, 16, supplhdr.start_long, j );
-
-    /*
-    gstr[17] = '\0';
-    printf("\n rads_to_str(mode0) on %f = '%s'", supplhdr.start_long, gstr );
-    */
-
-    fits_update_key( fits, TSTRING, "STT_CRD1", gstr,
-		     "Start coord 1 (hh:mm:ss.sss or ddd.ddd)", &sta);
-
-    rads_to_str( gstr, 16, supplhdr.start_lat, j+1 );
-    fits_update_key( fits, TSTRING, "STT_CRD2", gstr,
-		     "Start coord 2 (-dd:mm:ss.sss or -dd.ddd)", &sta);
-   
-    fits_update_key( fits, TSTRING, "TRK_MODE", supplhdr.trackmode,
-		     "Track mode (TRACK, SCANGC, SCANLAT)", &sta);
-
-    rads_to_str( gstr, 16, supplhdr.stop_long, j );
-    fits_update_key( fits, TSTRING, "STP_CRD1", gstr,
-		     "Stop coord 1 (hh:mm:ss.sss or ddd.ddd)", &sta);
-
-    rads_to_str( gstr, 16, supplhdr.stop_lat, j+1 );
-    fits_update_key( fits, TSTRING, "STP_CRD2", gstr,
-		     "Stop coord 2 (-dd:mm:ss.sss or -dd.ddd)", &sta);
-   
-    x = supplhdr.scan_cycles * ( (*c_c).integ_time / 1.0E06 );
-    fits_update_key( fits, TFLOAT, "SCANLEN ", &x,
-		     "[s] Requested scan length (E)", &sta);
-    
-    fits_update_key( fits, TSTRING, "FD_MODE", supplhdr.fdmode,
-		     "Feed track mode - Const FA, CPA, GPA", &sta);
-
-    fits_update_key( fits, TFLOAT, "FA_REQ", &supplhdr.xpolang,
-		     "[deg] Feed/Posn angle requested (E)", &sta);
-
-    fits_update_key( fits, TFLOAT, "ATTEN_A", &supplhdr.atten_a,
-		     "[db] Attenuator, Poln A (E)", &sta);
-
-    fits_update_key( fits, TFLOAT, "ATTEN_B", &supplhdr.atten_b,
-		     "[db] Attenuator, Poln B (E)", &sta);
-
-    fits_update_key( fits, TSTRING, "CAL_MODE", supplhdr.calmode,
-		     "Cal mode (OFF, SYNC, EXT1, EXT2)", &sta);
-
-    x = (float) (*c_c).pulsar_ncal_sig_frequency;
-    fits_update_key( fits, TFLOAT, "CAL_FREQ", &x,
-		     "[Hz] Cal modulation frequency (E)", &sta);
-
-    x = (float) (*c_c).pulsar_ncal_sig_duty_cycle;
-    fits_update_key( fits, TFLOAT, "CAL_DCYC", &x,
-		     "Cal duty cycle (E)", &sta);
-
-    x = (float) (*c_c).pulsar_ncal_sig_start_phase;
-    fits_update_key( fits, TFLOAT, "CAL_PHS ", &x,
-		     "Cal phase (wrt start time) (E)", &sta);
-    
-
-    new_file = 0;
-
-  }
-
-#ifdef POINT_PAR
-
-  /* Add Pointing Parameters BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 1; /* tfields */
-  ttype[0] = "PPAR    ";
-  tform[0] = "12E     ";
-
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, NULL, "POINTPAR", &sta);
-
-  /* Pointing parameters */
-  for( n=0; n<11; n++ ) xa[n] = (float) supplhdr.pointing_parameter[n];
-  xa[11] = 0.0;
-  fits_write_col( fits, TFLOAT, 1, 1, 1, 12, xa, &sta );
-
-#endif
-
-  /* Add Processing History BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 18; /* tfields */
-   
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   PHtype, PHform, PHunit, "HISTORY", &sta);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  pch[0] = date_time;
-  fits_write_col( fits, TSTRING, 1, 1, 1, 1, pch, &sta );
-  /* Processing program and command */
-  pch[0] = "WBCOR";
-  fits_write_col( fits, TSTRING, 2, 1, 1, 1, pch, &sta );
-  /* Polarisation identifier */
-  if( npols < 4 ) {
-    str[0] = '\0';
-    k = (*c_c).prod_group[first_normal_group].first_prod;
-    m = 0;
-    for( j=0; j<npols; j++ ) {
-      pol = (*c_c).product[k].polarisation;
-      if( pol == 1 ) strcat( str, "XX" );
-      else if( pol == 2 ) {
-	/* An XY product will be written out as two pols, real and imag */
-	strcat( str, "CRCI" );
-	m++;
-      }
-      else if( pol == 3 ) {
-	/* A YX product will be written out as two pols, real and imag */
-	strcat( str, "CRCI" );
-	m++;
-      }
-      else if( pol == 4 ) strcat( str, "YY" );
-      else strcat( str, "??" );
-      k++;
-    }
-  }
-  else {
-    strcpy( str, "XXYYXYYX" );
-  }
-  pch[0] = str;
-  fits_write_col( fits, TSTRING, 3, 1, 1, 1, pch, &sta );
-
-  /* Nr of pols  - i.e. actually written out */
-  sj = npols + m;
-  fits_write_col( fits, TSHORT, 4, 1, 1, 1, &sj, &sta );
-
-  /* Nr of bins per product (0 for SEARCH mode) */
-  sj = (*c_c).band[0].num_bins;
-  fits_write_col( fits, TSHORT, 5, 1, 1, 1, &sj, &sta );
-
-  /* Nr of bins per period */
-  fits_write_col( fits, TSHORT, 6, 1, 1, 1, &sj, &sta );
-
-  /* Bin time */
-  dx =  (*c_c).pulsar_period / sj;
-  fits_write_col( fits, TDOUBLE, 7, 1, 1, 1, &dx, &sta );
-
-  /* Centre freq. */
-  dx = header.band[0].frequency;  
-  fits_write_col( fits, TDOUBLE, 8, 1, 1, 1, &dx, &sta );
-
-  /* Number of channels */
-  chan_inc = header.band[0].channel_increment;
-  if( chan_inc <= 0 ) chan_inc = 1;
-  n = ( ( header.band[0].last_channel - 
-		   header.band[0].first_channel ) 
-		 / chan_inc ) + 1;
-
-  /* Don't include DC channel */  
-  if( header.band[0].first_channel == 1 ) n--;
-  
-  sj = n;
-  fits_write_col( fits, TSHORT, 9, 1, 1, 1, &sj, &sta );
-
-  /* Channel bandwidth */
-  dy = header.band[0].bandwidth / (double) ( (*c_c).band[0].nfft / 2 );
-  if( header.band[0].spectrum_inverted < 0 ) dy = -dy;
-
-  /* Channel incr. width - signed */
-  dx = (double) chan_inc * dy;
-  fits_write_col( fits, TDOUBLE, 10, 1, 1, 1, &dx, &sta );
-
-  /* Create frequency array for later */
-  /* Get freq. of first channel */
-  if( ( k = header.band[0].first_channel ) == 1 ) k = 2;
-  
-  j = ( (*c_c).band[0].nfft / 4 ) + 1 - k;
-  dz = header.band[0].frequency - ( j * dy );
-
-  for(i=0; i<n; i++ ) {
-    binned_freq[i] = (float) dz;
-    dz += dx;
-  }    
-
-
-  sj = 0;
-  /* Parallactic angle correction applied */
-  fits_write_col( fits, TSHORT, 11, 1, 1, 1, &sj, &sta );
-  /* RM correction applied */
-  fits_write_col( fits, TSHORT, 12, 1, 1, 1, &sj, &sta );
-  /* Data dedispersed */
-  fits_write_col( fits, TSHORT, 13, 1, 1, 1, &sj, &sta );
-  /* Dedispersion method */
-  pch[0] = "NONE";
-  fits_write_col( fits, TSTRING, 14, 1, 1, 1, pch, &sta );
-  /* Scattered power correction method */
-  pch[0] = supplhdr.scpwr;
-  fits_write_col( fits, TSTRING, 15, 1, 1, 1, pch, &sta );
-  /* Calibration method */
-  pch[0] = "NONE";
-  fits_write_col( fits, TSTRING, 16, 1, 1, 1, pch, &sta );
-  /* Name of calibration file */
-  pch[0] = "NONE";
-  fits_write_col( fits, TSTRING, 17, 1, 1, 1, pch, &sta );
-  /* RFI excision method */
-  pch[0] = supplhdr.rfiex;
-  fits_write_col( fits, TSTRING, 18, 1, 1, 1, pch, &sta );
-
-
-  /* Add Original BANDPASS BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 3;  /* tfields */
-
-  nchan_orig = ( (*c_c).band[0].nfft / 2 ) + 1;
-
-  naxes[0] = nchan_orig;
-  naxes[1] = nrcvr;
-
-  sprintf( str, "%ldE", naxes[1] );
-
-  ttype[0] = "DAT_OFFS";
-  tform[0] = str;
-  tunit[0] = "";
-
-  ttype[1] = "DAT_SCL ";
-  tform[1] = str;
-  tunit[1] = "";
-
-  sprintf( Istr, "%ldI", ( naxes[0] * naxes[1] ) );
-  ttype[2] = "DATA    ";
-  tform[2] = Istr;
-  tunit[2] = "Jy      ";
-
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, tunit, "BANDPASS", &sta);
-
-  /* Add dimensions of column 3 = BANDPASS Data */  
-  fits_write_tdim( fits, 3, 2, naxes, &sta );
-
-  /* Add keywords */
-  fits_update_key( fits, TINT, "NCH_ORIG", &nchan_orig,
-		     "Number of channels in original bandpass (I)", &sta);
-  fits_update_key( fits, TINT, "BP_NPOL ", &nrcvr,
-		     "Number of polarizations in bandpass (I)", &sta);
-
-  /* Store hdu number */
-  fits_get_hdu_num( fits, &bpass_hdu );
-
-
-  /* Add Pulsar Ephemeris BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 56; /* tfields */
-
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   PEtype, PEform, NULL, "PSREPHEM", &sta);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  pch[0] = date_time;
-  fits_write_col( fits, TSTRING, 1, 1, 1, 1, pch, &sta );
-  /* Processing program and command */
-  pch[0] = "WBCOR";
-  fits_write_col( fits, TSTRING, 2, 1, 1, 1, pch, &sta );
-  /* Ephemeris version */
-  pch[0] = "PSRINFO:1.4";
-  fits_write_col( fits, TSTRING, 3, 1, 1, 1, pch, &sta );
-
-  /* Open ephemeris file */
-  /* Construct filename  */
-  if( ( qch = getenv( "cor_pulsar" ) ) == NULL ) return(-11);
-
-  strcpy( filename, qch );
-  if( filename[ strlen(filename) - 1 ] != '/' )
-    strcat( filename, "/" );
-  strcat( filename, "online.eph" );
- 
-  if( ( fp = fopen( filename, "r" ) ) == NULL ) return(-12);
-
-  while( fgets( gstr, GSTR_LEN, fp ) != NULL ) {
-
-    if( ( qch = strtok( gstr, " " ) ) != NULL ) {
-
-      /* Following gets a name change - From PSRJ to PSR_NAME */
-      if( strcmp( qch, "PSRJ" ) == 0 ) i = 3;
-      /* Following two get split into integer and fractional parts */
-      else if( strcmp( qch, "F" ) == 0 ) i = 10;
-      else if( strcmp( qch, "F0" ) == 0 ) i = 10; /* Possible alternative to just F */
-      else if( strcmp( qch, "TZRMJD" ) == 0 ) i = 47;
-      else {
-	for( i=0; i<ncols; i++ ) {
-	  if( strcmp( qch, PEtype[i] ) == 0 ) break;
-	}
-      }
-
-      if( i < ncols ) {
-	/* Get next parameter */
-	if( ( rch = strtok( NULL, " " ) ) == NULL ) return(-13);
-
-	if( i == 10 || i == 47 || ( qch = strchr( PEform[i], 'D' ) ) != NULL ) {
-	  /* Change any D exponent to E */
-	  if( ( sch = strrchr( rch, 'D' ) ) != NULL ) *sch = 'E';
-	  tch = sch;
-	
-	  if( i == 10 || i == 47 ) {
-	    /* Convert to integer + fractional part AND
-	       if i == 10 convert from Hz to mHz i.e. multiply by 1000 */
-	    /* Get exponent */
-	    if( sch != NULL ) {
-	      if( sscanf( ++sch, "%d", &j ) != 1 )  return(-91);
-	    }
-	    else j = 0;
-	  
-	    /* get position of decimal point */
-	    if( ( sch = strrchr( rch, '.' ) ) == NULL ) {
-	      /* Integer part only */
-	      if( sscanf( rch, "%ld", &lk ) != 1 ) return(-92);
-	      dx = 0.0;
-	    }
-	    else {
-	      /* Decimal point present */
-	      if( i == 10 ) j += 3;  /* multiply by 1000 - sec. to ms. */
-
-	      if( j >= 0 ) {
-		k = (int) ( sch - rch );
-		if( k > 0 ) {
-		  strncpy( astr, rch, k );
-		  astr[k] = '\0';
-		}
-		else strcpy( astr, "0" );
-	      
-		if( j > 0 ) { /* multiply by 10**j, i.e. move decimal point */
-		  strncat( astr, (sch+1), j );
-		  *(sch += j) = '.';
-		  *--sch = '0';
-		}
-		/* Now astr contains integer part, sch points to fractional part */
-		if( sscanf( astr, "%ld", &lk ) != 1 ) return(-93);
-		/* Don't want exponent - reduced to fraction */
-		if( tch != NULL ) *tch = '\0';
-		if( sscanf( sch, "%lf", &dx ) != 1 ) return(-94);
-	      }
-	      else {
-		/* Fractional part only */
-		lk = 0;
-		if( sscanf( sch, "%lf", &dx ) != 1 ) return(-94);
-		if( i == 10 ) dx *= 1000.0;
-	      }
-	    	    
-	    }
-	  
-	    pv = &lk;
-	    j = TLONG;
-
-	  }
-	  else {
-
-	    if( sscanf( rch, "%lf", &dx ) != 1 ) return(-14);
-
-	    j = TDOUBLE;
-	    pv = &dx;
-
-	  }	
-	}
-	else if( ( qch = strchr( PEform[i], 'A' ) ) != NULL ) {
-	  j = TSTRING;
-	  /* Strip off any trailing newline */
-	  if( ( sch = strrchr( rch, '\n' ) ) != NULL ) *sch = '\0';
-	  pch[0] = rch;
-	  pv = pch;
-	}
-	else if( ( qch = strchr( PEform[i], 'I' ) ) != NULL ) {
-	  j = TSHORT;
-	  if( sscanf( rch, "%d", &k ) != 1 ) return(-15);
-	  sj = k;
-	  pv = &sj;
-	}
-	else if( ( qch = strchr( PEform[i], 'J' ) ) != NULL ) {
-	  j = TINT;
-	  if( sscanf( rch, "%d", &k ) != 1 ) return(-16);
-	  pv = &k;
-	}
-	else return(-17);
-            
-	fits_write_col( fits, j, i+1, 1, 1, 1, pv, &sta );
-
-	/* Write fractional part */
-	if( i == 10 || i == 47 ) {
-	  j = TDOUBLE;
-	  pv = &dx;
-	  fits_write_col( fits, j, i+2, 1, 1, 1, pv, &sta );
-	  
-	  printf( "\n In Ephemeris BINTABLE: %s = %ld %e", PEtype[i], lk, dx );
-	}
-      }
-    }
-  }
-  fclose( fp );
-  
-  /* Add Digitiser Statistics BINTABLE */
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 1; /* tfields */
-
-  wbsam_levs = 2;
-  num_wbsams = nrcvr;
-
-  naxes[0] = wbsam_levs;
-  naxes[1] = num_wbsams;
-  if( ( n = header.cycles_to_avg ) <= 0 ) n = 1;
-  naxes[2] = n;
-
-  sprintf( str, "%ldE", ( naxes[0] * naxes[1] * naxes[2] ) );
-  ttype[0] = "DATA    ";
-  tform[0] = str;
-
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   ttype, tform, NULL, "DIG_STAT", &sta);
-
-  /* Add dimensions of column 1 = Data */  
-  fits_write_tdim( fits, 1, 3, naxes, &sta );
-
-  /* Add keywords */
-  fits_update_key( fits, TSTRING, "DIG_MODE", "2-bit,3-level",
-		     "Digitiser mode", &sta);
-  fits_update_key( fits, TINT, "NDIGR", &num_wbsams,
-		     "Number of digitised channels (I)", &sta);
-  fits_update_key( fits, TINT, "NLEV", &wbsam_levs,
-		     "Number of digitiser levels (I)", &sta);
-  fits_update_key( fits, TINT, "NCYCSUB", &n,
-		     "Number of correlator cycles per subint (I)", &sta);
-
-  /* Store current hdu number */
-  fits_get_hdu_num( fits, &dig_stats_hdu );
-
-
-  
-  /* Add Polyco History BINTABLE */
-
-  /* Read in polyco file */
-  /* Construct filename from .eph name  */
-
-  qch = strstr( filename, ".eph" );
-  *qch = '\0';
-  strcat( filename, ".polyco" );
-  if( ( fp = fopen( filename, "r" ) ) == NULL ) return(-18);
-
-  k = 0;
-  while( ( k < MAX_BLKS ) && 
-	 ( ( n = fscanf( fp, "%s %s%lf%lf%lf%lf%lf%lf%lf %s%hd%hd%lf%16c", 
-			 gstr, gstr, &dx, &rmjd[k], &dx, &dx, &lgfiterr[k], &rphase[k], &f0[k],
-			 site[k], &nspan[k], &ncoeff[k], &rfreq[k], gstr ) ) != EOF ) ) {
-    if( n != 14 ) return(-20);
-    if( ncoeff[k] > MAX_COEFF ) return(-21);
-    
-    for( i=0; i<ncoeff[k]; i++ ) {
-      if( fscanf( fp, "%s", gstr  ) != 1 ) return(-22);
-      /* Translate exponent D to E */
-      if( ( qch = strchr( gstr, (int) 'D' ) ) != NULL ) *qch = 'E';
-      if( sscanf( gstr, "%lE", &coeff[k][i] ) != 1 ) return(-23);
-    }
-    for( i=ncoeff[k]; i<MAX_COEFF; i++ ) coeff[k][i] = 0.0;
-    k++;
-  }
-  if( k >= MAX_BLKS ) return(-24);
-  
-  fclose( fp );
-
-  printf("\nCFITS_SUBS:  Polyco - Site[0,1](hex) = %x %x", site[0][0], site[0][1] );
-  
-
-  nrows = 0;  /* naxis2 - Let CFITSIO sort this out */
-  ncols = 13; /* tfields */
-  
-
-  fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		   PPtype, PPform, NULL, "POLYCO  ", &sta);
-
-  /* Processing date and time (YYYY-MM-DDThh:mm:ss UTC) */
-  for( i=0; i<k; i++ ) pch[i] = date_time;
-  fits_write_col( fits, TSTRING, 1, 1, 1, k, pch, &sta );
-  /* Polyco version */
-  for( i=0; i<k; i++ ) pch[i] = "TEMPO:11.0";
-  fits_write_col( fits, TSTRING, 2, 1, 1, k, pch, &sta );
-  /* Span of polyco in min */
-  fits_write_col( fits, TSHORT, 3, 1, 1, k, nspan, &sta );
-  /* Nr of coefficients - per block */
-  fits_write_col( fits, TSHORT, 4, 1, 1, k, ncoeff, &sta );
-  /* Nr of polyco blocks (of NCOEF coefficients) -reuse nspan array */
-  for( i=0; i<k; i++ ) nspan[i] = k;
-  fits_write_col( fits, TSHORT, 5, 1, 1, k, nspan, &sta );
-  /* TEMPO site code - 1 character */
-  for( i=0; i<k; i++ ) pch[i] = &site[i][0];
-  fits_write_col( fits, TSTRING, 6, 1, 1, k, pch, &sta );
-  /* Reference frequency for phase */
-  fits_write_col( fits, TDOUBLE, 7, 1, 1, k, rfreq, &sta );
-
-  /* Predicted pulse phase at obs start - reuse rfreq  */
-  for( i=0; i<k; i++ ) rfreq[i] = newcycle.WBpsr_timer_start_phase;
-  fits_write_col( fits, TDOUBLE, 8, 1, 1, k, rfreq, &sta );
-
-  /* Reference MJD - NPBLK doubles */
-  fits_write_col( fits, TDOUBLE, 9, 1, 1, k, rmjd, &sta );
-  /* Reference phase - NPBLK doubles */
-  fits_write_col( fits, TDOUBLE, 10, 1, 1, k, rphase, &sta );
-  /* Reference F0 - NPBLK doubles */
-  fits_write_col( fits, TDOUBLE, 11, 1, 1, k, f0, &sta );
-  /* Fit error - NPBLK doubles */
-  fits_write_col( fits, TDOUBLE, 12, 1, 1, k, lgfiterr, &sta );
-  /* Polyco coefficients - NPBLK*NCOEF doubles */
-  j = k * MAX_COEFF;
-  fits_write_col( fits, TDOUBLE, 13, 1, 1, j, &coeff[0][0], &sta );
-
-
-  /* Store last header hdu number */
-  fits_get_hdu_num( fits, &last_scanhdr_hdu );
-  
-  /* Restart SUBINT counter */
-  subint_cnt = 0;
-  
-  return( sta );
-
-}
-
-
-
-void CDfits_fill_scanhdr( double *ut_secs )
-{
-  
-}
-
-
-int CDfits_fill_mosaic_list( char *buf, char *errstr )
-{
-
-  return(0);
-  
-}
-
-
-
-int CDfits_write_data( __complex__ float *data, int xant, int yant,
-		     float ut_secs, float u, float v, float w,
-		     int flag, int bin_num, int if_number, 
-		     int source_number, float integration_time )
-{
-  return( 0 );
-  
-}
-
-
-
-int CDfits_write_syscal( float ut_secs, int band_num, int source_num )
-{
-
-  return( 0 );
-  
-}
-
-int CDfits_write_subint( int num_cycles, int num_bins, int num_chans, int num_pols )
-{
-  int sta;
-  int j, k;
-  int nscl, ndata;
-  float x;
-  double dx, dy, dz, ds, dc;
-    
-  int nrows, ncols, col;
-  char *ttype[19], *tform[19], *tunit[19];
-  long naxes[3];
-  
-  char Cstr16[16], Estr16[16], Istr16[16];
-
-#define ASTR_LEN 32
-  char astr[ ASTR_LEN ];
-
-  
-  /* BEGIN */
-
-  nscl =  num_chans * num_pols;
-  ndata = num_bins * nscl;
-
-  sta = 0;
-  
-  /* Increment SUBINT counter and if first SUBINT, write header */
-  if( ++subint_cnt == 1 ) {
-
-    /* Add START TIME to primary HDU */
-    /* Move to primary HDU */
-    fits_movabs_hdu( fits, 1, NULL, &sta );
-
-    if( bat_to_ut_str( astr, ASTR_LEN, newcycle.WBpsr_timer_start_bat ) < 0 ) {
-      return( -9999 );
-    }
-    
-    astr[10] = '\0';
-    fits_update_key( fits, TSTRING, "STT_DATE", astr,
-		     "Start UT date (YYYY-MM-DD)", &sta);
-    fits_update_key( fits, TSTRING, "STT_TIME", &astr[11],
-		     "Start UT (hh:mm:ss)", &sta);
-
-    bat_to_mjd( &dx, newcycle.WBpsr_timer_start_bat );
-
-    dz = modf( dx, &dy );   /* dz = fractional day,  dy = days */    
-
-    j = (int) floor( ( dy + 0.1 ) );  /* Add 0.1d to make sure we get the correct one */
-    fits_update_key( fits, TINT, "STT_IMJD", &j,
-		     "Start MJD (UTC days) (J)", &sta);
-    
-    dy = dz * 86400.0;   /* This should be an exact second - timer starts on 1pps */
-    k = (int) floor( ( dy + 0.1 ) );   /* Add 0.1s to make sure we get the correct one */
-    fits_update_key( fits, TINT, "STT_SMJD", &k,
-		     "[s] Start time (sec past UTC 00h) (J)", &sta);
-
-    /* Add in offset = 1 - start phase - one bin !!!!!!!!!!! */
-    /* 9 Jun 2004 - remove one bin offset - wrong !! */
-    /* Was:
-       dz = 1.0 - modf( newcycle.WBpsr_start_psr_phase, &dx ) - 1.0 / (double) num_bins; 
-       dz *= (*c_c).pulsar_period;
-       Now: the offset time is available directly */
-    dz = newcycle.WBpsr_timer_start_offset_secs;
-    
-    /* Quantise to 128MHz clock cycles */
-    dz *= 128.0E06;
-    dx = floor( dz );
-    dx /= 128.0E06;
-    
-    fits_update_key( fits, TDOUBLE, "STT_OFFS", &dx,
-		     "[s] Start time offset (D)", &sta);
-
-    /* LST provided corresponds to integ. start time, i.e. oldcycle.bat */
-    bat_to_ut_secs( &dy, oldcycle.bat );
-    dy += dx;
-    dx = scan_start_time_secs - dy;
-    if( dx < -43200.0 ) dx += 86400.0;
-    if( dx >  43200.0 ) dx -= 86400.0;
-    dy = ( ( oldcycle.lst * 86400.0 ) / TwoPi ) + ( dx * 1.002737909350795 );
-    if( dy < 0.0 ) dy += 86400.0;
-    if( dy > 86400.0 ) dy -= 86400.0;
-    fits_update_key( fits, TDOUBLE, "STT_LST ", &dy,
-		     "[s] Start LST (D)", &sta);
-
-    /* Finished with primary HDU */
-
-    /* Move to last created HDU in scan header */
-    fits_movabs_hdu( fits, last_scanhdr_hdu, NULL, &sta );
-    
-
-    /* Create SUBINT BINTABLE */
-
-    nrows = 0; /* naxis2 - Let CFITSIO sort this out */
-    ncols = 19; /* tfields */
-
-    ttype[0] = "ISUBINT ";    /* Subint number. If NAXIS=-1, 0 indicates EOD. */
-    tform[0] = "1J      ";
-    tunit[0] = "";
-    ttype[1] = "INDEXVAL";    /* Optionally used if INT_TYPE != TIME */
-    tform[1] = "1D      ";
-    tunit[1] = "";
-    ttype[2] = "TSUBINT ";    /* [s] Length of subintegration */
-    tform[2] = "1D      ";
-    tunit[2] = "";
-    ttype[3] = "OFFS_SUB";    /* [s] Offset from Start UTC of subint centre */
-    tform[3] = "1D      ";
-    tunit[3] = "";
-    ttype[4] = "LST_SUB ";    /* [s] LST at subint centre */
-    tform[4] = "1D      ";
-    tunit[4] = "";
-    ttype[5] = "RA_SUB  ";    /* [turns] RA (J2000) at subint centre */
-    tform[5] = "1D      ";
-    tunit[5] = "";
-    ttype[6] = "DEC_SUB ";    /* [turns] Dec (J2000) at subint centre */
-    tform[6] = "1D      ";
-    tunit[6] = "";
-    ttype[7] = "GLON_SUB";    /* [deg] Gal longitude at subint centre */
-    tform[7] = "1D      ";
-    tunit[7] = "";
-    ttype[8] = "GLAT_SUB";    /* [deg] Gal latitude at subint centre */
-    tform[8] = "1D      ";
-    tunit[8] = "";
-    ttype[9] = "FD_ANG  ";    /* [deg] Feed angle at subint centre */
-    tform[9] = "1E      ";
-    tunit[9] = "";
-    ttype[10] = "POS_ANG ";    /* [deg] Position angle of feed at subint centre */
-    tform[10] = "1E      ";
-    tunit[10] = "";
-    ttype[11] = "PAR_ANG ";    /* [deg] Parallactic angle at subint centre */
-    tform[11] = "1E      ";
-    tunit[11] = "";
-    ttype[12] = "TEL_AZ  ";    /* [deg] Telescope azimuth at subint centre */
-    tform[12] = "1E      ";
-    tunit[12] = "";
-    ttype[13] = "TEL_ZEN ";    /* [deg] Telescope zenith angle at subint centre */
-    tform[13] = "1E      ";
-    tunit[13] = "";
-
-    sprintf( Cstr16, "%dE", num_chans );
-    ttype[14] = "DAT_FREQ";
-    tform[14] = Cstr16;
-    tunit[14] = "";
-    ttype[15] = "DAT_WTS ";
-    tform[15] = Cstr16;
-    tunit[15] = "";
-
-    sprintf( Estr16, "%dE", nscl );
-    ttype[16] = "DAT_OFFS";
-    tform[16] = Estr16;
-    tunit[16] = "";
-    ttype[17] = "DAT_SCL ";
-    tform[17] = Estr16;
-    tunit[17] = "";
-
-    sprintf( Istr16, "%dI", ndata );
-    ttype[18] = "DATA    ";
-    tform[18] = Istr16;
-    tunit[18] = "Jy      ";
-
-
-    fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		     ttype, tform, tunit, "SUBINT  ", &sta);
-
-    /* Add dimensions of column 'ncols' = SUBINT Data */
-    naxes[0] = num_bins;
-    naxes[1] = num_chans;
-    naxes[2] = num_pols;
-  
-    fits_write_tdim( fits, ncols, 3, naxes, &sta );
-
-    /* Add keywords */
-    fits_update_key( fits, TSTRING, "INT_TYPE", "TIME",
-		     "Time axis (TIME, BINPHSPERI, BINLNGASC, etc)", &sta);
-
-    fits_update_key( fits, TSTRING, "INT_UNIT", "SEC",
-		     "Unit of time axis (SEC, PHS (0-1), DEG)", &sta);
-
-    fits_update_key( fits, TINT, "NCH_FILE", &num_chans,
-		     "Number of channels/sub-bands in this file (I)", &sta);
-    j = 0;
-    fits_update_key( fits, TINT, "NCH_STRT", &j,
-		     "Start channel/sub-band number (0 to NCHAN-1) (I)", &sta);
-    
-    /* Store subint hdu number */
-    fits_get_hdu_num( fits, &subint_hdu );
-
-  }
-  
-  /* Write SUBINT BINTABLE columns */
-
-  /* Fill in columns of table */
-  col = 1;
-  
-  /* Subint number. If NAXIS=-1, 0 indicates EOD. */
-  fits_write_col( fits, TINT, col, subint_cnt, 1, 1, &subint_cnt, &sta );
-  col++;
-  
-  /* INDEXVAL - Optionally used if INT_TYPE != TIME */
-  dx = 0.0;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [s] Length of subint */
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &sum_subint_len_secs, &sta );
-  col++;
-
-  /* [s] Offset from Start UTC of subint centre */
-  dx = sum_subint_mid_pt / sum_subint_len_secs;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [s] LST at subint centre */
-  ds = sum_subint_lst_sin / sum_subint_len_secs;
-  dc = sum_subint_lst_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 86400.0;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [turns] RA (J2000) at subint centre */
-  ds = sum_subint_ra_sin / sum_subint_len_secs;
-  dc = sum_subint_ra_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [turns] Dec (J2000) at subint centre */
-  ds = sum_subint_dec_sin / sum_subint_len_secs;
-  dc = sum_subint_dec_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) / TwoPi;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [deg] Gal longitude at subint centre */
-  ds = sum_subint_Glon_sin / sum_subint_len_secs;
-  dc = sum_subint_Glon_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 360.0;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [deg] Gal latitude at subint centre */
-  ds = sum_subint_Glat_sin / sum_subint_len_secs;
-  dc = sum_subint_Glat_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) * 360.0 / TwoPi;
-  fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-  col++;
-
-  /* [deg] Feed angle at subint centre */
-  ds = sum_subint_fa_sin / sum_subint_len_secs;
-  dc = sum_subint_fa_cos / sum_subint_len_secs;
-  dx = atan2( ds, dc ) * 360.0 / TwoPi;
-  x = (float) dx;
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-  col++;
-
-  /* [deg] Parallactic angle at subint centre */
-  ds = sum_subint_pa_sin / sum_subint_len_secs;
-  dc = sum_subint_pa_cos / sum_subint_len_secs;
-  dy = atan2( ds, dc ) * 360.0 / TwoPi;
-
-  /* [deg] Position angle of feed at subint centre */
-  dx = dx + dy;
-  if( dx > 180.0 ) dx -= 360.0;
-  if( dx < 180.0 ) dx += 360.0;
-  x = (float) dx;
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-  col++;
-
-  /* [deg] Parallactic angle at subint centre */
-  x = (float) dy;
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-  col++;
-
-  /* [deg] Telescope azimuth at subint centre */
-  ds = sum_subint_az_sin / sum_subint_len_secs;
-  dc = sum_subint_az_cos / sum_subint_len_secs;
-  if( ( dx = ( atan2( ds, dc ) / TwoPi ) ) < 0.0 ) dx += 1.0;
-  dx *= 360.0;
-  x = (float) dx;
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-  col++;
-
-  /* [deg] Telescope zenith angle at subint centre */
-  ds = sum_subint_el_sin / sum_subint_len_secs;
-  dc = sum_subint_el_cos / sum_subint_len_secs;
-  dx = 90.0 - ( atan2( ds, dc ) * 360.0 / TwoPi );
-  x = (float) dx;
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-  col++;
-
-
-  /* Centre freq. for each channel - NCHAN floats */
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, num_chans, binned_freq, &sta );
-  col++;
-
-  /* Weights for each channel -  NCHAN floats */
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, num_chans, binned_weight, &sta );
-  col++;
-
-  /* Data offset for each channel - NCHAN*NPOL floats */
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, nscl, binned_offset, &sta );
-  col++;
-
-  /* Data scale factor for each channel - NCHAN*NPOL floats */
-  fits_write_col( fits, TFLOAT, col, subint_cnt, 1, nscl, binned_scale, &sta );
-  col++;
-
-  /* Subint data table - Dimensions of data table = (NBIN,NCHAN,NPOL) */
-  fits_write_col( fits, TSHORT, col, subint_cnt, 1, ndata, binned_data, &sta );
-  col++;
-  
-  /* Finished SUBINT */
-
-#define STEP_BACK
-#ifdef STEP_BACK
-
-  /* Move to digitiser statistics  */
-  fits_movabs_hdu( fits, dig_stats_hdu, NULL, &sta );
-
-  if( subint_cnt == 1 ) {
-    
-    /* Now we know whether samplers are in fixed or auto mode - Add DIGLEV key */
-    if( (*c_c).wb_ifsam.freq[0].ant[0].pol[0].sam_sta & WBSAM_FIXED )
-      strcpy( astr, "FIX" );
-    else 
-      strcpy( astr, "AUTO" );
-    fits_update_key( fits, TSTRING, "DIGLEV", astr,
-		     "Digitiser level-setting mode (AUTO, FIX)", &sta);
-  }
-  
-  /* Add data for this subint */
-  fits_write_col( fits, TFLOAT, 1, subint_cnt, 1, num_wbsam_stats, wbsam_stats, &sta );
-
-
-  /* Move to bandpass  */
-  fits_movabs_hdu( fits, bpass_hdu, NULL, &sta );
-  /* Overwrite row 1 with latest data  */
-
-  /* Data offset for each receiver channel - NRCVR floats */
-  fits_write_col( fits, TFLOAT, 1, 1, 1, nrcvr, bpass_offset, &sta );
-
-  /* Data scale factor for each receiver channel - NRCVR floats */
-  fits_write_col( fits, TFLOAT, 2, 1, 1, nrcvr, bpass_scale, &sta );
-
-  /* Bandpass data table - Dimensions of data table = (NCHAN_orig,NRCVR) */
-  ndata = nchan_orig * nrcvr;
-  fits_write_col( fits, TSHORT, 3, 1, 1, ndata, bpass_data, &sta );
-
-
-  /* Move back to subint HDU for next subint */
-  fits_movabs_hdu( fits, subint_hdu, NULL, &sta );
-
-#endif /* STEP_BACK */
-
-  /* Now FLUSH any internal buffers to the file */
-  fits_flush_file( fits, &sta );
-
-
-  return( sta );
-  
-}
-
-
-
-int CDfits_close_reopen_file( void )
-{
-  return( 0 );
-  
-}
-
-int CDfits_close_file( void )
-{
-  int sta;
-  
-  sta = 0;
-  fits_close_file( fits, &sta );
-  return( sta );
-  
-}
-
-
diff --git a/filterbank-gmrt/pulse.c b/filterbank-gmrt/pulse.c
deleted file mode 100644
index b511cbf..0000000
--- a/filterbank-gmrt/pulse.c
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-  This program will search for non-periodic pulses in single-byte
-  dedispersed data. It applues a threshold test on a time series for
-  a single DM channel.
-
-  This program serves as a driver program, reading in data, analyzing
-  each DM channel, and looping over all channels.
-
-  v. 0.0  TJWL  29 Sept 1994
-  v. 0.1  MAM   26 Jul  1996 - corrected pulse indexing
-  v. 0.2  MAM   15 Sep  2001 - adapted to Parkes data format
-			     - compressed output files
-
-  The inputs to this subroutine include. 
-
-   'thresh' - Number of standard deviations by which a candidate must
-	      exceed the mean to be considered a detection.
-
-   'nsmax' - The maximum number of times to smooth the data.
-
-   'ndm' - The DM index of the searched time series.
-	 
-   'length' - Number of time samples to be read.
-
-   'data' - Input data array in single-byte format.
-
-   'loopsize' - is equal to ndatfft/8, with its max defined in pulse.h 
-*/
-#include <errno.h>
-#include <fcntl.h>
-#include <malloc.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include "pulse.h"
-
-#define STDOUT       1
-#define FOPENMAX	100
-
-int pulse_(realdata, thresh, nsmax, ndm, length, data, loopsize, scrdsk1, lsd1)
-int *nsmax, *length, *ndm, *loopsize, *lsd1;
-char scrdsk1[];
-float *thresh, realdata[];
-float *data;
-
-{
-  int done;
-  int ndata;                          /* number of floats to be read       */
-  int ndata2;                         /* number of floats sent to single_ch*/
-  int nover;                          /* number of samples to overlap      */
-                                      /* since the largest boxcar filter is*/
-                                      /* 2**(NSMAX-1) "bins" wide, nover   */
-                                      /* will be set to 2**(NSMAX+1)       */
-  int n, i, iloop, iover, iopt, npulse, nloops, ierr;
-  float testdata;
-  double mean, rms, smean, srms, test;
-  float *overlap;
-  char *file, *file2, *outfile; 
-  FILE *fd;
-
-  scrdsk1[*lsd1]=NULL;
-
-  nover = (int)pow(2.0, (double)(*nsmax+1));
-  if ((overlap=(float *)malloc( sizeof(float)*(unsigned)nover)) == NULL )
-    exit( 3 );
-
-  if ( *thresh < 0.0 )
-    {
-      if ( fprintf(stderr, "Thresh = 0!\n")  == EOF ) exit( EOF );
-      exit( 1 );
-    }
-
-  ierr = open_files(scrdsk1);		/* open new temporary output file */
-
-  n = *loopsize - nover;                   /* used for           */
-                                           /* overlapping        */
-  iover = 0;
-  iindx = 0;
-  iloop = 0;
-  nloops = (*length-nover)/(*loopsize) + 1;
-  ndata = *loopsize;
-
-  for (iloop=0; iloop<nloops; iloop++) {
-
-  ndata2 = ndata + iover; 
-
-  for (i=iover; i<ndata2; i++) realdata[i] = data[i+iindx];
-  if ( iloop > 1 ) for (i=0; i<nover; i++)  realdata[i] = overlap[i];
-
-  for (i=n; i<ndata2; i++) overlap[i-n] = realdata[i];
-
-      single_ch(ndata2, realdata, *nsmax, *thresh, *ndm, scrdsk1); 
-
-      iover = nover;
-      ndata = n;
-      iindx += n;
-  }
-return 0;
-}
diff --git a/filterbank-gmrt/pulse.h b/filterbank-gmrt/pulse.h
deleted file mode 100644
index e72dcff..0000000
--- a/filterbank-gmrt/pulse.h
+++ /dev/null
@@ -1,48 +0,0 @@
-typedef struct plinfo {
-  int index;                          /* the position of the pulse         */
-  float amp;                          /* the amplitude of the pulse in     */
-                                      /* of the standard deviation         */
-  double mean;                        /* the mean of the "chunk" where the */
-                                      /* pulse was found                   */
-  double rms;                         /* the rms of the "chunk" where the  */
-
-} Pulsus;
-
-int iindx;                            /* Since we don't read in the entire */
-                                      /* file at once, we must keep track  */
-                                      /* of how many reads have been done  */
-                                      /* on the file in order to get the   */
-                                      /* pulse index correct in the time   */
-                                      /* series.                           */
-
-char *optarg;
-int opterr;
-int optind;
-
-unsigned short iterate;               /* Use iterative method for mean     */
-                                      /* and rms?  iterate==0 means no     */
-float thresh;                         /* The threshold in units of the rms */
-
-char file_name[80];                   /* Basename of input file            */
-char input_file[80];                  /* Full name of input file           */
-
-int ndm;                              /* dm channel number from file name  */ 
-
-int nsubband;                         /* subband number from file name     */
-
-int nsmax;                            /* maximum number of smoothings to try */
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/filterbank-gmrt/pulse.inc b/filterbank-gmrt/pulse.inc
deleted file mode 100644
index 644c044..0000000
--- a/filterbank-gmrt/pulse.inc
+++ /dev/null
@@ -1,9 +0,0 @@
-c==============================================================================
-c Definition of the variables passed to the single-pulse program.
-c==============================================================================
-c
-      logical nofft
-      integer ncandsmax, nsmax
-      real spthresh
-c
-c==============================================================================
diff --git a/filterbank-gmrt/put.c b/filterbank-gmrt/put.c
deleted file mode 100644
index 1bfddec..0000000
--- a/filterbank-gmrt/put.c
+++ /dev/null
@@ -1,25 +0,0 @@
-#include <stdio.h>
-void puti(int i) /*includefile*/
-{
-  printf("%d\n",i);
-}
-void putf(float f) /*includefile*/
-{
-  printf("%.f\n",f);
-}
-void putd(double d) /*includefile*/
-{
-  printf("%.12lf\n",d);
-}
-void putu(unsigned long l) /*includefile*/
-{
-  printf("%ld\n",l);
-}
-void putl(long l) /*includefile*/
-{
-  printf("%ld\n",l);
-}
-void putld(long double d) /*includefile*/
-{
-  printf("%llf\n",d);
-}
diff --git a/filterbank-gmrt/quicklook.csh b/filterbank-gmrt/quicklook.csh
deleted file mode 100755
index a6af625..0000000
--- a/filterbank-gmrt/quicklook.csh
+++ /dev/null
@@ -1,303 +0,0 @@
-# QUICKLOOK : a csh script to process fast-sampled pulsar data 
-if ($1 == "" || $1 == "help") then
-    echo ""
-    echo "usage: quicklook <filename> -{options}"
-    echo ""
-    echo "options:"
-    echo ""
-    echo "-read time   - read and process only time (s) of data"
-    echo "-skip time   - skip the first time (s) of data"
-    echo "-addc nchans - add nchans chans together before dedispersion (def=none)"
-    echo "-addt nsamps - add nsamps samples together before dedispersion (def=none)"
-    echo "-nsints   n  - specify number of time sub-integrations (def=8)"
-    echo "-nbands   n  - specify number of frequency sub-bands (def=8)"
-    echo "-period p    - fold data at constant period (ms) (def=polyco)"
-    echo "-dm dmvalue  - dedisperse using dmvalue (pc cm-3) (def=polyco)"
-    echo "-clip value  - clip samples that deviate more than value*rms (def=noclipping)"
-    echo "-nbins n     - fold data using n bins (def=128)"
-    echo "-left phase  - specify left-hand phase window (def=0.0)"
-    echo "-right phase - specify right-hand phase window (def=0.0)"
-    echo "-singlepulse - set number of subints to be the number of pulses"
-    echo "-psr name    - fix source name for running TEMPO (def=filestem)"
-    echo "-mypolyco    - use an existing polyco file (def=make one)"
-    echo "-fakescale   - plot channels/bands using fake grey scale (def=real)"
-    echo "-clean       - remove large files before and after (def=keep them)"
-    echo "-wipe        - remove large files beforehand (def=keep them)"
-    echo "-ext string  - add a file extension string to output files (def=none)"
-    echo ""
-    exit
-endif
-
-# set up some default options
-set addt = 1
-set addc = 1
-set clip = ""
-set readopt = ""
-set skipopt = ""
-set sints = 8
-set singlepulse = 0
-set bands = 8
-set period = "polyco.dat"
-set dm = -1.0
-set binopt = "-n 128"
-set lopt = ""
-set ropt = ""
-set ext = ""
-if (-e phasestart) rm -f phasestart
-set polyname = ""
-set mypolyco = 0
-set clean = 0
-set wipe = 0
-set plotopt = "greyscale"
-
-# check out state of input file and get a polyco name
-set filename = $1
-if (-e $filename) then
-	  set polyname  = `echo $filename | awk -F. '{print substr($1,2,7)}'`
-else
-	  echo "file: $filename not found..."
- 	  exit
-endif
-
-# check on free diskspace and exit if less remaining than the current file
-
-set freespace = `df -k . | tail -1 | awk '{print $4*1024.0}'`
-set filespace = `ls -ln $filename | awk '{print $5*1.0}'`
-set full = \
-`echo "$filespace $freespace"  | awk '{if ($1>$2) {print 1} else {print 0}}'`
-set full = 0
-if ($full == "1") then
-	echo "not enough free space..."
-	df -k .
-	exit
-endif
-
-# parse the rest of the command line
-set i = 1
-set skipping = 1
-foreach item ($argv)
-	@ next = $i + 1
-	switch ($item)
-	case -read:
-		set readopt = "-r $argv[$next]"
-		set skipping = 1
-		breaksw
-	case -skip:
-		set skipopt = "-s $argv[$next]"
-		set skipping = 1
-		breaksw
-	case -nsints:
-		set sints = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -singlepulse:
-		set singlepulse = 1
-		set skipping = 0
-		breaksw
-	case -nbands:
-		set bands = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -addc:
-		set addc = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -addt:
-		set addt = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -clip:
-		set clip = "-c $argv[$next]"
-		set skipping = 1
-		breaksw
-	case -period:
-		set period = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -left:
-		set lopt = "-l $argv[$next]"
-                echo $argv[$next] >! phasestart
-		set skipping = 1
-		breaksw
-	case -right:
-		set ropt = "-r $argv[$next]"
-		set skipping = 1
-		breaksw
-	case -dm:
-		set dm = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -nbins:
-		set binopt = "-n $argv[$next]"
-                if ($argv[$next] == "opt") set binopt = ""
-		set skipping = 1
-		breaksw
-	case -psr:
-		set source = $argv[$next]
-		set skipping = 1
-		breaksw
-	case -mypolyco:
-		set mypolyco = 1
-		set skipping = 0
-		breaksw
-	case -clean:
-		set clean = 1
-                set wipe = 1
-		set skipping = 0
-		breaksw
-	case -wipe:
-		set wipe = 1
-		set skipping = 0
-		breaksw
-	case -fakescale:
-		set plotopt = ""
-		set skipping = 0
-		breaksw
-	case -ext:
-		set ext = $argv[$next]
-		set skipping = 1
-		breaksw
-	default:
-		if ($skipping == 0) then
-                  quicklook help
-		  echo "ERROR: command-line argument $item not recognized"
-		  exit
-		endif
-		set skipping = 0
-		breaksw
-	endsw
-	set i = $next
-end
-
-# wipe output data files before starting if requested
-if ($wipe == "1") then
-  if ($mypolyco == 0) rm -f polyco.dat
-  rm -f $filename.fil $filename.sub $filename.tim subbands.epn subints.epn
-endif
-
-	set mjd = `filterbank $filename | header -tstart`
-# establish whether we need to generate a polyco.dat file...
-if ( ($period == polyco.dat) && ($mypolyco == 0) ) then	
-	# get mjd and try to generate polyco
-	echo "polyco $polyname -mjd $mjd"
-	polyco $polyname -mjd $mjd  >! polyco.log
-	set psize = `ls -l polyco.dat | awk '{print $5}'`
-	if ($psize == 0) then
-		echo "ERROR creating polyco.dat...."
-		cat polyco.log
-		exit
-	endif
-endif
-
-# get the dm from the polyco if not already set by user
-if ($dm == -1.0) set dm = `head -1 polyco.dat | awk '{print $5}'`
-
-# produce filterbank file if necessary
-if (! -e $filename.fil) then
-   if (($addc>1) || ($addt>1)) then
-	echo "filterbank $filename -sumifs $readopt $skipopt | decimate -t $addt -c $addc -n 32 > $filename.fil"
-	      filterbank $filename -sumifs $readopt $skipopt | decimate -t $addt -c $addc -n 32 > $filename.fil
-   else 
-	echo "filterbank $filename -sumifs $readopt $skipopt > $filename.fil"
-        filterbank $filename -sumifs $readopt $skipopt > $filename.fil
-   endif
-else
-	echo "filterbank file: $filename.fil found"
-endif
-
-# make a little ascii header for later reading by the plot program
-header $filename.fil >! $filename.hdr
-
-# check whether we need to dedisperse a different number of subbands
-if (-e $filename.sub) then
-	set test = `header $filename.sub -nchans`
-	if ($test != $bands) rm -f $filename.sub
-else
-	rm -f $filename.sub
-endif
-
-# check to see if user has asked for all channels to be folded
-if ($bands == "all") then
-        if (-e $filename.sub) rm -f $filename.sub
-        # just make a link to the filterbank file!
-        ln -s $filename.fil $filename.sub
-else
-# form dedispersed sub-bands if necessary
-if (! -e $filename.sub) then
-	echo "dedisperse $filename.fil -d $dm -b $bands $clip> $filename.sub"
-	      dedisperse $filename.fil -d $dm -b $bands $clip> $filename.sub
-endif
-endif
-
-# fold subbands
-echo "fold $filename.sub -p $period $binopt $lopt $ropt -epn >! subbands.epn"
-      fold $filename.sub -p $period $binopt $lopt $ropt -epn >! subbands.epn
-
-# produce time series file if necessary (n.b sub bands only need to be added)
-if (! -e $filename.tim) then
-	echo "dedisperse $filename.sub -d $dm > $filename.tim"
-	      dedisperse $filename.sub -d $dm > $filename.tim
-else
-	echo "time series file: $filename.tim found"
-endif
-
-# produce 1024-sample average of time series
-        echo "decimate $filename.tim -T 1024 | reader >! timeseries"
-              decimate $filename.tim -T 1024 | reader >! timeseries
-
-# grab relevant parameters from the filterbank data header
-set telescope = `header $filename.fil -telescope`
-set machine   = `header $filename.fil -machine`
-set fch1      = `header $filename.fil -fch1`
-set foff      = `header $filename.fil -foff`
-set nchans    = `header $filename.fil -nchans`
-set nbits     = `header $filename.fil -nbits`
-set tsamp     = `header $filename.fil -tsamp`
-set tobs      = `header $filename.fil -tobs`
-set fcent     = `echo "$fch1 $foff $nchans" | awk '{print $1+$2*($3-1.0)/2.0}'`
-set bandwidth = `echo "$foff $nchans" | awk '{print sqrt($1*$1)*$2}'`
-set tdump     = `echo "$tobs $sints" | awk '{print $1/$2}'`
-if ($singlepulse == 1) set tdump = 1
-set cal       = `grep "Gregorian" $filename.hdr | awk '{print $NF}'`
-
-# put these in asciiheader file for use by the plot program
-cat << END    >! asciiheader
-$telescope
-$machine  
-$filename 
-$polyname 
-$mjd      
-$cal      
-$fcent    
-$bandwidth
-$fch1     
-$foff     
-$nchans   
-$tsamp    
-$tobs     
-$period   
-$dm       
-END
-
-# fold time series
-echo "fold $filename.tim -p $period $binopt -d $tdump $lopt $ropt -epn >! subints.epn"
-      fold $filename.tim -p $period $binopt -d $tdump $lopt $ropt -epn >! subints.epn
-
-# create postscript file summary and master epn file 
-quickplot $plotopt
-mv $filename.ps $filename$ext.ps
-cat subbands.epn subints.epn > $filename$ext.epn
-if (-e polyco.dat) cp polyco.dat $filename$ext.pco
-set date = `date`
-echo "all done... $date"
-echo "plotepn $filename$ext.epn"
-echo "gv $filename$ext.ps"
-echo "more $filename$ext.pco"
-
-# wipe output data files unless requested otherwise
-if ($clean == "1") then
-  if ($mypolyco == 0) rm -f polyco.dat
-  rm -f $filename.fil $filename.sub $filename.tim subbands.epn subints.epn
-endif
-
-exit
diff --git a/filterbank-gmrt/quickplot.f b/filterbank-gmrt/quickplot.f
deleted file mode 100644
index e19fa19..0000000
--- a/filterbank-gmrt/quickplot.f
+++ /dev/null
@@ -1,1544 +0,0 @@
-c==============================================================================
-      program quickplot
-c==============================================================================
-c
-c     Create postscript summary plot of output from the "quicklook" script 
-c
-      implicit none
-
-      include 'epnhdr.f'
-      integer nepnrec,i,j,nchan,nshift,nsubints,slen,nc,lun,istat
-      real x(maxbin),y(maxbin),xmin,xmax,ymin,ymax,dat(maxbin,1024),mean
-      real psnr,ssnr,smmax,fc,bw,f1,cb,pdm,ts,to,window,phasestart,trms
-      integer kwmax,greyscale,indx(maxbin),npts,n90,ndms,nbits
-      logical filexists,susfile,cent,summary
-      real*8 pfold,pfind,susdm,sussn
-      real z(maxbin),dmmodelrms,bestrms,pms,dc,testrms,bestdc
-      character*80 telescope,machine,source,comline,date,mjd,fstring
-      character*80 period,tstring,junk,dmc
-c
-c     Initialise some variables...
-c
-      padout=.false.
-      readwri=-1
-      recno=1
-      inquire(file='subbands.epn',exist=filexists)
-      if (.not.filexists) stop 'subbands.epn not found!'
-      inquire(file='subints.epn',exist=filexists)
-      if (.not.filexists) stop 'subints.epn not found!'
-      inquire(file='asciiheader',exist=filexists)
-      if (.not.filexists) stop 'asciiheader file not found!'
-      inquire(file='timeseries',exist=filexists)
-      if (.not.filexists) stop 'timeseries file not found!'
-      inquire(file='phasestart',exist=filexists)
-      if (filexists) then
-         call glun(lun)
-         open(lun,file='phasestart',status='old')
-         read(lun,*) phasestart
-         close(lun)
-      else
-         phasestart=0.0
-      endif
-
-      nchan=nepnrec('subbands.epn')
-      if (nchan.lt.1) stop 'no profiles found in subbands.epn'
-c     Modified BCJ to run on gfortran 03-sep-2007
-c      call rwepn('subbands.epn', readwri, nchan+1, padout)
-      call rwepn('subbands.epn', readwri, 1, padout)
-
-      nsubints=nepnrec('subints.epn')-1
-      if (nsubints.lt.1) stop 'no profiles found in subints.epn'
-      call rwepn('subbands.epn', readwri, 1, padout)
-      pfold=papp(1)*1000.0
-
-      call glun(lun)
-      open(lun,file='asciiheader',status='old',err=1)
-      read(lun,'(a)',err=2) telescope
-      read(lun,'(a)',err=2) machine
-      read(lun,'(a)',err=2) filename
-      read(lun,'(a)',err=2) source
-      read(lun,'(a)',err=2) mjd
-      read(lun,'(a)',err=2) date
-      read(lun,*,err=2) fc
-      read(lun,*,err=2) bw
-      read(lun,*,err=2) f1
-      read(lun,*,err=2) cb
-      read(lun,*,err=2) nc
-      read(lun,*,err=2) nbits ! new
-      read(lun,*,err=2) ts
-      read(lun,*,err=2) to
-      read(lun,'(a)',err=2) period
-      read(lun,'(a)',err=2) dmc
-      read(dmc,*) pdm
-    
-c      write(fstring,'(''F\\dOBS\\u: '',f6.3,'' GHz '',
-c     &      ''Bandwidth:'',f5.1,'' MHz Nchans: '',i4,
-c     &      ''  t\\dsamp\\u: '',f6.0,''\\gms'')') 
-c     & fc/1000.0,bw,nc,ts
-      close(lun)
-      
-      greyscale=0
-      call getarg(1,comline)
-      call getarg(2,junk)
-	
-      if (junk.eq.'greyscale'.or.junk.eq.'grayscale') greyscale=1
-      if (junk.eq.'centre'.or.junk.eq.'center') then
-         cent=.true.
-      else
-         cent=.false.
-      endif
-	cent=.true.
-      call getarg(3,junk)
-      if (junk.eq.'summary') then
-	summary=.true.
-      else
-	summary=.false.
-      endif
-      if (comline.eq.'?') then
-         call pgbegin(0,'?',1,1)
-      else 
-         if (summary) then
-           call pgbegin(0,filename(1:slen(filename))//'.ps/ps',1,1)
-	   write(*,'(a)') filename(1:slen(filename))//'.png'
-         else
-           call pgbegin(0,filename(1:slen(filename))//'.ps/vps',1,1)
-	   write(*,'(a)') filename(1:slen(filename))//'.ps'
-	 endif
-      endif
-      if (comline.eq.'greyscale'.or.comline.eq.'grayscale') greyscale=1
-      inquire(file=comline,exist=filexists)
-      if (filexists) then
-         susfile=.true.
-      else
-         susfile=.false.
-      endif
-      call pgscf(2)
-      call pgsch(0.9)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (summary) then
-	   call pgvport(0.08,0.98,0.6,0.7)
-	   call pgwindow(0.0,1.0,0.0,1.0)
-	   call pgtext(0.0,1.1,filename(1:slen(filename))//
-     &               '    P = '//period(1:slen(period))//' ms'//
-     &               '   DM = '//dmc(1:slen(dmc))//' cm-3 pc'
-     &                 )
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      xmin=+1.0e32
-      xmax=-1.0e32
-      ymin=+1.0e32
-      ymax=-1.0e32
-      call glun(lun)
-      open(lun,file='timeseries',status='old')
-      i=0
-      istat=0
-      do while(istat.eq.0) 
-         i=i+1
-         read(lun,*,iostat=istat) x(i),y(i)
-         if (istat.eq.0) then
-            xmin=min(xmin,x(i))
-            xmax=max(xmax,x(i))
-         endif
-      enddo
-      close(lun)
-      npts=i-1
-      n90=npts-npts/10
-      call indexx(npts,y,indx)
-      mean=0.0
-      do i=1,n90
-         mean=mean+y(indx(i))
-      enddo
-      mean=mean/real(n90)
-      do i=1,npts
-         y(i)=y(i)-mean
-      enddo
-      trms=0.0
-      do i=1,n90
-         trms=trms+(y(indx(i))*y(indx(i)))
-      enddo
-      trms=sqrt(trms/real(n90))
-      do i=1,npts
-         y(i)=y(i)/trms
-         ymin=min(ymin,y(i))
-         ymax=max(ymax,y(i))
-      enddo
-      if (summary) goto 111
-      if (susfile) then
-         call pgvport(0.125,0.48,0.67,0.79)
-      else 
-         call pgvport(0.125,0.925,0.67,0.79)
-      endif
-      call pgwindow(xmin,xmax,ymin,10.0)
-      
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgline(npts,x,y)
-      call pglabel('Telescope Time (s)','Flux (rms~1)',' ')
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      write(fstring,'(''Folded '',i5,'' s of'',
-     &      i4,'' x'',f7.1,''-kHz '',i2,
-     &      ''-bit filterbank data t\\dsmp\\u:'',
-     &      i5,''\\gms'')')
-     &      int(xmax),nc,1000*abs(bw)/real(nc),nbits,int(ts)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
- 111  if (susfile) then
-         xmin=+1.0e32
-         xmax=-1.0e32
-         ymin=+1.0e32
-         ymax=-1.0e32
-         call glun(lun)
-         open(lun,file=comline,status='old',err=1)
-         read(lun,'(a)',iostat=istat) junk
-         if (junk(1:1).eq."#") then
-	   read(junk(2:),*) pfind,sussn,susdm
-	 else
-	   read(junk,*) pfind,sussn,susdm
-	 endif
-         i=0
-         do while (istat.eq.0) 
-            i=i+1
-            read(lun,*,iostat=istat) ndms,x(i),y(i)
-         enddo
-         close(lun)
-         ndms=i-1
-         bestrms=1.0e32
-	 bestdc=0.01
-         pms = real(pfold)
-         do i=1,999
-           dc  = real(i)/1000.
-	   testrms=dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pms,dc)
-           if (testrms.lt.bestrms) then
-		bestdc=dc
-		bestrms=testrms
-	   endif
-         enddo 
-         testrms=dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pms,bestdc) 
-         if (summary) then
-           call pgvport(0.3,0.5,0.5,0.7)
-	 else
-           call pgvport(0.57,0.925,0.67,0.79)
-	 endif
-         ymin=y(1)
-	 ymax=y(1)
-	 do i=1,ndms
-	   ymin=min(y(i),ymin)
-	   ymax=max(y(i),ymax)
-         enddo
-         call pgwindow(xmin,xmax,ymin,ymax*1.1)
-         call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-c         call pgsls(4)
-c         call pgline(ndms,x,y)
-c         call pgslw(4)
-         call pgsls(1)
-         call pgline(ndms,x,z)
-         call pgslw(1)
-         call pgpoint(ndms,x,y,17)
-         call pglabel('Trial DM (cm\\u-3\\d pc)','S/N',' ')
-	 call pgwindow(0.0,1.0,0.0,1.0)
-         ssnr=ymax
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      ymax=-1.0e32
-      call rwepn('subints.epn', readwri, nsubints, padout)
-      do i=1,nbin
-         if (rawdata(1,i).gt.ymax) then
-            ymax=rawdata(1,i)
-            j=i
-         endif
-      enddo
-      nshift=nbin/2-j
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      xmin=+1.0e32
-      xmax=-1.0e32
-      ymin=+1.0e32
-      ymax=-1.0e32
-      do i=1,nsubints
-         call rwepn('subints.epn', readwri, i, padout)
-
-         do j=1,nbin
-            x(j)=real(j)*real(tbin)*1.0e-3
-            xmin=min(xmin,x(j))
-            xmax=max(xmax,x(j))
-            y(j)=rawdata(1,j)
-            ymin=min(ymin,y(j))
-            ymax=max(ymax,y(j))
-         enddo
-         if (cent) call sprof(y,nbin,nshift)
-         do j=1,nbin
-            dat(j,i)=y(j)
-         enddo
-      enddo
-      
-      xmin=0.0
-      xmax=1.0
-      ymin=0.0
-      ymax=real(nsubints)
-      if (summary) then
-        call pgvport(0.56,0.76,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.28,0.43)
-      endif
-      if (greyscale.eq.1) then
-         call grayscale(dat,maxbin,1024,nbin,nsubints,1) 
-      else 
-         call quickgrey(dat,maxbin,1024,nbin,nsubints,1) 
-      endif
-      window=real(nbin)*real(tbin)*1.0e-3/pfold
-c      call pgwindow(phasestart,phasestart+window,real(nsubints+1),0.0)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pglabel(' ','Subintegration',' ')
-      if (summary) 
-     & call pglabel('Pulse phase (turns)','Subintegration',' ')
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      do i=1,nchan
-         call rwepn('subbands.epn', readwri, i, padout)
-         do j=1,nbin
-            y(j)=rawdata(1,j)
-         enddo
-         if (cent) call sprof(y,nbin,nshift)
-         do j=1,nbin
-            dat(j,i)=y(j)
-            ymin=min(ymin,y(j))
-            ymax=max(ymax,y(j))
-         enddo
-      enddo
-      xmin=0.0
-      xmax=1.0
-      ymin=0.0
-      ymax=real(nchan)
-      if (summary) then
-        call pgvport(0.82,0.98,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.45,0.6)
-      endif
-      call pgwindow(1.0,real(nbin),0.0,real(nchan+1))
-      if (greyscale.eq.1) then
-         call grayscale(dat,maxbin,1024,nbin,nchan,1)
-      else
-         call quickgrey(dat,maxbin,1024,nbin,nchan,1)
-      endif
-c      call pgwindow(0.0,window,0.0,real(nchan+1))
-      if (summary) then
-	call pglabel('Pulse phase (turns)','Frequency band',' ')
-        call pgbox('bcnst',0.0,0,'bcnt',0.0,0)
-      else
-        call pglabel('','Frequency band',' ')
-        call pgbox('bcst',0.0,0,'bcnt',0.0,0)
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
- 222  call rwepn('subints.epn', readwri, nsubints+1, padout)
-      ymin=+1.0e32
-      ymax=-1.0e32
-      do j=1,nbin
-         x(j)=real(j-1)*real(tbin)*1.0e-3
-         x(j)=j
-         y(j)=rawdata(1,j)
-         ymin=min(ymin,y(j))
-         ymax=max(ymax,y(j))
-      enddo
-      xmin=0.0
-      xmax=pms
-      xmin=0.5
-      xmax=real(nbin)+0.5
-      if (summary) then
-        call pgvport(0.08,0.23,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.1,0.25)
-      endif
-      ymin=ymin-(ymax-ymin)*0.05
-      ymax=ymax+(ymax-ymin)*0.05
-      call pgwindow(xmin,xmax,ymin,ymax)
-      call pgbox('bcnst',0.0,0,'bc',0.0,0)
-      call pglabel('Pulse Phase (bins)','Flux density',' ')
-      if (cent) call sprof(y,nbin,nshift)
-      call pgmove(xmin,y(1))
-      do i=1,nbin-1
-         call pgdraw(x(i)+0.5,y(i))
-         call pgdraw(x(i)+0.5,y(i+1))
-      enddo
-      call pgdraw(xmax,y(nbin))
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (.not.cent) call sprof(y,nbin,nshift)
-      call smooth(y,nbin,kwmax,psnr,smmax)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (summary) then
-        call pgwindow(0.0,1.0,0.0,1.0)
-	write(junk,'(f6.1)') psnr
-	call pgtext(0.7,0.8,junk)
-	goto 333
-      endif
-      call pgvport(0.125,0.925,0.1,1.0)
-      call pgvport(0.06,0.925,0.1,1.0)
-      call pgwindow(0.0,1.0,0.0,1.0)
-      call pgtext(0.0,0.9,telescope(1:slen(telescope))//
-     &     ' '//machine(1:slen(machine))//': '//
-     &     filename(1:slen(filename))//'.ps')
-      call pgtext(0.0,0.875,'J2000 coords: '//source(1:slen(source))//
-     &     ' MJD: '//mjd(1:slen(mjd))//' Date: '//date(1:len(date)))
-      call pgtext(0.0,0.85,fstring)
-      write(tstring,'(''P\\dfromSEEK\\u: '',f16.10,
-     & '' ms  DM: '',f7.2,'' cm\\u-3\\d pc'',''  SEEK S/N: '',f6.1)') 
-     &   pfind,pdm,ssnr
-      call pgtext(0.0,0.825,tstring)
-      write(tstring,'(''P\\doptimized\\u: '',f16.10,
-     & '' ms N\\dbins\\u: '',i4,
-     & '' DC: '',f4.1,''%   PROF S/N: '',f6.1)') 
-     & pfold,nbin,bestdc*100,psnr
-      call pgtext(0.0,0.8,tstring)
- 333  call pgend
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      stop
- 1    stop 'ERROR: opening asciiheader'
- 2    stop 'ERROR: reading asciiheader'
-      end
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      real function dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pfold,dc)
-      integer ndms
-      real x(*),y(*),z(*),xmin,xmax,pdm,bw,fc,pfold,dc,weff
-      real ssq,zmax,wint,ymax
-      integer i
-      zmax=0.0
-      wint=dc*pfold
-      xmin=0.0
-      xmax=0.0	
-      ymax=0.0
-      do i=1,ndms
-        weff=sqrt(wint**2.0+(8.3e6*abs(pdm-x(i))*bw/fc/fc/fc)**2.0)
-        if(weff.gt.pfold) then
-  	  z(i)=0.0
-	  if (xmin.ne.0.0.and.xmax.eq.0.0) xmax=x(i)*1.1
-	else
-	  if (xmin.eq.0.0.and.xmax.eq.0.0) xmin=x(i)*0.9
-	  z(i)=sqrt(pfold-weff)/sqrt(weff)
-	endif
-        ymax=max(ymax,y(i))
-	zmax=max(zmax,z(i))
-      enddo
-      ssq=0.0
-      do i=1,ndms
-        z(i)=z(i)*ymax/zmax
-        ssq=ssq+(y(i)-z(i))**2.0
-      enddo
-      dmmodelrms=sqrt(ssq/real(ndms))
-      if (xmax.eq.xmin) then
-	xmin=x(1)
-	xmax=x(ndms)
-      endif
-      if (xmax.eq.0.0) xmax=x(ndms)*1.1
-      end
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      integer function slen(string)
-      character string*(*)
-c     
-c     OBTAIN THE LOCATION OF THE LAST NON-SPACE CHARACTER.
-c     
-      integer ilen
-c     search for the first null
-      ilen = len(string)
-c     use the position of the first null
-      do 1 i = ilen, 1, -1
-c     
-c     LENGTH FOUND.
-c     
-         if (string(i:i) .ne. char(32) .and.
-     &       string(i:i).ne.char(0)) then
-            slen = i
-            return 
-         end if
-c     
-c     STRING IS ALL SPACES OR ZERO LENGTH.
-c     
-    1 continue
-      slen = 0
-c     
-c     END OF INTEGER FUNCTION LENGTH.
-c     
-      return 
-      end
-      subroutine quickgrey(dat,nxd,nyd,nx,ny,flip)
-
-c  Coarse grey-scale plot using PG plot routines
-c  Assumed that viewport and window defined outside routine
-        integer nxd,nyd
-        integer nsym,flip
-        parameter(nsym=10)
-	integer*4 ksym(nsym)
-	real*4 dat(nxd,nyd)
-	data ksym/1,20,21,2,3,14,15,17,16,18/
-
-	s=0.
-	ss=0.
-	smin=1.e30
-	smax=-smin
-	do j=1,ny
-	  do i=1,nx
-	    aa=dat(i,j)
-	    s=s+aa
-	  enddo
-	enddo
-	s=s/(nx*ny) 
-	do j=1,ny
-	  do i=1,nx
-            aa=dat(i,j)-s
-	    ss=ss+aa**2
-	    if(aa.gt.smax)smax=aa
-	    if(aa.lt.smin)smin=aa
-	  enddo
-	enddo
-	rms=sqrt(ss/(nx*ny))
-
-        if (flip.eq.1) then
-           call pgwindow(1.0,real(nx),real(ny+1),0.0)
-        else 
-           call pgwindow(1.0,real(nx),0.0,real(ny+1))
-        endif
-	do j=1,ny
-	  do i=1,nx
-	    k=min(int((dat(i,j)-s)/rms),nsym)
-	    if(k.gt.0)then
-	      x=i
-	      y=j
-	      call pgpoint(1,x,y,ksym(k))
-	    endif
-	  enddo
-	enddo
-
-	return
-	end
-
-
-
-c==============================================================================
-C nicked from pgplot
-C*GRGLUN -- get a Fortran logical unit number (Sun/Convex-UNIX)
-C+
-      SUBROUTINE GLUN(LUN)
-      INTEGER LUN
-C
-C Get an unused Fortran logical unit number. 
-C Returns a Logical Unit Number that is not currently opened.
-C After GRGLUN is called, the unit should be opened to reserve
-C the unit number for future calls.  Once a unit is closed, it
-C becomes free and another call to GRGLUN could return the same
-C number.  Also, GRGLUN will not return a number in the range 1-9
-C as older software will often use these units without warning.
-C
-C Arguments:
-C  LUN    : receives the logical unit number, or -1 on error.
-C--
-C 12-Feb-1989 [AFT/TJP].
-C DRL adapted to subroutine GLUN for use with stand-alone software
-C 16-Jul-1993 @ JB
-c==============================================================================
-      INTEGER I
-      LOGICAL QOPEN
-C---
-      DO 10 I=99,10,-1
-          INQUIRE (UNIT=I,  OPENED=QOPEN)
-          IF (.NOT.QOPEN) THEN
-              LUN = I
-              RETURN
-          END IF
-   10 CONTINUE
-C none left
-      STOP 'RAN OUT OF LUNs!' 
-      END
-c==============================================================================
-c
-c     File: "rwepn.f"
-c     
-c     This file contains the generalised EPN format reading/writing routines
-c     It has been tested on an HP system with f77 -c rwepn.f to produce the 
-c     object file. It requires the accompanying include file "epnhdr.f"
-c
-c==============================================================================
-       subroutine rwepn(filename2,readwri,recno,padout)
-c==============================================================================
-c
-c     Subroutine to read or write data in EPN format. All parameters are
-c     defined in the include file "epnhdr.f" which should lie in the
-c     same directory as this file. Passed down variables to this routine
-c     are:
-c
-c     filename - character*80  - name of this EPN file
-c     readwri  - integer*4     - switch: -1 => read, +1 => write
-c     recno    - integer*4     - record number to read
-c
-c     Usage:
-c
-c     To incorporate this routine into your pulsar data reduction
-c     package, include the file "epnhdr.f" in your source code
-c     and set up the appropriate variables before.
-c
-c     Features:
-c
-c     When writing is requested, the routine will keep the file
-c     open for successive writes by default. To override this, pass
-c     down recno as -1, the presently opened file will be closed
-c     and a new one opened.
-c
-c     If an error occurs in reading, recno is returned as -999
-c
-c     By the very nature of the format, record lengths must be fixed.
-c     So if you want to have different lengthed data streams in the
-c     same archive you need to switch "padout" on. As its name suggests,
-c     this pads out the binned data to its maximum length so that
-c     the records are fixed. A draw back is of course that it uses
-c     up more space. Therefore if it is known that all the records
-c     are of the same lenght anyway (eg for a stream of single pulses)
-c     then it is recommended to switch padout off.
-c
-c==============================================================================
-c
-c     Created by Dunc Lorimer (dunc@mpifr-bonn.mpg.de) November 1996....
-c
-c     12/11/1996   Initial version
-c     15/11/1996   Implemented common blocks
-c     21/05/1997   Changed to HEX storage
-c     01/07/1997   Added tres and fluxflag to header
-c
-c==============================================================================
-c
-      implicit none
-      character*(*) filename2
-      include 'epnhdr.f' 
-c
-c     Data buffers...
-c
-      integer*4 intdata(maxbin) 
-      character*4 chrdata(maxbin)
-      real*4 tmp(maxbin)
-c
-c     The maximum length of an EPN file is the 6 line header, plus
-c     maxblk sets of maxbin bin data streams. Each stream of maxbin
-c     bins occupies (maxbin/20) sets of 80 character lines plus a 2
-c     line header. The number of charcters per record is:
-c
-c     (6+maxblk*(maxbin/20+2))*80 
-c
-c     One can tune this depending on the size of the data-sets...
-c     the default is maxblk=8, maxbin=4160 -> maxrec=66080
-c     suitable smaller setting for e.g. a PC would be...
-c                    maxblk=4, maxbin=1040 -> maxrec=17760.
-c     N.B. Both maxbin and maxblk are specified in "epnhdr.f"
-c
-      integer maxrec
-      parameter(maxrec=(6+maxblk*(maxbin/20+2))*80)
-      character line(maxrec/80)*80, recrd*(maxrec)
-c
-c==============================================================================
-c
-c     Local variables
-c
-      integer lun, lfil, nlin, next, i, j, k, l, iras, ipol,
-     &        wrecno, recln, maxint, lct, length
-      real rras, pvno, vno
-      character*1 dsign, lin1*12, line40*40
-      logical reading,writing,filex,opened,first
-      save
-      data opened/.false./, first/.true./
-      line40='----------------------------------------'
-c
-c==============================================================================
-c
-c     Sort out whether reading or writing
-c
-      reading=(readwri.eq.-1)
-      writing=(.not.reading)
-      if (readwri.ne.-1.and.readwri.ne.1) then
-         write(*,'(''Unknown read/write option passed to rwepn!!'')')
-         write(*,'(''Your "readwri" integer reads: '',i4)')readwri
-         stop
-      endif
-c
-c     If writing required and recno=-1, then close a previously
-c     opened file (if one is open) and proceed
-c
-      if (writing.and.recno.eq.-1.and.opened) then
-         close(unit=lun)
-         opened=.false.
-      endif
-c
-c     Get a free logical unit number
-c
-      if (.not.opened) call glun(lun)
-c
-c     Check whether the file exists or not....
-c     
-c     For reading: the routine will stop if not
-c     For writing: the routine will append to the previous file
-c
-      lfil=length(filename2)
-      filename=filename2(1:lfil)
-      inquire(file=filename(1:lfil),exist=filex)
-c
-c     Open the input file
-c
-      if (reading) then
-         if (filex) then
-c
-c          Read in the very first line, and work out the
-c          required record length...(number of 80 chr lines)
-c
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=12)
-           read(lun,rec=1) lin1
-           read(lin1,'(8x,i4)') counter
-           close(unit=lun)
-           recln=counter*80
-c
-c          Now open as a direct access unformatted file
-c
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=recln)
-           if (recno.lt.1) recno=1
-           read(lun,rec=recno,err=999) recrd(1:recln)
-           close(unit=lun)
-         else
-           stop 'EPN file does not exist!'
-         endif
-      endif
-      if (writing) then
-c
-c       Establish out how many 'lines' will make up this record...
-c
-        if (padout) then
-           recln=maxrec ! use maximum record length
-           nlin=maxbin/20
-           npol=maxblk
-           counter=6+npol*(nlin+2)
-        else
-           nlin=nbin/20
-           next=nbin-nlin*20
-           if (next.gt.0) nlin=nlin+1
-           counter=6+npol*(nlin+2)
-           recln=counter*80
-        endif
-        if (opened) then
-c
-c          Increase the internal record counter
-c
-           wrecno=wrecno+1
-        else
-c
-c          Reset the internal record counter...
-c
-           wrecno=1
-           open(unit=lun,file=filename(1:lfil),status='unknown',
-     &          access='direct',form='unformatted',recl=recln)
-           opened=.true.
-        endif
-      endif
-c
-c     As from Version 5.0 data is scaled into hex format...
-c     This gives an increas in dynamic range by over a factor 6
-c
-      pvno=5.0
-      maxint=65535
-c
-c     As from Version 6.0, actual resolution of the data is
-c     recorded, the factor fcal is no longer recorded, instead
-c     the flag fluxflag is written into line 4 to signify whether
-c     the data are flux calibrated or not. (1.7.1997)
-c
-      pvno=6.0
-      lct=1
-c
-c     Line 1
-c
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),11) version, counter, history
-        read(version(4:),'(f5.2)') vno
-        if (vno.lt.pvno) then
-           if (first) then
-              write(*,*) 'Reading an old EPN file - Version',vno
-              first=.false.
-           endif
-           maxint=9999
-        endif
-      else
-        vno=pvno
-        write(version,'(a3,f5.2)') 'EPN',vno
-        write(line(lct),11) version, counter, history
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,11) version, counter, history
-c
- 11   format(a8,i4,a68)
-c
-c     Line 2
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),22) 
-     &  jname,cname,pbar,dm,rm,catref,bibref
-      else
-        write(line(lct),22) jname, cname, pbar, dm, rm, catref, bibref
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,22) jname, cname, pbar, dm, rm, catref, bibref
-c
- 22   format(a12,a12,f16.11,f8.3,f10.3,a6,a8,8x)
-c
-c     Line 3
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),33) 
-     &               rah,ram,iras,rras,dsign,ded,dem,des, 
-     &               telname, epoch, opos, paflag, timflag
-        ras=float(iras)+rras
-        if (dsign.eq.'-') ded=-1*ded
-        if (dsign.eq.'-'.and.ded.eq.0) then
-           dem=-1*dem
-           des=-1.0*des
-        endif
-      else
-        rras=ras-int(ras)
-        iras=int(ras)
-        dsign='+'
-        if (index(jname,'-').gt.0) dsign='-'
-        if (ded.lt.0) ded=-1*ded
-        write(line(lct),33) rah, ram, iras, rras, dsign, ded, dem, des, 
-     &               telname, epoch, opos, paflag, timflag
-      endif
-c
-c     Un-comment this line for tracing... 
-c      write(*,33) rah, ram, iras, rras, dsign, ded, dem, des, telname, 
-c     &           epoch, opos, paflag, timflag
-c
- 33    format(3i2.2,f4.3,a1,2i2.2,f6.3,a8,f10.3,f8.3,a1,a1,31x)
-c
-c     Line 4 - (X,Y,Z) of telescope - NEW - implemented in V 6.0
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        if (reading) then
-           read(recrd((lct-1)*80+1:lct*80),44) xtel,ytel,ztel
-        else
-           write(line(lct),44) xtel,ytel,ztel
-        endif
-      endif
- 44   format(3f17.5,29x) 
-c
-c     Line 5
-c
-      lct=lct+1
-      if (reading) then
-        if (vno.ge.6.0) then
-        read(recrd((lct-1)*80+1:lct*80),55) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-        else
-        read(recrd((lct-1)*80+1:lct*80),56) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, nint, ncal, lcal, fcal
-        endif
-      else
-        write(line(lct),55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, tres, nint, ncal, lcal, fluxflag
-c      write(*,56) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, nint, ncal, lcal, fcal
-c
- 55   format(2i2.2,i4.4,2i4.4,i2,i4,i4,2f12.6,i6,i4,i4,a1,15x) ! Version 6
- 56   format(2i2.2,i4.4,2i4.4,i2,i4,i4,f12.6,i6,i4,i4,f8.3,20x)
-c
-c     Line 6 - Blank at the moment
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        write(line(lct),66) line40,line40
-      endif
- 66   format(2a40) 
-c      
-c     Loop around each polarisation...
-c
-      do ipol=1,npol
-c
-c       sub-header line 1
-c
-        lct=lct+1
-        if (reading) then
-          if (vno.ge.6.0) then
-          read(recrd((lct-1)*80+1:lct*80),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-          else
-          f0u(ipol)=' GHz'
-          dfu(ipol)=' MHz'
-          read(recrd((lct-1)*80+1:lct*80),78) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),df(ipol),tstart(ipol)
-          endif
-        else
-          if (f0u(ipol).eq.' ') f0u(ipol)=' GHz'  ! Default units
-          if (dfu(ipol).eq.' ') dfu(ipol)=' MHz'  ! Default units
-          write(line(lct),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c       write(*,77) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-c       write(*,78) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              df(ipol),tstart(ipol)
-c
- 77     format(a8,i4,i4,f12.8,a8,f12.6,a8,f17.5,7x)
- 78     format(a8,i4,i4,f12.8,f12.6,f17.5,23x)
-        if (writing) then 
-c
-c         Zero the integer and character arrays
-c
-          do i=1,maxbin
-            intdata(i)=0
-	    chrdata(i)='0000'
-          enddo
-c
-c         Scale the data
-c     
-          do k=1,nbin
-             tmp(k)=rawdata(ipol,k)
-          enddo
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-c
-c         Convert to a hex string
-c
-          do k=1,nbin
-             call b102hex(intdata(k),chrdata(k))
-          enddo
-        endif
-c
-c       Sub-header line 2
-c
-        lct=lct+1
-        if (reading) then
-          read(recrd((lct-1)*80+1:lct*80),88)  scale(ipol),offset(ipol),
-     &    rms(ipol),papp(ipol)
-        else
-          write(line(lct),88) scale(ipol),offset(ipol),
-     &                            rms(ipol),papp(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c        write(*,88) scale(ipol), offset(ipol), rms(ipol), papp(ipol)
-c
- 88     format(3e12.6,f16.11,28x) 
-c
-c       Now we finally get to the data!!
-c
-c
-c       Read the data (20 i4s per 80 column line)
-c
-        nlin=(counter-4)/npol-2
-        if (vno.ge.6.0) nlin=(counter-6)/npol-2
-        k=1
-        do i=1,nlin
-          lct=lct+1
-          if (reading) then
-c            read(recrd((lct-1)*80+1:lct*80),99)(chrdata(j),j=k,k+19)
-            l=0
-	    do j=k,k+19
-              chrdata(j)=recrd((lct-1)*80+1+l:(lct-1)*80+4+l)
-              call hex2b10(chrdata(j),intdata(j))
-              l=l+4
-	    enddo
-          else
-c            write(line(lct),99)(chrdata(j),j=k,k+19)
-            l=1
-	    do j=k,k+19
-              line(lct)(l:l+3)=chrdata(j)
-              l=l+4
-	    enddo
-          endif
-c
-c         Un-comment this line for tracing...
-c          write(*,99)(chrdata(j),j=k,k+19)
-c
-          k=k+20
-        enddo
-c
-c       Format for the data
-c
- 99     format(20a4)
-        if (reading) then
-c
-c         Convert hex string to integer for versions from 5.0
-c
-          do k=1,nbin
-             if (vno.ge.5.0) then
-c                call hex2b10(chrdata(k),intdata(k))
-             else
-                read(chrdata(k),'(i4.4)') intdata(k)
-             endif
-          enddo
-c
-c         De-scale the data
-c     
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-          do k=1,nbin
-             rawdata(ipol,k)=tmp(k)
-          enddo
-        endif
-      enddo
-c
-c     Write the record...
-c
-      if (writing) then
-        do i=1,lct
-          j=(i-1)*80+1
-          k=j+79
-          recrd(j:k)=line(i)
-        enddo
-        write(lun,rec=wrecno) recrd(1:k)
-        return
-      endif
-c
-c     Bail out!
-c
-      return
-c
-c     On error return this record number
-c
- 999  recno=-999
-      end
-c==============================================================================
-      subroutine hex2b10(hexstr,b10no)
-c==============================================================================
-
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      b10no=0
-      dig=0
-
-      do i=4,1,-1
-         do j=1,16
-            if (hexstr(i:i).eq.hex(j)) goto 5
-         enddo
- 5       continue
-         b10no=b10no+int(16.0**float(dig)*float(j-1))
-         dig=dig+1
-      enddo
-
-      end
-c==============================================================================
-      subroutine b102hex(b10no,hexstr)
-c==============================================================================
-c
-c	Converts a base 10 number passed down as the integer "b10no"
-c	to a hexadeximal string returned as the character*4 "hexstr"
-c       N.B. maximum integer for 4 character hex string is 65535
-c
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,no,num,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      no=b10no
-      dig=0
-
-      do i=4,1,-1
-         do j=15,0,-1
-            num=int(float(j)*16.0**float(i-1))
-            if (num.le.no) goto 5
-         enddo
- 5       continue
-         dig=dig+1
-         hexstr(dig:dig)=hex(j+1)
-         no=no-num
-      enddo
-
-      end
-c==============================================================================
-      subroutine rawtfint(raw,nbin,intdata,scale,offset,rms,dirn,maxint)
-c==============================================================================
-c
-c     Routine to convert "raw" (i.e. floating point) to/from integer
-c     format. In this case, the integer may vary between 0 and maxint.
-c     Raw data is passed down from site software and stored as integers
-c     in the EPN files.
-c
-c     The direction of the conversion is controlled by "dirn":
-c
-c     dirn = +1 : raw -> int
-c     dirn = -1 : int -> raw
-c
-c==============================================================================
-c    
-      implicit none
-c
-c     Passed down variables
-c
-      real raw(*)
-      real*8 scale, offset, rms
-      integer nbin, intdata(*), dirn, maxint
-c
-c     Local variables
-c
-      real dmin, dmax, sumsq, pmax, sum, mean, ndiv
-      integer i, ibmax, nshift
-      if (dirn.eq.1) then
-c
-c       Scale the data:
-c
-c       Find minimum & maximum values of the data
-c
-        dmin = raw(1)
-        dmax = raw(1)
-        do i=1,nbin
-          dmax=max(raw(i),dmax)
-          dmin=min(raw(i),dmin)
-        enddo
-        offset=dmin
-        scale=float(maxint)/(dmax-dmin)
-c
-c       Now do the scaling
-c
-        do i=1,nbin
-          intdata(i)=int((raw(i)-offset)*scale)
-        enddo
-c
-c-------------------------------------------------------------
-c       If no rms has been supplied by the user, have a go at 
-c       calculating it from the wings of the profile after 
-c       shifting it so that its peak lies at bin number nbin/2
-c-------------------------------------------------------------
-c
-        if (rms.eq.0.0) then
-          pmax=-1.0e32
-          ibmax=0
-          do i=1,nbin
-             if (raw(i).gt.pmax) then
-                ibmax=i
-                pmax=raw(i)
-             endif
-          enddo
-          nshift=nbin/2-ibmax
-          call sprof(raw,nbin,nshift)
-          sumsq=0.0
-          sum=0.0
-          do i=1,nbin/15
-            sumsq=sumsq+raw(i)*raw(i)
-            sumsq=sumsq+raw(nbin-i+1)*raw(nbin-i+1)
-            sum=sum+raw(i)
-            sum=sum+raw(nbin-i+1)
-          enddo
-	  ndiv=max(1.0,float(2*nbin/15))
-          rms=sqrt(sumsq/ndiv)
-          mean=sum/ndiv
-        endif
-      else if (dirn.eq.-1) then
-c
-c       Prepare to de-scale the data:
-c
-        do i=1,nbin
-          raw(i)=real(offset+dble(intdata(i))/scale)
-        enddo
-      else
-c
-c       Silly option was passed down...
-c
-        write(*,*) 'Invalid value for dirn passed to rawtfint : ',dirn
-        stop
-      endif
-c
-c     Job done!
-c
-      end
-c==============================================================================
-      integer function nepnrec(filename)
-c==============================================================================
-c
-c     Function to find out the number of records in an EPN file.
-c
-c     This can in principle be done with an INQUIRE statement but
-c     it is system dependent. The following approach uses a simple
-c     binary search algorithm to find the last record which is far
-c     quicker than reading in every record in very large EPN files.
-c
-c     if the file doesn't exist nepnrec is returned as 0
-c     nepnrec = -1 if an error occurred whilst reading the file
-c
-c     Created 96/12/03 DRL@MPIfR
-c     Modified October 1997 to return -1 on error
-c
-c
-      implicit none
-      character*(*) filename
-
-      character lin1*12,recrd*80
-      integer irec,istat,counter,recln,hirec,lorec,orec,lun
-      logical filex
-c
-c     Check to see whether the EPN file exists...
-c     return nepnrec=0 if it doesn't
-c
-      nepnrec=0
-      inquire(file=filename,exist=filex)
-      if (.not.filex) return 
-c
-c     It exists! Open it and find out the true record length..
-c
-      call glun(lun)
-      nepnrec=-1 ! This will be the value of nepnrec if an error occurs
-      irec=-1
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=12,err=999)
-      read(lun,rec=1,err=999)lin1
-      read(lin1,'(8x,i4)',err=999)counter
-      close(unit=lun)
-      recln=counter*80
-      if (recln.le.0) return ! Error
-c
-c     Find out crude lower and upper bounds for the last record
-c
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=recln,err=999)
-      irec=1
-      istat=0
-      do while(.true.)
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.ne.0) goto 998
-         irec=irec*2
-      enddo
- 998  hirec=irec
-      lorec=irec/2
-c
-c     Now search for the last record within these bounds iteratively
-c
-      istat=0
-      orec=0
-      do while(orec.ne.irec)
-         orec=irec
-         irec=lorec+(hirec-lorec)/2
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.eq.0) then
-            lorec=irec
-         else
-            hirec=irec
-         endif
-      enddo
- 999  continue
-      close(unit=lun)
-      nepnrec=irec
-      end
-c============================================================================= 
-      subroutine dattim(date,hh,mm,ss)
-c============================================================================= 
-c
-c     Returns the time obtained by truncating the MJD passed down
-c     as date
-c
-      implicit none 
-      double precision date,dummy,ss
-      integer hh,mm
-
-
-      dummy=abs(date-int(date))
-
-      dummy=dummy*24.0
-      hh=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      mm=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      ss=dummy
-
-      end
-      subroutine smooth(pr,nbin,kwmax,snrmax,smmax)
-c******************************************************************
-c
-c  convolves profile pr(nbin) with a boxcar of width kw.  it returns
-c    the width kwmax which gave the highest s/n ratio snrmax, and the
-c    corresponding pulse amplitude smmax.
-c
-c******************************************************************
-c
-
-      integer nbin,kwmax
-      real*4 pr(*),rmsp,snrmax,smmax
-c
-      integer j,k,kw,nn,ja,jj
-      real*4 s,wrk(43),al,an,sn,smax
-c
-      snrmax=0.
-c---------------------------------------
-c  remove baseline
-c      ksm=nbin/2.5+0.5
-c      smax=1.e30
-c      do 10 j = 1,nbin
-c        s=0.0
-c        do 20 k = 1,ksm
-c          s = s + pr(mod(j+k-1,nbin)+1)
-c   20   continue
-c        if(s.lt.smax) smax=s
-c   10 continue
-c      smax=smax/ksm
-c      do 30 j = 1,nbin
-c        pr(j) = pr(j) - smax
-c   30 continue
-c--------------------------------------
-c      remove baseline and calc rmsp
-      do i=1,2
-      s=0
-      k=0
-      do j=1,nbin
-         if (j.le.nbin/10.or.j.ge.nbin-nbin/10) then
-            k=k+1
-            s=s+pr(j)
-         endif
-      enddo
-      s=s/real(k)
-      do j=1,nbin
-         pr(j)=pr(j)-s
-      enddo
-      enddo
-      k=0
-      rmsp=0.0
-      do j=1,nbin
-         if (j.le.nbin/10.or.j.ge.nbin-nbin/10) then
-            k=k+1
-            rmsp=rmsp+pr(j)*pr(j)
-         endif
-      enddo
-      rmsp=sqrt(rmsp/real(k))
-c
-c
-      do 40 nn=1,6
-        kw=2**(nn-1)
-        if(kw.gt.nbin/2) return
-	s=0.0
-	do 50 k=1,kw
-	  s=s+pr(k)
-	  wrk(k)=pr(k)
-   50   continue
-	ja=0
-	smax=s
-	do 60 j=2,nbin
-	  ja=ja+1
-	  if(ja.gt.kw) ja=ja-kw
-	  al=wrk(ja)
-	  jj=j+kw-1
-	  if(jj.gt.nbin)jj=jj-nbin
-	  an=pr(jj)
-	  s=s+an-al
-	  wrk(ja)=an
-	  if(s.gt.smax) smax=s
-   60   continue
-
-        sn=smax/(rmsp*sqrt(kw*(1.+real(kw)/nbin)))
-        if(sn.gt.snrmax) then
-          snrmax=sn
-          kwmax=kw
-          smmax=smax/kw
-        endif
-   40 continue
-
-      end
-c==============================================================================
-      subroutine sprof(profile,nbins,shift)
-c==============================================================================
-c
-c     shifts the profile in the array profile() with nbins bins by the 
-c     number of bins passed down in shift. shift>0 means shift forward,
-c     shift<0 means shift backwards.
-c
-      implicit none
-
-      real profile(*)
-      integer nbins, shift
-c
-c     local variables
-c
-      integer i,j
-      real dummy
-
-      if (shift.lt.0) shift=nbins+shift
-      do i=1,shift
-         dummy=profile(nbins)
-         do j=nbins,2,-1
-            profile(j)=profile(j-1)
-         enddo
-         profile(1)=dummy
-      enddo
-
-      end
-      subroutine grayscale(dat,nxd,nyd,nx,ny,flip)
-
-      integer nxd,nyd
-      integer nsym,flip
-      parameter(nsym=10)
-      real*4 dat(nxd,nyd),tr(6),xw,yw
-      save
-      
-      s=0.
-      ss=0.
-      do j=1,ny
-	 smin=1.0e30
-         do i=1,nx
-	    aa=dat(i,j)
-	    smin=min(smin,aa)
-	    s=s+aa
-         enddo
-	 do i=1,nx
-	    dat(i,j)=dat(i,j)-smin
-	 enddo
-      enddo
-      s=s/(nx*ny) 
-      smin=1.e30
-      smax=-smin
-      do j=1,ny
-         do i=1,nx
-            aa=dat(i,j)-s
-	    ss=ss+aa**2
-	    smax=max(smax,dat(i,j))
-	    smin=min(smin,dat(i,j))
-	    smin=min(smin,dat(i,j))
-         enddo
-      enddo
-      rms=sqrt(ss/(nx*ny))
-      
-      tr(1)=0.0
-      tr(2)=1.0
-      tr(3)=0.0
-      tr(4)=0.0
-      tr(5)=0.0
-      tr(6)=1.0
-      xmin=xw(tr,0.5,0.5)
-      ymin=yw(tr,0.5,0.5)
-      xmax=xw(tr,real(nx)+0.5,real(ny)+0.5)
-      ymax=yw(tr,real(nx)+0.5,real(ny)+0.5)
-
-      if (flip.eq.1) then
-         call pgwindow(xmin,xmax,ymax,ymin)
-      else
-         call pgwindow(xmin,xmax,ymin,ymax)
-      endif
-c      call pggray(dat,nxd,nyd,1,nx,1,ny,smax,s+0.5*rms,tr)
-      call pggray(dat,nxd,nyd,1,nx,1,ny,smax,smin,tr)
-      
-      end
-
-
-      real function xw(tr,i,j)
-      real tr(6),i,j
-      xw=tr(1)+tr(2)*i+tr(3)*j
-      end
-      
-      real function yw(tr,i,j)
-      real tr(6),i,j
-      yw=tr(4)+tr(5)*i+tr(6)*j
-      end
-      
-C from numerical recipes
-      SUBROUTINE INDEXX(N,ARRIN,INDX)
-      DIMENSION ARRIN(N),INDX(N)
-      if (n.eq.1) then
-	indx(1)=1
-        return
-      endif
-      DO 11 J=1,N
-         INDX(J)=J
- 11   CONTINUE
-      L=N/2+1
-      IR=N
- 10   CONTINUE
-      IF(L.GT.1)THEN
-         L=L-1
-         INDXT=INDX(L)
-         Q=ARRIN(INDXT)
-      ELSE
-         INDXT=INDX(IR)
-         Q=ARRIN(INDXT)
-         INDX(IR)=INDX(1)
-         IR=IR-1
-         IF(IR.EQ.1)THEN
-            INDX(1)=INDXT
-            RETURN
-         ENDIF
-      ENDIF
-      I=L
-      J=L+L
- 20   IF(J.LE.IR)THEN
-         IF(J.LT.IR)THEN
-            IF(ARRIN(INDX(J)).LT.ARRIN(INDX(J+1)))J=J+1
-         ENDIF
-         IF(Q.LT.ARRIN(INDX(J)))THEN
-            INDX(I)=INDX(J)
-            I=J
-            J=J+J
-         ELSE
-            J=IR+1
-         ENDIF
-         GO TO 20
-      ENDIF
-      INDX(I)=INDXT
-      GO TO 10
-      END
-c     DECK LENGTH
-c     
-c     
-c     
-c     
-c     RETURNS THE LENGTH OF 'STRING' EXCLUDING ANY TRAILING SPACES.
-c     
-      integer function length(string)
-      implicit none
-      character string*(*)
-c     
-c     OBTAIN THE LOCATION OF THE LAST NON-SPACE CHARACTER.
-c     
-      integer ilen,i
-c     search for the first null
-      ilen = len(string)
-c     use the position of the first null
-      do 1 i = ilen, 1, -1
-c     
-c     LENGTH FOUND.
-c     
-         if (string(i:i) .ne. char(32) .and.
-     &       string(i:i).ne.char(0)) then
-            length = i
-            return 
-         end if
-c     
-c     STRING IS ALL SPACES OR ZERO LENGTH.
-c     
-    1 continue
-      length = 0
-c     
-c     END OF INTEGER FUNCTION LENGTH.
-c     
-      return 
-      end
-
-
-
-
-
-
-
-
-
-
diff --git a/filterbank-gmrt/quickplot.test.f b/filterbank-gmrt/quickplot.test.f
deleted file mode 100644
index 9a1767e..0000000
--- a/filterbank-gmrt/quickplot.test.f
+++ /dev/null
@@ -1,1572 +0,0 @@
-c==============================================================================
-      program quickplot
-c==============================================================================
-c
-c     Create postscript summary plot of output from the "quicklook" script 
-c
-      implicit none
-
-      include 'epnhdr.f'
-      integer nepnrec,i,j,nchan,nshift,nsubints,slen,nc,lun,istat,nopass
-      real x(maxbin),y(maxbin),xmin,xmax,ymin,ymax,dat(maxbin,1024),mean
-      real psnr,ssnr,smmax,fc,bw,f1,cb,pdm,ts,to,window,phasestart,trms
-      integer kwmax,greyscale,indx(maxbin),npts,n90,ndms,nbits
-      logical filexists,susfile,cent,summary
-      real*8 pfold,pfind,susdm,sussn
-      real z(maxbin),dmmodelrms,bestrms,pms,dc,testrms,bestdc
-      character*80 telescope,machine,source,comline,date,mjd,fstring
-      character*80 period,tstring,junk,dmc
-c
-c     Initialise some variables...
-c
-      nopass = 1
-      padout=.false.
-      readwri=-1
-      recno=1
-      inquire(file='subbands.epn',exist=filexists)
-      if (.not.filexists) stop 'subbands.epn not found!'
-      inquire(file='subints.epn',exist=filexists)
-      if (.not.filexists) stop 'subints.epn not found!'
-      inquire(file='asciiheader',exist=filexists)
-      if (.not.filexists) stop 'asciiheader file not found!'
-      inquire(file='timeseries',exist=filexists)
-      if (.not.filexists) stop 'timeseries file not found!'
-      inquire(file='phasestart',exist=filexists)
-      if (filexists) then
-         call glun(lun)
-         open(lun,file='phasestart',status='old')
-         read(lun,*) phasestart
-         close(lun)
-      else
-         phasestart=0.0
-      endif
-
-      nchan=nepnrec('subbands.epn')
-      if (nchan.lt.1) stop 'no profiles found in subbands.epn'
-      write( *,*) nchan
-c      call rwepn('subbands.epn', readwri, nchan+1, padout,nopass)
-      call rwepn('subbands.epn', readwri, 1, padout,nopass)
-      write(*,*) nopass
-
-      nsubints=nepnrec('subints.epn')-1
-      if (nsubints.lt.1) stop 'no profiles found in subints.epn'
-      call rwepn('subbands.epn', readwri, 1, padout,nopass)
-      write(*,*) nopass
-      pfold=papp(1)*1000.0
-
-      call glun(lun)
-      open(lun,file='asciiheader',status='old',err=1)
-      read(lun,'(a)',err=2) telescope
-      read(lun,'(a)',err=2) machine
-      read(lun,'(a)',err=2) filename
-      read(lun,'(a)',err=2) source
-      read(lun,'(a)',err=2) mjd
-      read(lun,'(a)',err=2) date
-      read(lun,*,err=2) fc
-      read(lun,*,err=2) bw
-      read(lun,*,err=2) f1
-      read(lun,*,err=2) cb
-      read(lun,*,err=2) nc
-      read(lun,*,err=2) nbits ! new
-      read(lun,*,err=2) ts
-      read(lun,*,err=2) to
-      read(lun,'(a)',err=2) period
-      read(lun,'(a)',err=2) dmc
-      read(dmc,*) pdm
-    
-c      write(fstring,'(''F\\dOBS\\u: '',f6.3,'' GHz '',
-c     &      ''Bandwidth:'',f5.1,'' MHz Nchans: '',i4,
-c     &      ''  t\\dsamp\\u: '',f6.0,''\\gms'')') 
-c     & fc/1000.0,bw,nc,ts
-      close(lun)
-      
-      greyscale=0
-      call getarg(1,comline)
-      call getarg(2,junk)
-	
-      if (junk.eq.'greyscale'.or.junk.eq.'grayscale') greyscale=1
-      if (junk.eq.'centre'.or.junk.eq.'center') then
-         cent=.true.
-      else
-         cent=.false.
-      endif
-	cent=.true.
-      call getarg(3,junk)
-      if (junk.eq.'summary') then
-	summary=.true.
-      else
-	summary=.false.
-      endif
-      if (comline.eq.'?') then
-         call pgbegin(0,'?',1,1)
-      else 
-         if (summary) then
-           call pgbegin(0,filename(1:slen(filename))//'.ps/ps',1,1)
-	   write(*,'(a)') filename(1:slen(filename))//'.png'
-         else
-           call pgbegin(0,filename(1:slen(filename))//'.ps/vps',1,1)
-	   write(*,'(a)') filename(1:slen(filename))//'.ps'
-	 endif
-      endif
-      if (comline.eq.'greyscale'.or.comline.eq.'grayscale') greyscale=1
-      inquire(file=comline,exist=filexists)
-      if (filexists) then
-         susfile=.true.
-      else
-         susfile=.false.
-      endif
-      call pgscf(2)
-      call pgsch(0.9)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (summary) then
-	   call pgvport(0.08,0.98,0.6,0.7)
-	   call pgwindow(0.0,1.0,0.0,1.0)
-	   call pgtext(0.0,1.1,filename(1:slen(filename))//
-     &               '    P = '//period(1:slen(period))//' ms'//
-     &               '   DM = '//dmc(1:slen(dmc))//' cm-3 pc'
-     &                 )
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      xmin=+1.0e32
-      xmax=-1.0e32
-      ymin=+1.0e32
-      ymax=-1.0e32
-      call glun(lun)
-      open(lun,file='timeseries',status='old')
-      i=0
-      istat=0
-      do while(istat.eq.0) 
-         i=i+1
-         read(lun,*,iostat=istat) x(i),y(i)
-         if (istat.eq.0) then
-            xmin=min(xmin,x(i))
-            xmax=max(xmax,x(i))
-         endif
-      enddo
-      close(lun)
-      npts=i-1
-      n90=npts-npts/10
-      call indexx(npts,y,indx)
-      mean=0.0
-      do i=1,n90
-         mean=mean+y(indx(i))
-      enddo
-      mean=mean/real(n90)
-      do i=1,npts
-         y(i)=y(i)-mean
-      enddo
-      trms=0.0
-      do i=1,n90
-         trms=trms+(y(indx(i))*y(indx(i)))
-      enddo
-      trms=sqrt(trms/real(n90))
-      do i=1,npts
-         y(i)=y(i)/trms
-         ymin=min(ymin,y(i))
-         ymax=max(ymax,y(i))
-      enddo
-      if (summary) goto 111
-      if (susfile) then
-         call pgvport(0.125,0.48,0.67,0.79)
-      else 
-         call pgvport(0.125,0.925,0.67,0.79)
-      endif
-      call pgwindow(xmin,xmax,ymin,10.0)
-      
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pgline(npts,x,y)
-      call pglabel('Telescope Time (s)','Flux (rms~1)',' ')
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      write(fstring,'(''Folded '',i5,'' s of'',
-     &      i4,'' x'',f7.1,''-kHz '',i2,
-     &      ''-bit filterbank data t\\dsmp\\u:'',
-     &      i5,''\\gms'')')
-     &      int(xmax),nc,1000*abs(bw)/real(nc),nbits,int(ts)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
- 111  if (susfile) then
-         xmin=+1.0e32
-         xmax=-1.0e32
-         ymin=+1.0e32
-         ymax=-1.0e32
-         call glun(lun)
-         open(lun,file=comline,status='old',err=1)
-         read(lun,'(a)',iostat=istat) junk
-         if (junk(1:1).eq."#") then
-	   read(junk(2:),*) pfind,sussn,susdm
-	 else
-	   read(junk,*) pfind,sussn,susdm
-	 endif
-         i=0
-         do while (istat.eq.0) 
-            i=i+1
-            read(lun,*,iostat=istat) ndms,x(i),y(i)
-         enddo
-         close(lun)
-         ndms=i-1
-         bestrms=1.0e32
-	 bestdc=0.01
-         pms = real(pfold)
-         do i=1,999
-           dc  = real(i)/1000.
-	   testrms=dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pms,dc)
-           if (testrms.lt.bestrms) then
-		bestdc=dc
-		bestrms=testrms
-	   endif
-         enddo 
-         testrms=dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pms,bestdc) 
-         if (summary) then
-           call pgvport(0.3,0.5,0.5,0.7)
-	 else
-           call pgvport(0.57,0.925,0.67,0.79)
-	 endif
-         ymin=y(1)
-	 ymax=y(1)
-	 do i=1,ndms
-	   ymin=min(y(i),ymin)
-	   ymax=max(y(i),ymax)
-         enddo
-         call pgwindow(xmin,xmax,ymin,ymax*1.1)
-         call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-c         call pgsls(4)
-c         call pgline(ndms,x,y)
-c         call pgslw(4)
-         call pgsls(1)
-         call pgline(ndms,x,z)
-         call pgslw(1)
-         call pgpoint(ndms,x,y,17)
-         call pglabel('Trial DM (cm\\u-3\\d pc)','S/N',' ')
-	 call pgwindow(0.0,1.0,0.0,1.0)
-         ssnr=ymax
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      ymax=-1.0e32
-      call rwepn('subints.epn', readwri, nsubints, padout,nopass)
-      write(*,*) nopass
-
-      do i=1,nbin
-         if (rawdata(1,i).gt.ymax) then
-            ymax=rawdata(1,i)
-            j=i
-         endif
-      enddo
-      nshift=nbin/2-j
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      xmin=+1.0e32
-      xmax=-1.0e32
-      ymin=+1.0e32
-      ymax=-1.0e32
-      do i=1,nsubints
-         call rwepn('subints.epn', readwri, i, padout,nopass)
-         write(*,*) nopass
-
-
-         do j=1,nbin
-            x(j)=real(j)*real(tbin)*1.0e-3
-            xmin=min(xmin,x(j))
-            xmax=max(xmax,x(j))
-            y(j)=rawdata(1,j)
-            ymin=min(ymin,y(j))
-            ymax=max(ymax,y(j))
-         enddo
-         if (cent) call sprof(y,nbin,nshift)
-         do j=1,nbin
-            dat(j,i)=y(j)
-         enddo
-      enddo
-      
-      xmin=0.0
-      xmax=1.0
-      ymin=0.0
-      ymax=real(nsubints)
-      if (summary) then
-        call pgvport(0.56,0.76,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.28,0.43)
-      endif
-      if (greyscale.eq.1) then
-         call grayscale(dat,maxbin,1024,nbin,nsubints,1) 
-      else 
-         call quickgrey(dat,maxbin,1024,nbin,nsubints,1) 
-      endif
-      window=real(nbin)*real(tbin)*1.0e-3/pfold
-c      call pgwindow(phasestart,phasestart+window,real(nsubints+1),0.0)
-      call pgbox('bcnst',0.0,0,'bcnst',0.0,0)
-      call pglabel(' ','Subintegration',' ')
-      if (summary) 
-     & call pglabel('Pulse phase (turns)','Subintegration',' ')
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      do i=1,nchan
-         call rwepn('subbands.epn', readwri, i, padout,nopass)
-         write(*,*) nopass
-
-         do j=1,nbin
-            y(j)=rawdata(1,j)
-         enddo
-         if (cent) call sprof(y,nbin,nshift)
-         do j=1,nbin
-            dat(j,i)=y(j)
-            ymin=min(ymin,y(j))
-            ymax=max(ymax,y(j))
-         enddo
-      enddo
-      xmin=0.0
-      xmax=1.0
-      ymin=0.0
-      ymax=real(nchan)
-      if (summary) then
-        call pgvport(0.82,0.98,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.45,0.6)
-      endif
-      call pgwindow(1.0,real(nbin),0.0,real(nchan+1))
-      if (greyscale.eq.1) then
-         call grayscale(dat,maxbin,1024,nbin,nchan,1)
-      else
-         call quickgrey(dat,maxbin,1024,nbin,nchan,1)
-      endif
-c      call pgwindow(0.0,window,0.0,real(nchan+1))
-      if (summary) then
-	call pglabel('Pulse phase (turns)','Frequency band',' ')
-        call pgbox('bcnst',0.0,0,'bcnt',0.0,0)
-      else
-        call pglabel('','Frequency band',' ')
-        call pgbox('bcst',0.0,0,'bcnt',0.0,0)
-      endif
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
- 222  call rwepn('subints.epn', readwri, nsubints+1, padout,nopass)
-      write(*,*) nopass
-
-      ymin=+1.0e32
-      ymax=-1.0e32
-      do j=1,nbin
-         x(j)=real(j-1)*real(tbin)*1.0e-3
-         x(j)=j
-         y(j)=rawdata(1,j)
-         ymin=min(ymin,y(j))
-         ymax=max(ymax,y(j))
-      enddo
-      xmin=0.0
-      xmax=pms
-      xmin=0.5
-      xmax=real(nbin)+0.5
-      if (summary) then
-        call pgvport(0.08,0.23,0.5,0.7)
-      else
-        call pgvport(0.125,0.925,0.1,0.25)
-      endif
-      ymin=ymin-(ymax-ymin)*0.05
-      ymax=ymax+(ymax-ymin)*0.05
-      call pgwindow(xmin,xmax,ymin,ymax)
-      call pgbox('bcnst',0.0,0,'bc',0.0,0)
-      call pglabel('Pulse Phase (bins)','Flux density',' ')
-      if (cent) call sprof(y,nbin,nshift)
-      call pgmove(xmin,y(1))
-      do i=1,nbin-1
-         call pgdraw(x(i)+0.5,y(i))
-         call pgdraw(x(i)+0.5,y(i+1))
-      enddo
-      call pgdraw(xmax,y(nbin))
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (.not.cent) call sprof(y,nbin,nshift)
-      call smooth(y,nbin,kwmax,psnr,smmax)
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      if (summary) then
-        call pgwindow(0.0,1.0,0.0,1.0)
-	write(junk,'(f6.1)') psnr
-	call pgtext(0.7,0.8,junk)
-	goto 333
-      endif
-      call pgvport(0.125,0.925,0.1,1.0)
-      call pgvport(0.06,0.925,0.1,1.0)
-      call pgwindow(0.0,1.0,0.0,1.0)
-      call pgtext(0.0,0.9,telescope(1:slen(telescope))//
-     &     ' '//machine(1:slen(machine))//': '//
-     &     filename(1:slen(filename))//'.ps')
-      call pgtext(0.0,0.875,'J2000 coords: '//source(1:slen(source))//
-     &     ' MJD: '//mjd(1:slen(mjd))//' Date: '//date(1:len(date)))
-      call pgtext(0.0,0.85,fstring)
-      write(tstring,'(''P\\dfromSEEK\\u: '',f16.10,
-     & '' ms  DM: '',f7.2,'' cm\\u-3\\d pc'',''  SEEK S/N: '',f6.1)') 
-     &   pfind,pdm,ssnr
-      call pgtext(0.0,0.825,tstring)
-      write(tstring,'(''P\\doptimized\\u: '',f16.10,
-     & '' ms N\\dbins\\u: '',i4,
-     & '' DC: '',f4.1,''%   PROF S/N: '',f6.1)') 
-     & pfold,nbin,bestdc*100,psnr
-      call pgtext(0.0,0.8,tstring)
- 333  call pgend
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      stop
- 1    stop 'ERROR: opening asciiheader'
- 2    stop 'ERROR: reading asciiheader'
-      end
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      real function dmmodelrms(ndms,x,y,z,xmin,xmax,pdm,bw,fc,pfold,dc)
-      integer ndms
-      real x(*),y(*),z(*),xmin,xmax,pdm,bw,fc,pfold,dc,weff
-      real ssq,zmax,wint,ymax
-      integer i
-      zmax=0.0
-      wint=dc*pfold
-      xmin=0.0
-      xmax=0.0	
-      ymax=0.0
-      do i=1,ndms
-        weff=sqrt(wint**2.0+(8.3e6*abs(pdm-x(i))*bw/fc/fc/fc)**2.0)
-        if(weff.gt.pfold) then
-  	  z(i)=0.0
-	  if (xmin.ne.0.0.and.xmax.eq.0.0) xmax=x(i)*1.1
-	else
-	  if (xmin.eq.0.0.and.xmax.eq.0.0) xmin=x(i)*0.9
-	  z(i)=sqrt(pfold-weff)/sqrt(weff)
-	endif
-        ymax=max(ymax,y(i))
-	zmax=max(zmax,z(i))
-      enddo
-      ssq=0.0
-      do i=1,ndms
-        z(i)=z(i)*ymax/zmax
-        ssq=ssq+(y(i)-z(i))**2.0
-      enddo
-      dmmodelrms=sqrt(ssq/real(ndms))
-      if (xmax.eq.xmin) then
-	xmin=x(1)
-	xmax=x(ndms)
-      endif
-      if (xmax.eq.0.0) xmax=x(ndms)*1.1
-      end
-ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
-      integer function slen(string)
-      character string*(*)
-c     
-c     OBTAIN THE LOCATION OF THE LAST NON-SPACE CHARACTER.
-c     
-      integer ilen
-c     search for the first null
-      ilen = len(string)
-c     use the position of the first null
-      do 1 i = ilen, 1, -1
-c     
-c     LENGTH FOUND.
-c     
-         if (string(i:i) .ne. char(32) .and.
-     &       string(i:i).ne.char(0)) then
-            slen = i
-            return 
-         end if
-c     
-c     STRING IS ALL SPACES OR ZERO LENGTH.
-c     
-    1 continue
-      slen = 0
-c     
-c     END OF INTEGER FUNCTION LENGTH.
-c     
-      return 
-      end
-      subroutine quickgrey(dat,nxd,nyd,nx,ny,flip)
-
-c  Coarse grey-scale plot using PG plot routines
-c  Assumed that viewport and window defined outside routine
-        integer nxd,nyd
-        integer nsym,flip
-        parameter(nsym=10)
-	integer*4 ksym(nsym)
-	real*4 dat(nxd,nyd)
-	data ksym/1,20,21,2,3,14,15,17,16,18/
-
-	s=0.
-	ss=0.
-	smin=1.e30
-	smax=-smin
-	do j=1,ny
-	  do i=1,nx
-	    aa=dat(i,j)
-	    s=s+aa
-	  enddo
-	enddo
-	s=s/(nx*ny) 
-	do j=1,ny
-	  do i=1,nx
-            aa=dat(i,j)-s
-	    ss=ss+aa**2
-	    if(aa.gt.smax)smax=aa
-	    if(aa.lt.smin)smin=aa
-	  enddo
-	enddo
-	rms=sqrt(ss/(nx*ny))
-
-        if (flip.eq.1) then
-           call pgwindow(1.0,real(nx),real(ny+1),0.0)
-        else 
-           call pgwindow(1.0,real(nx),0.0,real(ny+1))
-        endif
-	do j=1,ny
-	  do i=1,nx
-	    k=min(int((dat(i,j)-s)/rms),nsym)
-	    if(k.gt.0)then
-	      x=i
-	      y=j
-	      call pgpoint(1,x,y,ksym(k))
-	    endif
-	  enddo
-	enddo
-
-	return
-	end
-
-
-
-c==============================================================================
-C nicked from pgplot
-C*GRGLUN -- get a Fortran logical unit number (Sun/Convex-UNIX)
-C+
-      SUBROUTINE GLUN(LUN)
-      INTEGER LUN
-C
-C Get an unused Fortran logical unit number. 
-C Returns a Logical Unit Number that is not currently opened.
-C After GRGLUN is called, the unit should be opened to reserve
-C the unit number for future calls.  Once a unit is closed, it
-C becomes free and another call to GRGLUN could return the same
-C number.  Also, GRGLUN will not return a number in the range 1-9
-C as older software will often use these units without warning.
-C
-C Arguments:
-C  LUN    : receives the logical unit number, or -1 on error.
-C--
-C 12-Feb-1989 [AFT/TJP].
-C DRL adapted to subroutine GLUN for use with stand-alone software
-C 16-Jul-1993 @ JB
-c==============================================================================
-      INTEGER I
-      LOGICAL QOPEN
-C---
-      DO 10 I=99,10,-1
-          INQUIRE (UNIT=I,  OPENED=QOPEN)
-          IF (.NOT.QOPEN) THEN
-              LUN = I
-              RETURN
-          END IF
-   10 CONTINUE
-C none left
-      STOP 'RAN OUT OF LUNs!' 
-      END
-c==============================================================================
-c
-c     File: "rwepn.f"
-c     
-c     This file contains the generalised EPN format reading/writing routines
-c     It has been tested on an HP system with f77 -c rwepn.f to produce the 
-c     object file. It requires the accompanying include file "epnhdr.f"
-c
-c==============================================================================
-       subroutine rwepn(filename2,readwri,recno,padout,nopass)
-c==============================================================================
-c
-c     Subroutine to read or write data in EPN format. All parameters are
-c     defined in the include file "epnhdr.f" which should lie in the
-c     same directory as this file. Passed down variables to this routine
-c     are:
-c
-c     filename - character*80  - name of this EPN file
-c     readwri  - integer*4     - switch: -1 => read, +1 => write
-c     recno    - integer*4     - record number to read
-c
-c     Usage:
-c
-c     To incorporate this routine into your pulsar data reduction
-c     package, include the file "epnhdr.f" in your source code
-c     and set up the appropriate variables before.
-c
-c     Features:
-c
-c     When writing is requested, the routine will keep the file
-c     open for successive writes by default. To override this, pass
-c     down recno as -1, the presently opened file will be closed
-c     and a new one opened.
-c
-c     If an error occurs in reading, recno is returned as -999
-c
-c     By the very nature of the format, record lengths must be fixed.
-c     So if you want to have different lengthed data streams in the
-c     same archive you need to switch "padout" on. As its name suggests,
-c     this pads out the binned data to its maximum length so that
-c     the records are fixed. A draw back is of course that it uses
-c     up more space. Therefore if it is known that all the records
-c     are of the same lenght anyway (eg for a stream of single pulses)
-c     then it is recommended to switch padout off.
-c
-c==============================================================================
-c
-c     Created by Dunc Lorimer (dunc@mpifr-bonn.mpg.de) November 1996....
-c
-c     12/11/1996   Initial version
-c     15/11/1996   Implemented common blocks
-c     21/05/1997   Changed to HEX storage
-c     01/07/1997   Added tres and fluxflag to header
-c
-c==============================================================================
-c
-      implicit none
-      character*(*) filename2
-      integer nopass
-      include 'epnhdr.f' 
-c
-c     Data buffers...
-c
-      integer*4 intdata(maxbin) 
-      character*4 chrdata(maxbin)
-      real*4 tmp(maxbin)
-c
-c     The maximum length of an EPN file is the 6 line header, plus
-c     maxblk sets of maxbin bin data streams. Each stream of maxbin
-c     bins occupies (maxbin/20) sets of 80 character lines plus a 2
-c     line header. The number of charcters per record is:
-c
-c     (6+maxblk*(maxbin/20+2))*80 
-c
-c     One can tune this depending on the size of the data-sets...
-c     the default is maxblk=8, maxbin=4160 -> maxrec=66080
-c     suitable smaller setting for e.g. a PC would be...
-c                    maxblk=4, maxbin=1040 -> maxrec=17760.
-c     N.B. Both maxbin and maxblk are specified in "epnhdr.f"
-c
-      integer maxrec
-      parameter(maxrec=(6+maxblk*(maxbin/20+2))*80)
-      character line(maxrec/80)*80, recrd*(maxrec)
-c
-c==============================================================================
-c
-c     Local variables
-c
-      integer lun, lfil, nlin, next, i, j, k, l, iras, ipol,
-     &        wrecno, recln, maxint, lct, length,nos
-      real rras, pvno, vno
-      character*1 dsign, lin1*12, line40*40
-      logical reading,writing,filex,opened,first,ops
-      save
-      data opened/.false./, first/.true./
-      line40='----------------------------------------'
-c
-c==============================================================================
-c
-c     Sort out whether reading or writing
-c
-      write( *, *) 'This is RWEPN PASS no ', nopass,readwri,filename2
-      nopass = nopass + 1
-      reading=(readwri.eq.-1)
-      writing=(.not.reading)
-      if (readwri.ne.-1.and.readwri.ne.1) then
-         write(*,'(''Unknown read/write option passed to rwepn!!'')')
-         write(*,'(''Your "readwri" integer reads: '',i4)')readwri
-         stop
-      endif
-c
-c     If writing required and recno=-1, then close a previously
-c     opened file (if one is open) and proceed
-c
-      if (writing.and.recno.eq.-1.and.opened) then
-         close(unit=lun)
-         opened=.false.
-      endif
-c
-c     Get a free logical unit number
-c
-      if (.not.opened) call glun(lun)
-c
-c     Check whether the file exists or not....
-c     
-c     For reading: the routine will stop if not
-c     For writing: the routine will append to the previous file
-c
-      lfil=length(filename2)
-      filename=filename2(1:lfil)
-      inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-      write( *,*) filename, ops, nos
-c
-c     Open the input file
-c
-      if (reading) then
-         if (filex) then
-c
-c          Read in the very first line, and work out the
-c          required record length...(number of 80 chr lines)
-c
-           write( *,*) lun
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=12)
-           read(lun,rec=1) lin1
-           read(lin1,'(8x,i4)') counter
-           close(unit=lun)
-           recln=counter*80
-           inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-           write( *,*) filename, ops, nos
-c
-c          Now open as a direct access unformatted file
-c
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=recln)
-           if (recno.lt.1) recno=1
-           read(lun,rec=recno,err=999) recrd(1:recln)
-           close(unit=lun)
-           inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-           write( *,*) filename, ops, nos
-         else
-           stop 'EPN file does not exist!'
-         endif
-      endif
-      inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-      write( *,*) filename, ops, nos
-      if (writing) then
-c
-c       Establish out how many 'lines' will make up this record...
-c
-        if (padout) then
-           recln=maxrec ! use maximum record length
-           nlin=maxbin/20
-           npol=maxblk
-           counter=6+npol*(nlin+2)
-        else
-           nlin=nbin/20
-           next=nbin-nlin*20
-           if (next.gt.0) nlin=nlin+1
-           counter=6+npol*(nlin+2)
-           recln=counter*80
-        endif
-        if (opened) then
-c
-c          Increase the internal record counter
-c
-           wrecno=wrecno+1
-        else
-c
-c          Reset the internal record counter...
-c
-           wrecno=1
-           open(unit=lun,file=filename(1:lfil),status='unknown',
-     &          access='direct',form='unformatted',recl=recln)
-           opened=.true.
-        endif
-      endif
-      inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-      write( *,*) filename, ops, nos
-c
-c     As from Version 5.0 data is scaled into hex format...
-c     This gives an increas in dynamic range by over a factor 6
-c
-      pvno=5.0
-      maxint=65535
-c
-c     As from Version 6.0, actual resolution of the data is
-c     recorded, the factor fcal is no longer recorded, instead
-c     the flag fluxflag is written into line 4 to signify whether
-c     the data are flux calibrated or not. (1.7.1997)
-c
-      pvno=6.0
-      lct=1
-c
-c     Line 1
-c
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),11) version, counter, history
-        read(version(4:),'(f5.2)') vno
-        if (vno.lt.pvno) then
-           if (first) then
-              write(*,*) 'Reading an old EPN file - Version',vno
-              first=.false.
-           endif
-           maxint=9999
-        endif
-      else
-        vno=pvno
-        write(version,'(a3,f5.2)') 'EPN',vno
-        write(line(lct),11) version, counter, history
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,11) version, counter, history
-c
- 11   format(a8,i4,a68)
-c
-c     Line 2
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),22) 
-     &  jname,cname,pbar,dm,rm,catref,bibref
-      else
-        write(line(lct),22) jname, cname, pbar, dm, rm, catref, bibref
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,22) jname, cname, pbar, dm, rm, catref, bibref
-c
- 22   format(a12,a12,f16.11,f8.3,f10.3,a6,a8,8x)
-c
-c     Line 3
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),33) 
-     &               rah,ram,iras,rras,dsign,ded,dem,des, 
-     &               telname, epoch, opos, paflag, timflag
-        ras=float(iras)+rras
-        if (dsign.eq.'-') ded=-1*ded
-        if (dsign.eq.'-'.and.ded.eq.0) then
-           dem=-1*dem
-           des=-1.0*des
-        endif
-      else
-        rras=ras-int(ras)
-        iras=int(ras)
-        dsign='+'
-        if (index(jname,'-').gt.0) dsign='-'
-        if (ded.lt.0) ded=-1*ded
-        write(line(lct),33) rah, ram, iras, rras, dsign, ded, dem, des, 
-     &               telname, epoch, opos, paflag, timflag
-      endif
-c
-c     Un-comment this line for tracing... 
-c      write(*,33) rah, ram, iras, rras, dsign, ded, dem, des, telname, 
-c     &           epoch, opos, paflag, timflag
-c
- 33    format(3i2.2,f4.3,a1,2i2.2,f6.3,a8,f10.3,f8.3,a1,a1,31x)
-c
-c     Line 4 - (X,Y,Z) of telescope - NEW - implemented in V 6.0
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        if (reading) then
-           read(recrd((lct-1)*80+1:lct*80),44) xtel,ytel,ztel
-        else
-           write(line(lct),44) xtel,ytel,ztel
-        endif
-      endif
- 44   format(3f17.5,29x) 
-c
-c     Line 5
-c
-      lct=lct+1
-      if (reading) then
-        if (vno.ge.6.0) then
-        read(recrd((lct-1)*80+1:lct*80),55) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-        else
-        read(recrd((lct-1)*80+1:lct*80),56) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, nint, ncal, lcal, fcal
-        endif
-      else
-        write(line(lct),55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, tres, nint, ncal, lcal, fluxflag
-c      write(*,56) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, nint, ncal, lcal, fcal
-c
- 55   format(2i2.2,i4.4,2i4.4,i2,i4,i4,2f12.6,i6,i4,i4,a1,15x) ! Version 6
- 56   format(2i2.2,i4.4,2i4.4,i2,i4,i4,f12.6,i6,i4,i4,f8.3,20x)
-c
-c     Line 6 - Blank at the moment
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        write(line(lct),66) line40,line40
-      endif
- 66   format(2a40) 
-c      
-c     Loop around each polarisation...
-c
-      do ipol=1,npol
-c
-c       sub-header line 1
-c
-        lct=lct+1
-        if (reading) then
-          if (vno.ge.6.0) then
-          read(recrd((lct-1)*80+1:lct*80),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-          else
-          f0u(ipol)=' GHz'
-          dfu(ipol)=' MHz'
-          read(recrd((lct-1)*80+1:lct*80),78) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),df(ipol),tstart(ipol)
-          endif
-        else
-          if (f0u(ipol).eq.' ') f0u(ipol)=' GHz'  ! Default units
-          if (dfu(ipol).eq.' ') dfu(ipol)=' MHz'  ! Default units
-          write(line(lct),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c       write(*,77) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-c       write(*,78) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              df(ipol),tstart(ipol)
-c
- 77     format(a8,i4,i4,f12.8,a8,f12.6,a8,f17.5,7x)
- 78     format(a8,i4,i4,f12.8,f12.6,f17.5,23x)
-        if (writing) then 
-c
-c         Zero the integer and character arrays
-c
-          do i=1,maxbin
-            intdata(i)=0
-	    chrdata(i)='0000'
-          enddo
-c
-c         Scale the data
-c     
-          do k=1,nbin
-             tmp(k)=rawdata(ipol,k)
-          enddo
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-c
-c         Convert to a hex string
-c
-          do k=1,nbin
-             call b102hex(intdata(k),chrdata(k))
-          enddo
-        endif
-c
-c       Sub-header line 2
-c
-        lct=lct+1
-        if (reading) then
-          read(recrd((lct-1)*80+1:lct*80),88)  scale(ipol),offset(ipol),
-     &    rms(ipol),papp(ipol)
-        else
-          write(line(lct),88) scale(ipol),offset(ipol),
-     &                            rms(ipol),papp(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c        write(*,88) scale(ipol), offset(ipol), rms(ipol), papp(ipol)
-c
- 88     format(3e12.6,f16.11,28x) 
-c
-c       Now we finally get to the data!!
-c
-c
-c       Read the data (20 i4s per 80 column line)
-c
-        nlin=(counter-4)/npol-2
-        if (vno.ge.6.0) nlin=(counter-6)/npol-2
-        k=1
-        do i=1,nlin
-          lct=lct+1
-          if (reading) then
-c            read(recrd((lct-1)*80+1:lct*80),99)(chrdata(j),j=k,k+19)
-            l=0
-	    do j=k,k+19
-              chrdata(j)=recrd((lct-1)*80+1+l:(lct-1)*80+4+l)
-              call hex2b10(chrdata(j),intdata(j))
-              l=l+4
-	    enddo
-          else
-c            write(line(lct),99)(chrdata(j),j=k,k+19)
-            l=1
-	    do j=k,k+19
-              line(lct)(l:l+3)=chrdata(j)
-              l=l+4
-	    enddo
-          endif
-c
-c         Un-comment this line for tracing...
-c          write(*,99)(chrdata(j),j=k,k+19)
-c
-          k=k+20
-        enddo
-c
-c       Format for the data
-c
- 99     format(20a4)
-        if (reading) then
-c
-c         Convert hex string to integer for versions from 5.0
-c
-          do k=1,nbin
-             if (vno.ge.5.0) then
-c                call hex2b10(chrdata(k),intdata(k))
-             else
-                read(chrdata(k),'(i4.4)') intdata(k)
-             endif
-          enddo
-c
-c         De-scale the data
-c     
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-          do k=1,nbin
-             rawdata(ipol,k)=tmp(k)
-          enddo
-        endif
-      enddo
-c
-c     Write the record...
-c
-      if (writing) then
-        do i=1,lct
-          j=(i-1)*80+1
-          k=j+79
-          recrd(j:k)=line(i)
-        enddo
-        write(lun,rec=wrecno) recrd(1:k)
-        return
-      endif
-      inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-      write( *,*) filename, ops, nos
-c
-c     Bail out!
-c
-      return
-c
-c     On error return this record number
-c
- 999  recno=-999
-      inquire(file=filename(1:lfil),exist=filex,OPENED=ops,NUMBER=nos)
-      write( *,*) filename, ops, nos
-      end
-c==============================================================================
-      subroutine hex2b10(hexstr,b10no)
-c==============================================================================
-
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      b10no=0
-      dig=0
-
-      do i=4,1,-1
-         do j=1,16
-            if (hexstr(i:i).eq.hex(j)) goto 5
-         enddo
- 5       continue
-         b10no=b10no+int(16.0**float(dig)*float(j-1))
-         dig=dig+1
-      enddo
-
-      end
-c==============================================================================
-      subroutine b102hex(b10no,hexstr)
-c==============================================================================
-c
-c	Converts a base 10 number passed down as the integer "b10no"
-c	to a hexadeximal string returned as the character*4 "hexstr"
-c       N.B. maximum integer for 4 character hex string is 65535
-c
-      implicit none
-
-      integer b10no
-      character*4 hexstr
-      character*1 hex(16)
-      integer i,j,no,num,dig
-      data hex/'0','1','2','3','4','5','6','7','8','9',
-     &         'A','B','C','D','E','F'/
-
-      no=b10no
-      dig=0
-
-      do i=4,1,-1
-         do j=15,0,-1
-            num=int(float(j)*16.0**float(i-1))
-            if (num.le.no) goto 5
-         enddo
- 5       continue
-         dig=dig+1
-         hexstr(dig:dig)=hex(j+1)
-         no=no-num
-      enddo
-
-      end
-c==============================================================================
-      subroutine rawtfint(raw,nbin,intdata,scale,offset,rms,dirn,maxint)
-c==============================================================================
-c
-c     Routine to convert "raw" (i.e. floating point) to/from integer
-c     format. In this case, the integer may vary between 0 and maxint.
-c     Raw data is passed down from site software and stored as integers
-c     in the EPN files.
-c
-c     The direction of the conversion is controlled by "dirn":
-c
-c     dirn = +1 : raw -> int
-c     dirn = -1 : int -> raw
-c
-c==============================================================================
-c    
-      implicit none
-c
-c     Passed down variables
-c
-      real raw(*)
-      real*8 scale, offset, rms
-      integer nbin, intdata(*), dirn, maxint
-c
-c     Local variables
-c
-      real dmin, dmax, sumsq, pmax, sum, mean, ndiv
-      integer i, ibmax, nshift
-      if (dirn.eq.1) then
-c
-c       Scale the data:
-c
-c       Find minimum & maximum values of the data
-c
-        dmin = raw(1)
-        dmax = raw(1)
-        do i=1,nbin
-          dmax=max(raw(i),dmax)
-          dmin=min(raw(i),dmin)
-        enddo
-        offset=dmin
-        scale=float(maxint)/(dmax-dmin)
-c
-c       Now do the scaling
-c
-        do i=1,nbin
-          intdata(i)=int((raw(i)-offset)*scale)
-        enddo
-c
-c-------------------------------------------------------------
-c       If no rms has been supplied by the user, have a go at 
-c       calculating it from the wings of the profile after 
-c       shifting it so that its peak lies at bin number nbin/2
-c-------------------------------------------------------------
-c
-        if (rms.eq.0.0) then
-          pmax=-1.0e32
-          ibmax=0
-          do i=1,nbin
-             if (raw(i).gt.pmax) then
-                ibmax=i
-                pmax=raw(i)
-             endif
-          enddo
-          nshift=nbin/2-ibmax
-          call sprof(raw,nbin,nshift)
-          sumsq=0.0
-          sum=0.0
-          do i=1,nbin/15
-            sumsq=sumsq+raw(i)*raw(i)
-            sumsq=sumsq+raw(nbin-i+1)*raw(nbin-i+1)
-            sum=sum+raw(i)
-            sum=sum+raw(nbin-i+1)
-          enddo
-	  ndiv=max(1.0,float(2*nbin/15))
-          rms=sqrt(sumsq/ndiv)
-          mean=sum/ndiv
-        endif
-      else if (dirn.eq.-1) then
-c
-c       Prepare to de-scale the data:
-c
-        do i=1,nbin
-          raw(i)=real(offset+dble(intdata(i))/scale)
-        enddo
-      else
-c
-c       Silly option was passed down...
-c
-        write(*,*) 'Invalid value for dirn passed to rawtfint : ',dirn
-        stop
-      endif
-c
-c     Job done!
-c
-      end
-c==============================================================================
-      integer function nepnrec(filename)
-c==============================================================================
-c
-c     Function to find out the number of records in an EPN file.
-c
-c     This can in principle be done with an INQUIRE statement but
-c     it is system dependent. The following approach uses a simple
-c     binary search algorithm to find the last record which is far
-c     quicker than reading in every record in very large EPN files.
-c
-c     if the file doesn't exist nepnrec is returned as 0
-c     nepnrec = -1 if an error occurred whilst reading the file
-c
-c     Created 96/12/03 DRL@MPIfR
-c     Modified October 1997 to return -1 on error
-c
-c
-      implicit none
-      character*(*) filename
-
-      character lin1*12,recrd*80
-      integer irec,istat,counter,recln,hirec,lorec,orec,lun
-      logical filex
-c
-c     Check to see whether the EPN file exists...
-c     return nepnrec=0 if it doesn't
-c
-      nepnrec=0
-      inquire(file=filename,exist=filex)
-      if (.not.filex) return 
-c
-c     It exists! Open it and find out the true record length..
-c
-      call glun(lun)
-      nepnrec=-1 ! This will be the value of nepnrec if an error occurs
-      irec=-1
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=12,err=999)
-      read(lun,rec=1,err=999)lin1
-      read(lin1,'(8x,i4)',err=999)counter
-      close(unit=lun)
-      recln=counter*80
-      if (recln.le.0) return ! Error
-c
-c     Find out crude lower and upper bounds for the last record
-c
-      open(unit=lun,file=filename,status='old',access='direct',
-     &     form='unformatted',recl=recln,err=999)
-      irec=1
-      istat=0
-      do while(.true.)
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.ne.0) goto 998
-         irec=irec*2
-      enddo
- 998  hirec=irec
-      lorec=irec/2
-c
-c     Now search for the last record within these bounds iteratively
-c
-      istat=0
-      orec=0
-      do while(orec.ne.irec)
-         orec=irec
-         irec=lorec+(hirec-lorec)/2
-         read(lun,rec=irec,iostat=istat) recrd
-         if (istat.eq.0) then
-            lorec=irec
-         else
-            hirec=irec
-         endif
-      enddo
- 999  continue
-      close(unit=lun)
-      nepnrec=irec
-      end
-c============================================================================= 
-      subroutine dattim(date,hh,mm,ss)
-c============================================================================= 
-c
-c     Returns the time obtained by truncating the MJD passed down
-c     as date
-c
-      implicit none 
-      double precision date,dummy,ss
-      integer hh,mm
-
-
-      dummy=abs(date-int(date))
-
-      dummy=dummy*24.0
-      hh=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      mm=int(dummy)
-
-      dummy=abs(dummy-int(dummy))
-
-      dummy=dummy*60.0
-      ss=dummy
-
-      end
-      subroutine smooth(pr,nbin,kwmax,snrmax,smmax)
-c******************************************************************
-c
-c  convolves profile pr(nbin) with a boxcar of width kw.  it returns
-c    the width kwmax which gave the highest s/n ratio snrmax, and the
-c    corresponding pulse amplitude smmax.
-c
-c******************************************************************
-c
-
-      integer nbin,kwmax
-      real*4 pr(*),rmsp,snrmax,smmax
-c
-      integer j,k,kw,nn,ja,jj
-      real*4 s,wrk(43),al,an,sn,smax
-c
-      snrmax=0.
-c---------------------------------------
-c  remove baseline
-c      ksm=nbin/2.5+0.5
-c      smax=1.e30
-c      do 10 j = 1,nbin
-c        s=0.0
-c        do 20 k = 1,ksm
-c          s = s + pr(mod(j+k-1,nbin)+1)
-c   20   continue
-c        if(s.lt.smax) smax=s
-c   10 continue
-c      smax=smax/ksm
-c      do 30 j = 1,nbin
-c        pr(j) = pr(j) - smax
-c   30 continue
-c--------------------------------------
-c      remove baseline and calc rmsp
-      do i=1,2
-      s=0
-      k=0
-      do j=1,nbin
-         if (j.le.nbin/10.or.j.ge.nbin-nbin/10) then
-            k=k+1
-            s=s+pr(j)
-         endif
-      enddo
-      s=s/real(k)
-      do j=1,nbin
-         pr(j)=pr(j)-s
-      enddo
-      enddo
-      k=0
-      rmsp=0.0
-      do j=1,nbin
-         if (j.le.nbin/10.or.j.ge.nbin-nbin/10) then
-            k=k+1
-            rmsp=rmsp+pr(j)*pr(j)
-         endif
-      enddo
-      rmsp=sqrt(rmsp/real(k))
-c
-c
-      do 40 nn=1,6
-        kw=2**(nn-1)
-        if(kw.gt.nbin/2) return
-	s=0.0
-	do 50 k=1,kw
-	  s=s+pr(k)
-	  wrk(k)=pr(k)
-   50   continue
-	ja=0
-	smax=s
-	do 60 j=2,nbin
-	  ja=ja+1
-	  if(ja.gt.kw) ja=ja-kw
-	  al=wrk(ja)
-	  jj=j+kw-1
-	  if(jj.gt.nbin)jj=jj-nbin
-	  an=pr(jj)
-	  s=s+an-al
-	  wrk(ja)=an
-	  if(s.gt.smax) smax=s
-   60   continue
-
-        sn=smax/(rmsp*sqrt(kw*(1.+real(kw)/nbin)))
-        if(sn.gt.snrmax) then
-          snrmax=sn
-          kwmax=kw
-          smmax=smax/kw
-        endif
-   40 continue
-
-      end
-c==============================================================================
-      subroutine sprof(profile,nbins,shift)
-c==============================================================================
-c
-c     shifts the profile in the array profile() with nbins bins by the 
-c     number of bins passed down in shift. shift>0 means shift forward,
-c     shift<0 means shift backwards.
-c
-      implicit none
-
-      real profile(*)
-      integer nbins, shift
-c
-c     local variables
-c
-      integer i,j
-      real dummy
-
-      if (shift.lt.0) shift=nbins+shift
-      do i=1,shift
-         dummy=profile(nbins)
-         do j=nbins,2,-1
-            profile(j)=profile(j-1)
-         enddo
-         profile(1)=dummy
-      enddo
-
-      end
-      subroutine grayscale(dat,nxd,nyd,nx,ny,flip)
-
-      integer nxd,nyd
-      integer nsym,flip
-      parameter(nsym=10)
-      real*4 dat(nxd,nyd),tr(6),xw,yw
-      save
-      
-      s=0.
-      ss=0.
-      do j=1,ny
-	 smin=1.0e30
-         do i=1,nx
-	    aa=dat(i,j)
-	    smin=min(smin,aa)
-	    s=s+aa
-         enddo
-	 do i=1,nx
-	    dat(i,j)=dat(i,j)-smin
-	 enddo
-      enddo
-      s=s/(nx*ny) 
-      smin=1.e30
-      smax=-smin
-      do j=1,ny
-         do i=1,nx
-            aa=dat(i,j)-s
-	    ss=ss+aa**2
-	    smax=max(smax,dat(i,j))
-	    smin=min(smin,dat(i,j))
-	    smin=min(smin,dat(i,j))
-         enddo
-      enddo
-      rms=sqrt(ss/(nx*ny))
-      
-      tr(1)=0.0
-      tr(2)=1.0
-      tr(3)=0.0
-      tr(4)=0.0
-      tr(5)=0.0
-      tr(6)=1.0
-      xmin=xw(tr,0.5,0.5)
-      ymin=yw(tr,0.5,0.5)
-      xmax=xw(tr,real(nx)+0.5,real(ny)+0.5)
-      ymax=yw(tr,real(nx)+0.5,real(ny)+0.5)
-
-      if (flip.eq.1) then
-         call pgwindow(xmin,xmax,ymax,ymin)
-      else
-         call pgwindow(xmin,xmax,ymin,ymax)
-      endif
-c      call pggray(dat,nxd,nyd,1,nx,1,ny,smax,s+0.5*rms,tr)
-      call pggray(dat,nxd,nyd,1,nx,1,ny,smax,smin,tr)
-      
-      end
-
-
-      real function xw(tr,i,j)
-      real tr(6),i,j
-      xw=tr(1)+tr(2)*i+tr(3)*j
-      end
-      
-      real function yw(tr,i,j)
-      real tr(6),i,j
-      yw=tr(4)+tr(5)*i+tr(6)*j
-      end
-      
-C from numerical recipes
-      SUBROUTINE INDEXX(N,ARRIN,INDX)
-      DIMENSION ARRIN(N),INDX(N)
-      if (n.eq.1) then
-	indx(1)=1
-        return
-      endif
-      DO 11 J=1,N
-         INDX(J)=J
- 11   CONTINUE
-      L=N/2+1
-      IR=N
- 10   CONTINUE
-      IF(L.GT.1)THEN
-         L=L-1
-         INDXT=INDX(L)
-         Q=ARRIN(INDXT)
-      ELSE
-         INDXT=INDX(IR)
-         Q=ARRIN(INDXT)
-         INDX(IR)=INDX(1)
-         IR=IR-1
-         IF(IR.EQ.1)THEN
-            INDX(1)=INDXT
-            RETURN
-         ENDIF
-      ENDIF
-      I=L
-      J=L+L
- 20   IF(J.LE.IR)THEN
-         IF(J.LT.IR)THEN
-            IF(ARRIN(INDX(J)).LT.ARRIN(INDX(J+1)))J=J+1
-         ENDIF
-         IF(Q.LT.ARRIN(INDX(J)))THEN
-            INDX(I)=INDX(J)
-            I=J
-            J=J+J
-         ELSE
-            J=IR+1
-         ENDIF
-         GO TO 20
-      ENDIF
-      INDX(I)=INDXT
-      GO TO 10
-      END
-c     DECK LENGTH
-c     
-c     
-c     
-c     
-c     RETURNS THE LENGTH OF 'STRING' EXCLUDING ANY TRAILING SPACES.
-c     
-      integer function length(string)
-      implicit none
-      character string*(*)
-c     
-c     OBTAIN THE LOCATION OF THE LAST NON-SPACE CHARACTER.
-c     
-      integer ilen,i
-c     search for the first null
-      ilen = len(string)
-c     use the position of the first null
-      do 1 i = ilen, 1, -1
-c     
-c     LENGTH FOUND.
-c     
-         if (string(i:i) .ne. char(32) .and.
-     &       string(i:i).ne.char(0)) then
-            length = i
-            return 
-         end if
-c     
-c     STRING IS ALL SPACES OR ZERO LENGTH.
-c     
-    1 continue
-      length = 0
-c     
-c     END OF INTEGER FUNCTION LENGTH.
-c     
-      return 
-      end
-
-
-
-
-
-
-
-
-
-
diff --git a/filterbank-gmrt/quikgray.f b/filterbank-gmrt/quikgray.f
deleted file mode 100644
index 9d2c636..0000000
--- a/filterbank-gmrt/quikgray.f
+++ /dev/null
@@ -1,71 +0,0 @@
-	subroutine quikgray(dat,nxd,nyd,nx,ny)
-
-c  Coarse grey-scale plot using PG plot routines
-c  Assumed that viewport and window defined outside routine
-        integer nxd,nyd
-        integer nsym
-        parameter(nsym=10)
-	integer*4 ksym(nsym)
-	real*4 dat(nxd,nyd),tr(6),xw,yw
-	data ksym/1,20,21,2,3,14,15,17,16,18/
-
-	s=0.
-	ss=0.
-	smin=1.e30
-	smax=-smin
-	do j=1,ny
-	  do i=1,nx
-	    aa=dat(i,j)
-	    s=s+aa
-	  enddo
-	enddo
-	s=s/(nx*ny) 
-	do j=1,ny
-	  do i=1,nx
-            aa=dat(i,j)-s
-	    ss=ss+aa**2
-	    smax=max(smax,dat(i,j))
-	    smin=min(smin,dat(i,j))
-	  enddo
-	enddo
-	rms=sqrt(ss/(nx*ny))
-        
-	tr(1)=0.0 
-	tr(2)=1.0/real(nx)
-	tr(3)=0.0
-	tr(4)=0.0
-	tr(5)=0.0
-	tr(6)=1.0
-	xmin=xw(tr,0.5,0.5)
-	ymin=yw(tr,0.5,0.5)
-	xmax=xw(tr,real(nx)+0.5,real(ny)+0.5)
-	ymax=yw(tr,real(nx)+0.5,real(ny)+0.5)
-	call pgwindow(xmin,xmax,ymin,ymax)
-        call pggray(dat,nxd,nyd,1,nx,1,ny,smax,s+0.5*rms,tr)
-
-	return
-
-	do j=1,ny
-	  do i=1,nx
-	    k=min(int((dat(i,j)-s)/rms),nsym)
-	    if(k.gt.0)then
-	      x=i
-	      y=j
-	      call pgpoint(1,x,y,ksym(k))
-	    endif
-	  enddo
-	enddo
-
-	end
-
-
-	real function xw(tr,i,j)
-	real tr(6),i,j
-	xw=tr(1)+tr(2)*i+tr(3)*j
-	end
-
-	real function yw(tr,i,j)
-	real tr(6),i,j
-	yw=tr(4)+tr(5)*i+tr(6)*j
-	end
-
diff --git a/filterbank-gmrt/random.c b/filterbank-gmrt/random.c
deleted file mode 100644
index 315e1c1..0000000
--- a/filterbank-gmrt/random.c
+++ /dev/null
@@ -1,196 +0,0 @@
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include "sigproc.h"
-
-#define IA 16807
-#define IM 2147483647
-#define AM (1.0/IM)
-#define IQ 127773
-#define IR 2836
-#define MASK 123459876
-
-float nrran0(long *idum) /*includefile*/
-{
-	long k;
-	float ans;
-
-	*idum ^= MASK;
-	k=(*idum)/IQ;
-	*idum=IA*(*idum-k*IQ)-IR*k;
-	if (*idum < 0) *idum += IM;
-	ans=AM*(*idum);
-	*idum ^= MASK;
-	return ans;
-}
-#undef IA
-#undef IM
-#undef AM
-#undef IQ
-#undef IR
-#undef MASK
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-
-#define IA 16807
-#define IM 2147483647
-#define AM (1.0/IM)
-#define IQ 127773
-#define IR 2836
-#define NTAB 32
-#define NDIV (1+(IM-1)/NTAB)
-#define EPS 1.2e-7
-#define RNMX (1.0-EPS)
-
-float nrran1(long *idum) /*includefile*/
-{
-	int j;
-	long k;
-	static long iy=0;
-	static long iv[NTAB];
-	float temp;
-
-	if (*idum <= 0 || !iy) {
-		if (-(*idum) < 1) *idum=1;
-		else *idum = -(*idum);
-		for (j=NTAB+7;j>=0;j--) {
-			k=(*idum)/IQ;
-			*idum=IA*(*idum-k*IQ)-IR*k;
-			if (*idum < 0) *idum += IM;
-			if (j < NTAB) iv[j] = *idum;
-		}
-		iy=iv[0];
-	}
-	k=(*idum)/IQ;
-	*idum=IA*(*idum-k*IQ)-IR*k;
-	if (*idum < 0) *idum += IM;
-	j=iy/NDIV;
-	iy=iv[j];
-	iv[j] = *idum;
-	if ((temp=AM*iy) > RNMX) return RNMX;
-	else return temp;
-}
-#undef IA
-#undef IM
-#undef AM
-#undef IQ
-#undef IR
-#undef NTAB
-#undef NDIV
-#undef EPS
-#undef RNMX
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-
-#define IM1 2147483563
-#define IM2 2147483399
-#define AM (1.0/IM1)
-#define IMM1 (IM1-1)
-#define IA1 40014
-#define IA2 40692
-#define IQ1 53668
-#define IQ2 52774
-#define IR1 12211
-#define IR2 3791
-#define NTAB 32
-#define NDIV (1+IMM1/NTAB)
-#define EPS 1.2e-7
-#define RNMX (1.0-EPS)
-
-float nrran2(long *idum) /*includefile*/
-{
-	int j;
-	long k;
-	static long idum2=123456789;
-	static long iy=0;
-	static long iv[NTAB];
-	float temp;
-
-	if (*idum <= 0) {
-		if (-(*idum) < 1) *idum=1;
-		else *idum = -(*idum);
-		idum2=(*idum);
-		for (j=NTAB+7;j>=0;j--) {
-			k=(*idum)/IQ1;
-			*idum=IA1*(*idum-k*IQ1)-k*IR1;
-			if (*idum < 0) *idum += IM1;
-			if (j < NTAB) iv[j] = *idum;
-		}
-		iy=iv[0];
-	}
-	k=(*idum)/IQ1;
-	*idum=IA1*(*idum-k*IQ1)-k*IR1;
-	if (*idum < 0) *idum += IM1;
-	k=idum2/IQ2;
-	idum2=IA2*(idum2-k*IQ2)-k*IR2;
-	if (idum2 < 0) idum2 += IM2;
-	j=iy/NDIV;
-	iy=iv[j]-idum2;
-	iv[j] = *idum;
-	if (iy < 1) iy += IMM1;
-	if ((temp=AM*iy) > RNMX) return RNMX;
-	else return temp;
-}
-#undef IM1
-#undef IM2
-#undef AM
-#undef IMM1
-#undef IA1
-#undef IA2
-#undef IQ1
-#undef IQ2
-#undef IR1
-#undef IR2
-#undef NTAB
-#undef NDIV
-#undef EPS
-#undef RNMX
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-
-float gauss(long *seed, float mean, float sigma) /*includefile*/
-{
-  float r1,r2;
-  r1=nrran2(seed);
-  r2=nrran2(seed);
-  return (sigma * sqrt(-1.0*(2.0*log(r1))) * cos(2.0*3.1415927*r2) + mean);
-}
-
-float gasdev(long *idum) /*includefile*/
-{
-	static int iset=0;
-	static float gset;
-	float fac,rsq,v1,v2;
-
-	if  (iset == 0) {
-		do {
-			v1=2.0*nrran2(idum)-1.0;
-			v2=2.0*nrran2(idum)-1.0;
-			rsq=v1*v1+v2*v2;
-		} while (rsq >= 1.0 || rsq == 0.0);
-		fac=sqrt(-2.0*log(rsq)/rsq);
-		gset=v1*fac;
-		iset=1;
-		return v2*fac;
-	} else {
-		iset=0;
-		return gset;
-	}
-}
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-
-float flat(float min, float max, long *seed) /*includefile*/
-{
-  return(min+(max-min)*nrran2(seed));
-}
-
-long startseed(void) /*includefile*/
-{
-  long seed;
-  int i, nits;
-
-  nits = ssm();
-  seed = (long) nits;
-  for (i=0; i<nits; i++) nrran2(&seed);
-
-  return (seed);
-}
-
-
diff --git a/filterbank-gmrt/rdfbtab.f b/filterbank-gmrt/rdfbtab.f
deleted file mode 100644
index 0e60d5b..0000000
--- a/filterbank-gmrt/rdfbtab.f
+++ /dev/null
@@ -1,41 +0,0 @@
-	subroutine rdfbtab(skyfreq,maxchans,nchans)
-	implicit none
-c
-c	Reads in the details of the filterbank contained in
-c       the ASCII file fb.tab
-c
-	integer maxchans,nchans
-	real skyfreq(maxchans)
-
-	integer lun,i
-
-	call glun(lun)
-	nchans=maxchans
-	open(unit=lun,file='fb.tab',status='old',err=999)
-	do i=1,maxchans
-	  read(lun,*,end=1) skyfreq(i)
-        enddo
- 1	close(unit=lun)
-	if (i.lt.maxchans) nchans=i-1
-	write(*,*) 'The filterbank has',nchans,' channels...'
-	do i=1,nchans
-	  write(*,*) 'Chan #',i,' Freq:',skyfreq(i),' MHz'
-        enddo
-	return
-c
-c	Couldn't find filterbank table... Tell the user what to do...
-c	
- 999    write(*,*) 'You have not made a filterbank table: "fb.tab"'
-	write(*,*) 'This should be a free-format ASCII listing'
-	write(*,*) 'For example:'
-	write(*,*) '1424.0'
-	write(*,*) '1420.0'
-	write(*,*) '1416.0'
-	write(*,*) '1412.0'
-	write(*,*) 'would be the set up for a four channel filterbank.'
-	write(*,*) 'For the PSE in Effelsberg, all numbers should be'
-	write(*,*) 'identical and equal to the centre frequency used.'
-	write(*,*)
-	write(*,*) 'All numbers are sky frequencies in MHz. Good luck!'
-	stop
-        end 
diff --git a/filterbank-gmrt/rdhead.f b/filterbank-gmrt/rdhead.f
deleted file mode 100644
index e414919..0000000
--- a/filterbank-gmrt/rdhead.f
+++ /dev/null
@@ -1,35 +0,0 @@
-c==============================================================================
-      subroutine rdhead(hdrfile,pspmfile,f0,chbw,tsamp,nsrec,nchan)
-c==============================================================================
-      implicit none
-      character*(*) hdrfile,pspmfile
-      real f0,chbw,tsamp
-      integer nsrec,nchan,lun,idx
-      character*80 line
-
-      call glun(lun)
-      open(unit=lun,file=hdrfile,status='old',err=999)
-      read(lun,'(a)') line  ! filename
-      idx=index(line,':')+1
-      pspmfile=line(idx:)
-      read(lun,'(a)') line  ! tsamp (us)
-      idx=index(line,':')+1
-      read(line(idx:),*) tsamp
-      tsamp=tsamp*1.0e-3
-      read(lun,'(a)') line  ! nsrec
-      idx=index(line,':')+1
-      read(line(idx:),*) nsrec
-      read(lun,'(a)') line  ! fcent (MHz)
-      idx=index(line,':')+1
-      read(line(idx:),*) f0  
-      read(lun,'(a)') line  ! channel band (kHz)
-      idx=index(line,':')+1
-      read(line(idx:),*) chbw
-      chbw=chbw/1000.0
-      read(lun,'(a)') line  !  nchans
-      idx=index(line,':')+1
-      read(line(idx:),*) nchan
-      close(unit=lun)
-      return
- 999  stop 'Header file not found!'
-      end
diff --git a/filterbank-gmrt/read_aoscan.c b/filterbank-gmrt/read_aoscan.c
deleted file mode 100644
index f3a79fe..0000000
--- a/filterbank-gmrt/read_aoscan.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include <stdio.h>
-#include <malloc.h>
-#include <string.h>
-/* returns day number, year (yyyy), and scan number from an aoscan number */
-void read_aoscan(unsigned long aoscan, int *day, int *year, int *scan) /*includefile*/
-{
-  char cao[12],cscan[3],cyear[4],cday[3];
-  int i,l,s;
-
-  sprintf(cao,"%u",aoscan);
-  l=strlen(cao);
-  /* scan number */
-  sprintf(cscan,"%c%c%c",cao[l-3],cao[l-2],cao[l-1]);  
-  *scan=atoi(cscan);
-  /* year */
-  if (cao[l-5]=='9') {
-    sprintf(cyear,"%c%c",cao[l-5],cao[l-4]);
-    *year=1900+atoi(cyear);
-    s=l-6;
-  } else {
-    sprintf(cyear,"%c%c%c%c",cao[l-7],cao[l-6],cao[l-5],cao[l-4]);
-    *year=atoi(cyear);
-    s=l-8;
-  }
-  /* day */
-  for (i=0; i<=s; i++) {
-	cday[i]=cao[i];
-  }
-  *day=atoi(cday);
-  if (*year > 2010) *year=0;
-}
diff --git a/filterbank-gmrt/read_block.c b/filterbank-gmrt/read_block.c
deleted file mode 100644
index 4c3e38f..0000000
--- a/filterbank-gmrt/read_block.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/* read a block of data into datablock */
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include "sigproc.h"
-
-int read_block(FILE *input, int nbits, float *block, int nread) /*includefile*/
-{
-  int i,j,k,s1,s2,iread;
-  unsigned char *charblock;
-  unsigned short *shortblock;
-  long seed=0;
-
-  /* decide how to read the data based on the number of bits per sample */
-  switch(nbits) {
-  case 1:
-    /* read n/8 bytes into character block containing n 1-bit pairs */
-    charblock=(unsigned char *) malloc(nread/8);
-    iread=fread(charblock,1,nread/8,input);
-    k=0;
-    /* unpack 1-bit pairs into the datablock */
-    for (i=0; i<iread; i++) {
-      for (j=0;j<8;j++) {
-	block[k++]=charblock[i]&1;
-	charblock[i]>>=1;
-      }
-    }
-    iread=k; /* this is the number of samples read in */
-    free(charblock);
-    break;
-  case 4:
-    /* read n/2 bytes into character block containing n 4-bit pairs */
-    charblock=(unsigned char *) malloc(nread/2);
-    iread=fread(charblock,1,nread/2,input);
-    j=0;
-    /* unpack 4-bit pairs into the datablock */
-    for (i=0; i<iread; i++) {
-      char2ints(charblock[i],&s1,&s2);
-      block[j++]=(float) s1;
-      block[j++]=(float) s2;
-    }
-    iread*=2; /* this is the number of samples read in */
-    free(charblock);
-    break;
-  case 8:
-    /* read n bytes into character block containing n 1-byte numbers */
-    charblock=(unsigned char *) malloc(nread);
-    iread=fread(charblock,1,nread,input);
-    /* copy numbers into datablock */
-    for (i=0; i<iread; i++) {
-      block[i]=(float) charblock[i];
-    }
-    free(charblock);
-    break;
-  case 16:
-    /* read 2*n bytes into short block containing n 2-byte numbers */
-    shortblock=(unsigned short *) malloc(2*nread);
-    iread=fread(shortblock,2,nread,input);
-    /* copy numbers into datablock */
-    for (i=0; i<iread; i++) {
-      block[i]=(float) shortblock[i];
-    }
-    free(shortblock);
-    break;
-  case 32:
-    /* read 4*n bytes into floating block containing n 4-byte numbers */
-    iread=fread(block,4,nread,input); 
-    break;
-  default:
-    error_message("read_block - nbits can only be 4,8,16 or 32!");
-  }
-
-  /* return number of samples read */
-  return iread;
-}
diff --git a/filterbank-gmrt/read_header.c b/filterbank-gmrt/read_header.c
deleted file mode 100644
index 8df1550..0000000
--- a/filterbank-gmrt/read_header.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/* read_header.c - general handling routines for SIGPROC headers */
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include "header.h"
-int nbins;
-double period;
-/* read a string from the input which looks like nchars-char[1-nchars] */
-void get_string(FILE *inputfile, int *nbytes, char string[]) /* includefile */
-{
-  int nchar;
-  strcpy(string,"ERROR");
-  fread(&nchar, sizeof(int), 1, inputfile);
-  if (feof(inputfile)) exit(0);
-  if (nchar>80 || nchar<1) return;
-  *nbytes=sizeof(int);
-  fread(string, nchar, 1, inputfile);
-  string[nchar]='\0';
-  *nbytes+=nchar;
-}
-
-/* attempt to read in the general header info from a pulsar data file */
-int read_header(FILE *inputfile) /* includefile */
-{
-  char string[80], message[80];
-  int itmp,nbytes,totalbytes,expecting_rawdatafile=0,expecting_source_name=0; 
-  int expecting_frequency_table=0,channel_index;
-
-
-  /* try to read in the first line of the header */
-  get_string(inputfile,&nbytes,string);
-  if (!strings_equal(string,"HEADER_START")) {
-	/* the data file is not in standard format, rewind and return */
-	rewind(inputfile);
-	return 0;
-  }
-  /* store total number of bytes read so far */
-  totalbytes=nbytes;
-
-  /* loop over and read remaining header lines until HEADER_END reached */
-  while (1) {
-    get_string(inputfile,&nbytes,string);
-    if (strings_equal(string,"HEADER_END")) break;
-    totalbytes+=nbytes;
-    if (strings_equal(string,"rawdatafile")) {
-      expecting_rawdatafile=1;
-    } else if (strings_equal(string,"source_name")) {
-      expecting_source_name=1;
-    } else if (strings_equal(string,"FREQUENCY_START")) {
-      expecting_frequency_table=1;
-      channel_index=0;
-    } else if (strings_equal(string,"FREQUENCY_END")) {
-      expecting_frequency_table=0;
-    } else if (strings_equal(string,"az_start")) {
-      fread(&az_start,sizeof(az_start),1,inputfile);
-      totalbytes+=sizeof(az_start);
-    } else if (strings_equal(string,"za_start")) {
-      fread(&za_start,sizeof(za_start),1,inputfile);
-      totalbytes+=sizeof(za_start);
-    } else if (strings_equal(string,"src_raj")) {
-      fread(&src_raj,sizeof(src_raj),1,inputfile);
-      totalbytes+=sizeof(src_raj);
-    } else if (strings_equal(string,"src_dej")) {
-      fread(&src_dej,sizeof(src_dej),1,inputfile);
-      totalbytes+=sizeof(src_dej);
-    } else if (strings_equal(string,"tstart")) {
-      fread(&tstart,sizeof(tstart),1,inputfile);
-      totalbytes+=sizeof(tstart);
-    } else if (strings_equal(string,"tsamp")) {
-      fread(&tsamp,sizeof(tsamp),1,inputfile);
-      totalbytes+=sizeof(tsamp);
-    } else if (strings_equal(string,"period")) {
-      fread(&period,sizeof(period),1,inputfile);
-      totalbytes+=sizeof(period);
-    } else if (strings_equal(string,"fch1")) {
-      fread(&fch1,sizeof(fch1),1,inputfile);
-      totalbytes+=sizeof(fch1);
-    } else if (strings_equal(string,"fchannel")) {
-      fread(&frequency_table[channel_index++],sizeof(double),1,inputfile);
-      totalbytes+=sizeof(double);
-      fch1=foff=0.0; /* set to 0.0 to signify that a table is in use */
-    } else if (strings_equal(string,"foff")) {
-      fread(&foff,sizeof(foff),1,inputfile);
-      totalbytes+=sizeof(foff);
-    } else if (strings_equal(string,"nchans")) {
-      fread(&nchans,sizeof(nchans),1,inputfile);
-      totalbytes+=sizeof(nchans);
-    } else if (strings_equal(string,"telescope_id")) {
-      fread(&telescope_id,sizeof(telescope_id),1,inputfile);
-      totalbytes+=sizeof(telescope_id);
-    } else if (strings_equal(string,"machine_id")) {
-      fread(&machine_id,sizeof(machine_id),1,inputfile);
-      totalbytes+=sizeof(machine_id);
-    } else if (strings_equal(string,"data_type")) {
-      fread(&data_type,sizeof(data_type),1,inputfile);
-      totalbytes+=sizeof(data_type);
-    } else if (strings_equal(string,"ibeam")) {
-      fread(&ibeam,sizeof(ibeam),1,inputfile);
-      totalbytes+=sizeof(ibeam);
-    } else if (strings_equal(string,"nbeams")) {
-      fread(&nbeams,sizeof(nbeams),1,inputfile);
-      totalbytes+=sizeof(nbeams);
-    } else if (strings_equal(string,"nbits")) {
-      fread(&nbits,sizeof(nbits),1,inputfile);
-      totalbytes+=sizeof(nbits);
-    } else if (strings_equal(string,"barycentric")) {
-      fread(&barycentric,sizeof(barycentric),1,inputfile);
-      totalbytes+=sizeof(barycentric);
-    } else if (strings_equal(string,"pulsarcentric")) {
-      fread(&pulsarcentric,sizeof(pulsarcentric),1,inputfile);
-      totalbytes+=sizeof(pulsarcentric);
-    } else if (strings_equal(string,"nbins")) {
-      fread(&nbins,sizeof(nbins),1,inputfile);
-      totalbytes+=sizeof(nbins);
-    } else if (strings_equal(string,"nsamples")) {
-      /* read this one only for backwards compatibility */
-      fread(&itmp,sizeof(itmp),1,inputfile);
-      totalbytes+=sizeof(itmp);
-    } else if (strings_equal(string,"nifs")) {
-      fread(&nifs,sizeof(nifs),1,inputfile);
-      totalbytes+=sizeof(nifs);
-    } else if (strings_equal(string,"npuls")) {
-      fread(&npuls,sizeof(npuls),1,inputfile);
-      totalbytes+=sizeof(npuls);
-    } else if (strings_equal(string,"refdm")) {
-      fread(&refdm,sizeof(refdm),1,inputfile);
-      totalbytes+=sizeof(refdm);
-    } else if (expecting_rawdatafile) {
-      strcpy(rawdatafile,string);
-      expecting_rawdatafile=0;
-    } else if (expecting_source_name) {
-      strcpy(source_name,string);
-      expecting_source_name=0;
-    } else {
-      sprintf(message,"read_header - unknown parameter: %s\n",string);
-      fprintf(stderr,"ERROR: %s\n",message);
-      exit(1);
-    } 
-  } 
-
-  /* add on last header string */
-  totalbytes+=nbytes;
-
-  /* return total number of bytes read */
-  return totalbytes;
-}
diff --git a/filterbank-gmrt/read_polyco.c b/filterbank-gmrt/read_polyco.c
deleted file mode 100644
index e2fca4f..0000000
--- a/filterbank-gmrt/read_polyco.c
+++ /dev/null
@@ -1,162 +0,0 @@
-/** BCJ Modified for new polycos */
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include <string.h>
-#include "sigproc.h"
-#include "header.h"
-int poly_override;
-double override_f0;
-int read_polycoset(FILE *polycofile, struct POLYCO *polyco) /*includefile*/
-{
-  char coefficient[25],obsname[10];
-  int i,j;
-
-  /* read in the first two lines of the polyco set (header info) */
-  // changed no of characters and then removed numbers totally - BCH 25/05/18
-  //  if((fscanf(polycofile,"%10s%10s%11lf%20lf%21lf%7lf%7lf",
-  //      &polyco->psrname,&polyco->date,&polyco->utc,&polyco->tmid,&polyco->dm,
-  //      &polyco->doppler,&polyco->lfrms))== -1) return(0);
-  if((fscanf(polycofile,"%s %s %lf %lf %lf %lf %lf",
-      &polyco->psrname,&polyco->date,&polyco->utc,&polyco->tmid,&polyco->dm,
-	     &polyco->doppler,&polyco->lfrms))== -1) return(0);
-  // Uncomment if need to print : BCJ
-  //  printf("%10s %10s %11lf %20lf %21lf %7lf %7lf\n",
-  //  polyco->psrname,polyco->date,polyco->utc,polyco->tmid,polyco->dm,
-  //	 polyco->doppler,polyco->lfrms);
-  // changed no of characters and then removed numbers totally - BCH 25/05/18
-  //  if ((fscanf(polycofile,"%20lf%18lf%5i%6i%5i%9lf\n",&polyco->rphase,
-  //    &polyco->f0,&polyco->obsno,&polyco->span,&polyco->nc,
-  //	&polyco->fobs)) == -1) return(0);
-  if ((fscanf(polycofile,"%lf %lf %s %d %d %lf\n",&polyco->rphase,
-        &polyco->f0,obsname,&polyco->span,&polyco->nc,
-	      &polyco->fobs)) == -1) return(0);
-  // Uncomment if need to print : BCJ
-  //  printf("%lf %lf %s %d %d %lf\n",polyco->rphase,
-  //    polyco->f0,obsname,polyco->span,polyco->nc,
-  //	 polyco->fobs);
-  if (poly_override) polyco->f0=override_f0;
-  polyco->coeff = (double *) malloc((polyco->nc)*sizeof(double));
-
-  i=0;
-  while (i<polyco->nc) {
-    /* look for coefficients of the form .....D... (TEMPO - f77 style) */
-    //    if ((fscanf(polycofile,"%25s",coefficient))==-1) return(0);
-    if ((fscanf(polycofile,"%s",coefficient))==-1) return(0);
-    //    printf("%d %s\n", i, coefficient);
-    if ((strstr(coefficient,"D") != 0) || (strstr(coefficient,"E") != 0)) {
-      /* replace the D/Es with an e and copy string to coefficient array */
-      for (j=0; j<strlen(coefficient); j++) {
-	if(coefficient[j]=='D') coefficient[j]='e';
-	if(coefficient[j]=='E') coefficient[j]='e';
-      }
-    }
-    // moved here to give proper loop
-    polyco->coeff[i]=atof(coefficient);
-    i++;
-  }
-  return(polyco->nc);
-}
-
-void get_nearest_polyco(char *filename, double mjd, struct POLYCO *polyco) /*includefile*/
-{
-  double diff,best,dt,tmid0,tmid1;
-  int i,set,first=1,minutes;
-  FILE *polycofile;
-  char sname[80],pname[80];
-  static double last=0.0;
-
-  /* check to see when routine last called - return if still within a span */ 
-  if (last==0.0) {
-	last = mjd;
-  } else {
-        minutes = (mjd-last)*1440.0;
-	/* 28/5/04 - bugfix - previous versions did not have factor of 2!!! */
-	if (minutes >= polyco->span/2.0) {
-		last = mjd;
-	} else {
-		return;
-	}
-  }
-
-  //  printf("last and MJD : %lf %lf\n", last, mjd);
-
-  polycofile=fopen(filename,"r");
-  best=1.0e32;
-  i=0;
-
-  while (read_polycoset(polycofile,polyco) != 0) 
-    {
-      if (i==0) tmid0=polyco->tmid;
-      if (i==1) tmid1=polyco->tmid;
-      diff=fabs((polyco->tmid)-mjd);
-      if (diff<best) {
-	set=i;
-	best=diff;
-      }
-      i++;
-      //  printf("Next set : %d\n", i);
-    }
-
-  fclose(polycofile);
-  // printf("I SET diff best tmid1-tmid0: %d %d %f %f %f\n", i, set, best, diff,(tmid1-tmid0) );
-
-  /* check to see if the difference is within the spans of neighbouring sets */
-  if (best > (tmid1-tmid0)) 
-    fprintf(stderr,"WARNING: polyco spacing: %.0f s, nearest set: %.0f s\n",
-	(tmid1-tmid0)*86400.0,best*86400.0);
-
-  /* read in the best set */
-  polycofile=fopen(filename,"r");
-  for(i=0; i<=set; i++) read_polycoset(polycofile,polyco);
-  fclose(polycofile);
-
-
-  if (first) {
-    /* strip off any B/Js from the source/polyco names */
-    if (source_name[0] == 'J' || source_name[0] == 'B') 
-      strcpy(sname,source_name+1);
-    else
-      strcpy(sname,source_name);
-
-    if (polyco->psrname[0] == 'J' || polyco->psrname[0] == 'B') 
-      strcpy(pname,polyco->psrname+1);
-    else
-      strcpy(pname,polyco->psrname);
-
-    /*
-    if (strings_equal(sname,"")) {
-      fprintf(stderr,"WARNING: no source name in time series header!\n");
-    } else if (!strings_equal(sname,pname)) {
-      fprintf(stderr,
-      "WARNING: source name (%s) and polyco name (%s) do not match!\n",
-	      source_name,polyco->psrname);
-    }
-    */
-    first=0;
-  }
-
-}
-
-double polyco_period(double mjd, struct POLYCO polyco) /*includefile*/
-{
-  int i;
-  double dt,freq,factor,period;
-
-  dt=(mjd-polyco.tmid)*1440.0;
-  factor=polyco.coeff[1];
-  for (i=2; i<polyco.nc; i++) factor+=pow(dt,i-1)*i*polyco.coeff[i]; 
-  freq=polyco.f0+(factor/60.0);
-  period=1.0/freq;
-  return (period);
-}
-
-double polyco_phase(double mjd, struct POLYCO polyco) /*includefile*/
-{
-  int i;
-  double dt,phase;
-  dt=(mjd-polyco.tmid)*1440.0;
-  phase=polyco.rphase +(dt*60.0*polyco.f0)+polyco.coeff[0];
-  for (i=1; i<polyco.nc; i++) phase+=pow(dt,i)*polyco.coeff[i]; 
-  return(phase);
-}
diff --git a/filterbank-gmrt/readdat.f b/filterbank-gmrt/readdat.f
deleted file mode 100644
index b751c1c..0000000
--- a/filterbank-gmrt/readdat.f
+++ /dev/null
@@ -1,213 +0,0 @@
-c=============================================================================
-	subroutine readdat(llog,pzero)
-c=============================================================================
-        implicit none 
-	include 'seek.inc'
-	real rtsamp,tmin,temp,sum,sumsq,mean,sigma,sample,tmpdm
-	integer lun,i,j,llog,near2,imin,isec,nskip,isamp,ichan,nadd
-	integer length,nsrec,nchan,nread,seed,norg,nmax,ihour
- 	integer readsample,skipsample
-	character*80 pfile
-	real f0,chbw
-	logical filterbank,opened,pzero
-	data opened/.false./
-	save
-
-	if (index(filename,'.tim').gt.0) then
-	   header=' '
-	   refac=0.0
-	   nchans=1
-	   write(llog,*) 'Working with time series data...'
-	   call readhd(filename,tmpdm,rtsamp)
-	   if (refdm.eq.0.0) refdm=tmpdm
-	   ntim=1
-	   nread=1
-	   nadd=0
-	   sum=0.0
-	   nskip=skp/rtsamp
-	   if (nskip.lt.0) stop "silly skip length passed down..."
-	   if (nskip.gt.0) then
-		write(*,*) 'Skipping',nskip,' samples...'
-	        i=skipsample(nskip)
-		if (i.ne.0) stop "Error skipping..."
-		nskip=0
- 	   endif
-	   if (tsize.eq.0) then
-	      nmax=npts
-	   else
-	      nmax=2**tsize
-	   endif
-	   j=0
-	   do while (ntim.lt.nmax.and.nread.ne.0) 
-	      nread=readsample(sample)
-	      j=j+1
-	      if (j.gt.nskip) then
-		 sum=sum+sample
-		 nadd=nadd+1
-		 if (nadd.eq.rfac) then
-		    series(ntim)=sum/real(rfac)
-		    ntim=ntim+1
-		    sum=0.0
-		    nadd=0
-		 endif
-	      endif
-	   enddo
-	   rtsamp=rtsamp*real(rfac)
-	   write(llog,*) 'Read',ntim,' samples...'
-	   write(llog,'(x,a80)') header
-	   write(llog,*) 'Reference DM:',refdm
-	   write(llog,*) 'Sampling time:',rtsamp*1.0e6,' us'
-	   if (rfac.gt.1)write(llog,*) '(every',rfac,
-     &     ' samples were added during reading of time series)'
-	   tsamp=rtsamp
-	   ntim2 = ntim
-	   goto 2
-	endif
-
-	if (dmidx.ne.-1) then
-	   call rdhead(filename(1:lst)//'.hdr',pfile,f0,chbw,
-     &                 rtsamp,nsrec,nchan)
-	   refdm=real(dmidx-1)*(32.0/real(nchan-1))*(rtsamp/0.08)
-	   rtsamp=rtsamp/1000.0
-	   tsamp=rtsamp
-	   call getddis(llog,filename,nchan,dmidx)
-	   write(llog,*) 'Reference DM:',refdm,' Reference AC:',refac
-	   write(llog,*) 'Sampling time:',rtsamp*1.0e6,' us'
-	   nchans=1
-	   goto 2
-	endif
-
-	filterbank=index(filename,'.dat').gt.0
-	if (filterbank) then
-	   if (.not.opened) call rdfbtab(skyfreq,maxchans,nchans)
-	   write(llog,*) 'Working with filterbank data...'
-	else if (index(filename,'.fft').gt.0) then
-	   write(llog,*) 'Working with pre-FFT-ed data...'
-        else
-	   write(llog,*) 'Working with time series data...'
-	endif
-
-	if (opened) goto 1
-	call glun(lun)
-	open(unit=lun,file=filename,status='old',!err=999)
-     &  form='unformatted',err=999)
-	opened=.true.
-	ichan=0
-        write(llog,'('' Opened input data file: '',a)')
-     &  filename(1:lst+4)
-	read(lun) header
-c	header=' '
-	header=header(1:length(header))
-	
-	if (filterbank) then
-	   read(lun) ntim,nchans,isamp
-	   rtsamp=real(isamp)*1.0e-6
-	   refdm=0.0
-	   refac=0.0
-	else
-	   read(lun) ntim,rtsamp,refdm,refac
-	   nchans=1
-	endif
-	if (ntim.gt.npts) then
-	   write(*,*) 'WARNING - too many points in time series!'
-	   write(*,*) '** reading in max possible:',npts/1024,' kpts'
-	   ntim=npts
-	endif
-	
- 	write(llog,*) 'Reading',ntim/1024,' kpt data file...',ntim 
-	write(llog,'(x,a80)') header
-	write(llog,*) 'Reference DM:',refdm
-	write(llog,*) 'Sampling time:',rtsamp*1.0e6,' us'
-	tsamp=rtsamp
-
- 1	read(lun) (series(i),i=1,ntim)
-
-	ichan=ichan+1
-	if (filterbank) write(llog,*) 'Sky frequency of this channel:',
-     &  skyfreq(ichan),' MHz'
-	
-	if (nchans.eq.1) then
-          close(unit=lun)
-	  opened=.false.
-	endif
-
- 2	continue
-c 	if (rfac.gt.1) then
-c	   write(llog,*) 'Compressing time series by a factor of',rfac
-c	   call rebin(series,ntim,rtsamp,rfac)
-c           tsamp=rtsamp
-c	   write(llog,*) 'Data file now contains',ntim/1024,' kpts'
-c  	   write(llog,*) 'Sampling time now:',rtsamp*1.0e6,' us'
-c	endif
-
-c	nskip=0
-c	if (skp.gt.0) nskip=skp*rtsamp
-c	if (nskip.gt.ntim) then
-c	   write(*,*) 'WARNING - requested skip size too large!'
-c	   write(*,*) '** no skipping carried out...'
-c	   nskip=0
-c	endif
-c	
-c	if (nskip.gt.0) then
-c	   j=0
-c	   do i=nskip+1,ntim
-c	      j=j+1
-c	      series(j)=series(i)
-c	   enddo
-c	   ntim=j
-c	   write(llog,*) 'Skipped ',nskip,' points...'
-c        endif
-
-	norg=ntim
-	temp=log10(real(ntim))/log10(2.0)
-	near2=nint(temp)
-
-	if (tsize.eq.0) then
-	   write(llog,*) 'Nearest power of 2:',near2
-	   tsize=near2
-	   ntim=2**tsize
-	else
-	   write(llog,*) 'Requested transform power of 2:',tsize
-	   ntim=2**tsize
-	   if (ntim.gt.npts) then
-	     write(*,*) 'WARNING - requested transform length too large!'
-	     write(*,*) '** using max possible:',npts/1024,' kpts'
-	     ntim=npts
-	   endif
-	endif
-	
-c
-c	pad out rest of time series with either gaussian noise or zeros
-c
-	if (ntim.gt.norg) then
-	sum=0.0
-	sumsq=0.0
-	do i=1,256
-	   sum=sum+series(i)
-	   sumsq=sumsq+series(i)*series(i)
-	enddo	
-	mean=sum/256.0
-	sigma=sqrt(sumsq)/16.0
-	   write(llog,*) 'Padding time series with additional zeros...'
-	   do i=norg+1,ntim
-	      series(i)=0.0
-	   enddo
-	endif
-
-        tmin=rtsamp*real(ntim)/60.0
-        imin=int(tmin)
-        isec=60.0*(tmin-real(imin))
-	if (imin.lt.60) then
-	   write(llog,*) 'Data length:',imin,' min',isec,' sec'
-	else
-	   ihour=imin/60
-	   imin=imin-(ihour*60)
-	   write(llog,*) 'Data length:',ihour,' hr',imin,' min'
-	endif
-	return
-	
- 999    write(llog,*) 'Data file not found!'
-        stop
-        end
-
-
diff --git a/filterbank-gmrt/reader.c b/filterbank-gmrt/reader.c
deleted file mode 100644
index 756ac42..0000000
--- a/filterbank-gmrt/reader.c
+++ /dev/null
@@ -1,160 +0,0 @@
-/* reader.c - reads SIGPROC data files and formats human output */
-/* 14/7/2004 - added byte option for converting time series to single bytes */
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include "sigproc.h"
-#include "header.h"
-FILE *input;
-main(int argc, char *argv[])
-{
-  int numerate,i,j,k,l,stream,nsperdmp,nsamps,indexing,indexnow;
-  int ifchan[16],frchan[4096],ifnum,chnum,ns,charout;
-  char message[80],byte;
-  unsigned char c;
-  unsigned short s;
-  float f[8];
-
-  /* zero IF and frequency channel arrays */
-  for (i=0;i<16;i++)   ifchan[i]=0;
-  for (i=0;i<4096;i++) frchan[i]=0;
-
-  /* default case is to read from standard input */
-  input=stdin;
-  charout=numerate=stream=0;
-  indexing=1;
-
-  /* parse command line if arguments were given */
-  if (argc>1) {
-    i=1;
-    while (i<argc) {
-      print_version(argv[0],argv[1]);
-      if (help_required(argv[i])) {
-	reader_help();
-	exit(0);
-      } else if (strings_equal(argv[i],"-i")) {
-	i++;
-	ifchan[atoi(argv[i])-1]=1;
-      } else if (strings_equal(argv[i],"-c")) {
-	i++;
-	frchan[atoi(argv[i])-1]=1;
-      } else if (strings_equal(argv[i],"-numerate")) {
-	numerate=1;
-      } else if (strings_equal(argv[i],"-noindex")) {
-	indexing=0;
-      } else if (strings_equal(argv[i],"-stream")) {
-	stream=1;
-      } else if (strings_equal(argv[i],"-byte")) {
-	charout=1;
-      } else if (file_exists(argv[i])) {
-	input=open_file(argv[i],"rb");
-      } else {
-	reader_help();
-	sprintf(message,"unknown argument (%s) passed to reader",argv[i]);
-	error_message(message);
-      }
-      i++;
-    }
-  }
-
-  /* try to read the header */
-  if (!read_header(input)) error_message("error reading header\n");
-
-  /* check what IF and frequency channels (if any the user has selected) */
-  j=0;
-  for (i=0; i<nifs; i++) if (ifchan[i]) j++;
-  if (j==0) for (i=0; i<nifs; i++) ifchan[i]=1;
-  j=0;
-  for (i=0; i<nchans; i++) if (frchan[i]) j++;
-  if (j==0) for (i=0; i<nchans; i++) frchan[i]=1;
-
-  /* number of samples to read per dump */
-  nsperdmp=nifs*nchans;
-  /* initialize loop counters and flags */
-  ifnum=chnum=nsamps=l=0;
-  indexnow=1;
-  if (stream && indexing) numerate=1;
-
-  while (!feof(input)) {
-
-    /* unpack the sample(s) if necessary */
-    switch (nbits) {
-    case 1:
-      fread(&c,1,1,input);
-      for (i=0;i<8;i++) {
-	f[i]=c&1;
-	c>>=1;
-      }
-      ns=8;
-      break;
-    case 4:
-      fread(&c,1,1,input);
-      char2ints(c,&j,&k);
-      f[0]=(float) j;
-      f[1]=(float) k;
-      ns=2;
-      break;
-    case 8:
-      fread(&c,nbits/8,1,input);
-      f[0]=(float) c;
-      ns=1;
-      break;
-    case 16:
-      fread(&s,nbits/8,1,input);
-      f[0]=(float) s;
-      ns=1;
-      break;
-    case 32:
-      fread(&f[0],nbits/8,1,input);
-      ns=1;
-      break;
-    default:
-      sprintf(message,"cannot read %d bits per sample...\n",nbits);
-      error_message(message);
-      break;
-    }
-
-    for (i=0; i<ns; i++) {
-      if (charout) {
-	byte=(char) f[i];
-	putchar(byte);
-      } else {
-      /* time stamp or index the data if needed */
-      if (indexnow && stream) {
-	puts("#START");
-      } else if (indexnow && indexing) {
-	if (numerate) 
-	  printf("%d ",l);
-	else
-	  printf("%f ",tsamp * (double) l);
-      }
-      indexnow=0;
-      /* print sample if it is one of the ones selected */
-      if (ifchan[ifnum] && frchan[chnum]) {
-	if (stream && numerate) printf("%d ",nsamps);
-	printf("%f ",f[i]);
-	if (stream) puts("");
-      } 
-      nsamps++;
-      chnum++;
-      if (chnum==nchans) {
-	chnum=0;
-	ifnum++;
-	if (ifnum==nifs) ifnum=0;
-      }
-      /* put newline and terminator if in streaming mode */
-      if (stream) {
-	if ((nsamps%nchans)==0) puts("#STOP");
-      } 
-      /* put newline if this is the last sample of the dump */
-      if ((nsamps%nsperdmp)==0) {
-	if (!stream) puts("");
-	nsamps=0;
-	indexnow=1;
-	l++;
-      }
-      }
-    }
-  }
-}
-
diff --git a/filterbank-gmrt/readspec.f b/filterbank-gmrt/readspec.f
deleted file mode 100644
index 5acced6..0000000
--- a/filterbank-gmrt/readspec.f
+++ /dev/null
@@ -1,41 +0,0 @@
-c=============================================================================
-      subroutine readspec(sfile,fold,ssnr,dm,ac,tsamp,npf)
-c=============================================================================
-c
-c     Reads in a power spectrum 
-c 
-c     99/07/12 - dunc@naic.edu -- added dm and ac to header info
-c      
-c=============================================================================
-      implicit none
-      character*80 sfile
-      real dm, ac
-      integer fold,npf
-      real*8 tsamp
-      real ssnr(*)
-      integer i,lun
-      character*80 fname
-C      byte bdat(2**23)
-C      real scale,offset
-      logical filex
-
-      if (sfile.ne.' ') then
-         fname=sfile
-      else
-         write(fname,'(''fold'',i1,''.spc'')')fold
-      endif
-
-      write(*,*) 'Spectrum file: ',fname
-      inquire(file=fname,exist=filex)
-      if (.not.filex) stop 'File does not exist!'
-      call glun(lun)
-      open(unit=lun,file=fname,status='unknown',form='unformatted')
-      read(lun) dm, ac ! new 
-      read(lun) tsamp,npf,fold
-      read(lun) (ssnr(i),i=1,npf)
-C      read(lun) scale,offset
-C      read(lun) (bdat(i),i=1,npf)
-C      call reatfbin(ssnr,npf,bdat,scale,offset,-1)
-      close(unit=lun)
-      end
-      
diff --git a/filterbank-gmrt/readsus.f b/filterbank-gmrt/readsus.f
deleted file mode 100644
index 6005450..0000000
--- a/filterbank-gmrt/readsus.f
+++ /dev/null
@@ -1,92 +0,0 @@
-c==============================================================================
-      subroutine readsus(filename, fold, mc, nc, mt, nt,
-     &                   par, snr, trid, fld, dm, ac, ad)
-c==============================================================================
-c
-c     Reads in a list of suspects from a FIND output file. The signals
-c     are either frequencies or periods. This is however irrelevant as
-c     far as this routine is concerned.
-c
-c     filename - ch - name of the suspect file
-c     fold     - i4 - harmonic fold number to read in (1-5 inclusive)
-c     mc       - i4 - maximum number of suspects allowed
-c     nc       - i4 - number of candidates read in
-c     mt       - i4 - maximum number of trial loops allowed
-c     nt       - i4 - number of trial loops read in
-c     par(mc)  - r4 - array containing the suspects for this fold
-c     snr(mc)  - r4 - array containing the suspect signal-to-noise ratios
-c     trid(mc) - i4 - array containing the trial (loop) index for each suspect
-c     fld(mc)  - i4 - array containing the fold for each suspect
-c     dm(mt)   - r4 - array containing the dm value for each list
-c     ac(mt)   - r4 - array containing the ac value for each list      
-c     ad(mt)   - r4 - array containing the ad value for each list      
-c
-c     (dunc@mpifr-bonn.mpg.de - November 1997)
-c      
-c     Modification history:
-c      
-c     98/07/01 -> dunc@mpifr-bonn.mpg.de (read in ac array)
-c     98/07/13 -> dunc@mpifr-bonn.mpg.de (read in ad array)
-c     98/07/15 -> dunc@mpifr-bonn.mpg.de (changed calling sequence)
-c     98/11/24 -> dunc@naic.edu          (trid now correct for multiple calls)
-c      
-c==============================================================================
-c
-      implicit none
-      character*(*) filename
-      integer fold, nc, nt, mc, mt
-      integer trid(mc),fld(mc)
-      real*8 par(mc)
-      real snr(mc),dm(mt),ac(mt),ad(mt)
-      integer lun,ltmp,istat,i,idx
-      real s(5)
-      real*8 p(5)
-      character*100 line
-
-      idx=0
-      call glun(lun)
-      open(unit=lun,file=filename,status='old',err=999)
-      do while(nc.lt.mc.and.nt.lt.mt)
-         read(lun,'(a)',end=998) line
-         if (index(line,'DM').gt.0) then
-            nt=nt+1
-            idx=idx+1
-            ltmp=index(line,'DM:')+3
-            read(line(ltmp:),*) dm(nt)
-            ltmp=index(line,'AC:')+3
-	    read(line(ltmp:),*) ac(nt)
-            ltmp=index(line,'AD:')+3
-            ad(nt)=0.0
-            if (ltmp.gt.3) read(line(ltmp:),*) ad(nt)
-         else 
-            nc=nc+1
-            fld(nc)=fold
-            if (index(filename,'.top').gt.0) then
-              read(line,*) s(1),p(1),s(2),p(2)
-              par(nc)=p(1)
-              snr(nc)=s(1)
-            else
-	      do i=1,5
-		p(i)=0.0
-		s(i)=0.0
-	      enddo
-              read(line,1,iostat=istat)
-     &        s(1),p(1),s(2),p(2),s(3),p(3),s(4),p(4),s(5),p(5)
-              par(nc)=p(fold)
-              snr(nc)=s(fold)
-            endif
-            if (par(nc).eq.1.0.or.snr(nc).eq.0.0) then
-               nc=nc-1
-            else
-               trid(nc)=idx
-            endif
-         endif
-      enddo
- 1    format(5(f5.1,1x,f13.8,1x))
- 998  close(unit=lun)
-      return
- 999  write(*,'(a)') 'Error handling file: ',filename
-      stop
-      end 
-c      
-c==============================================================================
diff --git a/filterbank-gmrt/readtim.c b/filterbank-gmrt/readtim.c
deleted file mode 100644
index 7abeecb..0000000
--- a/filterbank-gmrt/readtim.c
+++ /dev/null
@@ -1,67 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include "header.h"
-#include "sigproc.h"
-
-FILE *timfile;
-
-void readhd_(char filename[80], float *rdm, float *rtsmp)
-{
-  int i;
-  
-  /* first fix filename */
-  for (i=0; i<strlen(filename); i++) {
-    if (filename[i]==' ') {
-      filename[i]='\0';
-      break;
-    }
-  }
-
-  /* now open up the file and read in the header */
-  refdm=tsamp=0.0;
-  timfile=open_file(filename,"rb");
-  read_header(timfile);
-  *rtsmp=(float) tsamp;
-  *rdm=(float) refdm;
-  if (nbits != 32 && nbits != 8 && nbits != 16) {
-    fprintf(stderr,"cannot read %d bit data..\n");
-    exit(1);
-  }
-}
-
-int skipsample_(int *nskip)
-{
-  long offset;
-  if (feof(timfile)) {
-    fclose(timfile);
-    return 0;
-  }
-  offset = (long) (*nskip) * (nbits/8);
-  return fseek(timfile,offset,SEEK_CUR);
-}
-int readsample_(float *sample) 
-{
-  unsigned short *twobytes;
-  char *byte;
-
-  if (feof(timfile)) {
-    fclose(timfile);
-    return 0;
-  }
-  switch (nbits) {
-  case 32:
-    fread(sample,nbits/8,1,timfile);
-    break;
-  case 16:
-    fread(twobytes,nbits/8,1,timfile);
-    *sample = (float) *twobytes;
-    break;
-  case 8:
-    fread(byte,nbits/8,1,timfile);
-    *sample = (float) *byte;
-    break;
-  }
-  return(1);
-}
diff --git a/filterbank-gmrt/rebin.f b/filterbank-gmrt/rebin.f
deleted file mode 100644
index 4cae9f7..0000000
--- a/filterbank-gmrt/rebin.f
+++ /dev/null
@@ -1,24 +0,0 @@
-      subroutine rebin(series,ntim,tsamp,rfac)
-      implicit none
-      real series(*),tsamp
-      integer ntim,rfac
-      integer i,j,k
-      real sum
-      
-      j=0
-      k=0
-      sum=0.0
-      do i=1,ntim
-         sum=sum+series(i)
-         j=j+1
-         if (j.eq.rfac) then
-            k=k+1
-            series(k)=sum/real(rfac)
-            sum=0.0
-            j=0
-         endif
-      enddo
-      ntim=k
-      tsamp=tsamp*real(rfac)
-      end
-      
diff --git a/filterbank-gmrt/recipes.c b/filterbank-gmrt/recipes.c
deleted file mode 100644
index 43812f7..0000000
--- a/filterbank-gmrt/recipes.c
+++ /dev/null
@@ -1,103 +0,0 @@
-#include <math.h>
-#define SWAP(a,b) tempr=(a);(a)=(b);(b)=tempr
-void four1(float data[], unsigned long nn, int isign) /* includefile */
-{
-	unsigned long n,mmax,m,j,istep,i;
-	double wtemp,wr,wpr,wpi,wi,theta;
-	float tempr,tempi;
-
-	n=nn << 1;
-	j=1;
-	for (i=1;i<n;i+=2) {
-		if (j > i) {
-			SWAP(data[j],data[i]);
-			SWAP(data[j+1],data[i+1]);
-		}
-		m=n >> 1;
-		while (m >= 2 && j > m) {
-			j -= m;
-			m >>= 1;
-		}
-		j += m;
-	}
-	mmax=2;
-	while (n > mmax) {
-		istep=mmax << 1;
-		theta=isign*(6.28318530717959/mmax);
-		wtemp=sin(0.5*theta);
-		wpr = -2.0*wtemp*wtemp;
-		wpi=sin(theta);
-		wr=1.0;
-		wi=0.0;
-		for (m=1;m<mmax;m+=2) {
-			for (i=m;i<=n;i+=istep) {
-				j=i+mmax;
-				tempr=wr*data[j]-wi*data[j+1];
-				tempi=wr*data[j+1]+wi*data[j];
-				data[j]=data[i]-tempr;
-				data[j+1]=data[i+1]-tempi;
-				data[i] += tempr;
-				data[i+1] += tempi;
-			}
-			wr=(wtemp=wr)*wpr-wi*wpi+wr;
-			wi=wi*wpr+wtemp*wpi+wi;
-		}
-		mmax=istep;
-	}
-}
-#undef SWAP
-void realft(float data[], unsigned long n, int isign) /* includefile */
-{
-	void four1(float data[], unsigned long nn, int isign);
-	unsigned long i,i1,i2,i3,i4,np3;
-	float c1=0.5,c2,h1r,h1i,h2r,h2i;
-	double wr,wi,wpr,wpi,wtemp,theta;
-
-	theta=3.141592653589793/(double) (n>>1);
-	if (isign == 1) {
-		c2 = -0.5;
-		four1(data,n>>1,1);
-	} else {
-		c2=0.5;
-		theta = -theta;
-	}
-	wtemp=sin(0.5*theta);
-	wpr = -2.0*wtemp*wtemp;
-	wpi=sin(theta);
-	wr=1.0+wpr;
-	wi=wpi;
-	np3=n+3;
-	for (i=2;i<=(n>>2);i++) {
-		i4=1+(i3=np3-(i2=1+(i1=i+i-1)));
-		h1r=c1*(data[i1]+data[i3]);
-		h1i=c1*(data[i2]-data[i4]);
-		h2r = -c2*(data[i2]+data[i4]);
-		h2i=c2*(data[i1]-data[i3]);
-		data[i1]=h1r+wr*h2r-wi*h2i;
-		data[i2]=h1i+wr*h2i+wi*h2r;
-		data[i3]=h1r-wr*h2r+wi*h2i;
-		data[i4] = -h1i+wr*h2i+wi*h2r;
-		wr=(wtemp=wr)*wpr-wi*wpi+wr;
-		wi=wi*wpr+wtemp*wpi+wi;
-	}
-	if (isign == 1) {
-		data[1] = (h1r=data[1])+data[2];
-		data[2] = h1r-data[2];
-	} else {
-		data[1]=c1*((h1r=data[1])+data[2]);
-		data[2]=c1*(h1r-data[2]);
-		four1(data,n>>1,-1);
-	}
-}
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-#include <stdlib.h>
-void rfft(int nfft, double *org, double *fft) /* includefile */
-{
- int i;
- float *temp; 
- temp = (float *) malloc(nfft*sizeof(float));
- for (i=0;i<nfft;i++) temp[i]=org[i];
- realft(temp-1,(unsigned long) nfft, 1);
- for (i=0;i<nfft/2;i++) fft[i]=temp[2*i];
- free(temp);
-}
diff --git a/filterbank-gmrt/resample.f b/filterbank-gmrt/resample.f
deleted file mode 100644
index a54caf3..0000000
--- a/filterbank-gmrt/resample.f
+++ /dev/null
@@ -1,75 +0,0 @@
-c==============================================================================
-      subroutine resample(llog)
-c==============================================================================
-c
-c   Routine to re-sample a time series of ntim points contained in the array
-c   series() to the rest frame of an object with a changing velocity v.
-c      
-c   The required sampling time is given by: tau(t)=tau0(1.0+v/c)
-c
-c   Two approximations to v are available:
-c
-c     - constant acceleration: v=a*t
-c     - first derivative:      v=a*t + 0.5*adot*t*t
-c     
-c   The acceleration terms are stored in the common real*4's refac and refad.
-c
-c     refac - reference acceleration in m/s/s
-c     refad - reference a-dot in cm/s/s/s     (cm used for convenience)
-c
-c   The constant tau0 is normalised so that the final time series
-c   contains the same number of samples as the original one. The array
-c   samp() is used as a buffer to store the re-sampled time series.
-c
-c     Adapted from rebin2.f 98/07/12 (dunc@mpifr-bonn.mpg.de)
-c
-c==============================================================================
-      implicit none
-      integer llog
-      include 'seek.inc'
-      include 'csamp.inc'
-      real*8 tint,tau0,time,taut,next,tav,nav,c,ac,ad
-      parameter(c=2.99792458e8)
-      integer i,j
-
-      if (refac.eq.0.0.and.refad.eq.0.0) return
-      
-      nav=0.0
-      tav=0.0
-      do i=1,ntim
-         samp(i)=0.0
-      enddo
-      i=1
-      j=1
-      time=0.0
-      tint=real(ntim)*tsamp
-      ac=refac
-      ad=refad*0.01 ! convert from cm/s/s/s to m/s/s/s for calculation
-
-      tau0=tsamp/(1.0+ac*tint/2.0/c+ad*tint*tint/6.0/c)
-
-      write(llog,*)'Re-sampling time series. AC=',refac,' m/s/s. AD=',
-     &             refad,' cm/s/s/s'
-      
-      taut=tau0
-      next=taut
- 10   continue
-      if (next.gt.real(i)*tsamp) then
-      samp(j)=samp(j)+series(i)*(real(i)*tsamp-(next-taut))/tsamp
-      i=i+1
-      endif
-      if (next.le.real(i)*tsamp) then
-         samp(j)=samp(j)+series(i)*(next-real(i-1)*tsamp)/tsamp
-         j=j+1
-         time=next
-         taut=tau0*(1.0+ac*time/c+0.5*ad*time*time/c)
-         tav=tav+taut
-         nav=nav+1.0
-         next=next+taut
-      endif
-      if (i.lt.ntim) goto 10
-      do i=1,ntim
-         series(i)=samp(i)
-      enddo
-      end
-c==============================================================================
diff --git a/filterbank-gmrt/rwepn.f b/filterbank-gmrt/rwepn.f
deleted file mode 100644
index 14bcff0..0000000
--- a/filterbank-gmrt/rwepn.f
+++ /dev/null
@@ -1,463 +0,0 @@
-c==============================================================================
-c
-c     File: "rwepn.f"
-c     
-c     This file contains the generalised EPN format reading/writing routines
-c     It has been tested on an HP system with f77 -c rwepn.f to produce the 
-c     object file. It requires the accompanying include file "epnhdr.inc"
-c
-c==============================================================================
-       subroutine rwepn(filename,readwri,recno,padout)
-c==============================================================================
-c
-c     Subroutine to read or write data in EPN format. All parameters are
-c     defined in the include file "epnhdr.inc" which should lie in the
-c     same directory as this file. Passed down variables to this routine
-c     are:
-c
-c     filename - character*80  - name of this EPN file
-c     readwri  - integer*4     - switch: -1 => read, +1 => write
-c     recno    - integer*4     - record number to read
-c
-c     Usage:
-c
-c     To incorporate this routine into your pulsar data reduction
-c     package, include the file "epnhdr.inc" in your source code
-c     and set up the appropriate variables before.
-c
-c     Features:
-c
-c     When writing is requested, the routine will keep the file
-c     open for successive writes by default. To override this, pass
-c     down recno as -1, the presently opened file will be closed
-c     and a new one opened.
-c
-c     If an error occurs in reading, recno is returned as -999
-c
-c     By the very nature of the format, record lengths must be fixed.
-c     So if you want to have different lengthed data streams in the
-c     same archive you need to switch "padout" on. As its name suggests,
-c     this pads out the binned data to its maximum length so that
-c     the records are fixed. A draw back is of course that it uses
-c     up more space. Therefore if it is known that all the records
-c     are of the same lenght anyway (eg for a stream of single pulses)
-c     then it is recommended to switch padout off.
-c
-c==============================================================================
-c
-c     Created by Dunc Lorimer (dunc@mpifr-bonn.mpg.de) November 1996....
-c
-c     12/11/1996   Initial version
-c     15/11/1996   Implemented common blocks
-c     21/05/1997   Changed to HEX storage
-c     01/07/1997   Added tres and fluxflag to header
-c
-c==============================================================================
-c
-      implicit none
-      include 'epnhdr.inc'
-c
-c     Data buffers...
-c
-      integer*4 intdata(maxbin) 
-      character*4 chrdata(maxbin)
-      real*4 tmp(maxbin)
-c
-c     The maximum length of an EPN file is the 6 line header, plus
-c     maxblk sets of maxbin bin data streams. Each stream of maxbin
-c     bins occupies (maxbin/20) sets of 80 character lines plus a 2
-c     line header. The number of charcters per record is:
-c
-c     (6+maxblk*(maxbin/20+2))*80 
-c
-c     One can tune this depending on the size of the data-sets...
-c     the default is maxblk=8, maxbin=4160 -> maxrec=66080
-c     suitable smaller setting for e.g. a PC would be...
-c                    maxblk=4, maxbin=1040 -> maxrec=17760.
-c     N.B. Both maxbin and maxblk are specified in "epnhdr.inc"
-c
-      integer maxrec
-      parameter(maxrec=(6+maxblk*(maxbin/20+2))*80)
-      character line(maxrec/80)*80, recrd*(maxrec)
-c
-c==============================================================================
-c
-c     Local variables
-c
-      integer lun, lfil, nlin, next, i, j, k, l, iras, ipol,
-     &        wrecno, recln, maxint, lct
-      real rras, pvno, vno
-      character*1 dsign, lin1*12, line40*40
-      logical reading,writing,filex,opened,first
-      save
-      data opened/.false./, first/.true./
-      line40='----------------------------------------'
-c
-c==============================================================================
-c
-c     Sort out whether reading or writing
-c
-      reading=(readwri.eq.-1)
-      writing=(.not.reading)
-      if (readwri.ne.-1.and.readwri.ne.1) then
-         write(*,'(''Unknown read/write option passed to rwepn!!'')')
-         write(*,'(''Your "readwri" integer reads: '',i4)')readwri
-         stop
-      endif
-c
-c     If writing required and recno=-1, then close a previously
-c     opened file (if one is open) and proceed
-c
-      if (writing.and.recno.eq.-1.and.opened) then
-         close(unit=lun)
-         opened=.false.
-      endif
-c
-c     Get a free logical unit number
-c
-      if (.not.opened) call glun(lun)
-c
-c     Check whether the file exists or not....
-c     
-c     For reading: the routine will stop if not
-c     For writing: the routine will append to the previous file
-c
-      lfil=index(filename,' ')-1
-      inquire(file=filename(1:lfil),exist=filex)
-c
-c     Open the input file
-c
-      if (reading) then
-         if (filex) then
-c
-c          Read in the very first line, and work out the
-c          required record length...(number of 80 chr lines)
-c
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=12)
-           read(lun,rec=1) lin1
-           read(lin1,'(8x,i4)') counter
-           close(unit=lun)
-           recln=counter*80
-c
-c          Now open as a direct access unformatted file
-c
-           open(unit=lun,file=filename(1:lfil),status='old',
-     &          access='direct',form='unformatted',recl=recln)
-           if (recno.lt.1) recno=1
-           read(lun,rec=recno,err=999) recrd(1:recln)
-           close(unit=lun)
-         else
-           stop 'EPN file does not exist!'
-         endif
-      endif
-      if (writing) then
-c
-c       Establish out how many 'lines' will make up this record...
-c
-        if (padout) then
-           recln=maxrec ! use maximum record length
-           nlin=maxbin/20
-           npol=maxblk
-           counter=6+npol*(nlin+2)
-        else
-           nlin=nbin/20
-           next=nbin-nlin*20
-           if (next.gt.0) nlin=nlin+1
-           counter=6+npol*(nlin+2)
-           recln=counter*80
-        endif
-        if (opened) then
-c
-c          Increase the internal record counter
-c
-           wrecno=wrecno+1
-        else
-c
-c          Reset the internal record counter...
-c
-           wrecno=1
-           open(unit=lun,file=filename(1:lfil),status='unknown',
-     &          access='direct',form='unformatted',recl=recln)
-           opened=.true.
-        endif
-      endif
-c
-c     As from Version 5.0 data is scaled into hex format...
-c     This gives an increas in dynamic range by over a factor 6
-c
-      pvno=5.0
-      maxint=65535
-c
-c     As from Version 6.0, actual resolution of the data is
-c     recorded, the factor fcal is no longer recorded, instead
-c     the flag fluxflag is written into line 4 to signify whether
-c     the data are flux calibrated or not. (1.7.1997)
-c
-      pvno=6.0
-      lct=1
-c
-c     Line 1
-c
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),11) version, counter, history
-        read(version(4:),'(f5.2)') vno
-        if (vno.lt.pvno) then
-           if (first) then
-              write(*,*) 'Reading an old EPN file - Version',vno
-              first=.false.
-           endif
-           maxint=9999
-        endif
-      else
-        vno=pvno
-        write(version,'(a3,f5.2)') 'EPN',vno
-        write(line(lct),11) version, counter, history
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,11) version, counter, history
-c
- 11   format(a8,i4,a68)
-c
-c     Line 2
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),22) 
-     &  jname,cname,pbar,dm,rm,catref,bibref
-      else
-        write(line(lct),22) jname, cname, pbar, dm, rm, catref, bibref
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,22) jname, cname, pbar, dm, rm, catref, bibref
-c
- 22   format(a12,a12,f16.12,f8.3,f10.3,a6,a8,8x)
-c
-c     Line 3
-c
-      lct=lct+1
-      if (reading) then
-        read(recrd((lct-1)*80+1:lct*80),33) 
-     &               rah,ram,iras,rras,dsign,ded,dem,des, 
-     &               telname, epoch, opos, paflag, timflag
-        ras=float(iras)+rras
-        if (dsign.eq.'-') ded=-1*ded
-        if (dsign.eq.'-'.and.ded.eq.0) then
-           dem=-1*dem
-           des=-1.0*des
-        endif
-      else
-        rras=ras-int(ras)
-        iras=int(ras)
-        dsign='+'
-        if (index(jname,'-').gt.0) dsign='-'
-        if (ded.lt.0) ded=-1*ded
-        write(line(lct),33) rah, ram, iras, rras, dsign, ded, dem, des, 
-     &               telname, epoch, opos, paflag, timflag
-      endif
-c
-c     Un-comment this line for tracing... 
-c      write(*,33) rah, ram, iras, rras, dsign, ded, dem, des, telname, 
-c     &           epoch, opos, paflag, timflag
-c
- 33    format(3i2.2,f4.3,a1,2i2.2,f6.3,a8,f10.3,f8.3,a1,a1,31x)
-c
-c     Line 4 - (X,Y,Z) of telescope - NEW - implemented in V 6.0
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        if (reading) then
-           read(recrd((lct-1)*80+1:lct*80),44) xtel,ytel,ztel
-        else
-           write(line(lct),44) xtel,ytel,ztel
-        endif
-      endif
- 44   format(3f17.5,29x) 
-c
-c     Line 5
-c
-      lct=lct+1
-      if (reading) then
-        if (vno.ge.6.0) then
-        read(recrd((lct-1)*80+1:lct*80),55) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-        else
-        read(recrd((lct-1)*80+1:lct*80),56) 
-     &               cdd,cdm,cdy,scanno,subscan,npol,nfreq, 
-     &               nbin, tbin, nint, ncal, lcal, fcal
-        endif
-      else
-        write(line(lct),55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, 
-     &               nbin, tbin, tres, nint, ncal, lcal, fluxflag
-      endif
-c
-c     Un-comment this line for tracing...
-c      write(*,55) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, tres, nint, ncal, lcal, fluxflag
-c      write(*,56) cdd, cdm, cdy, scanno, subscan, npol, nfreq, nbin,
-c     &             tbin, nint, ncal, lcal, fcal
-c
- 55   format(2i2.2,i4.4,2i4.4,i2,i4,i4,2f12.6,i6,i4,i4,a1,15x) ! Version 6
- 56   format(2i2.2,i4.4,2i4.4,i2,i4,i4,f12.6,i6,i4,i4,f8.3,20x)
-c
-c     Line 6 - Blank at the moment
-c
-      if (vno.ge.6.0) then
-        lct=lct+1
-        write(line(lct),66) line40,line40
-      endif
- 66   format(2a40) 
-c      
-c     Loop around each polarisation...
-c
-      do ipol=1,npol
-c
-c       sub-header line 1
-c
-        lct=lct+1
-        if (reading) then
-          if (vno.ge.6.0) then
-          read(recrd((lct-1)*80+1:lct*80),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-          else
-          f0u(ipol)=' GHz'
-          dfu(ipol)=' MHz'
-          read(recrd((lct-1)*80+1:lct*80),78) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),df(ipol),tstart(ipol)
-          endif
-        else
-          if (f0u(ipol).eq.' ') f0u(ipol)=' GHz'  ! Default units
-          if (dfu(ipol).eq.' ') dfu(ipol)=' MHz'  ! Default units
-          write(line(lct),77) idfield(ipol),nband(ipol),
-     &    navg(ipol),f0(ipol),f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c       write(*,77) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              f0u(ipol),df(ipol),dfu(ipol),tstart(ipol)
-c       write(*,78) idfield(ipol),nband(ipol),navg(ipol),f0(ipol), 
-c     &              df(ipol),tstart(ipol)
-c
- 77     format(a8,i4,i4,f12.8,a8,f12.6,a8,f17.5,7x)
- 78     format(a8,i4,i4,f12.8,f12.6,f17.5,23x)
-        if (writing) then 
-c
-c         Zero the integer and character arrays
-c
-          do i=1,maxbin
-            intdata(i)=0
-	    chrdata(i)='0000'
-          enddo
-c
-c         Scale the data
-c     
-          do k=1,nbin
-             tmp(k)=rawdata(ipol,k)
-          enddo
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-c
-c         Convert to a hex string
-c
-          do k=1,nbin
-             call b102hex(intdata(k),chrdata(k))
-          enddo
-        endif
-c
-c       Sub-header line 2
-c
-        lct=lct+1
-        if (reading) then
-          read(recrd((lct-1)*80+1:lct*80),88)  scale(ipol),offset(ipol),
-     &    rms(ipol),papp(ipol)
-        else
-          write(line(lct),88) scale(ipol),offset(ipol),
-     &                            rms(ipol),papp(ipol)
-        endif
-c
-c       Un-comment this line for tracing...
-c        write(*,88) scale(ipol), offset(ipol), rms(ipol), papp(ipol)
-c
- 88     format(3e12.6,f16.12,28x) 
-c
-c       Now we finally get to the data!!
-c
-c
-c       Read the data (20 i4s per 80 column line)
-c
-        nlin=(counter-4)/npol-2
-        if (vno.ge.6.0) nlin=(counter-6)/npol-2
-        k=1
-        do i=1,nlin
-          lct=lct+1
-          if (reading) then
-c            read(recrd((lct-1)*80+1:lct*80),99)(chrdata(j),j=k,k+19)
-            l=0
-	    do j=k,k+19
-              chrdata(j)=recrd((lct-1)*80+1+l:(lct-1)*80+4+l)
-              call hex2b10(chrdata(j),intdata(j))
-              l=l+4
-	    enddo
-          else
-c            write(line(lct),99)(chrdata(j),j=k,k+19)
-            l=1
-	    do j=k,k+19
-              line(lct)(l:l+3)=chrdata(j)
-              l=l+4
-	    enddo
-          endif
-c
-c         Un-comment this line for tracing...
-c          write(*,99)(chrdata(j),j=k,k+19)
-c
-          k=k+20
-        enddo
-c
-c       Format for the data
-c
- 99     format(20a4)
-        if (reading) then
-c
-c         Convert hex string to integer for versions from 5.0
-c
-          do k=1,nbin
-             if (vno.ge.5.0) then
-c                call hex2b10(chrdata(k),intdata(k))
-             else
-                read(chrdata(k),'(i4.4)') intdata(k)
-             endif
-          enddo
-c
-c         De-scale the data
-c     
-          call rawtfint(tmp,nbin,intdata,
-     &         scale(ipol),offset(ipol),rms(ipol),readwri,maxint)
-          do k=1,nbin
-             rawdata(ipol,k)=tmp(k)
-          enddo
-        endif
-      enddo
-c
-c     Write the record...
-c
-      if (writing) then
-        do i=1,lct
-          j=(i-1)*80+1
-          k=j+79
-          recrd(j:k)=line(i)
-        enddo
-        write(lun,rec=wrecno) recrd(1:k)
-        return
-      endif
-c
-c     Bail out!
-c
-      return
-c
-c     On error return this record number
-c
- 999  recno=-999
-      end
diff --git a/filterbank-gmrt/scale_prof.c b/filterbank-gmrt/scale_prof.c
deleted file mode 100644
index 93c2aac..0000000
--- a/filterbank-gmrt/scale_prof.c
+++ /dev/null
@@ -1,17 +0,0 @@
-/* scale profile so each bin occupies an integer value between 0 and 65535 */
-#include <stdio.h>
-#include "sigproc.h"
-void scale_prof(float *profile, int nbins, unsigned long *iprofile, float *scale, float *offset) /*includefile*/
-{
-  int j;
-  float denominator;
-  *offset=vmin(profile,nbins);
-  denominator=(vmax(profile,nbins)-*offset);
-  if (denominator!=0.0)
-    *scale=65535.0/denominator;
-  else
-    *scale=0.0;
-  for (j=0;j<nbins;j++) {
-    iprofile[j]=(profile[j]-(*offset))*(*scale);
-  }
-}
diff --git a/filterbank-gmrt/scaledata.c b/filterbank-gmrt/scaledata.c
deleted file mode 100644
index 14970c9..0000000
--- a/filterbank-gmrt/scaledata.c
+++ /dev/null
@@ -1,53 +0,0 @@
-/* routines for scaling and descaling arrays */
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-void float2int(float *f, int n, int b, float min, float max, int *i) /*includefile*/ 
-{
-  int j;
-  float delta,imax;
-  imax=pow(2.0,(double) b)-1.0;
-  delta=max-min;
-  for (j=0; j<n; j++) {
-    f[j] = (f[j]>max) ? (max): f[j];
-    i[j] = (f[j]<min) ? (0.0): (int) rint((f[j]-min)*imax/delta);
-  }
-}
-
-void int2float(int *i, int n, int b, float min, float max, float *f) /*includefile*/ 
-{
-  int j;
-  float delta,imax;
-  imax=pow(2.0,(double) b)-1.0;
-  delta=max-min;
-  for (j=0; j<n; j++) f[j] = min+((float) i[j])*delta/imax;
-}
-
-void float2four(float *f, int n, float min, float max, unsigned char *c) /*includefile*/
-{
-  int *i,j;
-  i=(int *) malloc(sizeof(int)*n);
-  float2int(f,n,4,min,max,i);
-  for (j=0;j<n;j++) c[j]=0;
-  for (j=0;j<n-1;j+=2) c[j/2]=charof2ints(i[j],i[j+1]);
-  free(i);
-}
-
-void float2char(float *f, int n, float min, float max, unsigned char *c) /*includefile*/
-{
-  int *i,j;
-  i=(int *) malloc(sizeof(int)*n);
-  float2int(f,n,8,min,max,i);
-  for (j=0;j<n;j++) c[j]=(unsigned char) i[j];
-  free(i);
-}
-
-void float2short(float *f, int n, float min, float max, unsigned short *s) /*includefile*/
-{
-  int *i,j;
-  i=(int *) malloc(sizeof(int)*n);
-  float2int(f,n,16,min,max,i);
-  for (j=0;j<n;j++) s[j]=(unsigned short) i[j];
-  free(i);
-}
-
diff --git a/filterbank-gmrt/scamp2fb.c b/filterbank-gmrt/scamp2fb.c
deleted file mode 100644
index ad8acde..0000000
--- a/filterbank-gmrt/scamp2fb.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/* scamp2fb - converts SCAMP search-mode data into "filterbank" data 
-   modified - 05/04/04 (drl@jb.man.ac.uk) to flip the incoming data if
-   it has been saved in the less-common lower sideband format i.e. lowest
-   frequency channel first 
-   modified - 02/07/04 (drl@jb.man.ac.uk) to cope with 24/48k block sizes
-   modified - 29/04/05 (drl@jb.man.ac.uk) to clip samples before writing
-   modified - 21/07/05 (drl@jb.man.ac.uk) to ignore sections of the band
-   modified - 09/03/06 (drl@jb.man.ac.uk) to clip using stats from chaninfo
-   modified - 13/03/06 (drl@jb.man.ac.uk) to clip with random 0s and 1s
-*/
-#include "filterbank.h"
-int scamp_ignore[1024],scamp_chans;
-int scamp_block_size; /* read in from header, can be either 48k or 24k */
-int scamp_rawdata;    /* signifies whether data has been sc_td'd or not */
-/* bit-reverse the order of (i.e. flip) a byte */
-unsigned char flipchar(unsigned char orig) {
-  unsigned char flipped,c;
-  int i,j[8];
-  flipped=0;
-  j[0]=1;
-  j[1]=2;
-  j[2]=4;
-  j[3]=8;
-  j[4]=16;
-  j[5]=32;
-  j[6]=64;
-  j[7]=128;
-  for (i=0;i<8;i++) {
-    if (c=(orig&j[i])) flipped+=128/c;
-  }
-  return (flipped);
-}
-
-/* utility to sum the 1-bit samples in a byte */
-int sumchar(unsigned char c) /*includefile*/
-{
-  unsigned char i,j[8],sum;
-  sum=0;
-  j[0]=1;
-  j[1]=2;
-  j[2]=4;
-  j[3]=8;
-  j[4]=16;
-  j[5]=32;
-  j[6]=64;
-  j[7]=128;
-  for (i=0;i<8;i++) if (c&j[i]) sum++;
-  return(sum);
-}
-
-void scamp2fb(FILE *input, FILE *output) /* includefile */
-{
-  FILE *fpou,*bad_blocks;
-  unsigned char *gulp,*spew,*flip,sumof[256];
-  float mean,prob=0.5,realtime;
-  double junk;
-  char string[80],schead[640];
-  int i,j,k,l,startsamp=0,endsamp=0,doit,idump=0,nread,opened=0,s,f,total=0,
-	ngood=0,mask=165,ntotal=0,nclipped=0,isamp=0,ichans,sum,clipmax;
-  long seed=0;	
-
-  /*if (scamp_chans != nchans) exit(0);*/
-
-  /* allocated space to store incoming and outgoing data blocks */
-  gulp = (unsigned char *) malloc(scamp_block_size * sizeof(unsigned char));
-  flip = (unsigned char *) malloc(scamp_block_size * sizeof(unsigned char));
-  spew = (unsigned char *) malloc(8*scamp_block_size * sizeof(unsigned char));
-
-  if (headerfile) {
-    /* write output ASCII header file */
-    fpou=open_file("head","w");
-    fprintf(fpou,"Original SCAMP file: %s\n",inpfile);
-    fprintf(fpou,"Sample time (us): %f\n",tsamp*1.0e6);
-    fprintf(fpou,"Center freq (MHz): %f\n",fch1+(float)scamp_chans*foff/2.0);
-    fprintf(fpou,"Channel band (kHz): %f\n",fabs(foff)*1000.0);
-    fprintf(fpou,"Time stamp (MJD): %18.12f\n",tstart);
-    fprintf(fpou,"RA (J2000): %f\n",src_raj);
-    fprintf(fpou,"DEC (J2000):	%f\n",src_dej);
-    fclose(fpou);
-  }
-
-  if (clip_threshold != 0.0)  {
-     /* 
-       clip samples which deviate by more than clip_threshold 
-       sigma times the mean. For these data, mean=nchan/2 and
-       sigma = sqrt(nchan) 
-     */
-     clipmax=(float)(scamp_chans)/2.0+clip_threshold*sqrt((float)scamp_chans);
-     for (i=0;i<256;i++) sumof[i]=sumchar(i); /* look-up table of byte sums */
-     mean=(float)(scamp_chans/2);
-  }
-
-  if (clip_threshold == -1) 
-	bad_blocks=open_file("bad.blocks","r");
-
-  while (!feof(input)) {
-
-    /* read ina 48k block of data */
-    nread=fread(gulp,1,scamp_block_size,input);
-
-    /* do the band inversion here if necessary 
-       DEDISPERSE requires that the first channel is the highest frequency */
-    if (invert_band) {
-      for (i=0; i<scamp_block_size; i++) flip[i]=flipchar(gulp[i]);
-      for (i=0; i<scamp_block_size/scamp_chans; i++) {
-	s=i*scamp_chans; f=(i+1)*scamp_chans; k=0;
-	for (j=s;j<f;j++) {
-	  gulp[j]=flip[f-1-k];
-	  k++;
-	}
-      }
-    }
-
-    /* now do clipping if necessary: 
-           clip threshold > 0 uses dead reckoning 
-	   i.e. mean=nchans/2; sigma=sqrt(nchans) 
-
-	   clip threshold = -1 uses Simon's chaninfo output
-    */
-    if (clip_threshold != 0.0) {
-      ichans=sum=j=0; 
-      for (i=0; i<scamp_block_size; i++) {
-	/* keep track of sum over each byte (8 channels!) */
-	sum+=sumof[gulp[i]];
-	ichans+=8;
-	if (ichans==scamp_chans) {
-	        if (clip_threshold == -1) {
-			/* keep track of the absolute sample number */
-			isamp++;
-			/* read a line from bad.blocks if need be */
-		        while ( (!feof(bad_blocks)) && (isamp>endsamp) ) 
-				fscanf(bad_blocks,"%d %d",&startsamp,&endsamp);
-			/* now decide whether this is in a bad block */
-			if ((isamp>=startsamp) && (isamp<=endsamp)) {
-				/* it is - set sum/clipmax -> clipping */
-				clipmax=sum-1.0;
-			} else {
-				/* it is - set sum/clipmax -> no clipping */
-				clipmax=sum;
-			}
-	        }
-		/* decide whether to clip this sample */
-		if (sum>clipmax) {
-		  nclipped++;
-		  /* CLIP replace with random bits with same mean as good data*/
-		  for (k=j; k<=i; k++) {
-		    mask=0;
-		    for (l=0; l<8; l++) 
-		      if (nrran2(&seed)<prob) mask+=pow(2,l);
-		    gulp[k]=mask;
-		  }  
-		} else {
-		  /* NOCLIP keep track of mean of up to last 16k tamples */
-		  total+=sum;
-		  ngood++;
-		  mean=(float)total/(float)ngood;
-		  prob=mean/(float)scamp_chans;
-		  if (ngood==16384) {
-		    total=0;
-		    ngood=0;
-		  }
-		}
-		ntotal++;
-	        j=i+1;
-		sum=0;
-		ichans=0;
-	}
-      }
-    }
-
-    if (scamp_rawdata) {
-      /* read off the header from the data and proceed as normal */
-      fread(schead,sizeof(schead),1,input);
-    } else {
-      /* extra (FORTRAN!) junk that gets written after each block */
-      fread(&junk,8,1,input); 
-    }
-
-    /* decide whether to write out this block */
-    realtime=tsamp*idump;
-    if ((doit=process(realtime,start_time,final_time))==-1) break;
-    if (doit) {
-      if (idump%1024 == 0) {
-	if (!opened) {
-	  open_log("filterbank.monitor");
-	  opened=1;
-	}
-	sprintf(string,"time:%.1fs",realtime);
-	update_log(string);
-      }
-      /* output as single bit (default) or single byte data */
-      switch (obits) {
-      case 1:
-	idump+=8*nread/scamp_chans;
-	i=1;
-	/* write out only segments not in scamp.ignore */
-	for (j=1;j<=nread;j++) {
-	  if (!scamp_ignore[i]) fwrite(&gulp[j-1],1,1,output);
-	  i++;
-	  if (i>scamp_chans/8) i=1;
-	}
-	/*fwrite(gulp,1,nread,output);*/
-	break;
-      case 8:
-	k=0;
-	for (i=0; i<nread; i++) {
-	  for (j=0;j<8;j++) {
-	    spew[k]=gulp[i]&1;
-	    gulp[i]>>=1;
-	    k++;
-	    if (!(k%scamp_chans)) idump++;
-	  }
-	}
-	fwrite(spew,1,8*scamp_block_size,output);
-	break;
-      }
-    }
-  }
-  /* write out clipping statistics to ASCII file clip.stats */
-  if (clip_threshold != 0.0) {
-    fpou=open_file("clip.stats","w");
-    fprintf(fpou,"threshold %.1f sigma (sum = %d)\n",
-	clip_threshold,clipmax);
-    fprintf(fpou,"samples clipped = %d (total = %d)\n",
-	nclipped,ntotal);
-    fclose(fpou);
-  }
-  free(gulp);free(flip);free(spew);
-}
diff --git a/filterbank-gmrt/scamp_header.h b/filterbank-gmrt/scamp_header.h
deleted file mode 100644
index 1d973bf..0000000
--- a/filterbank-gmrt/scamp_header.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* 
- scamp_header.h - C structure of header files for SCAMP filterbank data
- 
- dlorimer@atnf.csiro.au - Oct 20, 2001 - adapted from sc_pmhead.inc
-*/
-typedef struct {
-
-  char tape[6];       /* Tape label */
-  char file[4];       /* File number on tape */
-  char block[8];      /* Block counter in file */
-  char date[8];       /* UT date 'yy/mm/dd' */
-  char mjd[8];        /* MJD at 00h UT */
-  char ut[16];        /* UT at file start ' hh:mm:ss.ssssss' */
-  char lst[12];       /* LST at file start ' hh:mm:ss.ss' */
-  char coord[2];      /* Coord system  04 = Galactic  05 = J2000 */
-  
-  char ra[16];        /* RA at file start ' hh:mm:ss.ssss' */
-  char dec[16];       /* Dec at file start '-dd:mm:ss.sss' */
-  char l[8];          /* Gal longitude at start 'ddd.dddd' */
-  char b[8];          /* Gal latitude at file start  '+dd.dddd' */
-  char fangle[8];     /* Feed angle (degrees) */
-  char obstime[8];    /* Obs length (seconds of time) 'ssss.sss' */
-  char comment[64];   /* Comment entered by user */
-  char nfilter[2];    /* No. of filter systems (01 or 02) */
-  char chbw[2][8];    /* Chan inc (MHz, -ve if inverted) 'bb.bbbb' */
-  char nchan[2][4];   /* No. of channels in each filter system */
-  char fch1[2][12];   /* RFof 1st chan center    'ffffff.fffff' */
-  
-  char tsamp[2][12];  /* Sample interval in us */
-  char nsgrp[2][4];   /* Samples per group (=1 for pmdaq) */
-  char ngblk[8];      /* Groups per block */
-  char blocksec[8];   /* Seconds per tape block */
-  char fdcntrl[2];    /* 0 = none, 1 = fixed FA, 2 = fixed PA or GPA */
-  char dtype[2][1];   /* Data type code (2=pol, 3=norm, 5=dedisp) */
-  
-  char uthd[16];      /* UT of block start ' hh:mm:ss.ssssss' */
-  char lsthd[12];     /* LST of block start ' hh:mm:ss.ss' */
-  char rahd[16];      /* RA at block start ' hh:mm:ss.ssss' */
-  char dechd[16];     /* Dec at block start '-dd:mm:ss.sss' */
-  char lhd[8];        /* Gal long at block start 'ddd.dddd' */
-  char bhd[8];        /* Gal lat at block start '+dd.dddd' */
-  char zahd[8];       /* Zenith angle at block start 'ddd.dddd' */
-  char azhd[8];       /* Azimuth at block start 'ddd.dddd' */
-    
-  char atten[4][4];   /* Attenuator settings (db) */
-  char tpower[20][4]; /* Total powers (Jy) 'iiii' */
-  char nblk_read[8];  /* Number of tape blocks in disk file */
-  char scanl[8];      /* scan rate in deg/min in long '-r.rrrrr' */
-  char scanb[8];      /* scan rate in deg/min in lat  '-r.rrrrr' */
-  char nbeam[4];      /* total number of beams */
-  char ibeam[4];      /* number of this beam */
-  char psrname[16];   /* pulsar name including B/J */
-  char obsfile[16];   /* config file name used */
-  char nbits[2][2];   /* number of bits per sample */
-  char dmdd[8];       /* DM for dedispersion */
-  char nddch[2][4];   /* number of channels per dedispersed band */
-  char move[2];       /* 'k0': On k(0-9), '01': grd '02': off '03:scanning'*/
-  
-  char pnterr[6];     /* pointing error in acmin mmm.mmm */
-  char tree[2];       /* ' ' normal 'T' tre dedisp 'D' pdm dedisp */
-  char nsys[2];       /* Filter systems disk file */
-  char telid[10];     /* Telescope ID */
-  char pangle[8];     /* Parallactic angle degrees */
-  char nspbsw[8];     /* Number of samples per beam switch */
-  char pcalcyc[4];    /* Cal cycle period in samples */
-  
-  char reserve[22];
-
-} SCAMP_HEADER;
diff --git a/filterbank-gmrt/seek.f b/filterbank-gmrt/seek.f
deleted file mode 100644
index 21b08db..0000000
--- a/filterbank-gmrt/seek.f
+++ /dev/null
@@ -1,58 +0,0 @@
-c=============================================================================
-      program seek
-c=============================================================================
-c
-c     A program (formerly known as find) to seek for periodic signals in data
-c
-c     Created: 97/11/21 (dunc@mpifr-bonn.mpg.de)
-c
-c     Modification history:
-c
-c     98/04/10 - (dunc) added acceleration capability (no longer need rbin)
-c     98/04/30 - (dunc) source code overhauled. Now more user-friendly
-c     98/11/20 - (dunc) added read and FFT capability for ".dis" files
-c     99/07/08 - (dunc) added read spectrum file capability
-c     01/02/15 - (dunc) added capability to read new data format ".tim" files
-c     01/10/11 - (dunc) added -pmzap option and fixed call to zapit routine
-c     02/03/01 - (dunc) added -pulse option to call Maura's single-pulse code
-c     02/03/20 - (dunc) changed ordering of spectral zapping in dosearch.f
-c     02/03/21 - (dunc) added -pzero option to pad with zeros if need be
-c     02/03/21 - (dunc) make pmax a command-line parameter
-c     05/04/07 - (dunc) changed name of program to SEEK! to appease RNM et al.
-c     05/04/28 - (dunc) added ability to read masks for all 5 harmonic folds
-c
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-      logical dump,rspc,acsearch,tanalyse,pmzap,pulse,append,pzero
-      character*80 sfile
-      real accn,adot
-      real*8 pmax
-      integer llog       
-      call seekin(llog,dump,rspc,pmzap,sfile,pulse,append,pzero,
-     &		  pmax,nofft,spthresh,ncandsmax,nsmax)
-      accn=refac
-      adot=refad
-      call timstart(llog)                    ! fire up the ship's clock
-      if (.not.rspc) call readdat(llog,pzero)! read in the time series 
-      if (pulse) then
-        call baseline(llog)
-        call singlepulse(llog,append,spthresh,ncandsmax,nsmax)
-      endif
-      if (.not.nofft) then
-      if (accn.ne.0.0) refac=accn
-      if (adot.ne.0.0) refad=adot
-      acsearch=accn.ne.0.0.or.adot.ne.0.0
-      tanalyse=(index(filename,'.ser').gt.0.0)
-     &     .or.(index(filename,'.tim').gt.0.0)
-     &     .or.(index(filename,'.dis').gt.0.0)
-      if (rspc) tanalyse=.false.
-      if (tanalyse) then                     ! (time series analysis only)
-         if (acsearch) call resample(llog)   ! re-sample time series
-         call fftdata(llog)                  ! fft the data
-      endif                                  ! (standard analysis follows)
-      call dosearch(llog,dump,rspc,pmzap,sfile,pmax)! search Fourier spectrum
-      endif
-      call timfinis(llog)                    ! stop the clock
-      end
-c=============================================================================
diff --git a/filterbank-gmrt/seek.inc b/filterbank-gmrt/seek.inc
deleted file mode 100644
index e44a2fd..0000000
--- a/filterbank-gmrt/seek.inc
+++ /dev/null
@@ -1,13 +0,0 @@
-c=============================================================================
-c   Common Variable declarations for find (includes common time series/head)
-c=============================================================================
-c
-      include 'vers.inc'
-      include 'time.inc'
-      include 'head.inc'
-      include 'pulse.inc'
-      real power   ! power spectrum
-      common /four/ power(5,npts/2)
-c    
-c=============================================================================
-    
diff --git a/filterbank-gmrt/seekin.f b/filterbank-gmrt/seekin.f
deleted file mode 100644
index f5d3624..0000000
--- a/filterbank-gmrt/seekin.f
+++ /dev/null
@@ -1,191 +0,0 @@
-c=============================================================================
-      subroutine seekin(llog,dump,rspc,pmzap,sfile,pulse,app,pzero,pmax,
-     &                  nofft,spthresh,ncandsmax,nsmax)
-c=============================================================================
-c
-c   Controls the command-line inputs to seek
-c
-      include 'seek.inc'
-      integer narg,iargc,i,llog,p2,lun
-      character*80 option,sfile
-      logical dump,rspc,pmzap,pulse,app,pzero
-      real*8 pmax
-      p2=nint(log10(real(npts))/log10(2.0))
-      narg=iargc()
-      call getarg(1,option)
-      if (option.eq.'version'.or.option.eq.'-version') then
-         write(*,'(a,a)') 'PROGRAM: seek ',version
-         stop
-      endif
-      if (option.eq.'-maxft') then
-         write(*,2) 'Maximum length of time series 2^',p2,' pts'
-         stop
-      endif
-      if (narg.lt.1.or.option.eq.'-help'.or.option.eq.'help') then
-         write(*,*)
-         write(*,1) 
-     &   'seek - searches for periodic signals in noisy time series'
-         write(*,*)
-         write(*,1)'usage: seek <INFILE> -{options}'
-         write(*,*)
-         write(*,1)'The input file may be a time series, or a set of'
-         write(*,1)'Fourier coefficients. The file extension MUST,'
-         write(*,1)'however, be either ".tim" ".ser" ".dis" or ".fft"'
-         write(*,1)'In the latter case, the FFT stage is skipped.'
-         write(*,*)
-         write(*,1)'options:'
-         write(*,*)
-         write(*,1)'-A: append output ASCII files if already exist'
-         write(*,1)'-s: dump spectra to ".spc" files after hsums'
-         write(*,1)'-q: quiet mode - all standard messages > INFILE.log'
-         write(*,1)'-pmzap: calls the PM survey routine zap_birdies'
-         write(*,1)'-pulse: calls Maura single pulse search'
-         write(*,1)'-pzero: pads out data with zeros (def=gaussian)'
-         write(*,1)'-maxft: report maximum length of Fourier transform'
-	 write(*,1)'-nofft: turns off FFT search'
-         write(*,*)
-         write(*,1)'-m[file]: mask birdies from file (def="mask")'
-         write(*,1)'-z[file]: zap birdies from file (def="birdies")'
-	 write(*,1)'-b[freq]: zap 10-sig+ spikes < freq (def=100 Hz)'
-         write(*,1)'-c[cfac]: add every cfac samples before FFT'
-         write(*,1)'-a[accn]: re-sample at constant accn (m/s/s)'
-         write(*,1)'-d[adot]: re-sample at constant adot (cm/s/s/s)'
-         write(*,1)'-D[dmvl]: change header DM to be dmvl'
-         write(*,1)'-t[tlen]: fix transform length to 2**tlen'
-         write(*,1)'-i[tsec]: ignore tsec seconds of data on reading'
-         write(*,1)'-p[pmax]: set maximum period of seach (def=9.999s)'
-	 write(*,1)'-T[spthresh]: set single-pulse search threshold (sigma)'
-	 write(*,1)'-n[ncandsmax]: maximum number of single-pulse candidates per DM channel'
-	 write(*,1)'-w[nsmax]: number of times to smooth time series for single-pulse search'
-         write(*,*)
- 1       format(a)
- 2       format(a,i2,a)
-         stop
-      endif
-
-      pmax=9.99999999
-      dmidx=-1
-      spthresh=4
-      ncandsmax=100000
-      nsmax=10
-      fbrute=0.0
-      zapfile=' '
-      maskfile(1)=' '
-      nmasks=0
-      rfac=1
-      llog=6
-      tsize=0
-      skp=0.0
-      dump=.false.
-      pmzap=.false.
-      pulse=.false.
-      nofft=.false.
-      pzero=.false.
-      dumpraw=.false. 
-      app=.false.
-      facc='sequential'
-      refac=0.0
-      rspc=.false.
-      sfile='fold0.spc'
-      refdm=0.0 
-      call getarg(1,filename)
-      
-      if (index(filename,'.ser').gt.0) then
-         lst=index(filename,'.ser')-1
-      else if (index(filename,'.tim').gt.0) then
-         lst=index(filename,'.tim')-1
-      else if (index(filename,'.dis').gt.0) then
-         lst=index(filename,'.dis')-1
-         dmidx=1
-      else if (index(filename,'.fft').gt.0) then
-         lst=index(filename,'.fft')-1
-      else if (index(filename,'.spc').gt.0) then
-         lst=index(filename,'.spc')-1
-         rspc=.true.
-         sfile=filename
-      else
-         stop 'file type not recognized! Type seek for help.'
-      endif
-      
-      do i=2,narg
-        call getarg(i,option)
-        if (index(option,'-z').gt.0) then
-          zapfile='birdies' ! default file
-	  if (option(3:).ne.' ') zapfile=option(3:)
-        else if (index(option,'-m').gt.0) then
-          maskfile(1)='mask' ! default file
-	  if (option(3:).ne.' ') maskfile(1)=option(3:)
-          call glun(lun)
-          open(unit=lun,file=maskfile(1),status='old')
-          read(lun,'(a)') option
-c
-c         establish whether 1 or 5 mask files are being read
-c
-          if (option.eq.'maskfiles are as follows:') then
-             do f=1,5
-                read(lun,'(a)') maskfile(f)
-             enddo
-             nmasks=5 ! added option to mask all five folds drl 28/05/05
-          else
-             nmasks=1 ! this is the old method of masking unfolded spectrum
-          endif
-          close(unit=lun)
-        else if (index(option,'-b').gt.0) then
-	  fbrute=100.0 ! default value
-          if (option(3:).ne.' ') read(option(3:),*) fbrute
-        else if (index(option,'-i').gt.0) then
-c          read(option(3:),*) dmidx
-          read(option(3:),*) skp
-        else if (index(option,'-D').gt.0) then
-          read(option(3:),*) refdm
-        else if (index(option,'-a').gt.0) then
-          read(option(3:),*) refac
-        else if (index(option,'-d').gt.0) then
-          read(option(3:),*) refad
-        else if (index(option,'-c').gt.0) then
-          read(option(3:),*) rfac
-c          if (mod(rfac,2).ne.0) then
-c            write(*,*) 'WARNING - rebin factor must be a multiple of 2!'
-c            write(*,*) '*** input value',rfac,' ignored...'
-c            rfac=1
-c          endif
-        else if (index(option,'-t').gt.0) then
-           read(option(3:),*) tsize
-        else if (index(option,'-q').gt.0) then
-           call glun(llog)
-        else if (index(option,'-pmzap').gt.0) then
-           pmzap=.true.
-        else if (index(option,'-pulse').gt.0) then
-           pulse=.true.
-	else if (index(option,'-nofft').gt.0) then
-	   nofft=.true.
-        else if (index(option,'-pzero').gt.0) then
-           pzero=.true.
-        else if (index(option,'-p').gt.0) then
-          read(option(3:),*) pmax
-	else if (index(option,'-T').gt.0) then
-          read(option(3:),*) spthresh
-	else if (index(option,'-w').gt.0) then
-	  read(option(3:),*) nsmax
-	else if (index(option,'-n').gt.0) then
-	  read(option(3:),*) ncandsmax
-        else if (index(option,'-s').gt.0) then
-          dump=.true.
-	  if (option(3:).ne.' ') dumpraw=.true.
-	  sfile=' '
-	  if (option(3:).ne.' ') sfile=option(3:)
-        else if (index(option,'-A').gt.0) then
-          facc='append'
-          app=.true.
-        else
-          write(*,*) 'WARNING.. command line option ',
-     &    option(1:index(option,' ')-1),' not recognized!!!'
-        endif
-      enddo
-      
-      if (llog.ne.6)
-     &open(unit=llog,file=filename(1:lst)//'.log',status='unknown',
-     &     access=facc)
-      write(llog,*)
-      write(llog,*) 'SEEK: ',version
-      end
diff --git a/filterbank-gmrt/seekinnew.f b/filterbank-gmrt/seekinnew.f
deleted file mode 100644
index 0426658..0000000
--- a/filterbank-gmrt/seekinnew.f
+++ /dev/null
@@ -1,227 +0,0 @@
-c=============================================================================
-      subroutine seekinnew(llog,dump,rspc,pmzap,sfile,pulse,app,pzero,pmax,
-     &                  nofft,spthresh,ncandsmax,nsmax)
-c=============================================================================
-c
-c   Controls the command-line inputs to seek
-c
-      include 'seek.inc'
-
-c Code Added for GMGPS BCJ 03-06-2011      
-      integer ninfile
-      character*80 infile(80)
-      common /newskinc/ infile, ninfile
-      character*80 listfile
-c Code Added for GMGPS BCJ 03-06-2011      
-
-      integer narg,iargc,i,llog,p2,lun
-      character*80 option,sfile
-      logical dump,rspc,pmzap,pulse,app,pzero
-      real*8 pmax
-      p2=nint(log10(real(npts))/log10(2.0))
-      narg=iargc()
-      call getarg(1,option)
-      if (option.eq.'version'.or.option.eq.'-version') then
-         write(*,'(a,a)') 'PROGRAM: seek ',version
-         stop
-      endif
-      if (option.eq.'-maxft') then
-         write(*,2) 'Maximum length of time series 2^',p2,' pts'
-         stop
-      endif
-      if (narg.lt.1.or.option.eq.'-help'.or.option.eq.'help') then
-         write(*,*)
-         write(*,1) 
-     &   'seek - searches for periodic signals in noisy time series'
-         write(*,*)
-         write(*,1)'usage: seek <INFILE> -{options}'
-         write(*,*)
-         write(*,1)'The input file may be a time series, or a set of'
-         write(*,1)'Fourier coefficients. The file extension MUST,'
-         write(*,1)'however, be either ".tim" ".ser" ".dis" or ".fft"'
-         write(*,1)'In the latter case, the FFT stage is skipped.'
-         write(*,*)
-         write(*,1)'options:'
-         write(*,*)
-         write(*,1)'-A: append output ASCII files if already exist'
-         write(*,1)'-s: dump spectra to ".spc" files after hsums'
-         write(*,1)'-q: quiet mode - all standard messages > INFILE.log'
-         write(*,1)'-pmzap: calls the PM survey routine zap_birdies'
-         write(*,1)'-pulse: calls Maura single pulse search'
-         write(*,1)'-pzero: pads out data with zeros (def=gaussian)'
-         write(*,1)'-maxft: report maximum length of Fourier transform'
-	 write(*,1)'-nofft: turns off FFT search'
-         write(*,*)
-         write(*,1)'-m[file]: mask birdies from file (def="mask")'
-         write(*,1)'-z[file]: zap birdies from file (def="birdies")'
-	 write(*,1)'-b[freq]: zap 10-sig+ spikes < freq (def=100 Hz)'
-         write(*,1)'-c[cfac]: add every cfac samples before FFT'
-         write(*,1)'-a[accn]: re-sample at constant accn (m/s/s)'
-         write(*,1)'-d[adot]: re-sample at constant adot (cm/s/s/s)'
-         write(*,1)'-D[dmvl]: change header DM to be dmvl'
-         write(*,1)'-t[tlen]: fix transform length to 2**tlen'
-         write(*,1)'-i[tsec]: ignore tsec seconds of data on reading'
-         write(*,1)'-p[pmax]: set maximum period of seach (def=9.999s)'
-	 write(*,1)'-T[spthresh]: set single-pulse search threshold (sigma)'
-	 write(*,1)'-n[ncandsmax]: maximum number of single-pulse candidates per DM channel'
-	 write(*,1)'-w[nsmax]: number of times to smooth time series for single-pulse search'
-
-c Code Added for GMGPS BCJ 03-06-2011    
-         write(*,1)'-f[listfile]:listfile with no and infile names'
-c Code Added for GMGPS BCJ 03-06-2011      
-
-         write(*,*)
- 1       format(a)
- 2       format(a,i2,a)
-         stop
-      endif
-
-      pmax=9.99999999
-      dmidx=-1
-      spthresh=4
-      ncandsmax=100000
-      nsmax=10
-      fbrute=0.0
-      zapfile=' '
-      maskfile(1)=' '
-      nmasks=0
-      rfac=1
-      llog=6
-      tsize=0
-      skp=0.0
-      dump=.false.
-      pmzap=.false.
-      pulse=.false.
-      nofft=.false.
-      pzero=.false.
-      dumpraw=.false. 
-      app=.false.
-      facc='sequential'
-      refac=0.0
-      rspc=.false.
-      sfile='fold0.spc'
-      refdm=0.0 
-      call getarg(1,filename)
-
-c Code Added for GMGPS BCJ 03-06-2011    
-      if(index(filename,'-') .gt. 0) then
-         if(index(filename,'-f') .gt. 0) then
-            if(filename(3:).ne. ' ')listfile=filename(3:)
-            call glun(lun)
-            open(unit=lun,file=listfile,status='old')
-            read(lun,*) ninfile
-            do f=1,ninfile
-               read(lun,'(a)') infile(f)
-            enddo
-         else
-            write(*,*) 'WARNING.. command line option ',
-     &      option(1:index(option,' ')-1),' not recognized!!!'
-            stop
-         endif
-      else
-         ninfile = 1
-c Code Added for GMGPS BCJ 03-06-2011    
-      
-         if (index(filename,'.ser').gt.0) then
-            lst=index(filename,'.ser')-1
-         else if (index(filename,'.tim').gt.0) then
-            lst=index(filename,'.tim')-1
-         else if (index(filename,'.dis').gt.0) then
-            lst=index(filename,'.dis')-1
-            dmidx=1
-         else if (index(filename,'.fft').gt.0) then
-            lst=index(filename,'.fft')-1
-         else if (index(filename,'.spc').gt.0) then
-            lst=index(filename,'.spc')-1
-            rspc=.true.
-            sfile=filename
-         else
-            stop 'file type not recognized! Type seek for help.'
-         endif
-
-c Code Added for GMGPS BCJ 03-06-2011    
-      endif
-c Code Added for GMGPS BCJ 03-06-2011    
-      
-      do i=2,narg
-        call getarg(i,option)
-        if (index(option,'-z').gt.0) then
-          zapfile='birdies' ! default file
-	  if (option(3:).ne.' ') zapfile=option(3:)
-        else if (index(option,'-m').gt.0) then
-          maskfile(1)='mask' ! default file
-	  if (option(3:).ne.' ') maskfile(1)=option(3:)
-          call glun(lun)
-          open(unit=lun,file=maskfile(1),status='old')
-          read(lun,'(a)') option
-c
-c         establish whether 1 or 5 mask files are being read
-c
-          if (option.eq.'maskfiles are as follows:') then
-             do f=1,5
-                read(lun,'(a)') maskfile(f)
-             enddo
-             nmasks=5 ! added option to mask all five folds drl 28/05/05
-          else
-             nmasks=1 ! this is the old method of masking unfolded spectrum
-          endif
-          close(unit=lun)
-        else if (index(option,'-b').gt.0) then
-	  fbrute=100.0 ! default value
-          if (option(3:).ne.' ') read(option(3:),*) fbrute
-        else if (index(option,'-i').gt.0) then
-c          read(option(3:),*) dmidx
-          read(option(3:),*) skp
-        else if (index(option,'-D').gt.0) then
-          read(option(3:),*) refdm
-        else if (index(option,'-a').gt.0) then
-          read(option(3:),*) refac
-        else if (index(option,'-d').gt.0) then
-          read(option(3:),*) refad
-        else if (index(option,'-c').gt.0) then
-          read(option(3:),*) rfac
-c          if (mod(rfac,2).ne.0) then
-c            write(*,*) 'WARNING - rebin factor must be a multiple of 2!'
-c            write(*,*) '*** input value',rfac,' ignored...'
-c            rfac=1
-c          endif
-        else if (index(option,'-t').gt.0) then
-           read(option(3:),*) tsize
-        else if (index(option,'-q').gt.0) then
-           call glun(llog)
-        else if (index(option,'-pmzap').gt.0) then
-           pmzap=.true.
-        else if (index(option,'-pulse').gt.0) then
-           pulse=.true.
-	else if (index(option,'-nofft').gt.0) then
-	   nofft=.true.
-        else if (index(option,'-pzero').gt.0) then
-           pzero=.true.
-        else if (index(option,'-p').gt.0) then
-          read(option(3:),*) pmax
-	else if (index(option,'-T').gt.0) then
-          read(option(3:),*) spthresh
-	else if (index(option,'-w').gt.0) then
-	  read(option(3:),*) nsmax
-	else if (index(option,'-n').gt.0) then
-	  read(option(3:),*) ncandsmax
-        else if (index(option,'-s').gt.0) then
-          dump=.true.
-	  if (option(3:).ne.' ') dumpraw=.true.
-	  sfile=' '
-	  if (option(3:).ne.' ') sfile=option(3:)
-        else if (index(option,'-A').gt.0) then
-          facc='append'
-          app=.true.
-        else
-          write(*,*) 'WARNING.. command line option ',
-     &    option(1:index(option,' ')-1),' not recognized!!!'
-        endif
-      enddo
-      
-      if (llog.ne.6)
-     &open(unit=llog,file=filename(1:lst)//'.log',status='unknown',
-     &     access=facc)
-      write(llog,*)
-      write(llog,*) 'SEEK: ',version
-      end
diff --git a/filterbank-gmrt/seeknew.f b/filterbank-gmrt/seeknew.f
deleted file mode 100644
index a73ab5b..0000000
--- a/filterbank-gmrt/seeknew.f
+++ /dev/null
@@ -1,101 +0,0 @@
-c=============================================================================
-      program seeknew
-c=============================================================================
-c
-c     A program (formerly known as find) to seek for periodic signals in data
-c
-c     Created: 97/11/21 (dunc@mpifr-bonn.mpg.de)
-c
-c     Modification history:
-c
-c     98/04/10 - (dunc) added acceleration capability (no longer need rbin)
-c     98/04/30 - (dunc) source code overhauled. Now more user-friendly
-c     98/11/20 - (dunc) added read and FFT capability for ".dis" files
-c     99/07/08 - (dunc) added read spectrum file capability
-c     01/02/15 - (dunc) added capability to read new data format ".tim" files
-c     01/10/11 - (dunc) added -pmzap option and fixed call to zapit routine
-c     02/03/01 - (dunc) added -pulse option to call Maura's single-pulse code
-c     02/03/20 - (dunc) changed ordering of spectral zapping in dosearch.f
-c     02/03/21 - (dunc) added -pzero option to pad with zeros if need be
-c     02/03/21 - (dunc) make pmax a command-line parameter
-c     05/04/07 - (dunc) changed name of program to SEEK! to appease RNM et al.
-c     05/04/28 - (dunc) added ability to read masks for all 5 harmonic folds
-c     11/06/03 - (bcj) added seeknew for GMGPS broken survey
-c
-c=============================================================================
-      implicit none
-      include 'seek.inc'
-
-c Code Added for GMGPS BCJ 03-06-2011      
-      include 'csampacc.inc'
-      include 'csamp.inc'
-      integer ninfile, nfl
-      character*80 infile(80)
-      common /newskinc/ infile, ninfile
-      integer ifile
-c Code Added for GMGPS BCJ 03-06-2011      
-
-      logical dump,rspc,acsearch,tanalyse,pmzap,pulse,append,pzero
-      character*80 sfile
-      real accn,adot
-      real*8 pmax
-      integer llog, i, npf      
-      call seekinnew(llog,dump,rspc,pmzap,sfile,pulse,append,pzero,
-     &		  pmax,nofft,spthresh,ncandsmax,nsmax)
-
-c Code Added for GMGPS BCJ 03-06-2011      
-      ifile = 1
-      write(*,*) ninfile
-      do while(ifile .le. ninfile)
-         if( ninfile .gt. 1 ) then
-            filename = infile(ifile)
-            if (index(filename,'.tim').gt.0) then
-               lst=index(filename,'.tim')-1
-            else
-               stop 'file type not recognized! Type seek for help.'
-            endif
-         endif
-         ifile = ifile + 1
-         write(*,*) ifile
-c Code Added for GMGPS BCJ 03-06-2011      
-
-      accn=refac
-      adot=refad
-      call timstart(llog)                    ! fire up the ship's clock
-      if (.not.rspc) call readdat(llog,pzero)! read in the time series 
-      if (pulse) then
-        call baseline(llog)
-        call singlepulse(llog,append,spthresh,ncandsmax,nsmax)
-      endif
-      if (.not.nofft) then
-      if (accn.ne.0.0) refac=accn
-      if (adot.ne.0.0) refad=adot
-      acsearch=accn.ne.0.0.or.adot.ne.0.0
-      tanalyse=(index(filename,'.ser').gt.0.0)
-     &     .or.(index(filename,'.tim').gt.0.0)
-     &     .or.(index(filename,'.dis').gt.0.0)
-      if (rspc) tanalyse=.false.
-      if (tanalyse) then                     ! (time series analysis only)
-         if (acsearch) call resample(llog)   ! re-sample time series
-         call fftdata(llog)                  ! fft the data
-      endif                                  ! (standard analysis follows)
-
-c Code Added for GMGPS BCJ 03-06-2011      
-
-      nfl=real(tsamp)*ntim/real(pmax)
-      write(llog,*) 'Forming power spectrum. (Pmax=',pmax,' s!)'
-      call accspec(npf, nfl, ifile)
-      endif
-      enddo
-      i = 1
-      do while( i .le. npf ) 
-         samp(i) = sampacc(i)
-         i = i + 1
-      enddo
-      call dosearchnew(llog,dump,rspc,pmzap,sfile,pmax)! search Fourier spectrum
-
-c Code Added for GMGPS BCJ 03-06-2011      
-
-      call timfinis(llog)                    ! stop the clock
-      end
-c=============================================================================
diff --git a/filterbank-gmrt/select.c b/filterbank-gmrt/select.c
deleted file mode 100644
index 0084788..0000000
--- a/filterbank-gmrt/select.c
+++ /dev/null
@@ -1,46 +0,0 @@
-#define SWAP(a,b) temp=(a);(a)=(b);(b)=temp;
-
-float select(unsigned long k, unsigned long n, float arr[])
-{
-	unsigned long i,ir,j,l,mid;
-	float a,temp;
-
-	l=1;
-	ir=n;
-	for (;;) {
-		if (ir <= l+1) {
-			if (ir == l+1 && arr[ir] < arr[l]) {
-				SWAP(arr[l],arr[ir])
-			}
-			return arr[k];
-		} else {
-			mid=(l+ir) >> 1;
-			SWAP(arr[mid],arr[l+1])
-			if (arr[l+1] > arr[ir]) {
-				SWAP(arr[l+1],arr[ir])
-			}
-			if (arr[l] > arr[ir]) {
-				SWAP(arr[l],arr[ir])
-			}
-			if (arr[l+1] > arr[l]) {
-				SWAP(arr[l+1],arr[l])
-			}
-			i=l+1;
-			j=ir;
-			a=arr[l];
-			for (;;) {
-				do i++; while (arr[i] < a);
-				do j--; while (arr[j] > a);
-				if (j < i) break;
-				SWAP(arr[i],arr[j])
-			}
-			arr[l]=arr[j];
-			arr[j]=a;
-			if (j >= k) ir=j-1;
-			if (j <= k) l=i;
-		}
-	}
-}
-#undef SWAP
-/* (C) Copr. 1986-92 Numerical Recipes Software i9k''3. */
-
diff --git a/filterbank-gmrt/send_stuff.c b/filterbank-gmrt/send_stuff.c
deleted file mode 100644
index 0e7baa8..0000000
--- a/filterbank-gmrt/send_stuff.c
+++ /dev/null
@@ -1,54 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-FILE *input, *output;
-int swapout;
-void send_string(char *string) /* includefile */
-{
-  int len;
-  len=strlen(string);
-  if (swapout) swap_int(&len);
-  fwrite(&len, sizeof(int), 1, output);
-  if (swapout) swap_int(&len);
-  fwrite(string, sizeof(char), len, output);
-  /*fprintf(stderr,"%s\n",string);*/
-}
-
-void send_float(char *name,float floating_point) /* includefile */
-{
-  send_string(name);
-  if (swapout) swap_float(&floating_point);
-  fwrite(&floating_point,sizeof(float),1,output);
-  /*fprintf(stderr,"%f\n",floating_point);*/
-}
-
-void send_double (char *name, double double_precision) /* includefile */
-{
-  send_string(name);
-  if (swapout) swap_double(&double_precision);
-  fwrite(&double_precision,sizeof(double),1,output);
-  /*fprintf(stderr,"%f\n",double_precision);*/
-}
-
-void send_int(char *name, int integer) /* includefile */
-{
-  send_string(name);
-  if (swapout) swap_int(&integer);
-  fwrite(&integer,sizeof(int),1,output);
-  /*fprintf(stderr,"%d\n",integer);*/
-}
-
-void send_long(char *name, long integer) /* includefile */
-{
-  send_string(name);
-  if (swapout) swap_long(&integer);
-  fwrite(&integer,sizeof(long),1,output);
-  /*fprintf(stderr,"%ld\n",integer);*/
-}
-
-void send_coords(double raj, double dej, double az, double za) /*includefile*/
-{
-  if ((raj != 0.0) || (raj != -1.0)) send_double("src_raj",raj);
-  if ((dej != 0.0) || (dej != -1.0)) send_double("src_dej",dej);
-  if ((az != 0.0)  || (az != -1.0))  send_double("az_start",az);
-  if ((za != 0.0)  || (za != -1.0))  send_double("za_start",za);
-}
diff --git a/filterbank-gmrt/shift_prof.c b/filterbank-gmrt/shift_prof.c
deleted file mode 100644
index 52f2538..0000000
--- a/filterbank-gmrt/shift_prof.c
+++ /dev/null
@@ -1,23 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-/* 
-   shift a profile located in the memory position *profile by an integer
-   number of phase bins = shift. nbins is the total number of bins. 
-*/
-void shift_prof(float *profile, int nbins, int ishift) /* includefile */
-{
-  float *prcopy;
-  int i,j;
-
-  /* assign space and make a copy of the original profile */
-  prcopy=(float *) malloc(nbins * sizeof(float));
-  for (i=0;i<nbins;i++) prcopy[i]=profile[i];
-
-  for (i=0;i<nbins;i++) {
-    j = i + ishift;
-    j = (j > nbins-1) ? j - nbins : j;
-    j = (j < 0) ? j + nbins : j;
-    profile[j]=prcopy[i];
-  }
-  free(prcopy);
-}
diff --git a/filterbank-gmrt/short.f b/filterbank-gmrt/short.f
deleted file mode 100644
index 52e15f0..0000000
--- a/filterbank-gmrt/short.f
+++ /dev/null
@@ -1,72 +0,0 @@
-c=============================================================================
-      subroutine srd(infile,header,ntim,mpts,tsamp,refdm,refac,series)
-      implicit none
-      character*80 header,infile
-      integer ntim,mpts
-      real tsamp,refdm,refac,series(mpts)
-      integer lun,i
-      call glun(lun)
-      open(lun,file=infile,status='old',form='unformatted',err=999)
-      read(lun) header
-      read(lun) ntim,tsamp,refdm,refac
-      if (ntim.gt.mpts) then
-	write(*,*) 'WARNING - too many points in data file!'
-	write(*,*) '** reading in max possible:',mpts/1024,' kpts'
-	ntim=mpts
-      endif
-      read(lun) (series(i),i=1,ntim)
-      close(unit=lun)
-      return
- 999  stop 'Error opening input file!'
-      end
-c=============================================================================
-      subroutine swr(oufile,header,ntim,mpts,tsamp,refdm,refac,series)
-      implicit none
-      character*80 header,oufile
-      integer ntim,mpts
-      real tsamp,refdm,refac,series(mpts)
-      integer lun,i
-      call glun(lun)
-      open(unit=lun,file=oufile,status='unknown',
-     &     form='unformatted')
-      write(lun) header
-      write(lun) ntim,tsamp,refdm,refac
-      write(lun) (series(i),i=1,ntim)
-      close(unit=lun)
-      end
-c==============================================================================
-      subroutine ope(infile,lun,header,ntim,mpts,tsamp,refdm,refac)
-      implicit none
-      character*80 header,infile
-      integer ntim,mpts
-      real tsamp,refdm,refac
-      integer lun
-      call glun(lun)
-      open(lun,file=infile,status='old',form='unformatted',err=999)
-      read(lun) header
-      read(lun) ntim,tsamp,refdm,refac
-      if (ntim.gt.mpts) then
-	write(*,*) 'WARNING - too many points in data file!'
-	write(*,*) '** will read in max possible:',mpts/1024,' kpts'
-	ntim=mpts
-      endif
-      return
- 999  stop 'Error opening input file!'
-      end
-c=============================================================================
-      integer function glp(lun,gulp,ntim,gmean)
-      implicit none
-      integer lun,ntim,i
-      real gulp(*),gmean
-      gmean=0.0
-      glp=0
-      read(lun,end=999) (gulp(i),i=1,ntim)
-      do i=1,ntim
-         gmean=gmean+gulp(i)
-      enddo
-      gmean=gmean/real(ntim)
-      return
- 999  glp=-1 
-      end
-c=============================================================================
-      
diff --git a/filterbank-gmrt/sigproc.h b/filterbank-gmrt/sigproc.h
deleted file mode 100644
index 790c8ed..0000000
--- a/filterbank-gmrt/sigproc.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/* sigproc.h: Automatically generated include file for sigproc-3.7 */
-#include <stdlib.h>
-#include <string.h>
-#include "polyco.h"
-#include "epn.h"
-#include "version.h"
-char *backend_name (int machine_id) ;
-char *data_category (int data_type) ;
-char *headername (char *filename) ;
-char *telescope_name (int telescope_id) ;
-char tempo_site(int telescope_id) ;
-double *bandfactors(int nchans) ;
-double *chan_freqs(double fmid, double foff, int nchans, int wapp_off) ;
-double deg2dms(double angle) ;
-double dmdelay(double f1, double f2, double dm) ;
-double ffreq(double tsamp, int npf, int fold, int k) ;
-double h2hms(double hours) ;
-double inv_cerf(double input) ;
-double mjd(int year, int month, int day) ;
-double polyco_period(double mjd, struct POLYCO polyco) ;
-double polyco_phase(double mjd, struct POLYCO polyco) ;
-double pspm_tstart(unsigned long scan_num, char *start_time, double tick_offset, double *mjdobs);
-double slaDranrm ( double angle ) ;
-double slaGmst ( double ut1 ) ;
-double wappcorrect(double mjd) ;
-FILE *open_file(char *filename, char *descriptor) ;
-float flat(float min, float max, long *seed) ;
-float  *fold_data() ;
-float gasdev(long *idum) ;
-float gauss(long *seed, float mean, float sigma) ;
-float nrran0(long *idum) ;
-float nrran1(long *idum) ;
-float nrran2(long *idum) ;
-float nrselect(unsigned long k, unsigned long n, float arr[]) ;
-float *pspm_prof(FILE *input, int nbins, int nchans, int *table);
-float vmax(float *vec, float n) ;
-float vmin(float *vec, float n) ;
-float *wapp_prof(int nbins, int nchans, int nifs, int np1, int np2) ;
-int aoftm_read_header(char *filename) ;
-int big_endian() ;
-int bit(int bitindex, unsigned char byte) ;
-int  *bpp_chans(double bw, int mb_start_addr, int mb_end_addr, int mb_start_brd, int mb_end_brd, int *cb_id, double *aib_los, float *dfb_sram_freqs, double rf_lo) ;
-int *dmshift(double f1, double df, int nchans, int nbands, double dm, double refrf, double tsamp, double frequency_table[]) ;
-int fbin(double tsamp, int npf, int fold, double freq) ;
-int file_exists(char *filename) ;
-int help_required(char *string) ;
-int *ignored_channels(char *filename, int nchans) ;
-int little_endian() ;
-int np2(int n) ;
-int process(float time, float start_time, float final_time) ;
-int *pspm_chans(int nchans) ;
-int read_block(FILE *input, int nbits, float *block, int nread) ;
-int read_header(FILE *inputfile) ;
-int read_polycoset(FILE *polycofile, struct POLYCO *polyco) ;
-int ssm(void) ;
-int strings_equal (char *string1, char *string2) ;
-int sumchar(unsigned char c) ;
-int typeof_inputdata(FILE *fptr, char *filename) ;
-int vanvleck3lev(double *rho,int npts) ;
-long long nsamples(char *filename,int headersize, int nbits, int nifs, int nchans) ;
-long long sizeof_file(char name[]) ;
-long startseed(void) ;
-unsigned char charof2ints (int i, int j) ;
-void add_channels(float *data, int nsamples, int nadd) ;
-void add_samples(float *data, int nifs, int nchans, int nadd) ;
-void angle_split(double angle, int *dd, int *mm, double *ss) ;
-void aoftm2fb(char *filename, FILE *output) ;
-void bandpass_help() ;
-void barycentre_help() ;
-void blanker_help() ;
-void bpp2fb(FILE *input, FILE *output) ;
-void cal(double djm, int *year, int *month, int *day) ;
-void cel2gal(int rah, int ram, double ras,int decd,int decm,double decs,double *glon,double *glat) ;
-void char2ints (unsigned char c, int *i, int *j) ;
-void close_log() ;
-void create_bro(int nfft) ;
-void decimate_data(FILE *input, FILE *output) ;
-void decimate_header() ;
-void decimate_help() ;
-void dedispersecal_data(FILE *input, FILE *output) ;
-void dedispersecal_help() ;
-void dedisperse_data(FILE *input, FILE *output) ;
-void dedisperse_header() ;
-void dedisperse_help() ;
-void denorm_prof(float *prof, float *cnt, int nbins, int nifs, int nchans) ;
-void depolyco_help() ;
-void eight_bit_reorder(unsigned short *spectrum, int nfft) ;
-void error_message(char *message) ;
-void fake_help() ;
-void filterbank_header(FILE *outptr) ;
-void filterbank_help() ;
-void float2char(float *f, int n, float min, float max, unsigned char *c) ;
-void float2four(float *f, int n, float min, float max, unsigned char *c) ;
-void float2int(float *f, int n, int b, float min, float max, int *i) ;
-void float2short(float *f, int n, float min, float max, unsigned short *s) ;
-void fold_header() ;
-void fold_help() ;
-void four1(float data[], unsigned long nn, int isign) ;
-void fshift_prof(float *profile, int nbins, double fshift) ;
-void get_nearest_polyco(char *filename, double mjd, struct POLYCO *polyco) ;
-void get_string(FILE *inputfile, int *nbytes, char string[]) ;
-void gmrt2fb(FILE *input, FILE *output) ;
-void gmrt2fbgsb32512(FILE *input, FILE *output) ;
-void gmrt2fbgwbf(FILE *input, FILE *output, int nch) ;
-void gmrt2fbgwbr(FILE *input, FILE *output, int nch) ;
-void gmrt2fblsb(FILE *input, FILE *output) ;
-void gmrt2fbusblsb(FILE *input, FILE *output) ;
-void header_help() ;
-void indexx(unsigned long n, float arr[], unsigned long indx[]) ;
-void int2float(int *i, int n, int b, float min, float max, float *f) ;
-void machine2prf(FILE *input, FILE *output) ;
-void norm_prof(float *prof, float *cnt, int nbins, int nifs, int nchans) ;
-void nrsort(unsigned long n, float arr[]) ;
-void ooty2fb(FILE *input, FILE *output) ;
-void open_log(char *filename) ;
-void phcalc(double mjd0,double mjd1,double *phase,double *psrfreq,double *rphase,double *psr_f0,double *poly_tmid,double *coeff,int *num_coeff) ;
-void print_version(char *program, char *argument) ;
-void prof_adds(float *profile, int *nbins, int nchans, int nifs, int nadd);
-void prof_cent(float *profile, int nbins, int nchans) ;
-void prof_ddis(float *profile, int nbins, int nchans, int nbands, int nifs, double *chanfreq,  double period, double dm, double reference_frequency, float jyf1, float jyf2) ;
-void profile_help() ;
-void prof_sbas(char *srcname, float *profile, int nbins, int nchans, int nifs) ;
-void prof_sumc(float *profile, int nbins, int nbands, int *nchans, int nifs, int *ignore) ;
-void prof_sumifs(float *profile, int nbins, int nchans, int *nifs) ;
-void pspm2fb(FILE *input, FILE *output) ;
-void pspm_decode(int *rawdata, float *tmparray) ;
-void putd(double d) ;
-void putf(float f) ;
-void puti(int i) ;
-void putld(long double d) ;
-void putl(long l) ;
-void putu(unsigned long l) ;
-void read_aoscan(unsigned long aoscan, int *day, int *year, int *scan) ;
-void reader_help() ;
-void realft(float data[], unsigned long n, int isign) ;
-void rfft(int nfft, double *org, double *fft) ;
-void scale_prof(float *profile, int nbins, unsigned long *iprofile, float *scale, float *offset) ;
-void scamp2fb(FILE *input, FILE *output) ;
-void send_coords(double raj, double dej, double az, double za) ;
-void send_double (char *name, double double_precision) ;
-void send_float(char *name,float floating_point) ;
-void send_int(char *name, int integer) ;
-void send_long(char *name, long integer) ;
-void send_string(char *string) ;
-void shift_prof(float *profile, int nbins, int ishift) ;
-void slaCaldj ( int iy, int im, int id, double *djm, int *j ) ;
-void slaCalyd(int iy, int im, int id, int *ny, int *nd, int *j );
-void slaCldj ( int iy, int im, int id, double *djm, int *j ) ;
-void slaDjcal ( int ndp, double djm, int iymdf[4], int *j ) ;
-void subcal(float *profile, int nbins) ;
-void submean(float *profile, int nbins) ;
-void submedian(float *profile, int nbins) ;
-void swap_double( double *pd ) ;
-void swap_float( float *pf ) ;
-void swap_int( int *pi ) ;
-void swap_longlong( long long *pl ) ;
-void swap_long( long *pi ) ;
-void swap_short( unsigned short *ps ) ;
-void swap_ulong( unsigned long *pi ) ;
-void tune_help() ;
-void two_bit_reorder(unsigned short *spectrum, int nfft) ;
-void update_log(char *string) ;
-void uttime(double mjd, int *hh, int *mm, float *ss) ;
-void vanvleck9lev(double *rho,int npts) ;
-void wapp2fb(FILE *input, FILE *output) ;
-void write_dedispcal(float *dedisp, int nsout, int nifs, int nbands, float *offset,FILE *output,float *calfac);
-void write_dedisp(float *dedisp, int nsout, int nifs, int nbands, float *offset, FILE *output);
-void write_epn(FILE *fptr, struct EPN epn) ;
-void write_profiles(float *prof,int nbins, int nchan, int nifs, FILE *out);
diff --git a/filterbank-gmrt/sigproc.tex b/filterbank-gmrt/sigproc.tex
deleted file mode 100644
index 63c311e..0000000
--- a/filterbank-gmrt/sigproc.tex
+++ /dev/null
@@ -1,1455 +0,0 @@
-% THIS FILE SHOULD NOT BE EDITED -- EDIT documentation.tex
-\documentclass[11pt]{article}
-\usepackage{makeidx}
-\makeindex
-\def\lapp{\ifmmode\stackrel{<}{_{\sim}}\else$\stackrel{<}{_{\sim}}$\fi}
-\def\gapp{\ifmmode\stackrel{>}{_{\sim}}\else$\stackrel{>}{_{\sim}}$\fi}
-\textheight 670pt 
-\textwidth 500pt  
-\evensidemargin 5mm            
-\oddsidemargin -5mm  
-\topmargin -15mm     
-\headheight 12pt 
-\headsep 15pt
-\parindent 0pt
-\parskip 8pt plus 2pt minus 1pt
-
-\begin{document}
-\begin{center}
-{\LARGE {\sc SIGPROC--v3.7} : {\bf (Pulsar) Signal Processing Programs}}\\
-\bigskip
-\bigskip
-{\large Dunc Lorimer --- Jodrell Bank Observatory --- {\tt drl@jb.man.ac.uk} --- Sunday March 26, 2006}
-\end{center}
-\noindent {\bf Summary:} The SIGPROC package is a collection of
-programs written to convert and process fast-sampled pulsar data into
-a compact and easy-to-use format suitable for off-line analyses for
-searching, timing and polarimetry applications. This document
-describes how to install and run the various programs. Several example
-applications are presented using real and simulated data sets.
-\tableofcontents
-
-\clearpage
-\section{About SIGPROC}
-
-\index{Backends!AOFTM}
-\index{Backends!WAPP}
-\index{Backends!PSPM}
-\index{Backends!BPP}
-\index{Backends!Parkes/Jodrell filterbanks}
-\index{Backends!OOTY}
-SIGPROC is a package designed to standardize the initial analysis of
-the many types of fast-sampled pulsar data. Currently recognized
-machines are the Wide Band Arecibo Pulsar Processor (WAPP), the Penn
-State Pulsar Machine (PSPM), the Arecibo Observatory Fourier Transform
-Machine (AOFTM), the Berkeley Pulsar Processors (BPP), the Parkes/Jodrell
-1-bit filterbanks (SCAMP) and the
-filterbank at the Ooty radio telescope (OOTY). The package
-should help users look at their data quickly, without the need to
-write (yet) another routine to read data or worry about big/little
-\index{byte swapping} \index{big endian} \index{little endian}
-endian compatibility (byte swapping is handled automatically).  The
-current suite of programs is:
-
-\index{Programs!{\tt filterbank}}
-\bigskip
-\noindent {\tt filterbank} - convert raw pulsar-machine data to 
-filterbank format: a stream of n-bit numbers corresponding to multiple
-polarization and/or frequency channels. 
-
-\index{Programs!{\tt splice}}
-\smallskip
-\noindent {\tt splice} - join together multiple filterbank
-files which have the same time stamp.
-
-\index{Programs!{\tt fake}}
-\smallskip
-\noindent {\tt fake} - produce fake filterbank format data
-containing periodic signals immersed in Gaussian noise for
-testing and calibration of downstream programs.
-
-\index{Programs!{\tt decimate}}
-\smallskip
-\noindent {\tt decimate} - add together frequency channels
-and/or time samples of incoming filterbank data to reduce
-the time and/or frequency resolution (useful for quick-look
-purposes).
-
-\index{Programs!{\tt dedisperse}}
-\smallskip
-\noindent {\tt dedisperse} - correct incoming filterbank data
-for interstellar dispersion, writing the output time series as
-one or more dedispersed sub-bands.
-
-\index{Programs!{\tt fold}}
-\smallskip
-\noindent {\tt fold} - fold incoming filterbank or time series
-data modulo a pulse period. Pulses are output in ASCII
-EPN (\S \ref{epn}) or PSRFITS format. An Expect script to 
-generate polynomial coefficients is also available.
-
-\index{Programs!{\tt profile}}
-\smallskip
-\noindent {\tt profile} - displays profiles from {\tt fold} in
-ASCII or pseudo grey-scale plots to the standard output.
-
-\index{Programs!{\tt pgplotter}}
-\smallskip
-\noindent {\tt pgplotter} - displays profiles from {\tt fold} 
-and other SIGPROC output to a PGPLOT window.
-
-\index{Programs!{\tt bandpass}}
-\smallskip
-\noindent {\tt bandpass} - write out the mean bandpass to an ASCII file.
-
-\index{Programs!{\tt header}}
-\smallskip
-\noindent {\tt header} - read raw data files,
-filterbank or time series data and display header info as plain ASCII.
-
-\index{Programs!{\tt header}}
-\smallskip
-\noindent {\tt reader} - read the filterbank or time series
-data and display in human-readable form.
-
-\index{Programs!{\tt quicklook}}
-\smallskip
-\noindent {\tt quicklook} - csh script to perform a quick
-analysis of total-power filterbank data on a known pulsar.
-
-\index{Programs!{\tt monitor}}
-\smallskip
-\noindent {\tt monitor} - wish script to
-monitor programs running in a given
-directory using a Tk pop-up widget.
-
-\bigskip
-\noindent
-All of the programs within SIGPROC are written in C and can be run
-from the UNIX command-line. Use is made of standard input and output
-streams so that piping between programs is possible to ``glue''
-together various tasks. As an example, the following pipeline:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19 -s 4 | fold -p polyco.dat > B0823+26.prf
-\end{verbatim}
-will read in and dedisperse raw PSPM data into four subbands which are
-then folded modulo the pulse period based on a set of polynomial
-coefficients generated by TEMPO stored in the file {\tt polyco.dat}.
-The folded profiles for each band are written in ASCII format
-to the file {\tt B0823+26.prf}.  
-\index{polyco.dat}
-
-A detailed description of these programs and scripts is given in the
-remainder of this document which is structured as follows: in \S
-\ref{install} we describe how to install SIGPROC; \S \ref{dataformat}
-describes the filterbank data and header format used by all the
-programs; producing real and fake filterbank data is described in \S
-\ref{filterbank} and \S \ref{fake} respectively; programs to look at
-the headers and raw data are discussed in \S \ref{headers} and \S
-\ref{looking}; data reduction tasks (decimation and dedispersion) are
-described in \S \ref{reduction}; folding filterbank data to produce
-pulse profiles is described in \ref{folding}; a script do quick data
-analyses is presented in \S \ref{quicklook} respectively; version
-history and plans for future work (\S \ref{past/future}). 
-Supplementary appendices deal with
-monitoring the programs (\S \ref{monitoring}), 
-generating {\tt polyco.dat} files using {\sc TEMPO}
-(\S \ref{polyco}) and the EPN data format (\S \ref{epn}).
-
-\section{Installation procedure}
-\label{install}
-\index{installation}
-SIGPROC has so far been successfully installed for use on Solaris,
-Linux, HP-UX and Macs.
-ANSII C was (hopefully!)  adhered to fairly closely
-during writing of the programs so that installation on other operating
-systems should also be possible.  Installation proceeds as follows:
-
-\noindent {\bf 0:}
-Download the package from 
-\verb+http://www.jb.man.ac.uk/~drl/sigproc/sigproc.tar.gz+
-
-\noindent {\bf 1:}
-Unpack the gzip-compressed tar file and extract its contents:
-
-\noindent 
-{\tt gunzip -c sigproc-3.7.tar.gz | tar xvf -}
-
-\noindent {\bf 2:}
-The contents of the tar file will be distributed in the directory
-{\tt sigproc-3.7/}. Go into this directory and run the configuration
-script by typing: 
-
-\noindent
-{\tt cd sigproc-3.7}\\
-{\tt ./configure}
-
-\noindent
-When prompted, supply the name
-of a directory in which you would like the SIGPROC executables to
-be placed.
-If compiling on more than one system, log into the the other system
-and run the same script on this computer.
-Note that only one copy of the source code is required
-if you are compiling under multiple platforms.
-
-\noindent {\bf 3:}
-For each operating system you are using, type:
-
-\noindent
-{\tt make}
-
-\noindent in the
-{\tt sigproc-3.7} directory
-and let the compiler go to work. 
-
-Four other software packages are desirable, but not absolutely
-necessary.  To output profiles in PSRFITS format, you will need
-CFITSIO ({\tt 
-heasarc.gsfc.nasa.gov/docs/software/fitsio/fitsio.html})
-and uncomment and edit the appropriate path to the LFITS variable in your
-{\tt makfile.osname} file. To take advantage of the FFTW subroutines,
-you will need to install version 3 of this package (available from
-{\tt fftw.org}) and then uncomment and edit the LFFTW variable in
-{\tt makfile.osname}.
-To create files containing polynomial coefficients for
-high-precision folding, install the {\sc TEMPO} software package which
-\index{Software Packages!{\sc TEMPO}}
-is freely available from the Princeton pulsar website ({\tt
-pulsar.princeton.edu}).  To monitor the programs using a Tk
-pop-up widget make sure that the {\tt wish} shell is in your path (we
-recommend use of Tcl/Tk version 8.0 or higher). This is freely
-available from {\tt scriptics.com}. For making diagnostic
-\index{Software Packages!Tcl/Tk}
-plots you will need to compile the {\tt quickplot} Fortran program which
-requires the {\sc PGPLOT} graphics package available from 
-\verb+astro.caltech.edu/~tjp/pgplot+. Edit the {\tt
-makefile} to give the appropriate path to {\sc PGPLOT} on your system
-\index{Software Packages!{\sc PGPLOT}}
-before typing {\tt make quickplot}.
-
-\clearpage
-\section{Header information and data format}
-\label{dataformat}
-\index{Data formats!SIGPROC}
-Before describing the programs in detail, some description of the
-header and data formats used within SIGPROC is appropriate for those
-wishing to read the data into other programs.  The {\tt filterbank}
-program (see \S \ref{filterbank}) reads in the raw data files produced
-by the machine, dealing with the header information contained in the
-files and the (usually non-trivial) channel ordering of the
-samples. {\tt filterbank} outputs the data in the following way:
-\begin{verbatim}
-HEADER_START stream_of_header_parameters HEADER_END stream_of_data_values
-\end{verbatim}
-The \verb+HEADER_START+ and \verb+HEADER_END+ character strings
-signal the start and
-finish of a stream of header parameters that describe the data.  The
-default is to include these at the beginning of the data file.  We
-recognize that some users will prefer not to have to deal with the
-header in this way. For these users, {\tt filterbank} has a {\tt
--headerfile} command-line option to pipe the header into a seperate
-ASCII file (this is described along with the other command-line
-options later on).
-
-The header variables have been restricted to key parameters for ease of use.
-Currently these are:
-\begin{itemize}
-\item {\bf telescope\_id} (\verb+int+): 
-\index{Header parameters!{\bf telescope\_id}}
-0=fake data; 1=Arecibo; 2=Ooty... others to be added
-\item {\bf machine\_id} (\verb+int+): 
-\index{Header parameters!{\bf machine\_id}}
-0=FAKE; 1=PSPM; 2=WAPP; 3=OOTY... others to be added
-\item {\bf data\_type} (\verb+int+): 
-\index{Header parameters!{\bf data\_type}}
-1=filterbank; 2=time series... others to be added
-\item {\bf rawdatafile} (\verb+char []+): 
-\index{Header parameters!{\bf rawdatafile}}
-the name of the original data file
-\item {\bf source\_name} (\verb+char []+): 
-\index{Header parameters!{\bf source\_name}}
-the name of the source being observed by the telescope
-\item {\bf barycentric} (\verb+int+):
-equals 1 if data are barycentric or 0 otherwise
-\item {\bf pulsarcentric} (\verb+int+):
-equals 1 if data are pulsarcentric or 0 otherwise
-\item {\bf az\_start} (\verb+double+): 
-\index{Header parameters!{\bf az\_start}}
-telescope azimuth at start of scan (degrees)
-\item {\bf za\_start} (\verb+double+): 
-\index{Header parameters!{\bf za\_start}}
-telescope zenith angle at start of scan (degrees)
-\item {\bf src\_raj} (\verb+double+): 
-\index{Header parameters!{\bf src\_raj}}
-right ascension (J2000) of source (hhmmss.s)
-\item {\bf src\_dej} (\verb+double+): 
-\index{Header parameters!{\bf src\_dej}}
-declination (J2000) of source (ddmmss.s)
-\item {\bf tstart} (\verb+double+): 
-\index{Header parameters!{\bf tstart}}
-time stamp (MJD) of first sample
-\item {\bf tsamp}  (\verb+double+): 
-\index{Header parameters!{\bf tsamp}}
-time interval between samples (s)
-\item {\bf nbits} (\verb+int+): 
-\index{Header parameters!{\bf nbits}}
-number of bits per time sample
-\item {\bf nsamples} (\verb+int+): 
-\index{Header parameters!{\bf nsamples}}
-number of time samples in the data file (rarely used any more)
-\item {\bf fch1}  (\verb+double+): 
-\index{Header parameters!{\bf fch1}}
-centre frequency (MHz) of first filterbank channel
-\item {\bf foff}  (\verb+double+): 
-\index{Header parameters!{\bf foff}}
-filterbank channel bandwidth (MHz)
-\item {\bf FREQUENCY\_START}  (\verb+character+): 
-\index{Header parameters!{\bf FREQUENCY\_START}}
-start of frequency table (see below for explanation)
-\item {\bf fchannel}  (\verb+double+): 
-\index{Header parameters!{\bf fchannel}}
-frequency channel value (MHz)
-\item {\bf FREQUENCY\_END}  (\verb+character+): 
-\index{Header parameters!{\bf FREQUENCY\_END}}
-end of frequency table (see below for explanation)
-\item {\bf nchans} (\verb+int+): 
-\index{Header parameters!{\bf nchans}}
-number of filterbank channels
-\item {\bf nifs} (\verb+int+): 
-\index{Header parameters!{\bf nifs}}
-number of seperate IF channels
-\item {\bf refdm}  (\verb+double+): 
-\index{Header parameters!{\bf refdm}}
-reference dispersion measure (cm$^{-3}$ pc)
-\item {\bf period}  (\verb+double+): 
-\index{Header parameters!{\bf period}}
-folding period (s)
-\end{itemize}
-A given header stream will contain most, but not necessarily all, of the 
-above variables. 
-
-In the general case, the data consists of {\bf nifs} polarization
-channels of {\bf nchans} frequency channels of {\bf nbit} numbers. The
-data stream following the header can then be thought of as 1-D array
-of $N$ elements with indices running between 0 and $N-1$, where
-\begin{displaymath}
-	N = {\rm \bf nifs} \times {\rm \bf nchans} \times {\rm \bf nsamples},
-\end{displaymath}
-and {\bf nsamples} is the observation time divided by {\bf tsamp}.
-Thus, for a given IF channel $i = (0,1,2,3)$ and frequency channel $c
-= (0 \dots {\rm \bf nchans}-1)$, the array index for sample $s =
-(0,1,2 \dots)$ is
-\begin{displaymath}
-s \times {\rm \bf nifs} \times {\rm \bf nchans}+ i \times {\rm \bf nchans} + c.
-\end{displaymath}
-The sky frequency of channel $c$ is then simply
-\begin{displaymath}
-		{\rm \bf fch1} + c \times {\rm \bf foff}.
-\end{displaymath}
-We follow the Parkes/Jodrell Bank
-convention of assigning a negative frequency to {\bf
-foff} in the headers to signify that the highest frequency channel is
-{\bf fch1}.  Currently, all filterbank data is written out in this order
-and the {\tt dedisperse} program relies on this fact in its dedispersing
-algorithm (see \S \ref{reduction}).
-
-Although this system works well for most applications, from version 2.3
-there is a more flexible way of describing the frequency channels.
-Instead of writing {\bf fch1} and {\bf foff}, it is now possible to 
-write the individual frequency channel frequencies directly into the header
-in the following way:
-\begin{verbatim}
-FREQUENCY_START f1 f2 f3 f4 FREQUENCY_END
-\end{verbatim}
-where \verb+f1+, \verb+f2+.... are the frequency channel
-values in MHz. These may be in any order, {\em provided that}
-the \verb+f1+ is the highest frequency (again this is 
-stipulated because of {\tt dedisperse}'s algorithm).
-This frequency table approach is used by the {\tt splice} program
-to deal with non-contiguous data described next.
-
-\clearpage
-\section{Data conversion using {\tt filterbank} and {\tt splice}}
-\label{filterbank}
-\index{Programs!{\tt filterbank}}
-
-The interface between the raw data and the rest of the SIGPROC package
-is the {\tt filterbank} program. As with all the programs on-line help
-is obtained by typing the name of the program followed by {\tt help}:
-\input{filterbank.help}
-Given just the name of the raw data file as the argument, {\tt
-filterbank} will determine the origin of the data and, if it can read
-the file, unpack the samples before writing the header parameters
-and data as described in \S \ref{dataformat}. The header and data go
-to the standard output by default but can be redirected to a file
-using the {\tt -o filename} option, or in the standard way:
-\begin{verbatim}
-% filterbank rawdatafile > filterbankfile
-\end{verbatim}
-With no further options, {\tt filterbank} will read and unscramble all
-the data in the original file. A specific portion of the data can be
-specified using the {\tt -r} and {\tt -s} command-line options. For example:
-\begin{verbatim}
-% filterbank rawdatafile -r 10.0 > filterbankfile
-\end{verbatim}
-reads just the first 10 seconds of data. These options are useful for
-a quick look at the data.
-
-\subsection*{Selecting and/or summing IF streams}
-\index{summing IFs}
-\index{selecting IF streams}
-By default, all the IF streams (if there are more than one) in the
-file are read and processed. To select one or more of these, ignoring
-the others, use the {\tt -i} option:
-\begin{verbatim}
-% filterbank rawdatafile -i 1 -i 2 > filterbankfile
-\end{verbatim}
-will process just the first two IF channels of the raw data file.
-{\tt filterbank} provides the option to sum {\sl just the first two} IF
-channels (to form total-power data) via the {\tt -sumifs} option:
-\begin{verbatim}
-% filterbank rawdatafile -sumifs > filterbankfile
-\end{verbatim}
-This is a useful, for example, to get just total power from
-polarimetry data for off-line searching.
-
-\subsection*{ASCII headers}
-\index{ASCII headers}
-As mentioned in \S \ref{dataformat}, {\tt filterbank} will broadcast a
-header stream before writing the data. This header is used by other
-downstream SIGPROC programs to process the data. To make use of it in
-analysis with other programs, call the function \verb+read_header+ and
-link with the other routines contained in the file
-\verb+read_header.c+.  For those who prefer not to be bothered with
-these routines, use the {\tt -headerfile} option when calling
-filterbank. For example:
-\begin{verbatim}
-% filterbank B0823+26.pspm -headerfile > B0823+26.fil
-\end{verbatim}
-will create the file {\tt B0823+26.fil} containing just the filterbank
-channels along with the relevant header parameters in an ASCII file
-{\tt head}. In this case:
-\begin{verbatim}
-Original PSPM file: B0823+26.pspm
-Sample time (us): 80.000002
-Time stamp (MJD): 51740.882986111108
-Number of samples/record: 512
-Center freq (MHz): 430.000000
-Channel band (kHz): 62.000000
-Number of channels/record: 128
-\end{verbatim}
-the user is then left to parse this file as he/she feels fit.
-An alternative means of getting header information would be
-to use the {\tt header} program in the following example:
-\begin{verbatim}
-% filterbank B0823+26.pspm | header -tstart
-\end{verbatim}
-which will return {\tt 51740.882986111108} to the standard output.
-Any of the header variable names listed in \S \ref{dataformat}
-can be given as a command-line option to the {\tt header} program.
-Further details are given in \S \ref{looking}.
-
-\subsection*{Changing the number of bits per sample}
-By default, {\tt filterbank} will write the outgoing data with the same
-number of bits per sample as the native format (e.g.~4 bits per sample
-for PSPM). For machines which write out larger numbers of bits
-(e.g.~the WAPP) it is useful to be able to pack the data more
-efficiently using the {\tt -n} option.  For example, the sequence:
-\begin{verbatim}
-% filterbank wappdatafile -n 8 > filterbankfile
-\end{verbatim}
-will process a WAPP data file (usually 16 bits per sample) and
-pack the outgoing samples as single-byte integers. For search
-purposes, where only marginal loss in sensitivity is seen and data products
-are reduced significantly, use of this option is highly recommended.
-For WAPP data, the loss in sensitivity from 16 to 8 bits is negligible,
-packing down to 4 bits results in losses $\sim$5\%.
-
-\subsection*{Floating-point output}
-\index{floating-point output}
-Currently, no descaling parameters are given in the header when
-packing down data. This means that for applications where the
-absolute value of the data is necessary (e.g.~polarization work)
-it is necessary to store the data as floating-point numbers.
-The option {\tt -floats} is provided for this purpose (although this
-is really just an alias for {\tt -n 32}).
-
-\subsection*{Byte swapping issues}
-\index{byte swapping}
-Multi-byte precision data are written in different orders depending on
-your machine's operating system. The original WAPP data, for example,
-was written on a PC (little endian format).  The {\tt filterbank}
-program knows about this and {\sl automatically} does any byte
-swapping required while reading. When it comes to writing the data
-out, however, the program will always write data in the native order
-of the processing machine.  To swap the bytes around before writing
-for use on other machines, use the {\tt -swapout} option.
-
-\subsection*{Correlator-specific options}
-Presently, the WAPP is the only correlator machine recognized by SIGPROC
-which records auto- and, in polarization mode, cross-correlation functions for 
-given numbers of lags. The autocorrelation function $R(\tau)$, as a 
-function of lag $\tau$ is defined by:
-\begin{displaymath}
-R(\tau) = \lim_{T\rightarrow\infty} \frac{1}{T} \int_0^T V(t) V^*(t+\tau) dt,
-\end{displaymath}
-where $V(t)$ is the complex signal voltage as a function of time $t$.
-From the Weiner-Khinchin theorem, the power 
-spectral density function $P(f)$ is the Fourier transform of $R(\tau)$:
-\begin{displaymath}
-P(f)=\frac{1}{2\pi} \int_{-\infty}^{+\infty} R(\tau) e^{-2\pi i f \tau} d\tau.
-\end{displaymath}
-In practice to obtain the equivalent of frequency channels of a
-filterbank, the lags from each IF channel need to be corrected for
-finite-level quantization --- the so-called van Vleck correction (see 
-\index{van Vleck correction}
-for example Hagen \& Farley 1973, Radio Science, {\bf 8}, 775--784)
-before the Fast Fourier Transform (FFT) to obtain the spectra. For
-reference, the three-level van Vleck formula used within {\tt filterbank} to 
-correct measured auto-correlation values ($r$) to unbiased ones ($\rho$)
-can be written as
-\begin{displaymath}
-r = \frac{1}{\pi} \int_0^{\rho} \left(
-\exp \left( \frac{-(\alpha/\sigma)^2}{1+x} \right) +
-\exp \left( \frac{-(\alpha/\sigma)^2}{1-x} \right) \right)
-\frac{dx}{\sqrt(1-x^2)},
-\end{displaymath}
-where $\alpha$ is the digitizer threshold and $\sigma$ the rms
-voltage. This correction is what {\tt filterbank} does by default
-before FFTing the correlation functions to produce spectra. 
-
-A number of options exist to modify the default processing.
-To reduce FFT leakage, either a Hanning or Hamming window
-\index{Hanning smoothing}
-\index{Hamming smoothing}
-can be applied to the correlation functions via the
-{\tt -hamming} and {\tt -hanning} switches. Select {\tt -rawcfs} to
-output the raw correlation functions quantized to the precision
-specified by {\bf nbits}.  To get at the raw correlation functions,
-include the floating-point option:
-\begin{verbatim}
-% filterbank wappdatafile -rawcfs -floats > rawcffile
-\end{verbatim}
-The {\tt -corcfs} option will write out the correlation 
-functions {\sl applying} the van Vleck correction.
-
-\subsection*{Obscure correlator options} For completeness, we mention two
-other correlator specific options: {\tt -novanvleck} and {\tt
--zerolag}. The {\tt -novanvleck} option will not apply the
-quantization correction before the FFT. This feature is really for
-instructional purposes since, to FFT the data to get frequency
-channels, signal-to-noise will be lost if the van Vleck correction
-is not applied. Another option that
-is primarily used for testing is {\tt -zerolag}. If selected, this
-outputs just the first correlation function for each IF (the so-called
-zero lag) as a floating-point number. Inserting $\tau=0$ into the
-above expression for $P(f)$, we note that the zero lag is just the sum
-over all the frequency channels --- equivalent to a time series with
-no dispersion measure correction. 
-
-For WAPP data, one final option is {\tt -invert}
-\index{bandpass inversion}
-which inverts the band after the FFT to change the frequency ordering.
-This should normally be dealt with in the WAPP header but is included
-here to process data where the header information about frequency
-ordering is incorrect.
-
-\subsection*{Splicing files}
-\index{Programs!{\tt splice}}
-
-Most data acquisition systems store the collected data as single
-files per observation. For the new multiple WAPP system at Arecibo,
-where each machine runs independently to sample a different part of
-the band, a number of data files result for each frequency band.
-In order to analyse these datasets together, the {\tt splice} program
-will join multiple filterbank files, provided that they all have
-on the same time stamp. The syntax is very simple:
-\begin{verbatim}
-	splice file1.fil file2.fil file3.fil > splice.fil
-\end{verbatim}
-where it is assumed that the input files \verb+file1.fil+, \verb+file2.fil+ and
-\verb+file3.fil+ have already been converted into filterbank format
-as described above. The resulting file, \verb+splice.fil+ in this
-example, is also in filterbank format and can be read by subsequent
-programs. Although the files need not span a contiguous
-radio frequency band,
-{\tt splice} will complain if the input files do not
-all have the same time stamp, or if they are not ordered in
-descending frequency order. The latter check is done so
-that the data conform to the order expected by the 
-dedispersion algorithm (\S \ref{reduction}).
-
-\clearpage
-\section{Creating mock data sets using {\tt fake}}
-\index{Programs!{\tt fake}}
-
-The {\tt fake} program was written to create test data sets containing
-pulses hidden in Gaussian noise:
-\label{fake}
-\input{fake.help}
-Default parameters are a filterbank similar to the PSPM. As an example, 
-consider some fake PSPM data for a 42-s observation of a
-pulsar with a period of $\sim\pi$ ms, a duty cycle of 10\% and a DM of 30:
-\begin{verbatim}
-% fake -period 3.1415927 -width 10 -dm 30 -tobs 42 -nbits 4 > pspm.fil
-\end{verbatim}
-Each channel of fake data has a zero mean and unit rms.  The
-signal-to-noise ratio refers to the height of a single pulse in each
-channel. In the above example, the default signal-to-noise was
-used. Weaker pulsars can be easily made to challenge limits of
-off-line search algorithms etc. By default, the fake pulse width $w$
-is smeared by an amount dependent on the filterbank setup using the
-quadrature sum:
-\begin{displaymath}
-	\sqrt{w^2 + {\rm \bf tsamp}^2 + t_{\rm DM}^2},
-\end{displaymath}
-where $t_{\rm DM}$ is the dispersion smearing of the pulse over a
-single filterbank channel given by:
-\begin{displaymath}
- t_{\rm DM} = 8.3 \times 10^6 {\rm ms} \, \, {\rm DM} \, \Delta \nu / \nu^3,
-\end{displaymath}
-assuming the centre frequency $\nu$ is much larger than the channel bandwidth
-$\Delta \nu$ (both measured in MHz). Smearing can be disabled using the {\tt
--nosmear} option. Bit-format and byte-swapping options are identical
-to those described for the {\tt filterbank} program in the previous
-section. The starting seed of the random number generator defaults to
-a number obtained by starting with the number of seconds since midnight
-and calling the random number generator that many times. This can be 
-overridden by specifying a seed using the {\tt -seed} option. 
-
-\section{Looking at headers using {\tt header}}
-\label{headers}
-\index{Programs!{\tt header}}
-The {\tt header} program allows humans easy access to the raw data
-file, or the binary header string in the filterbank data format.  
-As an example of the full
-output, here is the header of our PSPM test data:
-\begin{verbatim}
-% header B0823+26.fil
-
-Data file                        : B0823+26.fil
-Header size (bytes)              : 191
-Data size (bytes)                : 2359296
-Data type                        : filterbank
-Telescope                        : Arecibo
-Datataking Machine               : PSPM
-Frequency of channel 1 (MHz)     : 433.968000
-Channel bandwidth      (MHz)     : -0.062000
-Number of channels               : 128
-Time stamp of first sample (MJD) : 51740.882986111108
-Gregorian date (YYYY/MM/DD)      : 2000/07/15
-Sample time (us)                 : 80.00000
-Number of samples                : 36864
-Observation length (seconds)     : 2.949120
-Number of bits per sample        : 4
-Number of IFs                    : 1
-\end{verbatim}
-alternatively, {\tt header} can be used with one or more of the
-above command-line options to return just the value of the
-parameter of interest (this is particularly useful when 
-getting values from within scripts without having to parse
-the standard output). Currently available options are:
-\begin{verbatim}
--telescope  - return telescope name
--machine    - return datataking machine name
--fch1       - return frequency of channel 1 in MHz
--foff       - return channel bandwidth in MHz
--nchans     - return number of channels
--tstart     - return time stamp of first sample (MJD)
--tsamp      - return sample time (us)
--nbits      - return number of bits per sample
--nifs       - return number of IF channels
--headersize - return header size in bytes
--datasize   - return data size in bytes if known
--nsamples   - return number of samples if known
--tobs       - return length of observation if known (s)
-\end{verbatim}
-It should be noted that {\bf headersize}, {\bf datasize}, {\bf
-nsamples} and {\bf tobs} are not header variables {\it per se};
-they are derived by the program, based upon the file size and the real
-header variables.
-
-\clearpage
-\section{Looking at data using {\tt bandpass}, {\tt reader} and {\tt pgplotter}}
-\index{Programs!{\tt bandpass}}
-\label{looking}
-The {\tt bandpass} program is a simple utility to read incoming
-data and output a time-averaged bandpass:
-\input{bandpass.help}
-In its simplest form, {\tt bandpass} averages over the entire
-data file. The data for Fig.~\ref{0823band} were obtained using:
-\begin{verbatim}
-% filterbank B0823+26.pspm | bandpass > bandpass.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2.5)
-\put(1.2,3.2){\special{psfile=0823band.ps hscale=40 vscale=40 angle=270}}
-\end{picture}
-\caption{\sl Output data from {\tt bandpass} for the test
-observation of PSR B0823+26 using the PSPM.}
-\label{0823band}
-\end{figure}
-The ASCII data is written in a simple format with one line
-for each frequency channel: \verb+frequency if1 if2...+ for
-up to {\bf nifs} seperate IFs. The {\tt -d} and {\tt -t} 
-options allow averaging and output of the bandpass for a
-given number of dumps, or seconds. Each dump is encapsulated
-within \verb+#START+ and \verb+#STOP+ separators:
-\begin{verbatim}
-#START
-freq(1)      if(1) .... if(nifs)
- ...           .    ..    ...
-freq(nchans) if(1) .... if(nifs)
-#STOP
-\end{verbatim}
-where the \verb+freq(1)+ is the sky frequency of channel 1 in MHz and
-so on for all {\bf nchans} channels. Although plotting is left up to
-the users discretion in general, SIGPROC provides a little PGPLOT
-utility {\tt pgplotter} which plots data streams passed in this
-format. For example, try
-\begin{verbatim}
-% filterbank B0823+26.pspm | bandpass | pgplotter
-\end{verbatim}
-\index{Programs!{\tt pgplotter}}
-
-Another useful program is {\tt reader} which will
-print out filterbank-format data as an ASCII stream to the 
-standard output. 
-\input{reader.help}
-In the general case, a filterbank file with 
-{\bf nchans} channels and {\bf nifs} IFs, output is of the form:
-\begin{verbatim}
-% reader filterbankfile
-
-time(1) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-time(2) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-time(3) if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-\end{verbatim}
-the default case is to print out all IF and frequency channels.
-The output can be tailored by the {\tt -i} and {\tt -c} options
-to get just specific channels of interest. For example:
-\begin{verbatim}
-% filterbank B0823+26.pspm | reader -c 1 -c 2 -c 3 -c 4 | head
-
-0.000000 5.000000 5.000000 6.000000 5.000000 
-0.000080 7.000000 5.000000 7.000000 6.000000 
-0.000160 7.000000 5.000000 6.000000 6.000000 
-0.000240 5.000000 5.000000 5.000000 7.000000 
-0.000320 5.000000 4.000000 5.000000 6.000000 
-0.000400 5.000000 4.000000 5.000000 6.000000 
-0.000480 5.000000 5.000000 5.000000 6.000000 
-0.000560 5.000000 5.000000 6.000000 5.000000 
-0.000640 6.000000 4.000000 5.000000 7.000000 
-0.000720 6.000000 6.000000 6.000000 5.000000 
-\end{verbatim}
-shows just the first four frequency channels of the PSPM data
-as a function of time. The {\tt -numerate} switch will
-change this time stamp to an integer counter. Time or
-integer counters can be turned off completely via the
-{\tt -noindex} option. The {\tt -stream} option will,
-\index{Data formats!{\tt -stream}}
-as in the case of the continuous {\tt bandpass} output
-above, output a stream of numbers encapsulated by
-\verb+#START+ and \verb+#STOP+ separators. As before, this
-format may be passed to {\tt pgplotter} for plotting.
-\index{Programs!{\tt reader}}
-
-\section{Data reduction using {\tt decimate} and {\tt dedisperse}}
-\label{reduction}
-\index{Programs!{\tt decimate}}
-
-Adding of adjacent time and/or frequency channels 
-together to reduce the original resolution and size of the original
-data file is possible using the {\tt decimate} program:
-\input{decimate.help}
-Output data from {\tt decimate} is in standard filterbank format
-so that it can be easily read in by other SIGPROC programs.
-To get ASCII data, use the {\tt reader} program (see \S \ref{looking}).
-The following example adds all the frequency channels together,
-and every 32 time samples, to create the time series shown in
-Fig.~\ref{0823time}.
-\begin{verbatim}
-% filterbank B0823+26.pspm | decimate -t 32 -n 32 | reader > timeseries.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2.5)
-\put(1.2,3.2){\special{psfile=0823time.ps hscale=40 vscale=40 angle=270}}
-\end{picture}
-\caption{\sl Output time series from {\tt decimate} for the test
-observation of PSR B0823+26 using the PSPM.}
-\label{0823time}
-\end{figure}
-Note that we have used the {\tt -n} option to force the output
-number of bits per sample to be 32. By default {\tt decimate}
-outputs data with the same number of bits as the incoming filterbank
-data. In this case, where there are strong single pulses,
-adding all the channels together would result in a signal-to-noise
-loss when trying to write the output time series with 4-bit precision.
-
-While {\tt decimate} is a good means for getting time series of weakly
-dispersed pulsars, it does not take into account the effects of
-dispersion by the interstellar medium where pulses emitted at higher
-radio frequencies travel faster through the interstellar medium,
-arriving earlier than those emitted at lower frequencies.  The time
-delay $\Delta t$ between a high frequency $\nu_{\rm hi}$ relative to a
-lower on $\nu_{\rm lo}$ is \index{dedispersion}
-\begin{displaymath}
- \Delta t = 4.15 \times 10^6 \, \, {\rm ms} \, \,
- \times (\nu_{\rm lo}^{-2} - \nu_{\rm hi}^{-2})  
- \times {\rm DM},
-\end{displaymath}
-where the frequencies are in MHz and the dispersion measure 
-${\rm DM} = \int_{\rm 0}^{d} \,\, n_{\rm e} \,\, dl$
-(cm$^{-3}$ pc) is the integrated
-column density of free electrons along the line of sight.
-Here, $d$ is the distance to the pulsar (pc) and $n_{\rm e}$ is the
-free electron density (cm$^{-3}$). For distant high-DM pulsars,
-especially those with short periods, dispersion needs
-to be accounted for to retain full time resolution.  The {\tt
-dedisperse} program does this by adding frequency channels with the
-appropriate time delays given a DM value:
-\input{dedisperse.help}
-The dedispersion algorithm reads in a block of data and
-gets the appropriately delayed sample by looking forward in
-the array. This there requires that the frequency channels
-are passed down in descending frequency order and {\tt dedisperse}
-will complain if this condition is not met!
-\index{Programs!{\tt dedisperse}}
-
-In the example data for the 1.5578-ms pulsar B1937+21 shown in 
-Fig.~\ref{1937giant}, the left panel was produced via:
-\begin{verbatim}
-% filterbank B1937+21.539 | dedisperse -d 71.04 | reader > timeseries.ascii
-\end{verbatim}
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,2)
-\put(-0.1,2.4){\special{psfile=1937whole.ps hscale=33 vscale=33 angle=270}}
-\put(+3.7,2.2){\special{psfile=1937bands.ps hscale=28 vscale=28 angle=270}}
-\end{picture}
-\caption{\sl A WAPP observation of the millisecond pulsar B1937+21
-showing a single ``giant''pulse. Left: the dedispersed time series over the
-entire 100-MHz band. Right: the pulse seen in four dedispersed 25-MHz 
-subbands. The length of the time series segment is $\sim0.26$ s. 
-The sampling time is 63.32 $\mu$s.}
-\label{1937giant}
-\end{figure}
-This single pulse is shown in four dedispersed frequency subbands in
-the right-hand panel of Fig.~\ref{1937giant}. These were obtained
-by adding a {\tt -b 4} option into the dedisperse
-command-line in the above pipeline. In this case, dedispersion is
-carried out relative to the frequency of the first summed channel in
-each of the bands.
-
-\section{Getting pulse profiles using {\tt fold} and {\tt profile}}
-\label{folding}
-\index{Programs!{\tt fold}}
-
-Obtaining integrated pulse profiles, and single pulses, from your
-data files is possible using the {\tt fold} program which allows you
-to fold filterbank data modulo a pulse period to produce
-pulse profiles. In addition, there is now a basic ASCII viewing
-program {\tt profile} which displays profiles from {\tt fold} to the
-standard output. {\tt fold} accepts
-any number of IF and/or frequency channels, producing
-{\bf nifs} $\times$ {\bf nchans} sets of profiles. The folding
-algorithm used is a simple one: for each time sample, compute
-the phase based on a, possibly time-dependent, value of the
-pulse period and add that sample to the nearest phase bin of
-the appropriate profile. The synopsis of {\tt fold} is summarized below:
-\input{fold.help}
-
-\subsection*{Folding data at a fixed period} Consider folding a series containing
-our fake $\sim\pi$-ms pulsar:
-\begin{verbatim}
-% fake -period 3.14159 -nchans 1 -nbits 32 | fold -p 3.14159 > profile.ascii
-\end{verbatim}
-Note that the default profile output is in ASCII format. 
-\index{Data formats!{\tt -ascii}}
-This may be substituted by EPN or PSRFITS using the {\tt -epn} or
-{\tt -psrfits} options on the command line. The
-format of this output is a line for each bin:
-\begin{verbatim}
-bin_number if(1)c(1) if(1)c(2) .... if(1)c(nchans) ...... if(nifs)c(nchans)
-\end{verbatim}
-In order to avoid overflows during folding, {\tt fold} will by default
-subtract an offset from each folded sample calculated as the median
-value of a given data block. To turn off this feature, use the {\tt
--nobaseline} option.  The default number of bins is given by the next
-largest integer value to the ratio of the folding period divided by
-the sampling time. This is, however, completely flexible. A lower
-number of bins would be desirable, for example, when folding data for
-a faint pulsar or candidate.  {\tt fold} will permit oversampling
-\index{oversampling}
-which can pay dividends for high signal-to-noise observations of
-short-period pulsars.
-
-A useful feature of {\tt fold} for weak pulsars, and those for which the 
-pulse happens to lie on the edge of the window is the {\tt -m} option
-which allows the display of multiple pulses. For example, try:
-\begin{verbatim}
-% fake -period 3.14159 -nchans 1 -nbits 32 | fold -p 3.14159 -m 2 | pgplotter
-\end{verbatim}
-
-\subsection*{Folding data using polynomial coefficients} For practical
-applications, the apparent pulse period is time-variable during
-the integration due to Doppler shifts resulting from the Earth's
-motion and (for binary pulsars) from Doppler shifts induced by
-orbiting companions. To account for these the folding period 
-needs to be updated during the integration. The {\sc TEMPO}
-\index{Software Packages!{\sc TEMPO}}
-timing package can be used to create a set of polynomial coefficients
-to predict the change in period with time and {\tt fold} can
-read these ``polyco'' files from {\sc TEMPO} for these
-purposes. A script to run {\sc TEMPO} to produce these files
-is described in \S \ref{polyco}.
-To tell {\tt fold} to read a polyco file, supply
-the name of the filename with the {\tt -p} option.
-\begin{verbatim}
-% filterbank B0823+26.pspm | fold -p polyco.dat -n 128 -epn > B0823+26.epn
-\end{verbatim}
-will fold each channel of the sample PSPM data for PSR B0823+26 to
-produce 128-bin profiles written to the file {\tt B0823+26.epn} in
-EPN format. If no {\tt -p} option is given to {\tt fold} the program
-will look for the file {\tt polyco.dat} as a matter of course so
-that, in the above case, it was not strictly necessary to specify
-the name of the polyco file. This is assumed in the following pipeline
-where the data are first dedispersed at the reference DM value of
-19.4 cm$^{-3}$ pc before being passed to {\tt fold}:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19.4 -epn | fold > B0823+26.epn
-\end{verbatim}
-\index{polyco.dat}
-
-\subsection*{Getting sub-integrations} In the above examples,
-{\tt fold} produces one profile for each of {\bf nchans} $\times$ {\bf nifs}
-incoming data streams which corresponds to folding over the entire data 
-set. It is often desirable to look at sub-profiles dumped at regular
-intervals during the observation --- the {\tt -d} (dump) option allows you 
-to do this. Specifying a floating-point number, say $f$ seconds, in this 
-mode will output the accumulated profile every $f$ seconds.
-The following example on
-our fake millisecond pulsar data would dump a subintegration exactly
-every 15 seconds:
-\begin{verbatim}
-% fold fakepulsar.fil -d 15.0 -p 3.1415927 -epn > fakeprofiles.epn
-\end{verbatim}
-Supplying an integer argument with the {\tt -d} option, 
-say $n$, the profiles are dumped every $n$ pulses. So {\tt -d 15}
-in the above example
-results in a profile being dumped every 15 periods (about 47 ms).
-
-\subsection*{Single pulses and windowing profiles} Individual pulses
-\index{single pulses}
-can be obtained by specifying {\tt -d 1} to the {\tt fold}
-command line. The following example demonstrates this for the
-PSR B0823+26 PSPM data:
-\begin{verbatim}
-% filterbank B0823+26.pspm | dedisperse -d 19.4 | fold -d 1 -epn > B0823+26.epn
-\end{verbatim}
-The resulting EPN file contains a record for each single pulse.
-For this short data set, this amounts to just
-five single pulses shown in Fig.~\ref{0823sps}.
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,1.5)
-\put(-0.25,2){\special{psfile=nowindow.ps hscale=67 vscale=67 angle=270}}
-\put(-0.25,1){\special{psfile=window.ps   hscale=67 vscale=67 angle=270}}
-\end{picture}
-\caption{\sl Top: dedispersed single pulses for
-the PSPM test observation of PSR B0823+26. Bottom: the same data
-set after applying a phase window of 0.825 to 0.925 (see text)}
-\label{0823sps}
-\end{figure}
-
-For single-pulse applications, where the off-pulse region of the
-\index{pulse windowing}
-profile is usually not interesting, it is desirable to be able to set
-a window around the pulse. The {\tt fold} program allows setting of
-windows via the {\tt -l} and/or {\tt -r} command-line options which
-specify the left and right-hand phase values of the windows. 
-Phase values should be specified in turns ranging between 0.0
-and 1.0. For example, the pulses in the lower panel of Fig.~\ref{0823sps}
-were obtained using {\tt fold -l 0.825 -r 0.925} for the PSR B0823+26
-dataset. As before for the full profile, unless specified otherwise,
-{\tt fold} will choose the number of bins based on the size of
-the window divided by the sampling interval. 
-
-All of the above examples have used a seperate plotting program
-to produce the profiles for the figures. Since each user tends
-to have his/her favourite method for producing such plots, no
-facility exists within SIGPROC to to this. To get a quick look
-at profiles, there is now a program {\tt profile} which will
-display ASCII representations to the standard output. The program
-has two modes of operation: 2-D profile ``plots'' or 1-D grey-scale
-representations. To get a 2-D profile - the output from fold needs
-to come in the standard ASCII format. For example, let's create
-and fold data from a 1-s pulsar:
-\begin{verbatim}
-fake -period 1000.0 -nchans 1 | fold -p 1000.0 | profile
-\end{verbatim}
-The output from {\tt profile} would then be a mock 2-D profile
-and will look something like this:
-\begin{verbatim}
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ##                               
-                               ###                              
-                              ####                              
-                              ####                              
-                              ####                              
-   #                          ####                              
-####   #  # ##  #    #   # ## ##### #  ##  # # #     #### ### ##
-################################################################
-\end{verbatim}
-
-To get a 1-D pseudo ``grey-scale'' plot, the profiles need
-to be output from fold using the {\tt stream} option. This is
-particularly useful if you wish to display profiles as sub-integrations
-or folded frequency channels. For example, to display additions of
-every 2 pulses from our 1-s fake pulsar we would do the following:
-\begin{verbatim}
-fake -period 1000.0 -nchans 1 | fold -p 1000.0 -stream -d 2 -nobaseline| profile
-\end{verbatim}
-to produce the following output showing subintegration index and
-elapsed time to the left of each profile:
-\begin{verbatim}
-|0001|00:00:00|                              ,$#,                              |
-|0002|00:00:02|                               $#,                              |
-|0003|00:00:04|                              ,#$,                              |
-|0004|00:00:07|                              ,@#:                              |
-|0005|00:00:09|                               ##,                              |
-|0006|00:00:09|                               $#,                              |
-\end{verbatim}
-Where the {\tt -nobaseline} option during folding has been used to 
-preserve the original levels which would otherwise get changed each
-subintegration. Note also that the last ``subintegration'' in this
-plot is in fact the integrated profile which is dumped by {\tt fold}
-as a matter of course. Frequency channel plots can be produced in a 
-similar way. For example, try creating a 100-ms pulsar with 32 channels
-and a DM of 500 and piping this through {\tt fold} and {\tt profile}.
-\begin{verbatim}
-fake ..... | fold -p 100.0 -stream -nobaseline | profile -frequency
-\end{verbatim}
-where the {\tt -frequency} option will be required to label
-the frequency channels correctly.
-
-\section{Putting it all together: the {\tt quicklook} data reduction script}
-\label{quicklook}
-\index{Programs!{\tt quicklook}}
-As an application of most of the programs discussed in the preceding
-sections, we conclude with the {\tt quicklook} data analysis script
-which is designed to dedisperse and fold raw pulsar machine data taken
-on a known pulsar and produce a diagnostic output plot summarizing
-various aspects of the data:
-\input{quicklook.help}
-%Most of the above command-line options should be obvious given
-%the above explanation and the discussions of various aspects
-%of the preceding programs. 
-%{\tt quicklook} will try to construct
-%a source name based on the name of the raw datafile and generate
-%a polyco file. If it fails to do this, use the {\tt -psr} option
-%to specify the name of the pulsar required. The {\tt -mypolyco}
-%option will use a pre-existing {\tt polyco.dat} file to calculate
-%the period and get the dispersion measure. Alternatively it is
-%possible to process the data using a fixed period and dispersion
-%measure with the {\tt -period} and {\tt -dm} options. 
-As an example, the command:
-\begin{verbatim}
-% quicklook J1713+0747.744 -nbands 64 -nsints 32 -read 5
-\end{verbatim}
-reduces the first 5 seconds of a WAPP observation of the 
-millisecond pulsar J1713+0747 producing the plot shown in Fig.~\ref{1713}.
-N.B.~Use of this script assumes that you have the {\tt quickplot}
-program compiled (see \S \ref{install} for further details).
-
-\clearpage
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,6.8)
-\put(-0.1,-0.6){\special{psfile=J1713+0747.744.ps hscale=80 vscale=80}}
-\end{picture}
-\label{1713}
-\caption{\sl Sample output from the {\tt quicklook} script for the
-millisecond pulsar J1713+0747 observed by the WAPP. Top panel shows a
-1024-point average of the dedispersed time series which has been
-normalised (as far as possible) so that it has a zero mean and unit
-rms. Below this are two panels showing the dedispersed frequency
-sub-bands (which clearly show the dispersion of the pulsar) and time
-sub-integrations as a function of pulse phase. The bottom plot
-is the integrated pulse profile. The signal-to-noise rato of this
-profile is reported at the top of the plot along with essential header
-information.}
-\end{figure}
-\clearpage
-
-\section{Version history and plans for future work}
-\label{past/future}
-The file {\tt version.history} summarizes the work done
-on SIGPROC to date:
-\input{version.history}
-
-\noindent
-All suggestions for improvements, including (best of all!)
-offers to contribute write and/or improved routines for future 
-releases of the package are most welcome via email:
-{\tt drl@jb.man.ac.uk}.
-
-\section*{Acknowledgements}
-
-In putting together the SIGPROC package, I had the good fortune to
-work with a number of people who kindly donated existing routines or
-offered to write new ones.  Andy Dowd wrote the original version of
-what became the {\tt wapp2fb} routine for converting raw WAPP
-correlation values into spectra. Jeff Hagen also contributed to this
-effort and wrote the routines used for reading WAPP headers and byte
-swapping. Ingrid Stairs provided the \verb+pspm_decode+ routine --- a
-C-version of an original Fortran--77 subroutine written by Alex
-Wolsczcan. Ingrid also debugged {\tt dedisperse} so that it can handle
-WAPP timing-mode data.  Mike Keith and Ralph Eatough added the binary
-options to fake. Use was also made of some Numerical Recipes
-routines for FFTs and random number generation in {\tt fake}. Finally,
-many thanks to Jim Cordes, Maura Mclaughlin, Ramesh Bhat, Ingrid
-Stairs and Joanna Rankin
-for their help in putting together and debugging some of the
-routines, and their suggestions for functionality.
-
-\clearpage
-\appendix
-\section{Monitoring programs using the Tk {\tt monitor} widget}
-\label{monitoring}
-\index{Software Packages!Tcl/Tk}
-\index{monitoring programs}
-The SIGPROC programs run without any messages to the standard
-output. To keep track of their progress, a {\tt wish} script:
-{\tt monitor} can run in the background. 
-
-To start the {\tt monitor} script running, go to the directory
-where you are processing your files and type {\tt monitor}.
-For example, starting a filterbank command:
-\begin{verbatim}
-% filterbank J1713+0747.744 -sumifs > J1713+0747.744.fil
-\end{verbatim}
-will cause the following status bar to appear in the upper left-hand
-corner of the screen:
-
-\begin{figure}[hbt]
-\setlength{\unitlength}{1in}
-\begin{picture}(0,0.5)
-\put(0.4,-3.6){\special{psfile=monitor.ps hscale=70 vscale=70}}
-\end{picture}
-\end{figure}
-
-This counter will tick away updating as the file gets updated
-until the program is finished. If you have several jobs running,
-in a pipeline for example, several status bars will appear
-until their respective job is completed. To stop the monitor
-script at any time, type:
-\begin{verbatim}
-% monitor off
-\end{verbatim}
-Once the program
-is finished what it is doing, the monitor will go to sleep
-and wait for another SIGPROC program to start.
-
-Note that you will confuse the script if you have two
-programs running from the same directory (for example
-two {\tt filterbank} processes running on different
-raw datafiles) since the {\tt programname.monitor} file
-will get updated by both programs. For such applications,
-run the programs from separate directories.
-
-The {\tt monitor} script polls programs by looking at 
-logfiles which are written whenever the file {\tt monitor.running}
-exists in the working directory. If you prefer not to
-use {\tt monitor} but would like to look at these logfiles,
-simply create the file {\tt monitor.running} in your area
-\begin{verbatim}
-% touch monitor.running
-\end{verbatim}
-then run a SIGPROC program and {\tt tail} the resulting
-{\tt programname.monitor} file to keep track of what is
-going on. For example, while {\tt dedisperse} is running
-in a pipeline you would see the following:
-\begin{verbatim}
-% tail dedisperse.monitor
-input stdin status time:0.1s:DM:35.0pc/cc output stdout
-input stdin status time:0.2s:DM:35.0pc/cc output stdout
-\end{verbatim}
-To turn off this logging mode, simply delete the 
-{\tt monitor.running} file.
-
-\section{Running {\sc TEMPO} to generate polynomial coefficients}
-\label{polyco}
-\index{Software Packages!{\sc TEMPO}}
-\index{polyco.dat}
-If you have {\tt expect} in your path, you will also be able
-to take advantage of {\tt polyco} a simple script designed
-to take the pain out of running {\sc TEMPO} to generate 
-files containing polynomial coefficients for use by {\tt fold}.
-The synopsis of {\tt polyco} is as follows:
-\input{polyco.help}
-It is assumed that you have {\sc TEMPO} installed on your
-computer so that the {\tt tempo} executable file is in
-your path, and the {\tt TEMPO} environment variable set.
-At Arecibo, a solaris version of {\sc TEMPO} can be found
-in {\tt /home/pulsar/bin/tempo} and the {\tt TEMPO} 
-environment variable should be set to {\tt /home/pulsar/tempo11}.
-
-Running {\tt polyco} is then a matter of giving a pulsar name
-from the list of ephemeredes contained in \verb+$TEMPO/tztot.dat+
-and the start and stop MJD ranges over which you wish the 
-coefficients to apply. The default is to generate coefficients
-for use at the time you run {\sc TEMPO}.
-
-\section{The EPN data format}
-\label{epn}
-\index{Data formats!EPN}
-The {\bf E}uropean {\bf P}ulsar {\bf N}etwork (``{\bf EPN}'') is an
-association of European astrophysical research institutes that
-co--operate in the subject of pulsar research. The EPN format
-was developed for the exchange of pulse profiles between different
-groups of individuals to permit a free interchange of data.
-The following text was taken from a paper which originally
-appeared in Astronomy \& Astrophysics Supplement Series  (1998)
-{\bf 128} 541--544 and is included here for quick reference.
-
-Each EPN file consists of one or more blocks.  The basic structure
-of an EPN block is shown in Fig.~\ref{epnblock}.  
-Each file has a common fixed
-length {\it header} followed by a number of individual {\it data
-streams} of equal length. The header describes the data, containing
-information on the pulsar itself, the observing system used to make
-the observation as well as some free-form information about the
-processing history of the data. The onus is on the site--specific
-conversion process to ensure correct conversion to the standardized
-entries and reference to common catalogues (e.g.~the Taylor et al.~1993
-catalogue of pulsar
-parameters).  The full list of header variables is given in Tables 
-\ref{epnheader} and \ref{epnsubheader}.
-
-\begin{figure}[hbt]
-\small
-\begin{center}
-\begin{minipage}{3.8cm}
-\fbox{
- \parbox{3.5cm}{\begin{center} {\bf  Header } \\  480 Characters \end{center}} 
-      }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\   \end{center} } }
- \end{minipage}
-       }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\   \end{center} } }
- \end{minipage}
-       }
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf Sub-Header } \\ 160 Characters \end{center} }} 
-  \fbox{ \parbox{2.96cm}{\begin{center}  {\bf Data } \\  \end{center} } }
- \end{minipage}
-       } 
-\fbox{
- \begin{minipage}{3.5cm}
-  \fbox{ \parbox{3.1cm}{\begin{center} {\bf etc. ...}  \end{center} }} 
- \end{minipage}
-} 
-\end{minipage}
-\end{center}
-\caption{\sl Schematic representation of an EPN data block.}
-\label{epnblock}
-\end{figure}
-
-The data streams themselves may be outputs of different
-polarization channels, or individual channels (bands) of a filterbank
-or a combination thereof. In total, there may be $N_{\rm freq}$ data
-streams of i.e. different frequencies for each polarization.  Each
-data stream starts with a small, fixed length sub-header in front of
-the actual data values.  The number of data streams and their length may
-vary between different EPN files, but is constant within each file.  A
-character field and an ordinal number is provided for each stream for
-its identification. 
- 
-\begin{table}
-\begin{center}
-\footnotesize
-\begin{tabular}{|rcccp{8cm}|}
-\hline
-Position & Name & Format & Unit & Comment \\
-\hline 
-\hline
-1   &  version &  A8 & &  EPN + version of format (presently EPN05.00)\\
-9   &  counter &  I4 & &  No. of records contained in this data block\\
-13  &  history & A68  &  &comments and history of the data \\
-\hline
-81    & jname &  A12 & &  pulsar jname \\
-93   & name & A12 &  & common name              \\
-105   & $P_{\rm bar}$ &  F16.12 & s & current barycentric period\\
-121    & DM      &  F8.3   & pc cm$^{-3}$& dispersion measure\\
-129   & RM      &  F10.3  & rad m$^{-2}$ & rotation measure \\
-139  & CATREF &  A6   & & pulsar parameter catalogue in use \\
-145   & BIBREF    &  A8     & & bibliographical reference key (or observer's name) \\
-153   &         & 8X   &  &  blank space free for future expansion \\
-\hline
-161   & $\alpha_{2000}$  & I2,I2,F6.3 & hhmmss& right ascension of source \\
-171   & $\delta_{2000}$ & I3,I2,F6.3 & ddmmss& declination of source\\
-182  & telname   & A8  & & name of the observing telescope (site) \\
-190  & EPOCH  & F10.3 & day & modified Julian date of observation \\
-200  & OPOS   & F8.3  & degrees & position angle of telescope \\
-208  & PAFLAG & A1    &  &  A = absolute polarization position angle, else undefined\\
-209  & TIMFLAG & A1   &  &  A = absolute time stamps (UTC), else undefined \\
-210 &         & 31X   &  &  blank space free for future expansion \\
-\hline
-241  & $x_{\rm tel}$& F17.5& m & topocentric X rectangular position of telescope \\
-258  & $y_{\rm tel}$& F17.5& m & topocentric Y rectangular position of telescope \\
-275  & $z_{\rm tel}$& F17.5& m & topocentric Z rectangular position of telescope \\
-292 &         & 29X   &  &  blank space free for future expansion \\
-\hline
-321  & CDATE & I2,I2,I4 & d m y & creation/modification date of the dataset \\
-329  & SCANNO & I4 &  & sequence number of the observation \\
-333  & SUBSCAN & I4 &  &sub--sequence number of the observation \\
-337  & $N_{\rm pol}$ & I2 &  & number of polarizations observed \\ 
-339  & $N_{\rm freq}$ & I4 & & number of frequency bands per polarisation \\
-343  & $N_{\rm bin}$ & I4  & & number of phase bins per frequency (1-9999) \\
-347  & $t_{\rm bin}$ & F12.6 & $\mu$s & duration (sampling interval) of a phase bin \\
-359  & $t_{\rm res}$ & F12.6 & $\mu$s & temporal resolution of the data \\
-371  & $N_{\rm int}$ & I6  & & number of integrated pulses per block of data \\
-377  & $n_{\rm cal}$ & I4 & $t_{\rm bin}$ & bin number for start of calibration signal\\
-381  & $l_{\rm cal}$ & I4 & $t_{\rm bin}$ & length of calibration signal \\
-385  & FLUXFLAG      & A1 &    & F = data are flux calibrated in mJy, else undefined \\
-386  & & 15X  & & blank space free for future expansion \\
-\hline
-401 &         & 80X   &  &  blank space free for future expansion \\
-\hline
-\end{tabular}
-\normalsize
-\caption{\sl A description of the EPN format variables.}
-\label{epnheader}
-\end{center}
-\end{table}
-
-\begin{table}
-\begin{center}
-\footnotesize
-\begin{tabular}{|rcccp{8cm}|}
-\hline
-Position & Name & Format & Unit & Comment \\
-\hline 
-\hline
-481  & IDfield &  A8 & &  type of data stream (I,Q,U,V etc.) \\
-489  & $n_{\rm band}$& I4 & &  ordinal number of current stream  \\
-493  & $n_{\rm avg}$ & I4 & & number of streams averaged into the current one \\
-497  & $ f_0$ & F12.8 &  & effective centre sky frequency of this stream\\
-509  & $ U_f$ & A8 &  & unit of $f_0$ \\
-517  & $ \Delta f $&  F12.6 &  & effective band width \\
-529  & $ U_{\Delta} $&  A8 &  & unit of $\Delta f$\\
-537  & $ t_{\rm start} $ & F17.5 & $\mu$s& time of first phase bin w.r.t. EPOCH \\
-554  &               & 7X    &        & blank space free for future expansion\\
-\hline
-561  & SCALE  & E12.6 &  & scale factor for the data\\
-573  & OFFSET & E12.6 &  & offset to be added to the data \\
-585  & RMS    & E12.6 &  & rms for this data stream\\
-597   & $P_{\rm app}$ &  F16.12 & s & apparent period at time of first phase bin\\
-613  &     &  28X    &       & blank space free for future expansion\\
-\hline
-641 & Data(1)& I4 & & scaled data for first bin \\
-$ 4 (N_{\rm bin}-1)+641$& Data($N_{\rm bin}$) & I4 &  & 
-data for last bin of stream\\
-\hline 
-$640 + N_{\rm records}*80$& & & & end of first stream \\
-\hline
-\end{tabular}
-\normalsize
-\caption{\sl The sub-header variables within an EPN file}
-\label{epnsubheader}
-\end{center}
-\end{table}
-
-\subsection*{Format Compatible Software}
-
-To incorporate the capability to read and write data in this format
-within existing analysis software, a simple routine exists which can
-read and write data in this format. In addition, we have written some
-sample programs which can plot the data and display the header
-parameters.  The software are written in 
-{\it Fortran---77}\footnote{some simple C utilities are planned for
-a future version of SIGPROC} and have
-been packaged into a single UNIX tar file which is freely available
-via the {\it Internet} from 
-\verb+http://www.jb.man.ac.uk/~drl/download/epn.tar.gz+
-
-To uncompress and extract the contents of the tar file on a UNIX
-operating system, issue the commands:
-
-\begin{verbatim}
-% gunzip epnsoft.tar.gz
-% tar xvf epnsoft.tar
-\end{verbatim}
-
-\noindent
-The present package contains some sample data and two example programs ---
-{\tt plotepn} and {\tt viewepn} which plot and view EPN files respectively.
-The ASCII file {\bf 00README} in this packages gives further details of the 
-software and how to use it.
-
-\section{Barycentre correction using {\tt barycentre}}
-
-A simple utility \verb+barycentre+ exists to convert a time
-series or filterbank file to an equivalent frame which is
-at rest with respect to the solar system barycentre.
-The synposis of the program is
-\input{barycentre.help}
-
-By default, {\tt barycentre} runs {\tt TEMPO} to create a file
-{\tt polyco.bar} which it then uses to perform the correction.
-If you would prefer to supply a file to do this, create one in
-advance, call it {\tt polyco.bar} and use the {\tt -mypolyco} option. 
-
-%\section{Searching for pulsars using SEEK}
-%
-%The SEEK package searches for radio pulsars in noisy data sets.  So
-%far SEEK has found over 30 pulsars in a
-%number of projects with different telescopes and data acquisition
-%systems.  Since SEEK now operates on SIGPROC formatted data, the
-%entire package will shortly be merged into a future SIGPROC
-%release. Full documentation on this package will then be available
-%within this manual. The key programs are:
-%
-%\bigskip
-%\noindent {\tt find} - a program to look for periodic signals in noisy
-%time series.
-%
-%\smallskip
-%\noindent {\tt best} - report the best candidates from \verb+find+'s 
-%analysis
-%
-%\smallskip
-%\noindent {\tt hunt/accn} - scripts to search data 
-%using \verb+find+ over a range of DMs and trial accelerations.
-
-%\bigskip
-%\noindent
-%SEEK is currently available on the web at
-%\verb+http://www.jb.man.ac.uk/~drl/seek+.
-
-\section*{}
-\printindex
-\addcontentsline{toc}{section}{Index}
-
-\end{document}
diff --git a/filterbank-gmrt/single_ch.c b/filterbank-gmrt/single_ch.c
deleted file mode 100644
index b81c8db..0000000
--- a/filterbank-gmrt/single_ch.c
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
-  This routine applies a threshold test on a time series. Matched
-  boxcar filters are applied to the data, with different boxcar lengths,
-  and the threshold test is reapplied, in an effort to find broadened
-  pulses.
-
-  */
-
-#define MAXPULSE 81920 /* Maximum number of pulses allowed in each DM channel */
-
-#include "pulse.h"
-#include "stdio.h"
-#include "math.h"
-
-void decimation(ndata, data)
-int *ndata;
-float data[];
-{
-  int i;
-
-  for (i=0; i<*ndata; i+=2)
-    data[i/2] = data[i];
-
-  *ndata = *ndata/2 + *ndata%2;
-
-  return;
-}
-
-void single_ch(ndata, realdata, nsmax, thresh, ndm, scrdsk)
-int ndata, nsmax;
-char scrdsk[];
-float realdata[], thresh;
-{
-  int i, ns, npulse, npoints;
-  int ierr;
-  float sample_int,width_1,width_2;
-  FILE *fp; 
-  Pulsus pulse[MAXPULSE]; 
-
-  thresh_1d(ndata, realdata, 0, &npulse, pulse, thresh, scrdsk);
-  
-  /* fprintf(stderr,"%d pulses found in dm channel %d smoothing %d\n",npulse,ndm,ns); */
-
-  if ( npulse )
-    ierr = write_pulses(0, npulse, pulse, ndm, scrdsk);
-       /*    Note:  all errors are written out in write_pulses. */ 
-  /*
-    Now, start smoothing the data. */
-
-  npoints = ndata;
-  for (ns=1; ns<=nsmax; ns++)
-    {
-      smooth(&npoints, &realdata[0]);
-
-      thresh_1d(npoints, realdata, ns, &npulse, pulse, thresh, scrdsk);
-
-	/* fprintf(stderr,"%d pulses found in dm channel %d smoothing %d\n",npulse,ndm,ns); */
-
-      if ( npulse )
-        ierr = write_pulses(ns, npulse, pulse, ndm, scrdsk);
-           /* Note:  all errors are written out in write_pulses. */
-
-      npoints -= 1;
-      decimation(&npoints, &realdata[0]);
-      }
-
-  return;
-}
-
diff --git a/filterbank-gmrt/singlepulse.f b/filterbank-gmrt/singlepulse.f
deleted file mode 100644
index 62174f7..0000000
--- a/filterbank-gmrt/singlepulse.f
+++ /dev/null
@@ -1,349 +0,0 @@
-      subroutine singlepulse(llog,append,spthresh,ncandsmax,nsmax)
-
-      implicit none
-      include 'seek.inc'
-C
-C Variables for single-pulse search
-      logical append
-      integer done_pulse, pulse
-      integer loopsize,maxloopsize,lsd1,llog,npulses
-      parameter(maxloopsize=1048576)
-      real realdata(maxloopsize)
-      character best_pulses*132, hist_pulses*132, scrdisk*80
-
-c  initialize parameters for single-pulse search and write headerfile
-
-      best_pulses=filename(1:lst)//'.pls'
-      hist_pulses=filename(1:lst)//'.hst'
-
-      dmidx=0
-      if (append) dmidx=1
-      loopsize = ntim2/8
-      scrdisk='./'
-      lsd1=2
-      if (dmidx.eq.0) 
-     .write(llog,*) 'Searching for single pulses... (thresh=',spthresh,
-     .		     ', ncandsmax=',ncandsmax,', nsmax=',nsmax,')'
-
-c       Search for pulses in this DM file and write out to file best.tmp.
-
-	ntim2=ntim2-10./tsamp
-      done_pulse = pulse(realdata, spthresh, nsmax,
-     .     dmidx, ntim2, series, loopsize, scrdisk, lsd1)
-
-c       Find best smoothing index for each pulse and append pulses to file
-c       best_pulses.
-
-      call best_smoothing(ncandsmax, dmidx, refdm, ntim2,
-     .     best_pulses, hist_pulses, spthresh, nsmax, scrdisk,
-     .     npulses,tsamp)
-      write(llog,*) npulses, ' pulses found...'
-
-
-      return
-      end
- 	subroutine best_smoothing(ncandsmax, dmidx, dm, length,
-     .			           best_pulses, hist_pulses, thresh,
-     .			 	   nsmax, scrdsk1, npulses, tsamp)
-      implicit none
-
-c reads output file from pulse.c that is 
-c sorted according to time bin number.
-c For a given time bin, it finds the smoothing
-c that gives the largest s/n.
- 
-c program iterates nitmax times since it only looks at
-c pairs of events in each iteration
- 
-c jmc 9 May 1995
-
-      integer maxcands
-      parameter (maxcands = 2**21)
-
-      integer ndm, ns, timebin, ncandsmax, dmidx, npulses
-      real snr, mean, rms, dm
-      real*8 tsamp, time, width
-      integer ndm1, ns1, timebin1, npulse, n_to_print
-      real snr1, mean1, rms1, thresh
-
-      integer nsmax
-
-      integer length, power, lun
-      real rlength
-
-      integer best_dm(maxcands), best_ns(maxcands),
-     .	      best_time(maxcands), best_snr(maxcands)
-      integer itolerance, io_error, isamp
-      parameter (itolerance=16)
-      character*80 inline, inline1
-      character*132 scrdsk1
-      data inline/' '/, inline1/' '/
-
-      character *(*) best_pulses, hist_pulses
-
-      integer ind
-      logical latest
-
-      integer lnblnk			!fn to find line length
-      integer lunin, lunout
-
-      integer nit, nitmax
-      data nitmax/4/
-      integer l0,l1,l2,l3,l4,l5
-      npulses = 0
-
-
-c      lun=index(scrdsk1,' ')-1        ! MBy: for accomplishing modif done in
-      lun=index(scrdsk1,' ')-2         ! pulse.c of the string scrdsk1
-   
-      call glun(l0)
-      open(l0, file=scrdsk1(1:lun)//'/'//'best_tmp')
-
-      call glun(l1)
-      open(l1, file=scrdsk1(1:lun)//'/'//'best_tmp1')
-
-      call glun(l2)
-      open(l2, file=scrdsk1(1:lun)//'/'//'best_tmp2')
-
-      do nit = 1, nitmax
-
-       if(nit .eq. 1) then		!first time, use orig data file
-          lunin = l0
-          lunout = l1
-       else
-          if(mod(nit,2) .eq. 0) then    !other iterations: flip flop 
-             lunin = l1
-             lunout = l2
-          else
-             lunin = l2
-             lunout = l1
-          endif
-       endif
-
-       rewind(lunin)
-       rewind(lunout)
-       read(lunin, "(a80)",end=1000) inline
-       ind = lnblnk(inline)-1
-
-    1 continue
-      read(inline, *)  
-     .   ndm, ns, timebin, snr, mean, rms
-      read(lunin, "(a80)",end=998) inline1
-      latest = .false.
-      read(inline1, *) 
-     .   ndm1, ns1, timebin1, snr1, mean1, rms1
-      if(abs(timebin1-timebin).le.itolerance) then 
-           latest = .true.		!the better of the pair is written 
-           if(snr1 .gt. snr) then 
-             ind = lnblnk(inline1)
-             write(lunout,*) inline1(1:ind)
-           else
-             ind = lnblnk(inline)
-             write(lunout,*) inline(1:ind)
-           endif
-           read(lunin, "(a80)",end=999) inline
-           latest = .false.
-      else
-           ind = lnblnk(inline)
-           write(lunout,*) inline(1:ind)
-      inline = inline1
-      endif
-      go to 1
-
-c always save last line
-
-  998 continue
-      ind = lnblnk(inline)
-      write(lunout,*) inline(1:ind)
-
-  999 continue 
-
-      enddo
-
-      lunin = lunout
-      rewind(lunin)
-    2 continue
-      read(lunin,"(a80)", end=9999) inline
-      ind = lnblnk(inline)
-
-      read (inline(1:ind),*) ndm1, ns1, timebin1, snr1, mean1, rms1
-      if (timebin1.lt.length-10000) then
-      npulses = npulses + 1
-      best_dm(npulses) = ndm1
-      best_ns(npulses) = ns1
-      best_time(npulses) = timebin1
-      best_snr(npulses) = snr1*100
-      end if
-
-      go to 2
- 9999 continue
-       
- 1000	close(l0)
-	close(l1)
-	close(l2)
-
-	if (npulses.gt.0) then
-
-	call sort3(npulses,best_snr,best_time,best_ns)
-
-        if (dmidx.eq.1) then
-	   call glun(l3)
-           open(l3, file=best_pulses,access='append')
-        else
-	   call glun(l3)
-           open(l3, file=best_pulses)
-        end if
-
-	if (dmidx.eq.1) then
-	   call glun(l4)
-	   open (l4, file=hist_pulses,access='append')
-	else
-	   call glun(l4)
-	   open (l4, file=hist_pulses)
-	end if
-	
-	if (ncandsmax.gt.npulses) then 
- 	   n_to_print = npulses
-	else
-	   n_to_print = ncandsmax
-	end if
-
-        rlength = length
-        power = log(rlength)/log(2.) + 0.5
-
-	isamp = tsamp/1.e-6
-	if (dmidx.eq.0) 
-     .	write (l3,100) isamp,thresh,nsmax,ncandsmax
-	do npulse = npulses,npulses-n_to_print+1,-1
-	   write (l3,200) dm, best_ns(npulse),best_time(npulse),best_snr(npulse)/100.,power
-	end do
-
-	write (l4,300) dm, npulses
-	close (l3)
-	close (l4)
-
- 100	format('tsamp=',i4,' us, thresh= ',f4.1,' sigma, nsmax=',i3,', ncandsmax=',i8)
- 200	format(f7.1,3x,i2,3x,i10,3x,f7.2,3x,i2)
- 300	format(f7.1,3x,i8)
-	else 
-	   n_to_print = 0
-	end if
-	call system('rm best_tmp best_tmp1 best_tmp2')
-
-  	 end
-      SUBROUTINE sort3(n,arr,brr,crr)
-      INTEGER n,M,NSTACK
-      INTEGER arr(n),brr(n),crr(n) !changed fron REAL (MBy 01/11/01)
-      PARAMETER (M=7,NSTACK=50)
-      INTEGER i,ir,j,jstack,k,l,istack(NSTACK)
-      REAL a,b,c,temp
-      jstack=0
-      l=1
-      ir=n
-1     if(ir-l.lt.M)then
-        do 12 j=l+1,ir
-          a=arr(j)
-          b=brr(j)
-	  c=crr(j)
-          do 11 i=j-1,1,-1
-            if(arr(i).le.a)goto 2
-            arr(i+1)=arr(i)
-            brr(i+1)=brr(i)
-	    crr(i+1)=crr(i)
-11        continue
-          i=0
-2         arr(i+1)=a
-          brr(i+1)=b
-	  crr(i+1)=c
-12      continue
-        if(jstack.eq.0)return
-        ir=istack(jstack)
-        l=istack(jstack-1)
-        jstack=jstack-2
-      else
-        k=(l+ir)/2
-        temp=arr(k)
-        arr(k)=arr(l+1)
-        arr(l+1)=temp
-        temp=brr(k)
-        brr(k)=brr(l+1)
-        brr(l+1)=temp
-	temp=crr(k)
-	crr(k)=crr(l+1)
-	crr(l+1)=temp
-        if(arr(l+1).gt.arr(ir))then
-          temp=arr(l+1)
-          arr(l+1)=arr(ir)
-          arr(ir)=temp
-          temp=brr(l+1)
-          brr(l+1)=brr(ir)
-          brr(ir)=temp
-	  temp=crr(l+1)
-	  crr(l+1)=crr(ir)
-	  crr(ir)=temp
-        endif
-        if(arr(l).gt.arr(ir))then
-          temp=arr(l)
-          arr(l)=arr(ir)
-          arr(ir)=temp
-          temp=brr(l)
-          brr(l)=brr(ir)
-          brr(ir)=temp
-	  temp=crr(l)
-	  crr(l)=crr(ir)
-	  crr(ir)=temp
-        endif
-        if(arr(l+1).gt.arr(l))then
-          temp=arr(l+1)
-          arr(l+1)=arr(l)
-          arr(l)=temp
-          temp=brr(l+1)
-          brr(l+1)=brr(l)
-          brr(l)=temp
-	  temp=crr(l+1)
-	  crr(l+1)=crr(l)
-	  crr(l)=temp
-        endif
-        i=l+1
-        j=ir
-        a=arr(l)
-        b=brr(l)
-	c=crr(l)
-3       continue
-          i=i+1
-        if(arr(i).lt.a)goto 3
-4       continue
-          j=j-1
-        if(arr(j).gt.a)goto 4
-        if(j.lt.i)goto 5
-        temp=arr(i)
-        arr(i)=arr(j)
-        arr(j)=temp
-        temp=brr(i)
-        brr(i)=brr(j)
-        brr(j)=temp
-	temp=crr(i)
-	crr(i)=crr(j)
-	crr(j)=temp
-        goto 3
-5       arr(l)=arr(j)
-        arr(j)=a
-        brr(l)=brr(j)
-        brr(j)=b
-	crr(l)=crr(j)
-	crr(j)=c
-        jstack=jstack+2
-        if(jstack.gt.NSTACK)pause 'NSTACK too small in sort2'
-        if(ir-i+1.ge.j-l)then
-          istack(jstack)=ir
-          istack(jstack-1)=i
-          ir=j-1
-        else
-          istack(jstack)=j-1
-          istack(jstack-1)=l
-          l=i
-        endif
-      endif
-      goto 1
-      END
-C  (C) Copr. 1986-92 Numerical Recipes Software 0!5,.
diff --git a/filterbank-gmrt/sizeof_file.c b/filterbank-gmrt/sizeof_file.c
deleted file mode 100644
index e7110ad..0000000
--- a/filterbank-gmrt/sizeof_file.c
+++ /dev/null
@@ -1,22 +0,0 @@
-/*  ======================================================================  */
-/*                                                                          */
-/*  This is to find the size of the file by name "name". The out put is     */
-/*  in terms of bytes.       R. Ramachandran, 30-juli-97, nfra.             */
-/*                                                                          */
-/*  ======================================================================  */
-#include <stdio.h>
-#include <math.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-
-long long sizeof_file(char name[]) /* includefile */
-{
-     struct stat stbuf;
-
-     if(stat(name,&stbuf) == -1)
-     {
-          fprintf(stderr, "f_siz: can't access %s\n",name);
-          exit(0);
-     }
-     return(stbuf.st_size);
-}
diff --git a/filterbank-gmrt/slalib.c b/filterbank-gmrt/slalib.c
deleted file mode 100644
index 070f3dd..0000000
--- a/filterbank-gmrt/slalib.c
+++ /dev/null
@@ -1,393 +0,0 @@
-#include "slalib.h"
-#include "slamac.h"
-double slaDranrm ( double angle ) /*includefile*/
-/*
-**  - - - - - - - - - -
-**   s l a D r a n r m
-**  - - - - - - - - - -
-**
-**  Normalize angle into range 0-2 pi.
-**
-**  (double precision)
-**
-**  Given:
-**     angle     double      the angle in radians
-**
-**  The result is angle expressed in the range 0-2 pi (double).
-**
-**  Defined in slamac.h:  D2PI, dmod
-**
-**  Last revision:   19 March 1996
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   double w;
-
-   w = dmod ( angle, D2PI );
-   return ( w >= 0.0 ) ? w : w + D2PI;
-}
-double slaGmst ( double ut1 ) /*includefile*/
-/*
-**  - - - - - - - -
-**   s l a G m s t
-**  - - - - - - - -
-**
-**  Conversion from Universal Time to Sidereal Time.
-**
-**  (double precision)
-**
-**  Given:
-**    ut1    double     Universal Time (strictly UT1) expressed as
-**                      Modified Julian Date (JD-2400000.5)
-**
-**  The result is the Greenwich Mean Sidereal Time (double
-**  precision, radians).
-**
-**  The IAU 1982 expression (see page S15 of the 1984 Astronomical
-**  Almanac) is used, but rearranged to reduce rounding errors.
-**  This expression is always described as giving the GMST at
-**  0 hours UT.  In fact, it gives the difference between the
-**  GMST and the UT, which happens to equal the GMST (modulo
-**  24 hours) at 0 hours UT each day.  In this routine, the
-**  entire UT is used directly as the argument for the
-**  standard formula, and the fractional part of the UT is
-**  added separately;  note that the factor 1.0027379... does
-**  not appear.
-**
-**  See also the routine slaGmsta, which delivers better numerical
-**  precision by accepting the UT date and time as separate arguments.
-**
-**  Called:  slaDranrm
-**
-**  Defined in slamac.h:  D2PI, DS2R, dmod
-**
-**  Last revision:   19 March 1996
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   double tu;
-
-/* Julian centuries from fundamental epoch J2000 to this UT */
-   tu = ( ut1 - 51544.5 ) / 36525.0;
-
-/* GMST at this UT */
-   return slaDranrm ( dmod ( ut1, 1.0 ) * D2PI +
-                       ( 24110.54841 +
-                       ( 8640184.812866 +
-                       ( 0.093104 - 6.2e-6 * tu ) * tu ) * tu ) * DS2R );
-}
-void slaCaldj ( int iy, int im, int id, double *djm, int *j ) /*includefile*/
-/*
-**  - - - - - - - - -
-**   s l a C a l d j
-**  - - - - - - - - -
-**
-**  Gregorian calendar to Modified Julian Date.
-**
-**  (Includes century default feature:  use slaCldj for years
-**   before 100AD.)
-**
-**  Given:
-**     iy,im,id   int      year, month, day in Gregorian calendar
-**
-**  Returned:
-**     *djm       double   Modified Julian Date (JD-2400000.5) for 0 hrs
-**     *j         int      status:
-**                           0 = ok
-**                           1 = bad year   (MJD not computed)
-**                           2 = bad month  (MJD not computed)
-**                           3 = bad day    (MJD computed)
-**
-**  Acceptable years are 00-49, interpreted as 2000-2049,
-**                       50-99,     "       "  1950-1999,
-**                       100 upwards, interpreted literally.
-**
-**  Called:  slaCldj
-**
-**  Last revision:   21 October 1993
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   int ny;
-
-/* Default century if appropriate */
-   if ( ( iy >= 0 ) && ( iy <= 49 ) )
-      ny = iy + 2000;
-   else if ( ( iy >= 50 ) && ( iy <= 99 ) )
-      ny = iy + 1900;
-   else
-      ny = iy;
-
-/* Modified Julian Date */
-   slaCldj ( ny, im, id, djm, j );
-}
-
-void slaCalyd(int iy, int im, int id, int *ny, int *nd, int *j )/*includefile*/
-/*
-**  - - - - - - - - -
-**   s l a C a l y d
-**  - - - - - - - - -
-**
-**  Gregorian calendar date to year and day in year (in a Julian
-**  calendar aligned to the 20th/21st century Gregorian calendar).
-**
-**  (Includes century default feature:  use slaClyd for years
-**   before 100AD.)
-**
-**  Given:
-**     iy,im,id   int    year, month, day in Gregorian calendar
-**                       (year may optionally omit the century)
-**  Returned:
-**     *ny        int    year (re-aligned Julian calendar)
-**     *nd        int    day in year (1 = January 1st)
-**     *j         int    status:
-**                         0 = OK
-**                         1 = bad year (before -4711)
-**                         2 = bad month
-**                         3 = bad day (but conversion performed)
-**
-**  Notes:
-**
-**  1  This routine exists to support the low-precision routines
-**     slaEarth, slaMoon and slaEcor.
-**
-**  2  Between 1900 March 1 and 2100 February 28 it returns answers
-**     which are consistent with the ordinary Gregorian calendar.
-**     Outside this range there will be a discrepancy which increases
-**     by one day for every non-leap century year.
-**
-**  3  Years in the range 50-99 are interpreted as 1950-1999, and
-**     years in the range 00-49 are interpreted as 2000-2049.
-**
-**  Called:  slaClyd
-**
-**  Last revision:   22 September 1995
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   int i;
-
-/* Default century if appropriate */
-   if ( ( iy >= 0 ) && ( iy <= 49 ) )
-      i = iy + 2000;
-   else if ( ( iy >= 50 ) && ( iy <= 99 ) )
-      i = iy + 1900;
-   else
-      i = iy;
-
-/* Perform the conversion */
-   slaClyd ( i, im, id, ny, nd, j );
-}
-void slaDjcal ( int ndp, double djm, int iymdf[4], int *j ) /*includefile*/
-/*
-**  - - - - - - - - -
-**   s l a D j c a l
-**  - - - - - - - - -
-**
-**  Modified Julian Date to Gregorian calendar, expressed
-**  in a form convenient for formatting messages (namely
-**  rounded to a specified precision, and with the fields
-**  stored in a single array).
-**
-**  Given:
-**     ndp      int       number of decimal places of days in fraction
-**     djm      double    Modified Julian Date (JD-2400000.5)
-**
-**  Returned:
-**     iymdf    int[4]    year, month, day, fraction in Gregorian calendar
-**     *j       int       status:  nonzero = out of range
-**
-**  Any date after 4701BC March 1 is accepted.
-**
-**  Large ndp values risk internal overflows.  It is typically safe
-**  to use up to ndp=4.
-**
-**  The algorithm is derived from that of Hatcher 1984 (QJRAS 25, 53-55).
-**
-**  Defined in slamac.h:  dmod
-**
-**  Last revision:   17 August 1999
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   double fd, df, f, d;
-   long jd, n4, nd10;
-
-/* Validate */
-   if ( ( djm <= -2395520.0 ) || ( djm >= 1.0e9 ) ) {
-      *j = - 1;
-      return;
-   } else {
-
-   /* Denominator of fraction */
-      fd = pow ( 10.0, (double) gmax ( ndp, 0 ) );
-      fd = dnint ( fd );
-
-   /* Round date and express in units of fraction */
-      df = djm * fd;
-      df = dnint ( df );
-
-   /* Separate day and fraction */
-      f = dmod ( df, fd );
-      if ( f < 0.0 ) f += fd;
-      d = ( df - f ) / fd;
-
-   /* Express day in Gregorian calendar */
-      jd = (long) dnint ( d ) + 2400001L;
-      n4 = 4L * ( jd + ( ( 2L * ( ( 4L * jd - 17918L ) / 146097L)
-                                       * 3L ) / 4L + 1L ) / 2L - 37L );
-      nd10 = 10L * ( ( ( n4 - 237L ) % 1461L ) / 4L ) + 5L;
-      iymdf[0] = (int) ( ( n4 / 1461L ) - 4712L );
-      iymdf[1] = (int) ( ( ( nd10 / 306L + 2L ) % 12L ) + 1L );
-      iymdf[2] = (int) ( ( nd10 % 306L ) / 10L + 1L );
-      iymdf[3] = (int) dnint ( f );
-      *j = 0;
-   }
-}
-void slaCldj ( int iy, int im, int id, double *djm, int *j ) /*includefile*/
-/*
-**  - - - - - - - -
-**   s l a C l d j
-**  - - - - - - - -
-**
-**  Gregorian calendar to Modified Julian Date.
-**
-**  Given:
-**     iy,im,id     int    year, month, day in Gregorian calendar
-**
-**  Returned:
-**     *djm         double Modified Julian Date (JD-2400000.5) for 0 hrs
-**     *j           int    status:
-**                           0 = OK
-**                           1 = bad year   (MJD not computed)
-**                           2 = bad month  (MJD not computed)
-**                           3 = bad day    (MJD computed)
-**
-**  The year must be -4699 (i.e. 4700BC) or later.
-**
-**  The algorithm is derived from that of Hatcher 1984 (QJRAS 25, 53-55).
-**
-**  Last revision:   29 August 1994
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   long iyL, imL;
-
-/* Month lengths in days */
-   static int mtab[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-
-
-/* Validate year */
-   if ( iy < -4699 ) { *j = 1; return; }
-
-/* Validate month */
-   if ( ( im < 1 ) || ( im > 12 ) ) { *j = 2; return; }
-
-/* Allow for leap year */
-   mtab[1] = ( ( ( iy % 4 ) == 0 ) &&
-             ( ( ( iy % 100 ) != 0 ) || ( ( iy % 400 ) == 0 ) ) ) ?
-             29 : 28;
-
-/* Validate day */
-   *j = ( id < 1 || id > mtab[im-1] ) ? 3 : 0;
-
-/* Lengthen year and month numbers to avoid overflow */
-   iyL = (long) iy;
-   imL = (long) im;
-
-/* Perform the conversion */
-   *djm = (double)
-        ( ( 1461L * ( iyL - ( 12L - imL ) / 10L + 4712L ) ) / 4L
-        + ( 306L * ( ( imL + 9L ) % 12L ) + 5L ) / 10L
-        - ( 3L * ( ( iyL - ( 12L - imL ) / 10L + 4900L ) / 100L ) ) / 4L
-        + (long) id - 2399904L );
-}
-void slaClyd(int iy, int im, int id, int *ny, int *nd,int*jstat)/*uncludefile*/
-/*
-**  - - - - - - - -
-**   s l a C l y d
-**  - - - - - - - -
-**
-**  Gregorian calendar to year and day in year (in a Julian calendar
-**  aligned to the 20th/21st century Gregorian calendar).
-**
-**  Given:
-**     iy,im,id     int    year, month, day in Gregorian calendar
-**
-**  Returned:
-**     ny          int    year (re-aligned Julian calendar)
-**     nd          int    day in year (1 = January 1st)
-**     jstat       int    status:
-**                          0 = OK
-**                          1 = bad year (before -4711)
-**                          2 = bad month
-**                          3 = bad day (but conversion performed)
-**
-**  Notes:
-**
-**  1  This routine exists to support the low-precision routines
-**     slaEarth, slaMoon and slaEcor.
-**
-**  2  Between 1900 March 1 and 2100 February 28 it returns answers
-**     which are consistent with the ordinary Gregorian calendar.
-**     Outside this range there will be a discrepancy which increases
-**     by one day for every non-leap century year.
-**
-**  3  The essence of the algorithm is first to express the Gregorian
-**     date as a Julian Day Number and then to convert this back to
-**     a Julian calendar date, with day-in-year instead of month and
-**     day.  See 12.92-1 and 12.95-1 in the reference.
-**
-**  Reference:  Explanatory Supplement to the Astronomical Almanac,
-**              ed P.K.Seidelmann, University Science Books (1992),
-**              p604-606.
-**
-**  Last revision:   26 November 1994
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-{
-   long i, j, k, l, n, iyL, imL;
-
-/* Month lengths in days */
-   static int mtab[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
-
-
-
-/* Validate year */
-   if ( iy < -4711 ) { *jstat = 1; return; }
-
-/* Validate month */
-   if ( ( im < 1 ) || ( im > 12 ) ) { *jstat = 2; return; }
-
-/* Allow for (Gregorian) leap year */
-   mtab[1] = ( ( ( iy % 4 ) == 0 ) &&
-             ( ( ( iy % 100 ) != 0 ) || ( ( iy % 400 ) == 0 ) ) ) ?
-             29 : 28;
-
-/* Validate day */
-   *jstat = ( id < 1 || id > mtab[im-1] ) ? 3 : 0;
-
-/* Perform the conversion */
-   iyL = (long) iy;
-   imL = (long) im;
-   i = ( 14 - imL ) /12L;
-   k = iyL - i;
-   j = ( 1461L * ( k + 4800L ) ) / 4L
-     + ( 367L * ( imL - 2L + 12L * i ) ) / 12L
-     - ( 3L * ( ( k + 4900L ) / 100L ) ) / 4L + (long) id - 30660L;
-   k = ( j - 1L ) / 1461L;
-   l = j - 1461L * k;
-   n = ( l - 1L ) / 365L - l / 1461L;
-   j = ( ( 80L * ( l - 365L * n + 30L ) ) / 2447L ) / 11L;
-   i = n + j;
-   *nd = 59 + (int) ( l -365L * i + ( ( 4L - n ) / 4L ) * ( 1L - j ) );
-   *ny = (int) ( 4L * k + i ) - 4716;
-}
diff --git a/filterbank-gmrt/slalib.h b/filterbank-gmrt/slalib.h
deleted file mode 100644
index 07bc0a6..0000000
--- a/filterbank-gmrt/slalib.h
+++ /dev/null
@@ -1,487 +0,0 @@
-#ifndef SLALIBHDEF
-#define SLALIBHDEF
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <math.h>
-
-/*
-**  - - - - - - - - -
-**   s l a l i b . h
-**  - - - - - - - - -
-**
-**  Prototype function declarations for slalib library.
-**
-**  Last revision:   27 January 2000
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-
-void slaAddet ( double rm, double dm, double eq, double *rc, double *dc );
-
-void slaAfin ( char *string, int *iptr, float *a, int *j );
-
-double slaAirmas ( double zd );
-
-void slaAltaz ( double ha, double dec, double phi,
-                double *az, double *azd, double *azdd,
-                double *el, double *eld, double *eldd,
-                double *pa, double *pad, double *padd );
-
-void slaAmp ( double ra, double da, double date, double eq,
-              double *rm, double *dm );
-
-void slaAmpqk ( double ra, double da, double amprms[21],
-                double *rm, double *dm );
-
-void slaAop ( double rap, double dap, double date, double dut,
-              double elongm, double phim, double hm, double xp,
-              double yp, double tdk, double pmb, double rh,
-              double wl, double tlr,
-              double *aob, double *zob, double *hob,
-              double *dob, double *rob );
-
-void slaAoppa ( double date, double dut, double elongm, double phim,
-                double hm, double xp, double yp, double tdk, double pmb,
-                double rh, double wl, double tlr, double aoprms[14] );
-
-void slaAoppat ( double date, double aoprms[14] );
-
-void slaAopqk ( double rap, double dap, double aoprms[14],
-                double *aob, double *zob, double *hob,
-                double *dob, double *rob );
-
-void slaAtmdsp ( double tdk, double pmb, double rh, double wl1,
-                 double a1, double b1, double wl2, double *a2, double *b2 );
-
-void slaAv2m ( float axvec[3], float rmat[3][3] );
-
-float slaBear ( float a1, float b1, float a2, float b2 );
-
-void slaCaf2r ( int ideg, int iamin, float asec, float *rad, int *j );
-
-void slaCaldj ( int iy, int im, int id, double *djm, int *j );
-
-void slaCalyd ( int iy, int im, int id, int *ny, int *nd, int *j );
-
-void slaCc2s ( float v[3], float *a, float *b );
-
-void slaCc62s ( float v[6], float *a, float *b, float *r,
-                float *ad, float *bd, float *rd );
-
-void slaCd2tf ( int ndp, float days, char *sign, int ihmsf[4] );
-
-void slaCldj ( int iy, int im, int id, double *djm, int *j );
-
-void slaClyd ( int iy, int im, int id, int *ny, int *nd, int *jstat );
-
-void slaCombn ( int nsel, int ncand, int list[], int *j );
-
-void slaCr2af ( int ndp, float angle, char *sign, int idmsf[4] );
-
-void slaCr2tf ( int ndp, float angle, char *sign, int ihmsf[4] );
-
-void slaCs2c ( float a, float b, float v[3] );
-
-void slaCs2c6 ( float a, float b, float r, float ad,
-                float bd, float rd, float v[6] );
-
-void slaCtf2d ( int ihour, int imin, float sec, float *days, int *j );
-
-void slaCtf2r ( int ihour, int imin, float sec, float *rad, int *j );
-
-void slaDaf2r ( int ideg, int iamin, double asec, double *rad, int *j );
-
-void slaDafin ( char *string, int *iptr, double *a, int *j );
-
-double slaDat ( double dju );
-
-void slaDav2m ( double axvec[3], double rmat[3][3] );
-
-double slaDbear ( double a1, double b1, double a2, double b2 );
-
-void slaDbjin ( char *string, int *nstrt,
-                double *dreslt, int *jf1, int *jf2 );
-
-void slaDc62s ( double v[6], double *a, double *b, double *r,
-                double *ad, double *bd, double *rd );
-
-void slaDcc2s ( double v[3], double *a, double *b );
-
-void slaDcmpf ( double coeffs[6], double *xz, double *yz, double *xs,
-                double *ys, double *perp, double *orient );
-
-void slaDcs2c ( double a, double b, double v[3] );
-
-void slaDd2tf ( int ndp, double days, char *sign, int ihmsf[4] );
-
-void slaDe2h ( double ha, double dec, double phi,
-               double *az, double *el );
-
-void slaDeuler ( char *order, double phi, double theta, double psi,
-                 double rmat[3][3] );
-
-void slaDfltin ( char *string, int *nstrt, double *dreslt, int *jflag );
-
-void slaDh2e ( double az, double el, double phi, double *ha, double *dec);
-
-void slaDimxv ( double dm[3][3], double va[3], double vb[3] );
-
-void slaDjcal ( int ndp, double djm, int iymdf[4], int *j );
-
-void slaDjcl ( double djm, int *iy, int *im, int *id, double *fd, int *j );
-
-void slaDm2av ( double rmat[3][3], double axvec[3] );
-
-void slaDmat ( int n, double *a, double *y, double *d, int *jf, int *iw );
-
-void slaDmoon ( double date, double pv[6] );
-
-void slaDmxm ( double a[3][3], double b[3][3], double c[3][3] );
-
-void slaDmxv ( double dm[3][3], double va[3], double vb[3] );
-
-double slaDpav ( double v1[3], double v2[3] );
-
-void slaDr2af ( int ndp, double angle, char *sign, int idmsf[4] );
-
-void slaDr2tf ( int ndp, double angle, char *sign, int ihmsf[4] );
-
-double slaDrange ( double angle );
-
-double slaDranrm ( double angle );
-
-void slaDs2c6 ( double a, double b, double r, double ad, double bd,
-                double rd, double v[6] );
-
-void slaDs2tp ( double ra, double dec, double raz, double decz,
-                double *xi, double *eta, int *j );
-
-double slaDsep ( double a1, double b1, double a2, double b2 );
-
-double slaDt ( double epoch );
-
-void slaDtf2d ( int ihour, int imin, double sec, double *days, int *j );
-
-void slaDtf2r ( int ihour, int imin, double sec, double *rad, int *j );
-
-void slaDtp2s ( double xi, double eta, double raz, double decz,
-                double *ra, double *dec );
-
-void slaDtp2v ( double xi, double eta, double v0[3], double v[3] );
-
-void slaDtps2c ( double xi, double eta, double ra, double dec,
-                 double *raz1, double *decz1,
-                 double *raz2, double *decz2, int *n );
-
-void slaDtpv2c ( double xi, double eta, double v[3],
-                 double v01[3], double v02[3], int *n );
-
-double slaDtt ( double dju );
-
-void slaDv2tp ( double v[3], double v0[3], double *xi, double *eta, int *j );
-
-double slaDvdv ( double va[3], double vb[3] );
-
-void slaDvn ( double v[3], double uv[3], double *vm );
-
-void slaDvxv ( double va[3], double vb[3], double vc[3] );
-
-void slaE2h ( float ha, float dec, float phi, float *az, float *el );
-
-void slaEarth ( int iy, int id, float fd, float posvel[6] );
-
-void slaEcleq ( double dl, double db, double date, double *dr, double *dd );
-
-void slaEcmat ( double date, double rmat[3][3] );
-
-void slaEcor ( float rm, float dm, int iy, int id, float fd,
-               float *rv, float *tl );
-
-void slaEg50 ( double dr, double dd, double *dl, double *db );
-
-void slaEl2ue ( double date, int jform, double epoch, double orbinc,
-                double anode, double perih, double aorq, double e,
-                double aorl, double dm, double u[], int *jstat );
-
-double slaEpb ( double date );
-
-double slaEpb2d ( double epb );
-
-double slaEpco ( char k0, char k, double e );
-
-double slaEpj ( double date );
-
-double slaEpj2d ( double epj );
-
-void slaEqecl ( double dr, double dd, double date, double *dl, double *db );
-
-double slaEqeqx ( double date );
-
-void slaEqgal ( double dr, double dd, double *dl, double *db );
-
-void slaEtrms ( double ep, double ev[3] );
-
-void slaEuler ( char *order, float phi, float theta, float psi,
-                float rmat[3][3] );
-
-void slaEvp ( double date, double deqx,
-              double dvb[3], double dpb[3],
-              double dvh[3], double dph[3] );
-
-void slaFitxy ( int itype, int np, double xye[][2], double xym[][2],
-                double coeffs[6], int *j );
-
-void slaFk425 ( double r1950, double d1950, double dr1950,
-                double dd1950, double p1950, double v1950,
-                double *r2000, double *d2000, double *dr2000,
-                double *dd2000, double *p2000, double *v2000 );
-
-void slaFk45z ( double r1950, double d1950, double bepoch,
-                double *r2000, double *d2000 );
-
-void slaFk524 ( double r2000, double d2000, double dr2000,
-                double dd2000, double p2000, double v2000,
-                double *r1950, double *d1950, double *dr1950,
-                double *dd1950, double *p1950, double *v1950 );
-
-void slaFk52h ( double r5, double d5, double dr5, double dd5,
-                double *dr, double *dh, double *drh, double *ddh );
-
-void slaFk54z ( double r2000, double d2000, double bepoch,
-                double *r1950, double *d1950,
-                double *dr1950, double *dd1950 );
-
-void slaFk5hz ( double r5, double d5, double epoch,
-                double *rh, double *dh );
-
-void slaFlotin ( char *string, int *nstrt, float *reslt, int *jflag );
-
-void slaGaleq ( double dl, double db, double *dr, double *dd );
-
-void slaGalsup ( double dl, double db, double *dsl, double *dsb );
-
-void slaGe50 ( double dl, double db, double *dr, double *dd );
-
-void slaGeoc ( double p, double h, double *r, double *z );
-
-double slaGmst ( double ut1 );
-
-double slaGmsta ( double date, double ut1 );
-
-void slaH2e ( float az, float el, float phi, float *ha, float *dec );
-
-void slaH2fk5 ( double dr, double dh, double drh, double ddh,
-                double *r5, double *d5, double *dr5, double *dd5 );
-
-void slaHfk5z ( double rh, double dh, double epoch,
-                double *r5, double *d5, double *dr5, double *dd5 );
-
-void slaImxv ( float rm[3][3], float va[3], float vb[3] );
-
-void slaIntin ( char *string, int *nstrt, long *ireslt, int *jflag );
-
-void slaInvf ( double fwds[6], double bkwds[6], int *j );
-
-void slaKbj ( int jb, double e, char *k, int *j );
-
-void slaM2av ( float rmat[3][3], float axvec[3] );
-
-void slaMap ( double rm, double dm, double pr, double pd,
-              double px, double rv, double eq, double date,
-              double *ra, double *da );
-
-void slaMappa ( double eq, double date, double amprms[21] );
-
-void slaMapqk ( double rm, double dm, double pr, double pd,
-                double px, double rv, double amprms[21],
-                double *ra, double *da );
-
-void slaMapqkz ( double rm, double dm, double amprms[21],
-                 double *ra, double *da );
-
-void slaMoon ( int iy, int id, float fd, float posvel[6] );
-
-void slaMxm ( float a[3][3], float b[3][3], float c[3][3] );
-
-void slaMxv ( float rm[3][3], float va[3], float vb[3] );
-
-void slaNut ( double date, double rmatn[3][3] );
-
-void slaNutc ( double date, double *dpsi, double *deps, double *eps0 );
-
-void slaOap ( char *type, double ob1, double ob2, double date,
-              double dut, double elongm, double phim, double hm,
-              double xp, double yp, double tdk, double pmb,
-              double rh, double wl, double tlr,
-              double *rap, double *dap );
-
-void slaOapqk ( char *type, double ob1, double ob2, double aoprms[14],
-                double *rap, double *dap );
-
-void slaObs ( int n, char *c, char *name, double *w, double *p, double *h );
-
-double slaPa ( double ha, double dec, double phi );
-
-double slaPav ( float v1[3], float v2[3] );
-
-void slaPcd ( double disco, double *x, double *y );
-
-void slaPda2h ( double p, double d, double a,
-                double *h1, int *j1, double *h2, int *j2 );
-
-void slaPdq2h ( double p, double d, double q,
-                double *h1, int *j1, double *h2, int *j2 );
-
-void slaPermut ( int n, int istate[], int iorder[], int *j );
-
-void slaPertel (int jform, double date0, double date1,
-                double epoch0, double orbi0, double anode0,
-                double perih0, double aorq0, double e0, double am0,
-                double *epoch1, double *orbi1, double *anode1,
-                double *perih1, double *aorq1, double *e1, double *am1,
-                int *jstat );
-
-void slaPertue ( double date, double u[], int *jstat );
-
-void slaPlanel ( double date, int jform, double epoch, double orbinc,
-                 double anode, double perih, double aorq,  double e,
-                 double aorl, double dm, double pv[6], int *jstat );
-
-void slaPlanet ( double date, int np, double pv[6], int *j );
-
-void slaPlante ( double date, double elong, double phi, int jform,
-                 double epoch, double orbinc, double anode, double perih,
-                 double aorq, double e, double aorl, double dm,
-                 double *ra, double *dec, double *r, int *jstat );
-
-void slaPm ( double r0, double d0, double pr, double pd,
-             double px, double rv, double ep0, double ep1,
-             double *r1, double *d1 );
-
-void slaPolmo ( double elongm, double phim, double xp, double yp,
-                double *elong, double *phi, double *daz );
-
-void slaPrebn ( double bep0, double bep1, double rmatp[3][3] );
-
-void slaPrec ( double ep0, double ep1, double rmatp[3][3] );
-
-void slaPrecl ( double ep0, double ep1, double rmatp[3][3] );
-
-void slaPreces ( char sys[3], double ep0, double ep1,
-                 double *ra, double *dc );
-
-void slaPrenut ( double epoch, double date, double rmatpn[3][3] );
-
-void slaPv2el ( double pv[], double date, double pmass, int jformr,
-                int *jform, double *epoch, double *orbinc,
-                double *anode, double *perih, double *aorq, double *e,
-                double *aorl, double *dm, int *jstat );
-
-void slaPv2ue ( double pv[], double date, double pmass,
-                double u[], int *jstat );
-
-void slaPvobs ( double p, double h, double stl, double pv[6] );
-
-void slaPxy ( int np, double xye[][2], double xym[][2],
-              double coeffs[6],
-              double xyp[][2], double *xrms, double *yrms, double *rrms );
-
-float slaRange ( float angle );
-
-float slaRanorm ( float angle );
-
-double slaRcc ( double tdb, double ut1, double wl, double u, double v );
-
-void slaRdplan ( double date, int np, double elong, double phi,
-                 double *ra, double *dec, double *diam );
-
-void slaRefco ( double hm, double tdk, double pmb, double rh,
-                double wl, double phi, double tlr, double eps,
-                double *refa, double *refb );
-
-void slaRefcoq ( double tdk, double pmb, double rh, double wl,
-                double *refa, double *refb );
-
-void slaRefro ( double zobs, double hm, double tdk, double pmb,
-                double rh, double wl, double phi, double tlr, double eps,
-                double *ref );
-
-void slaRefv ( double vu[3], double refa, double refb, double vr[3] );
-
-void slaRefz ( double zu, double refa, double refb, double *zr );
-
-float slaRverot ( float phi, float ra, float da, float st );
-
-float slaRvgalc ( float r2000, float d2000 );
-
-float slaRvlg ( float r2000, float d2000 );
-
-float slaRvlsrd ( float r2000, float d2000 );
-
-float slaRvlsrk ( float r2000, float d2000 );
-
-void slaS2tp ( float ra, float dec, float raz, float decz,
-               float *xi, float *eta, int *j );
-
-float slaSep ( float a1, float b1, float a2, float b2 );
-
-void slaSmat ( int n, float *a, float *y, float *d, int *jf, int *iw );
-
-void slaSubet ( double rc, double dc, double eq,
-                double *rm, double *dm );
-
-void slaSupgal ( double dsl, double dsb, double *dl, double *db );
-
-void slaSvd ( int m, int n, int mp, int np,
-              double *a, double *w, double *v, double *work,
-              int *jstat );
-
-void slaSvdcov ( int n, int np, int nc,
-                 double *w, double *v, double *work, double *cvm );
-
-void slaSvdsol ( int m, int n, int mp, int np,
-                 double *b, double *u, double *w, double *v,
-                 double *work, double *x );
-
-void slaTp2s ( float xi, float eta, float raz, float decz,
-               float *ra, float *dec );
-
-void slaTp2v ( float xi, float eta, float v0[3], float v[3] );
-
-void slaTps2c ( float xi, float eta, float ra, float dec,
-                float *raz1, float *decz1,
-                float *raz2, float *decz2, int *n );
-
-void slaTpv2c ( float xi, float eta, float v[3],
-                float v01[3], float v02[3], int *n );
-
-void slaUe2el ( double u[], int jformr,
-                int *jform, double *epoch, double *orbinc,
-                double *anode, double *perih, double *aorq, double *e,
-                double *aorl, double *dm, int *jstat );
-
-void slaUe2pv ( double date, double u[], double pv[], int *jstat );
-
-void slaUnpcd ( double disco, double *x, double *y );
-
-void slaV2tp ( float v[3], float v0[3], float *xi, float *eta, int *j );
-
-float slaVdv ( float va[3], float vb[3] );
-
-void slaVn ( float v[3], float uv[3], float *vm );
-
-void slaVxv ( float va[3], float vb[3], float vc[3] );
-
-void slaXy2xy ( double x1, double y1, double coeffs[6],
-                double *x2, double *y2 );
-
-double slaZd ( double ha, double dec, double phi );
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/filterbank-gmrt/slamac.h b/filterbank-gmrt/slamac.h
deleted file mode 100644
index ac1ddcd..0000000
--- a/filterbank-gmrt/slamac.h
+++ /dev/null
@@ -1,108 +0,0 @@
-#ifndef SLAMACHDEF
-#define SLAMACHDEF
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-**  - - - - - - - - -
-**   s l a m a c . h
-**  - - - - - - - - -
-**
-**  Macros used by slalib library.
-**
-**  Last revision:   27 January 2000
-**
-**  Copyright P.T.Wallace.  All rights reserved.
-*/
-
-/* max(A,B) - larger (most +ve) of two numbers (generic) */
-#define gmax(A,B) ((A)>(B)?(A):(B))
-
-/* min(A,B) - smaller (least +ve) of two numbers (generic) */
-#define gmin(A,B) ((A)<(B)?(A):(B))
-
-/* dint(A) - truncate to nearest whole number towards zero (double) */
-#define dint(A) ((A)<0.0?ceil(A):floor(A))
-
-/* aint(A) - truncate to nearest whole number towards zero (float) */
-#define aint(A) ((A)<0.0f?(float)ceil((double)(A)):(float)floor((double)(A)))
-
-/* dnint(A) - round to nearest whole number (double) */
-#define dnint(A) ((A)<0.0?ceil((A)-0.5):floor((A)+0.5))
-
-/* anint(A) - round to nearest whole number (float) */
-#define anint(A) ((float)dnint((double)(A)))
-
-/* dsign(A,B) - magnitude of A with sign of B (double) */
-#define dsign(A,B) ((B)<0.0?-(A):(A))
-
-/* dmod(A,B) - A modulo B (double) */
-#define dmod(A,B) ((B)!=0.0?((A)*(B)>0.0?(A)-(B)*floor((A)/(B))\
-                                        :(A)+(B)*floor(-(A)/(B))):(A))
-
-/* logicals */
-#if !defined(FALSE) || ((FALSE)!=0)
-#define FALSE 0
-#endif
-#if !defined(TRUE) || ((TRUE)!=1)
-#define TRUE 1
-#endif
-
-/* pi */
-#define DPI 3.1415926535897932384626433832795028841971693993751
-
-/* 2pi */
-#define D2PI 6.2831853071795864769252867665590057683943387987502
-
-/* 1/(2pi) */
-#define D1B2PI 0.15915494309189533576888376337251436203445964574046
-
-/* 4pi */
-#define D4PI 12.566370614359172953850573533118011536788677597500
-
-/* 1/(4pi) */
-#define D1B4PI 0.079577471545947667884441881686257181017229822870228
-
-/* pi^2 */
-#define DPISQ 9.8696044010893586188344909998761511353136994072408
-
-/* sqrt(pi) */
-#define DSQRPI 1.7724538509055160272981674833411451827975494561224
-
-/* pi/2:  90 degrees in radians */
-#define DPIBY2 1.5707963267948966192313216916397514420985846996876
-
-/* pi/180:  degrees to radians */
-#define DD2R 0.017453292519943295769236907684886127134428718885417
-
-/* 180/pi:  radians to degrees */
-#define DR2D 57.295779513082320876798154814105170332405472466564
-
-/* pi/(180*3600):  arcseconds to radians */
-#define DAS2R 4.8481368110953599358991410235794797595635330237270e-6
-
-/* 180*3600/pi :  radians to arcseconds */
-#define DR2AS 2.0626480624709635515647335733077861319665970087963e5
-
-/* pi/12:  hours to radians */
-#define DH2R 0.26179938779914943653855361527329190701643078328126
-
-/* 12/pi:  radians to hours */
-#define DR2H 3.8197186342054880584532103209403446888270314977709
-
-/* pi/(12*3600):  seconds of time to radians */
-#define DS2R 7.2722052166430399038487115353692196393452995355905e-5
-
-/* 12*3600/pi:  radians to seconds of time */
-#define DR2S 1.3750987083139757010431557155385240879777313391975e4
-
-/* 15/(2pi):  hours to degrees x radians to turns */
-#define D15B2P 2.3873241463784300365332564505877154305168946861068
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/filterbank-gmrt/slfit.f b/filterbank-gmrt/slfit.f
deleted file mode 100644
index 0606b27..0000000
--- a/filterbank-gmrt/slfit.f
+++ /dev/null
@@ -1,82 +0,0 @@
-c==============================================================================
-      subroutine slfit(x, y, z, ndata, sig, weight, a, b, siga, sigb)
-c==============================================================================
-c
-c     Fits the data passed down in arrays x(ndata) y(ndata) to the
-c     straight line y=a+bx by minimising chi**2. Standard deviations
-c     in y are passed down by sig(ndata) and can be weighted into
-c     the fit if the logical switch weight is on. a and b together
-c     with their uncertainties siga and sigb are returned.
-c     Adapted from the fit routine given in numerical recipes to
-c     be used in the psrflux software.
-c     DRL 93/06/01 @ JB
-c
-      logical weight, useweight
-      dimension x(ndata),y(ndata),z(ndata),sig(ndata)
-
-      sx=0.
-      sy=0.
-      st2=0.
-      b=0.
-c
-c     for upper limits opt for an unweighted fit
-c     and use only three quarters the flux values
-c
-      useweight=weight
-      do i=1,ndata
-         z(i)=y(i)
-         if (sig(i).eq.-999.0) then
-           useweight=.false.
-           z(i)=0.75*y(i)
-         endif
-      enddo
-
-      if(useweight) then
-        ss=0.
-        do i=1,ndata
-          wt=1./(sig(i)**2)
-          ss=ss+wt
-          sx=sx+x(i)*wt
-          sy=sy+z(i)*wt
-        enddo
-      else
-        do i=1,ndata
-          sx=sx+x(i)
-          sy=sy+z(i)
-        enddo
-        ss=float(ndata)
-      endif
-      sxoss=sx/ss
-      if(useweight) then
-        do i=1,ndata
-          t=(x(i)-sxoss)/sig(i)
-          b=b+t*z(i)/sig(i)
-          st2=st2+t*t
-        enddo
-      else
-        do i=1,ndata
-          t=x(i)-sxoss
-          st2=st2+t*t
-          b=b+t*z(i)
-        enddo
-      endif
-      b=b/st2
-      a=(sy-sx*b)/ss
-      siga=sqrt((1.+sx*sx/(ss*st2))/ss)
-      sigb=sqrt(1./st2)
-      chi2=0.0
-      if (.not.useweight) then
-         do i=1,ndata
-           chi2=chi2+(z(i)-a-b*x(i))**2
-         enddo
-         q=1
-         sigdat=0.0
-c
-c        no uncertainty for an unweighted two point fit.
-c
-         if (ndata.gt.2)  sigdat=sqrt(chi2/(ndata-2)) 
-         siga=siga*sigdat
-         sigb=sigb*sigdat
-      endif
-
-      end
diff --git a/filterbank-gmrt/smooth.c b/filterbank-gmrt/smooth.c
deleted file mode 100644
index 18fb1c0..0000000
--- a/filterbank-gmrt/smooth.c
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-  This routine will smooth a time series by adding adjacent samples.
-
-  v. 0.0  TJWL  27 Sept 1994
-  v. 0.1  TJWL  30 Sept 1994 - minor bug fixes
-
-  Input:
-  int ndata;     the number of time series samples
-  float data[];  the time series
-
-  Output:
-  int ndata;     the number of smoothed time series samples
-  float data[];  the smoothed time series    
-
-*/
-
-void smooth(ndata, data)
-int *ndata;
-float data[];
-{
-  int i, npoints;
-
-  npoints = *ndata - 1;
-
-  for (i=0; i<npoints; i++)
-    data[i] = (data[i] + data[i+1])/2.0;
-
-  *ndata = npoints;
-
-  return;
-}
-
diff --git a/filterbank-gmrt/snrdm.c b/filterbank-gmrt/snrdm.c
deleted file mode 100644
index 1581554..0000000
--- a/filterbank-gmrt/snrdm.c
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  snrdm - a program to produce the expected signal-to-noise versus DM curve 
-  for a pulsar search given a set of observing parameters.
-
-  Created July 25, 2002 - drl@jb.man.ac.uk
- */
-#include <stdlib.h>
-#include <stdio.h>
-#include <math.h>
-#include "sigproc.h"
-main(int argc, char **argv) 
-{
-  char message[80];
-  int i;
-  float fmhz=430.0, bw=7.68, nch=128.0, dm=50.0, pms=150.0,
-        wms=5.0, tms=0.08, tsc=0.0, mdm=0.0, nrm=100.0;
-  float xdm, wef, snr, tdm, tdd, snrmax=0.0;
-  FILE *input;
-  if (argc > 1) {
-    print_version(argv[0],argv[1]);
-    if (help_required(argv[1])) {
-      /*snrdm_help();*/
-      exit(0);
-    }
-    i=1;
-    while (i<argc) {
-      if (file_exists(argv[i])) {
-	input=open_file(argv[i],"r");
-      } else if (strings_equal(argv[i],"-f")) {
-        fmhz=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-b")) {
-        bw=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-c")) {
-        nch=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-d")) {
-        dm=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-p")) {
-        pms=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-w")) {
-        wms=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-t")) {
-        tms=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-s")) {
-        tsc=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-m")) {
-        mdm=atof(argv[++i]);
-      } else if (strings_equal(argv[i],"-n")) {
-        nrm=atof(argv[++i]);
-      } else {
-	sprintf(message,"command-line argument %s not recognized...",argv[i]);
-	error_message(message);
-      }
-      i++;
-    }
-  }
-  if (mdm == 0.0) mdm=2.0*dm;
-  tdm=(float) dmdelay(fmhz-bw/nch,fmhz,dm)*1000.0;
-  for (xdm=0.0;xdm<mdm;xdm+=0.1) {
-    tdd=(float) dmdelay(fmhz-bw/2.0,fmhz+bw/2.0,abs(dm-xdm))*1000.0;
-    wef=sqrt(wms*wms+tsc*tsc+tms*tms+tdm*tdm+tdd*tdd);
-    snr=sqrt((pms-wef)/wef);
-    snrmax=(snr>snrmax)?snr:snrmax;
-  }
-  printf("#Signal-to-noise/DM curve assuming following parameters:\n");
-  fprintf(stderr,"#Pulse Period %.3f ms\n",pms);
-  fprintf(stderr,"#Intrinsic Width %.3f ms\n",wms);
-  fprintf(stderr,"#Scattering Time %.3f ms\n",tsc);
-  fprintf(stderr,"#True DM %.3f pc/cc\n",dm);
-  fprintf(stderr,"#Centre Frequency %.3f MHz\n",fmhz);
-  fprintf(stderr,"#Bandwidth %.3f MHz\n",bw);
-  fprintf(stderr,"#Number of Channels %d\n",nch);
-  printf("#START\n");
-  for (xdm=0.0;xdm<mdm;xdm+=0.1) {
-    tdd=(float) dmdelay(fmhz-bw/2.0,fmhz+bw/2.0,abs(dm-xdm))*1000.0;
-    wef=sqrt(wms*wms+tsc*tsc+tms*tms+tdm*tdm+tdd*tdd);
-    if (wef>pms) 
-      snr=0.0;
-    else
-      snr=nrm*sqrt((pms-wef)/wef)/snrmax;
-    printf("%.2f %f\n",xdm,snr);
-  }
-  printf("#STOP\n");
-  printf("#DONE\n");
-}
diff --git a/filterbank-gmrt/spcsnr.f b/filterbank-gmrt/spcsnr.f
deleted file mode 100644
index 8b276e7..0000000
--- a/filterbank-gmrt/spcsnr.f
+++ /dev/null
@@ -1,22 +0,0 @@
-      real function spcsnr(dat,n)
-      implicit none
-      integer n
-      real dat(n)
-      integer i,j,nb
-      real rms,peak,sumsq
-      peak=-1.0e32
-      sumsq=0.0
-      nb=n/10
-      j=0
-      do i=1,n
-         if (i.le.nb.or.i.ge.n-nb) then
-            sumsq=sumsq+dat(i)*dat(i)
-            j=j+1
-         else
-            peak=max(peak,dat(i))
-         endif
-      enddo
-      rms=sqrt(sumsq/real(j))
-      spcsnr=0.0
-      if (peak.gt.0.0) spcsnr=peak/rms
-      end
diff --git a/filterbank-gmrt/splice.c b/filterbank-gmrt/splice.c
deleted file mode 100644
index 157dfe0..0000000
--- a/filterbank-gmrt/splice.c
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-  SPLICE - splice several filterbank files starting on same time stamp together
-  for use to analyse data from cloned machines sampling several parts of the 
-  band. e.g. multi-WAPPs. 
-  Initial version (Nov 2002) required contiguous bands. 
-  New version     (Jun 2003) requires only high-lo frequency ordering
-  Modified        (Jul 2005) to write out to file if -o file option is given
-*/
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
-#include "sigproc.h"
-#include "header.h"
-FILE *output;
-main (int argc, char **argv)
-{
-  int i=1, j, k, nfiles=0, *numbt, schans=0, nbytes, *nchan;
-  FILE *input[32];
-  char *block;
-  double *stamp, *frch1, *froff, *frmhz;
-  output=stdout;
-  /* print help if necessary */
-  if (argc<=1 || help_required(argv[1])) {
-    /*splice_help();*/
-    exit(0);
-  } else {
-    print_version(argv[0],argv[1]);
-  }
-
-  /* open up files */
-  while (i<argc) {
-    if (file_exists(argv[i])) {
-      input[nfiles]=open_file(argv[i],"rb");
-      nfiles++;
-    } else if (strings_equal(argv[i],"-o")) {
-      output=open_file(argv[++i],"wb");
-    }
-    i++;
-  }
-
-  /* read in headers and check time stamps */
-  stamp = (double *) malloc(nfiles*sizeof(double));
-  frch1 = (double *) malloc(nfiles*sizeof(double));
-  froff = (double *) malloc(nfiles*sizeof(double));
-  numbt = (int *) malloc(nfiles*sizeof(int));
-  nchan = (int *) malloc(nfiles*sizeof(int));
-  for (i=0; i<nfiles; i++) {
-    if (read_header(input[i])) {
-      stamp[i]=tstart;
-      frch1[i]=fch1;
-      froff[i]=foff;
-      numbt[i]=nbits;
-      nchan[i]=nchans;
-      schans+=nchans;
-    } else {
-      error_message("problem reading header parameters");
-    }
-    if (data_type != 1) 
-      error_message("input data are not in filterbank format!");
-    if (stamp[i] != stamp[0]) 
-      error_message("start times in input files are not identical!");
-    if (numbt[i] != numbt[0])
-      error_message("number of bits per sample in input files not identical!");
-    if (i>0) {
-      if (frch1[i] > frch1[i-1]) 
-	error_message("input files not ordered in descending frequency!");
-    }
-
-  }
-
-
-  send_string("HEADER_START");
-  send_int("machine_id",machine_id);
-  send_int("telescope_id",telescope_id);
-  send_int("data_type",1);
-
-  send_string("FREQUENCY_START");
-  send_int("nchans",schans);
-  frmhz = (double *) malloc(sizeof(double)*schans);
-  k=0;
-  for (i=0; i<nfiles; i++) {
-    for (j=0; j<nchans; j++) {
-      frmhz[k]=frch1[i]+j*froff[i];
-      send_double("fchannel",frmhz[k++]);
-    }
-  }
-  send_string("FREQUENCY_END");
-  
-
-  if (!strings_equal(source_name,"")) {
-    send_string("source_name");
-    send_string(source_name);
-  }
-  send_coords(src_raj,src_dej,az_start,za_start);
-  send_int("nbits",nbits);
-  send_double("tstart",tstart);
-  send_double("tsamp",tsamp);
-  send_int("nifs",nifs);
-  send_string("HEADER_END");
-
-  nbytes = nchans*nbits/8;
-  block = (char *) malloc(nbytes);
-  while (1) {
-    for (i=0; i<nfiles; i++) {
-      if (feof(input[i])) exit(0);
-      fread(block,nbytes,1,input[i]);
-      fwrite(block,nbytes,1,output);
-    }
-  }
-}
diff --git a/filterbank-gmrt/splitter.c b/filterbank-gmrt/splitter.c
deleted file mode 100644
index fd3c223..0000000
--- a/filterbank-gmrt/splitter.c
+++ /dev/null
@@ -1,48 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include "sigproc.h"
-#define DEFBLOCK 32768
-#define DEFBYTES 2000000000
-main(int argc, char **argv)
-{
-  FILE *output;
-  char stem[80], newfile[80];
-  unsigned char block[DEFBLOCK];
-  int blocksize, filesize, nfiles=1, nread, snip=0, snipped=0;
-  if (argc < 2) {
-    puts("usage: splitter outputstem (filesize/bytes)");
-    exit(0);
-  }
-  strcpy(stem,argv[1]);
-  sprintf(newfile,"%s.%d",stem,nfiles);
-  output=fopen(newfile,"wb");
-  fprintf(stderr,"opened output file... %s\n",newfile);
-  if (strings_equal(argv[1],"snip")) snip=1;
-
-  if (argc>2) 
-    filesize=atoi(argv[2]);
-  else 
-    filesize=DEFBYTES;
-
-  if (DEFBLOCK > filesize) 
-    blocksize=filesize;
-  else
-    blocksize=DEFBLOCK;
-
-  while (nread=fread(block,1,blocksize,stdin)) {
-    fwrite(block,1,nread,output);
-    fflush(output);
-    if (sizeof_file(newfile)>=filesize) {
-      if (snip && snipped) {
-	continue;
-      } else {
-	fclose(output);
-	sprintf(newfile,"%s.%d",stem,++nfiles);
-	output=fopen(newfile,"wb");
-	fprintf(stderr,"opening new file... %s\n",newfile);
-	snipped=1;
-      }
-    }
-  }
-  fclose(output);
-}
diff --git a/filterbank-gmrt/sprof.f b/filterbank-gmrt/sprof.f
deleted file mode 100644
index 77c70b3..0000000
--- a/filterbank-gmrt/sprof.f
+++ /dev/null
@@ -1,28 +0,0 @@
-c==============================================================================
-      subroutine sprof(profile,nbins,shift)
-c==============================================================================
-c
-c     shifts the profile in the array profile() with nbins bins by the 
-c     number of bins passed down in shift. shift>0 means shift forward,
-c     shift<0 means shift backwards.
-c
-      implicit none
-
-      real profile(*)
-      integer nbins, shift
-c
-c     local variables
-c
-      integer i,j
-      real dummy
-
-      if (shift.lt.0) shift=nbins+shift
-      do i=1,shift
-         dummy=profile(nbins)
-         do j=nbins,2,-1
-            profile(j)=profile(j-1)
-         enddo
-         profile(1)=dummy
-      enddo
-
-      end
diff --git a/filterbank-gmrt/ssm.c b/filterbank-gmrt/ssm.c
deleted file mode 100644
index 1fc56b7..0000000
--- a/filterbank-gmrt/ssm.c
+++ /dev/null
@@ -1,19 +0,0 @@
-#include <time.h>
-#include <stdio.h>
-#include <stdlib.h>
-/* ssm - returns the approximate number of seconds since midnight */
-int ssm(void) /*includefile*/
-{
-  char hours[8],minutes[8],seconds[8];
-  struct tm *ptr;
-  time_t lt;
-
-  lt = time(NULL);
-  ptr= localtime(&lt);
-  strftime(hours,8,"%H",ptr);
-  strftime(minutes,8,"%M",ptr);
-  strftime(seconds,8,"%S",ptr);
-
-  return (atoi(hours)*3600 + atoi(minutes)*60 + atoi(seconds));
-}
-
diff --git a/filterbank-gmrt/step.f b/filterbank-gmrt/step.f
deleted file mode 100644
index 13e032a..0000000
--- a/filterbank-gmrt/step.f
+++ /dev/null
@@ -1,41 +0,0 @@
-c==============================================================================
-	program step
-c==============================================================================
-c       Produces DM/AC files for up to two loops (dunc@mpifr-bonn.mpg.de)
-c==============================================================================
-	real x,x1,x2,xs,y,y1,y2,ys
-	character*80 tmp
-	integer narg,iargc
-	logical inner
-	narg=iargc()
-	if (narg.lt.3) stop 'Specify min max step'
-	call getarg(1,tmp)
-	read(tmp,*) x1
-	call getarg(2,tmp)
-	read(tmp,*) x2
-	call getarg(3,tmp)
-	read(tmp,*) xs
-	call getarg(4,tmp)
-	inner=tmp.ne.' '
-	if (inner) then
-	   read(tmp,*) y1
-	   call getarg(5,tmp)
-	   read(tmp,*) y2
-	   call getarg(6,tmp)
-	   read(tmp,*) ys
-	endif
-	x=x1
-	do while (x.lt.x2+xs) 
-	  if (inner) then
-             y=y1	
-	     do while (y.lt.y2+ys)
-	     write(*,'(2(f8.3,3x))') x,y
-	     y=y+ys
-	     enddo
-	  else
-	     write(*,'(f8.3)') x
-	  endif
-	  x=x+xs
-	enddo
-	end
-c==============================================================================
diff --git a/filterbank-gmrt/strings_equal.c b/filterbank-gmrt/strings_equal.c
deleted file mode 100644
index cd14c9c..0000000
--- a/filterbank-gmrt/strings_equal.c
+++ /dev/null
@@ -1,9 +0,0 @@
-#include <stdio.h>
-int strings_equal (char *string1, char *string2) /* includefile */
-{
-  if (!strcmp(string1,string2)) {
-    return 1;
-  } else {
-    return 0;
-  }
-}
diff --git a/filterbank-gmrt/subint2prf.csh b/filterbank-gmrt/subint2prf.csh
deleted file mode 100755
index d34cfcc..0000000
--- a/filterbank-gmrt/subint2prf.csh
+++ /dev/null
@@ -1,17 +0,0 @@
-#!/bin/csh
-if ($1 == "") then
-	echo "usage: subint2prf file"
-	exit
-endif
-set mjd = `head -1 $1 | awk '{printf "%d",$2}'`
-set f = $1
-set n = `head -1 $f | awk '{print $8}'`
-@ h = $n + 1
-@ b = $n + 1
-set n = `wc -l $f | awk '{print $1}'`
-set i = 1
-while ($h < $n)
-head -$h $f | tail -$b > $mjd.$i.prf
-@ i++
-@ h = $h + $b
-end
diff --git a/filterbank-gmrt/submean.c b/filterbank-gmrt/submean.c
deleted file mode 100644
index fbabbd2..0000000
--- a/filterbank-gmrt/submean.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-void submean(float *profile, int nbins) /*includefile*/
-{
-  float *prcopy, mean;
-  int i,j;
-
-  /* assign space and make a copy of the original profile and find peak bin */
-  prcopy=(float *) malloc(nbins * sizeof(float));
-  mean=0.0; 
-  for (i=0;i<nbins;i++) {
-    prcopy[i]=profile[i];
-    if (prcopy[i]>mean) {
-      j=i;
-      mean=prcopy[i];
-    }
-  }
-
-  /* shift copy to center based on peak bin: j */
-  shift_prof(prcopy,nbins,j+1-nbins);
-
-  /* finally calculate mean from off-pulse data */
-  mean=0.0;
-  for (i=0;i<nbins/20;i++) mean+=prcopy[i];
-  for (i=nbins-1-nbins/20;i<nbins;i++) mean+=prcopy[i];
-  mean/=nbins/10;
-
-  /* now subtract this from original profile */
-  for (i=0;i<nbins;i++) profile[i]-=mean;
-
-  /* discard the copy */
-  free(prcopy);
-}
diff --git a/filterbank-gmrt/submedian.c b/filterbank-gmrt/submedian.c
deleted file mode 100644
index 9598fdb..0000000
--- a/filterbank-gmrt/submedian.c
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <stdio.h>
-#include "sigproc.h"
-void submedian(float *profile, int nbins) /*includefile*/
-{
-  float *prcopy, median;
-  int i,j;
-
-  /* assign space and make a copy of the original profile */
-  prcopy=(float *) malloc(nbins * sizeof(float));
-  for (i=0;i<nbins;i++) prcopy[i]=profile[i];
-
-  /* find median (don't worry about even/odd numbers) */
-  median=nrselect(nbins/2,nbins,prcopy-1);
-
-  /* now subtract this from original profile */
-  for (i=0;i<nbins;i++) profile[i]-=median;
-
-  /* discard the copy */
-  free(prcopy);
-}
-
-void subcal(float *profile, int nbins) /*includefile*/
-{
-  int i;
-  float num,sum,sub;
-  num=sum=0.0;
-  for (i=nbins-nbins/3;i<nbins;i++) {
-    sum+=profile[i];
-    num+=1.0;
-  }
-  sub=sum/num;
-  for (i=0;i<nbins;i++) profile[i]-=sub;
-}
diff --git a/filterbank-gmrt/sumhrm.f b/filterbank-gmrt/sumhrm.f
deleted file mode 100644
index a29093a..0000000
--- a/filterbank-gmrt/sumhrm.f
+++ /dev/null
@@ -1,123 +0,0 @@
-C **************************************************************
-      SUBROUTINE SUMHRM (SP,NF,NF1)
-C **************************************************************
-      include 'seek.inc'
-      INTEGER NF, NF1
-      REAL SP(NF), SPH(npts)
-
-      NF2 = MAX(1,MIN(2*NF1-1,NF))
-      NF4 = MAX(1,MIN(4*NF1-2,NF))
-      NF8 = MAX(1,MIN(8*NF1-4,NF))
-      NF16= MAX(1,MIN(16*NF1-8,NF))
-      do n=1,nf
-         power(1,n)=sp(n)
-      enddo
-      DO N=1,NF
-         SPH(N)=0.0
-      ENDDO
-
-      K = (NF2+1)/2
-      DO 20 N=NF2,NF-1,2
-         SPH(N)=SP(N)+SP(K)
-         SPH(1+N)=SP(1+N)+SP(K)
-         K=K+1
-   20 CONTINUE
-      do n=1,nf
-         power(2,n)=sph(n)
-      enddo
-      
-      KA = (NF4+2)/4
-      KB = (3*NF4+2)/4
-      DO 40 N=NF4,NF-3,4
-         SPH(N)=SPH(N)+SP(KA)+SP(KB)
-         SPH(1+N)=SPH(1+N)+SP(KA)+SP(KB)
-         SPH(2+N)=SPH(2+N)+SP(KA)+SP(1+KB)
-         SPH(3+N)=SPH(3+N)+SP(KA)+SP(2+KB)
-         KA = KA + 1
-         KB = KB + 3
-   40 CONTINUE
-      do n=1,nf
-         power(3,n)=sph(n)
-      enddo
-
-      JA = (NF8+4)/8
-      JB = (3*NF8+4)/8
-      JC = (5*NF8+4)/8
-      JD = (7*NF8+4)/8
-      DO 80 N=NF8,NF-7,8
-         SPH(  N)=SPH(  N)+SP(JA)+SP(  JB)+SP(  JC)+SP(  JD)
-         SPH(1+N)=SPH(1+N)+SP(JA)+SP(  JB)+SP(  JC)+SP(  JD)
-         SPH(2+N)=SPH(2+N)+SP(JA)+SP(  JB)+SP(1+JC)+SP(1+JD)
-         SPH(3+N)=SPH(3+N)+SP(JA)+SP(1+JB)+SP(1+JC)+SP(2+JD)
-         SPH(4+N)=SPH(4+N)+SP(JA)+SP(1+JB)+SP(2+JC)+SP(3+JD)
-         SPH(5+N)=SPH(5+N)+SP(JA)+SP(1+JB)+SP(3+JC)+SP(4+JD)
-         SPH(6+N)=SPH(6+N)+SP(JA)+SP(2+JB)+SP(3+JC)+SP(5+JD)
-         SPH(7+N)=SPH(7+N)+SP(JA)+SP(2+JB)+SP(4+JC)+SP(6+JD)
-         JA = JA + 1
-         JB = JB + 3
-         JC = JC + 5
-         JD = JD + 7
-   80 CONTINUE
-      do n=1,nf
-         power(4,n)=sph(n)
-      enddo
-
-      LA = (   NF16+8)/16
-      LB = (3*NF16+8)/16
-      LC = (5*NF16+8)/16
-      LD = (7*NF16+8)/16
-      LE = (9*NF16+8)/16
-      LF = (11*NF16+8)/16
-      LG = (13*NF16+8)/16
-      LH = (15*NF16+8)/16
-      DO 160 N=NF16,NF-15,16
-         SPH(  N)=SPH(  N)+SP(LA)+SP(  LB)+SP(  LC)+SP(  LD)+SP(  LE)+
-     +    SP(   LF)+SP(   LG)+SP(   LH)
-         SPH(1+N)=SPH(1+N)+SP(LA)+SP(  LB)+SP(  LC)+SP(  LD)+SP(  LE)+
-     +    SP(   LF)+SP(   LG)+SP(   LH)
-         SPH(2+N)=SPH(2+N)+SP(LA)+SP(  LB)+SP(  LC)+SP(  LD)+SP(1+LE)+
-     +    SP( 1+LF)+SP( 1+LG)+SP( 1+LH)
-         SPH(3+N)=SPH(3+N)+SP(LA)+SP(  LB)+SP(  LC)+SP(1+LD)+SP(1+LE)+
-     +    SP( 2+LF)+SP( 2+LG)+SP( 2+LH)
-         SPH(4+N)=SPH(4+N)+SP(LA)+SP(  LB)+SP(1+LC)+SP(1+LD)+SP(2+LE)+
-     +    SP( 2+LF)+SP( 3+LG)+SP( 3+LH)
-         SPH(5+N)=SPH(5+N)+SP(LA)+SP(  LB)+SP(1+LC)+SP(2+LD)+SP(2+LE)+
-     +    SP( 3+LF)+SP( 4+LG)+SP( 4+LH)
-         SPH(6+N)=SPH(6+N)+SP(LA)+SP(1+LB)+SP(1+LC)+SP(2+LD)+SP(3+LE)+
-     +    SP( 4+LF)+SP( 4+LG)+SP( 5+LH)
-         SPH(7+N)=SPH(7+N)+SP(LA)+SP(1+LB)+SP(2+LC)+SP(3+LD)+SP(3+LE)+
-     +    SP( 4+LF)+SP( 5+LG)+SP( 6+LH)
-         SPH(8+N)=SPH(8+N)+SP(LA)+SP(1+LB)+SP(2+LC)+SP(3+LD)+SP(4+LE)+
-     +    SP( 5+LF)+SP( 6+LG)+SP( 7+LH)
-         SPH(9+N)=SPH(9+N)+SP(LA)+SP(1+LB)+SP(2+LC)+SP(3+LD)+SP(5+LE)+
-     +    SP( 6+LF)+SP( 7+LG)+SP( 8+LH)
-         SPH(10+N)=SPH(10+N)+SP(LA)+SP(1+LB)+SP(3+LC)+SP(4+LD)+SP(5+LE)+
-     +    SP( 6+LF)+SP( 8+LG)+SP( 9+LH)
-         SPH(11+N)=SPH(11+N)+SP(LA)+SP(2+LB)+SP(3+LC)+SP(4+LD)+SP(6+LE)+
-     +    SP( 7+LF)+SP( 8+LG)+SP(10+LH)
-         SPH(12+N)=SPH(12+N)+SP(LA)+SP(2+LB)+SP(3+LC)+SP(5+LD)+SP(6+LE)+
-     +    SP( 8+LF)+SP( 9+LG)+SP(11+LH)
-         SPH(13+N)=SPH(13+N)+SP(LA)+SP(2+LB)+SP(4+LC)+SP(5+LD)+SP(7+LE)+
-     +    SP( 8+LF)+SP(10+LG)+SP(12+LH)
-         SPH(14+N)=SPH(14+N)+SP(LA)+SP(2+LB)+SP(4+LC)+SP(6+LD)+SP(7+LE)+
-     +    SP( 9+LF)+SP(11+LG)+SP(13+LH)
-         SPH(15+N)=SPH(15+N)+SP(LA)+SP(2+LB)+SP(4+LC)+SP(6+LD)+SP(8+LE)+
-     +    SP(10+LF)+SP(12+LG)+SP(14+LH)
-         LA = LA + 1
-         LB = LB + 3
-         LC = LC + 5
-         LD = LD + 7
-         LE = LE + 9
-         LF = LF + 11
-         LG = LG + 13
-         LH = LH + 15
-  160 CONTINUE
-      do n=1,nf
-         power(5,n)=sph(n)
-      enddo
-
-      RETURN
-C
-C END OF SUBROUTINE SUMHRM
-C
-      END
diff --git a/filterbank-gmrt/swap_bytes.c b/filterbank-gmrt/swap_bytes.c
deleted file mode 100644
index 695dafb..0000000
--- a/filterbank-gmrt/swap_bytes.c
+++ /dev/null
@@ -1,178 +0,0 @@
-/* 
-	some useful routines written by Jeff Hagen for swapping
-	bytes of data between Big Endian and  Little Endian formats:
-
-Big Endian - most significant byte in the lowest memory address, which
-is the address of the data.  
-
-Since TCP defines the byte ordering for network data, end-nodes must
-call a processor-specific convert utility (which would do nothing if
-the machine's native byte-ordering is the same as TCP's) that acts on
-the TCP and IP header information only. In a TCP/IP packet, the first
-transmitted data is the most significant byte.
-
-Most UNIXes (for example, all System V) and the Internet are Big
-Endian. Motorola 680x0 microprocessors (and therefore Macintoshes),
-Hewlett-Packard PA-RISC, and Sun SuperSPARC processors are Big
-Endian. The Silicon Graphics MIPS and IBM/Motorola PowerPC processors
-are both Little and Big Endian (bi-endian).
-
-Little Endian - least significant byte in the lowest-memory address,
-which is the address of the data. 
-
-The Intel 80X86 and Pentium and DEC Alpha RISC processors are Little Endian. 
-Windows NT and OSF/1 are Little Endian. 
-Little Endian is the less common UNIX implementation. 
-
-The term is used because of an analogy with the story Gulliver's
-Travels, in which Jonathan Swift imagined a never-ending fight between
-the kingdoms of the Big-Endians and the Little-Endians, whose only
-difference is in where they crack open a hard-boiled egg.
-
-*/
-void swap_short( unsigned short *ps ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = ( unsigned char *)ps;
-  t = pc[0];
-  pc[0] = pc[1];
-  pc[1] = t;
-}
-
-void swap_int( int *pi ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pi;
-
-  t = pc[0];
-  pc[0] = pc[3];
-  pc[3] = t;
-
-  t = pc[1];
-  pc[1] = pc[2];
-  pc[2] = t;
-}
-
-void swap_float( float *pf ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pf;
-
-  t = pc[0];
-  pc[0] = pc[3];
-  pc[3] = t;
-
-  t = pc[1];
-  pc[1] = pc[2];
-  pc[2] = t;
-}
-
-void swap_ulong( unsigned long *pi ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pi;
-
-  t = pc[0];
-  pc[0] = pc[3];
-  pc[3] = t;
-
-  t = pc[1];
-  pc[1] = pc[2];
-  pc[2] = t;
-}
-
-void swap_long( long *pi ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pi;
-
-  t = pc[0];
-  pc[0] = pc[3];
-  pc[3] = t;
-
-  t = pc[1];
-  pc[1] = pc[2];
-  pc[2] = t;
-}
-
-void swap_double( double *pd ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pd;
-
-  t = pc[0];
-  pc[0] = pc[7];
-  pc[7] = t;
-
-  t = pc[1];
-  pc[1] = pc[6];
-  pc[6] = t;
-
-  t = pc[2];
-  pc[2] = pc[5];
-  pc[5] = t;
-
-  t = pc[3];
-  pc[3] = pc[4];
-  pc[4] = t;
-
-}
-
-void swap_longlong( long long *pl ) /* includefile */
-{
-  unsigned char t;
-  unsigned char *pc;
-
-  pc = (unsigned char *)pl;
-
-  t = pc[0];
-  pc[0] = pc[7];
-  pc[7] = t;
-
-  t = pc[1];
-  pc[1] = pc[6];
-  pc[6] = t;
-
-  t = pc[2];
-  pc[2] = pc[5];
-  pc[5] = t;
-
-  t = pc[3];
-  pc[3] = pc[4];
-  pc[4] = t;
-}
-
-#include <stdio.h>
-int little_endian() /*includefile*/
-{
-  char *ostype;
-
-  if((ostype = (char *)getenv("OSTYPE")) == NULL )
-    error_message("environment variable OSTYPE not set!");
-  if (strings_equal(ostype,"linux")) return 1;
-  if (strings_equal(ostype,"hpux")) return 0;
-  if (strings_equal(ostype,"solaris")) return 0;
-  if (strings_equal(ostype,"darwin")) return 0;
-  fprintf(stderr,"Your OSTYPE environment variable is defined but not recognized!\n");
-  fprintf(stderr,"Consult and edit little_endian in swap_bytes.c and then recompile\n");
-  fprintf(stderr,"the code if necessary... Contact dunc@naic.edu for further help\n");
-  exit(0);
-}
-
-int big_endian() /*includefile*/
-{
-  return (!little_endian());
-}
-
diff --git a/filterbank-gmrt/tbary.f b/filterbank-gmrt/tbary.f
deleted file mode 100644
index 3bc8821..0000000
--- a/filterbank-gmrt/tbary.f
+++ /dev/null
@@ -1,36 +0,0 @@
-      subroutine tbary(ra,dec,topo,obs,mjd)
-c
-c     quick utility to return the barycentric arrival time
-c     by calling tempo given RA and DEC and a topocentric time
-c
-      implicit none
-      character*80 ra,dec,topo,obs
-      double precision mjd,pfphi,pfsec,orphi,freq,wgt,etoa,prephi,tmp
-      
-      if (obs.eq." ") stop "usage: tssb RA DEC MJD SITE"
-
-      open(10,file="tssb.par",status="unknown")
-      write(10,'(''PSR 0000+00'')')
-      write(10,'(''RAJ '',a)') ra(1:index(ra," ")-1)
-      write(10,'(''DECJ '',a)') dec(1:index(dec," ")-1)
-      write(10,'(''F0 1.0'')')
-      write(10,'(''DM 0.0'')')
-      write(10,'(''PEPOCH '',a)') topo(1:index(topo," ")-1)
-      close(10)
-
-      read(topo,*) mjd
-      open(10,file="tssb.tim",status="unknown")
-      write(10,'(a1,7x,a7,1x,f8.3,1x,f19.13,1x,i4,3x,f6.2)')
-     &       obs(1:1),"0000+00",9999.0,mjd,1024,10.0
-      close(10)
-
-      call system("tempo tssb.tim > /dev/null")
-      open(10,file="resid2.tmp",form="unformatted")
-      read(10) mjd,pfphi,pfsec,orphi,freq,wgt,etoa,prephi,tmp
-      close(10)
-      write(*,'(f19.13)') mjd
-
-      call system("rm -f tssb.tim tssb.par tempo.lis resid2.tmp")
-      call system("rm -f 0000+00.par")
-
-      end
diff --git a/filterbank-gmrt/thresh_1d.c b/filterbank-gmrt/thresh_1d.c
deleted file mode 100644
index b9dd723..0000000
--- a/filterbank-gmrt/thresh_1d.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-  This routine will apply the threshold test.
-
-  */
-
-#include <math.h>
-#include <stdio.h>
-#include <string.h>
-#include "pulse.h"
-
-void thresh_1d(ndata, realdata, ns, npulse, pulses, thresh, scrdsk)
-int ndata;
-char scrdsk[];
-float realdata[], thresh;
-int ns;
-int *npulse;
-Pulsus *pulses;
-{
-  int i, nd;
-  double mean, rms, smean, srms, test;
-  char *outfile;
-
-  char dir1[132];
-
-  strcpy(dir1,scrdsk);
-
-  mean = realdata[0];
-  rms = realdata[0]*realdata[0];
-
-  for (i=1; i<ndata; i++)
-    {
-      mean += realdata[i];
-      rms += realdata[i]*realdata[i];
-    }
-
-  smean = mean;
-  mean /= (double)ndata;
-  srms = rms;
-  test = (double)rms - (double)ndata*pow((double)mean, 2.0);
-  if (test < 0) printf("test = %f, rms = %f, mean = %f, ndata = %d\n",test,rms,mean,ndata);
-  rms = (double)sqrt(((double)rms - (double)ndata*pow((double)mean, 2.0))/(double)(ndata-1));
-
-  /*
-    Run through the time series again, this time comparing each sample
-    with the threshold.
-
-    NOTE:  The important thing, when figuring out the index in the time
-    series, is not how many times the time series has been smoothed, but
-    how many times it's been *decimated*.  The way single_ch() is currently
-    structured, the number of times the series has been decimated is (ns-1),
-    except for ns==0.
-
-    Also, adjust the mean and rms to remove pulses.  This prepares for
-    the final pass through the series below.
-    */
-
-  *npulse = 0;
-
-  if (ns)
-    nd = (int)pow(2.0, (double)(ns-1));
-  else
-    nd = 1;
-
-
-  for (i=0; i<ndata; i++)
-    {
-      float x;
-
-      x = (realdata[i] - mean)/rms; 
-      if ( x > thresh )
-        {
-          pulses[*npulse].index = i*nd + iindx;
-          pulses[*npulse].amp = x;
-          pulses[*npulse].mean = mean;
-          pulses[*npulse].rms = rms;
-
-          smean -= realdata[i];
-          srms -= realdata[i]*realdata[i];
-
-          (*npulse)++;
-        }
-    }
-      mean = smean/(double)(ndata-*npulse);
-      test = (double)srms - (double)(ndata-*npulse)*pow((double)mean, 2.0);
-      if (test < 0) printf("test = %f, rms = %f, mean = %f, ndata = %d\n",test,rms,mean,ndata);
-      rms = (double)sqrt(((double)srms - (double)(ndata-*npulse)*pow((double)mean, 2.0))/(double)(ndata-*npulse-1));
-
-      *npulse = 0;
-      for (i=0; i<ndata; i++)
-        {
-          float x;
-
-          x = (realdata[i] - mean)/rms;
-
-          if ( x > thresh )
-            {
-              pulses[*npulse].index = i*nd + iindx;
-              pulses[*npulse].amp = x;
-              pulses[*npulse].mean = mean;
-              pulses[*npulse].rms = rms;
-
-              smean -= realdata[i];
-              srms -= realdata[i]*realdata[i];
-
-              (*npulse)++;
-            }
-    }
-
-  return;
-}
-
-
diff --git a/filterbank-gmrt/time.inc b/filterbank-gmrt/time.inc
deleted file mode 100644
index 17bee6d..0000000
--- a/filterbank-gmrt/time.inc
+++ /dev/null
@@ -1,15 +0,0 @@
-c==============================================================================
-c Definition of the raw time series.
-c==============================================================================
-c
-      include 'npts.inc'
-      integer ntim ! actual number of points in time series
-      integer ntim2! actual number of points in time series
-      integer noff ! offset number of time samples (for fakedata)
-      integer iseg ! offset number of segments (for fakedata)
-      real series  ! time series
-      common /data/ series(npts)
-      common /idat/ ntim,ntim2,noff,iseg
-c
-c==============================================================================
-
diff --git a/filterbank-gmrt/timer.f b/filterbank-gmrt/timer.f
deleted file mode 100644
index 825c057..0000000
--- a/filterbank-gmrt/timer.f
+++ /dev/null
@@ -1,33 +0,0 @@
-c
-c     These two routines can be called from any two points within a program
-c     to start and stop a stop watch based on MJDs from the ship's clock.
-c     Note that the logical unit number for the output is required (6=screen)
-c
-c     Creation date: 98/04/30 (dunc@mpifr-bonn.mpg.de)
-c      
-c==============================================================================
-      subroutine timstart(llog)
-c==============================================================================
-c      
-      integer llog
-      double precision mjds,mjdf
-      common /timer/ mjds,mjdf
-      save
-      call getmjd(mjds)
-      write(llog,*) 'Timer is up and running...'
-      end
-c      
-c==============================================================================
-      subroutine timfinis(llog)
-c==============================================================================
-c      
-      integer llog
-      double precision mjds,mjdf
-      common /timer/ mjds,mjdf
-      save
-      call getmjd(mjdf)
-      write(llog,*) 'Timer clocked',
-     &nint((mjdf-mjds)*86400.0),' s for this job.'
-      end
-c      
-c==============================================================================
diff --git a/filterbank-gmrt/tree.c b/filterbank-gmrt/tree.c
deleted file mode 100644
index 8a312c7..0000000
--- a/filterbank-gmrt/tree.c
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
-  TREE - dedisperses filterbank data using the tree algorithm. 
-  
-  Ramach, 09-MAY-2004, Green Bank.
-  added to SIGPROC version 3.3 (drl-May 2005)
-*/
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include <fcntl.h>
-#include <math.h>
-#include <string.h>
-
-int     DMMin, DMMax, FlipSwitch, FlipSwitch;
-double  TSkip, TRead, DMMinv, DMMaxv;
-char   *unfname;
-
-#include "sigproc.h"
-#include "header.h"
-int nbands, nobits, userdm;
-FILE *output;
-
-void tree_help() {
-  puts("");
-  puts("tree - dedisperses filterbank data rapidly using the tree algorithm");
-  puts("");
-  puts("usage : tree <options> <UniqueID>");
-  puts("");
-  puts("-s skip - time length to skip (s; def=0)");
-  puts("-r read - time length to read (s; def=largest 2^n*tsamp)");
-  puts("-l dmlo - lower DM index to write (def=0)");
-  puts("-u dmup - upper DM index to write (def=nchan-1)");
-  puts("");
-  exit(0);
-}
-
-
-void tree_parms(int argc, char *argv[]) {
-
-  int   i;
-
-  unfname    = (char *) calloc(120, sizeof(char));
-  DMMin      = 0;
-  DMMax      = 0;
-  TSkip      = 0.0;
-  TRead      = 0.0;
-  FlipSwitch = 1;
-
-  for (i=0; i<argc; i++) {
-     if (strcmp(argv[i], "-l") == 0) {
-      sscanf(argv[i+1], "%d", &DMMin);
-    }
-
-    if (strcmp(argv[i], "-u") == 0) {
-      sscanf(argv[i+1], "%d", &DMMax);
-    }
-
-    if (strcmp(argv[i], "-s") == 0) {
-      sscanf(argv[i+1], "%lf", &TSkip);
-    }
-
-    if (strcmp(argv[i], "-r") == 0) {
-      sscanf(argv[i+1], "%lf", &TRead);
-    }
-
-    if (strcmp(argv[i], "-noflip") == 0) {
-      FlipSwitch = 0;
-      printf("\n");
-      printf("THE BAND IS NOT FLIPPED!!\n");
-    }
-  }
-
-  strcpy(unfname,argv[argc-1]);
-  printf("\n");
-  printf("Unique file name                  : %s\n",unfname);
-
-  return;
-}
-/*  ======================================================================  */
-/*  This function bit-reverses the given value "inval" with the number of   */
-/*  bits, "nbits".    ----  R. Ramachandran, 10-Nov-97, nfra.               */
-/*  ======================================================================  */
-
-
-int bitrev(int inval,int nbits)
-{
-     int     ifact,k,i,ibitr;
-
-     if(nbits <= 1)
-     {
-          ibitr = inval;
-     }
-     else
-     {
-          ifact = 1;
-          for (i=1; i<(nbits); ++i)
-               ifact  *= 2;
-          k     = inval;
-          ibitr = (1 & k) * ifact;
-
-          for (i=2; i < (nbits+1); i++)
-          {
-               k     /= 2;
-               ifact /= 2;
-               ibitr += (1 & k) * ifact;
-          }
-     }
-     return ibitr;
-}
-
-void AxisSwap(float Inbuf[],
-	      float Outbuf[], 
-	      int   nchans, 
-	      int   NTSampInRead) {
-  int    j1, j2, indx, jndx;
-
-  for (j1=0; j1<NTSampInRead; j1++) {
-    indx  = (j1 * nchans);
-    for (j2=(nchans-1); j2>=0; j2--) {
-      jndx = (j2 * NTSampInRead + j1);
-      Outbuf[jndx]  = Inbuf[indx+j2];
-    }
-  }
-
-  return;
-}
-void  FlipBand(float  Outbuf[], 
-	       int    nchans, 
-	       int    NTSampInRead) {
-
-  int    indx, jndx, kndx, i, j;
-  float *temp;
-
-  temp  = (float *) calloc((NTSampInRead*nchans), sizeof(float));
-
-  indx  = (nchans - 1);
-  for (i=0; i<nchans; i++) {
-    jndx = (indx - i) * NTSampInRead;
-    kndx = (i * NTSampInRead);
-    memcpy(&temp[jndx], &Outbuf[kndx], sizeof(float)*NTSampInRead);
-  }
-  memcpy(Outbuf, temp, (sizeof(float)*NTSampInRead * nchans));
-
-  free(temp);
-
-  return;
-}
-/*  ======================================================================  */
-/*  This is a function to Taylor-dedisperse a data stream. It assumes that  */
-/*  the arrangement of data stream is, all points in Chn.1, all points in   */
-/*  Chn.2, and so forth.                                                    */
-/*                     R. Ramachandran, 07-Nov-97, nfra.                    */
-/*                                                                          */
-/*  outbuf[]       : input array (short int), replaced by dedispersed data  */
-/*                   at the output                                          */
-/*  mlen           : dimension of outbuf[] (int)                            */
-/*  nchn           : number of frequency channels (int)                     */
-/*                                                                          */
-/*  This programme has been debugged and finalised! The main programme used */
-/*  for this purpose is "testtaylor.c", along with the function bitrev.c,   */
-/*  which does the bit-reversal.  ----  R. Ramachandran, 10-Nov-97, nfra.   */
-/*  ======================================================================  */
-
-void taylor_flt(float outbuf[], int mlen, int nchn)
-{
-  float itemp;
-  int   nsamp,npts,ndat1,nstages,nmem,nmem2,nsec1,nfin, i;
-  int   istages,isec,ipair,ioff1,i1,i2,koff,ndelay,ndelay2;
-  int   bitrev(int, int);
-
-  /*  ======================================================================  */
-
-  nsamp   = ((mlen/nchn) - (2*nchn));
-  npts    = (nsamp + nchn);
-  ndat1   = (nsamp + 2 * nchn);
-  nstages = (int)(log((float)nchn) / 0.6931471 + 0.5);
-  nmem    = 1;
-
-
-  for (istages=0; istages<nstages; istages++) {
-    nmem  *= 2;
-    nsec1  = (nchn/nmem);
-    nmem2  = (nmem - 2);
-
-    for (isec=0; isec<nsec1; isec++) {
-      ndelay = -1;
-      koff   = (isec * nmem);
-
-      for (ipair=0; ipair<(nmem2+1); ipair += 2) {
-	ioff1   = (bitrev(ipair,istages+1)+koff) * ndat1;
-	i2      = (bitrev(ipair+1,istages+1) + koff) * ndat1;
-	ndelay++;
-	ndelay2 = (ndelay + 1);
-	nfin    = (npts + ioff1);
-	for (i1=ioff1; i1<nfin; i1++) {
-	  itemp      = (outbuf[i1] + outbuf[i2+ndelay]);
-	  outbuf[i2] = (outbuf[i1] + outbuf[i2+ndelay2]);
-	  outbuf[i1] = itemp;
-	  i2++;
-	}
-      }
-    }
-  }
-
-  return;
-}
-
-
-main(int argc, char** argv)
-{
-  int dum_int, iread, iw, indx, ITStart, namelen, HdrSize,
-    NTOT, NSkip, NPtsToRead, SkiByte, log2NTOT, NDM,
-    NOPFiles, MAX, NTSampInRead, i, NSampInRead, BytePerFrame,
-    NByteInRead, ITOffset, NBitChan, *ibrev, NRead, IFiles, FOld,
-    FNew, FSwitch, KeepTrack, NTReadOld, NTReadNew, NReadOld,
-    NReadNew, OPFileSize, IOffset, SkipByte, oldper, newper ,NT_Files;
-
-  long long TotalTrack;
-
-  float  FMin, FMax, FCen, *Inbuf, *Outbuf, timecount;
-
-  char  *filename, *filefull, *parfile;
-
-  FILE  *fpar, *Fout[8192], *Fin;
-
-  if (argc <= 1) 
-    tree_help();
-  else 
-    tree_parms(argc, argv);
-
-  filename   = (char *) calloc(120, sizeof(char));
-  filefull   = (char *) calloc(120, sizeof(char));
-  parfile    = (char *) calloc(120, sizeof(char));
-
-  ITStart = 0; NT_Files = 0;
-
-  /* To read a sample header from first time file */
-
-  strcpy(filename, unfname);
-  namelen    = strlen(filename);
-
-  printf("First filename   : %s\n", filename);
-  if ((fpar     = fopen(filename, "rb")) == NULL) {
-    printf("ERROR opening file %s.\n", filename);
-    exit(0);
-  }
-  HdrSize  = read_header(fpar);
-  fclose(fpar);
-
-  FMin     = fch1;
-  FMax     = FMin + (float)(nchans - 1) * foff;
-  FCen     = (FMin + FMax) / 2.0;
-
-  printf("No. of frequency channels        : %d\n",nchans);
-  printf("Beginning radio frequency        : %f MHz\n", FMin - (foff / 2.0));
-  printf("Ending radio frequency           : %f MHz\n", FMax + (foff / 2.0));
-  printf("Centre frq. of the whole band    : %f MHz\n", FCen);
-  printf("\n");
-  printf("input sampling interval       : %f sec\n", tsamp);
-
-  NTOT = 0;
-  strcpy(filename, unfname);
-  namelen    = strlen(filename);
-  if ((fpar       = fopen(filename, "rb")) == NULL) {
-    printf("ERROR opening %s.\n", filename);
-  }
-
-  HdrSize    = read_header(fpar);
-  fclose(fpar);
-
-  NT_Files = (int)nsamples(filename, HdrSize, nbits, nifs, nchans);
-
-  NTOT       += NT_Files;
-  printf("File %5d   : %s with %d samples\n", i, filename, NT_Files);
-
-  NSkip      = (int)(TSkip / tsamp);
-  if (NSkip > NT_Files) {
-    printf("Initial Skip-length longer than the first file!\n");
-    exit(0);
-  }
-
-  NPtsToRead = (int)(TRead / tsamp);
-  if (NPtsToRead==0) {
-    TRead=NT_Files*tsamp;
-    NPtsToRead=NT_Files;
-  }
-  if (NPtsToRead > NTOT) NPtsToRead = NTOT;
-  SkipByte   = (NSkip * nbits * nchans / 8);
-
-  printf("\n");
-  printf("This data set contains %d number of samples\n", NTOT);
-  printf("Number of bits per sample          : %d\n", nbits);
-  printf("Time length to skip at the begin.  : %f\n", TSkip);
-  printf("Bytes to skip at the beginning     : %d\n", SkipByte);
-  printf("No. of time samples to skip        : %d\n", NSkip);
-  printf("Time length to read after skipping : %f\n", TRead);
-  printf("Samples to read after skipping     : %d\n", NPtsToRead);
-
-  NTOT  -= NSkip;
-  printf("Time samples after initial skip    : %d\n", NTOT);
-
-  if (NPtsToRead > NTOT) {
-    NPtsToRead  = NTOT;
-    printf("Too many samples to read. Truncated to %d samples\n", NTOT);
-  } else
-    NTOT  = NPtsToRead;
-
-  log2NTOT = (int)(log((double)NTOT) / log((double)2.0));
-  NTOT     = (1 << log2NTOT);
-  printf("After truncating to lower 2^n      : %d\n", NTOT);
-
-  if (DMMin < 0) DMMin = 0;
-  if (DMMax >= nchans) DMMax = (nchans - 1);
-  if ((DMMin == 0) && (DMMax == 0)) {
-    DMMin = 0; DMMax = (nchans - 1);
-  } else if ((DMMin != 0) && (DMMax == 0)) 
-    DMMax = (nchans - 1);
-  printf("\n");
-  printf("Minimum DM index = %d   Maximum = %d\n", DMMin, DMMax);
-  DMMinv=(tsamp/8.3e3)*(double)(DMMin)*pow((FMax+FMin)/2.,3.)/fabs(FMax-FMin);
-  DMMaxv=(tsamp/8.3e3)*(double)(DMMax)*pow((FMax+FMin)/2.,3.)/fabs(FMax-FMin);
-  printf("Minimum DM value = %f   Maximum = %f\n", DMMinv,DMMaxv);
-  NDM        = (DMMax - DMMin + 1);
-
-  NOPFiles   = NDM;
-  OPFileSize = sizeof(float) * NTOT;
-
-  printf("\n");
-  printf("Total number of output files    : %d\n", NOPFiles);
-  printf("Size of each output file        : %d bytes\n", OPFileSize);
-
-  for (i=0; i<NOPFiles; i++) {
-    strcpy(filefull,unfname);
-    sprintf(&filefull[strlen(filefull)-4], ".DM%.4d.tim", (i+DMMin));
-    if((Fout[i] = fopen(filefull,"wb")) == NULL) {
-      printf("ERROR opening output file %s.\n", filefull);
-      exit(0);
-    } else {
-      nbands=1;
-      nobits=32;
-      refdm=(tsamp/8.3e3)*(double)(i+DMMin)*pow((FMax+FMin)/2.,3.)/
-	fabs(FMax-FMin);
-      output=Fout[i];
-      dedisperse_header();
-    }
-  }
-  printf("\n");
-
-  /*
-  strcpy(parfile, "\0"); strcpy(parfile, unfname);
-  strncat(parfile, ".par", 4);
-  fpar = fopen(parfile, "w");
-  fprintf(fpar, "%s\n", unfname);
-  fprintf(fpar, "%d  %d  %10.8f \n ", NTOT, nchans, tsamp);
-  fprintf(fpar, "%d  %d  %d  %d\n", DMMin, DMMax, NDM, NOPFiles);
-  fprintf(fpar, "%d\n", nchans);
-  fprintf(fpar, "%f %f\n", FMin, FMax);
-  fclose(fpar);
-  */
-
-  MAX          = (1 << 12);
-  if (MAX > NTOT) MAX = NTOT;
-
-  NTSampInRead = (MAX + (2 * nchans));
-  NSampInRead  = (nchans * NTSampInRead);
-  BytePerFrame = (nchans * nbits / 8);
-  NByteInRead  = (NTSampInRead * BytePerFrame);
-
-  ITOffset     = 2 * nchans;
-  IOffset      = (-ITOffset * BytePerFrame);
-
-  NBitChan = (int)(log((double)nchans) / 0.6931471);
-
-  printf("Time samples to read in one read      : %d\n", NTSampInRead);
-  printf("Bytes to read in one read             : %d bytes\n", NByteInRead);
-  printf("Offset counter for each read          : %d time samples\n", IOffset);
-  printf("\n");
-  printf("No of bits to represent all channels  : %d\n", NBitChan);
-
-  Inbuf    = (float *) calloc(NSampInRead, sizeof(float));
-  Outbuf   = (float *) calloc(NSampInRead, sizeof(float));
-  ibrev    = (int *)   calloc(nchans, sizeof(int));
-
-  for (i=0; i<nchans; i++) {
-    ibrev[i] = bitrev(i, NBitChan);
-  }
-
-  NRead    = (int)(NTOT / MAX);
-  printf("Total number of reads in the run       : %d\n", NRead);
-
-  IFiles   = 0;
-  FOld     = 0;
-  FNew     = 0;
-  FSwitch  = 1;
-
-  strcpy(filename, unfname);  namelen    = strlen(filename);
-  printf("First filename   : %s\n", filename);
-  if ((Fin = fopen(filename, "rb")) == NULL) {
-    printf("ERROR opening file %s.\n", filename);
-    exit(0);
-  }
-  HdrSize  = read_header(Fin);
-  printf("Going into the main loop\n");
-
-  fseek(Fin, SkipByte, SEEK_CUR);
-  KeepTrack = (NT_Files - NSkip);
-  TotalTrack = 0;
-
-  newper   = 0.0;
-  oldper   = newper;
-  printf("\n\n");
-  for (iread=0; iread<NRead; iread++) {
-
-    newper = 100.0 * (((float)iread / (float)NRead));
-    if (newper > oldper) {
-      timecount = ((float)iread * NTSampInRead * tsamp);
-      printf("\rProcessed : %3d%%    Current file : %s    Time from beg : %8.2f sec", 
-	     (int)newper, filename, timecount); fflush(stdout);
-      oldper = newper;
-    }
-
-    KeepTrack  -= NTSampInRead;
-    TotalTrack += NTSampInRead;
-
-    if (KeepTrack > 0) {
-      read_block(Fin, nbits, Inbuf, NSampInRead);
-      fseek(Fin, IOffset, SEEK_CUR);
-      KeepTrack  += ITOffset;
-      TotalTrack -= ITOffset;
-    }
-
-    if (KeepTrack > 0) FSwitch = 1;
-
-    memset(&Outbuf[0], 0, (sizeof(float) * NSampInRead));
-
-    AxisSwap(Inbuf, Outbuf, nchans, NTSampInRead);
-
-    if (FlipSwitch == 0)  {
-      printf("BEFORE..."); fflush(stdout);
-      FlipBand(Outbuf, nchans, NTSampInRead);
-      printf("AFTER!\n");
-    }
-
-    taylor_flt(Outbuf, NSampInRead, nchans);
-
-    for (iw=DMMin; iw<=DMMax; iw++) {
-      indx  = (ibrev[iw] * NTSampInRead);
-      fwrite(&Outbuf[indx], sizeof(float), MAX, Fout[iw-DMMin]);
-    }
-  }
-
-  newper    = 100.0 * ((float)iread / NRead);
-  timecount = ((float)iread * NTSampInRead * tsamp);
-  printf("\rProcessed : %3d%%    Current file : %s    Time from beg : %8.2f sec", 
-	 (int)newper, filename, timecount); fflush(stdout);
-  printf("\n\n");
-
-  for (i=0; i<NOPFiles; i++) fclose(Fout[i]);
-
-  exit(0);
-}
diff --git a/filterbank-gmrt/tssb.f b/filterbank-gmrt/tssb.f
deleted file mode 100644
index 48346d2..0000000
--- a/filterbank-gmrt/tssb.f
+++ /dev/null
@@ -1,39 +0,0 @@
-      program tssb
-c
-c     quick utility to return the barycentric arrival time
-c     by calling tempo given RA and DEC and a topocentric time
-c
-      implicit none
-      character*80 ra,dec,topo,obs
-      double precision mjd,pfphi,pfsec,orphi,freq,wgt,etoa,prephi,tmp
-      
-      call getarg(1,ra)
-      call getarg(2,dec)
-      call getarg(3,topo)
-      call getarg(4,obs)
-      if (obs.eq." ") stop "usage: tssb RA DEC MJD SITE"
-
-      open(10,file="tssb.par",status="unknown")
-      write(10,'(''PSR 0000+00'')')
-      write(10,'(''RAJ '',a)') ra(1:index(ra," ")-1)
-      write(10,'(''DECJ '',a)') dec(1:index(dec," ")-1)
-      write(10,'(''F0 1.0'')')
-      write(10,'(''DM 0.0'')')
-      write(10,'(''PEPOCH '',a)') topo(1:index(topo," ")-1)
-      close(10)
-
-      read(topo,*) mjd
-      open(10,file="tssb.tim",status="unknown")
-      write(10,'(a1,7x,a7,1x,f8.3,1x,f19.13,1x,i4,3x,f6.2)')
-     &       obs(1:1),"0000+00",9999.0,mjd,1024,10.0
-      close(10)
-
-      call system("tempo tssb.tim > /dev/null")
-      open(10,file="resid2.tmp",form="unformatted")
-      read(10) mjd,pfphi,pfsec,orphi,freq,wgt,etoa,prephi,tmp
-      close(10)
-      write(*,'(f19.13)') mjd
-
-      call system("rm -f tssb.tim tssb.par tempo.lis resid2.tmp")
-      call system("rm -f 0000+00.par")
-      end
diff --git a/filterbank-gmrt/tune.c b/filterbank-gmrt/tune.c
deleted file mode 100644
index 6e9ea14..0000000
--- a/filterbank-gmrt/tune.c
+++ /dev/null
@@ -1,1071 +0,0 @@
-/*
-   TUNE
-   MK 2005 -- Based on fold.c 
-   This will try and tune using stack algorithm
- */
-#include "fold.h"
-#include "cpgplot.h"
-#include <string.h>
-
-#define SPEED_OF_LIGHT  299792458.0
-
-void     quikgray(float*dat,int nx,int ny,int nxx);
-
-
-struct tuneparam{
-	float maxPer;
-	float minPer;
-	float incPer;
-	float maxAcc;
-	float minAcc;
-	float incAcc;
-	float maxJer;
-	float minJer;
-	float incJer;
-};
-
-int main (int argc, char *argv[])
-{
-	/* local variables */
-	FILE *bestfile;
-	FILE *jreaperfile;
-	FILE *tunelistfile;
-	double fftperiod,fftsnr,fftdm;
-	double pfactor,newmjd=0.0;
-	float sefd,sub_time;
-	int i,opened_input=0,opened_output=0,headersize=0;
-	char string[80],format[40],jreaperfilename[40];
-	char stemname[80],susname[40];
-	int j,n,psnum,hrmnum;
-	int nsubints,nbins150;
-	float **subintArray;
-	float **subintEnds;
-	float *fortranSubintArray; 
-	float dmcurve[1000],dmcurvidx[1000];
-	int ndms; /* The number of elements used in the dmcurve array */
-	float realDM;
-	float perFactor,perMaxMax,perMaxMin, realPer;
-	float accFactor,accMaxMax,accMaxMin, realAcc;
-	float jerFactor,jerMaxMax,jerMaxMin, realJer;
-	struct tuneparam param;
-	float *fPtr, *sumProfile;
-	float s,sMax,sSquared,sSquMax,rms;
-	float mean,variance,snr,snrMax,snrMaxMax;
-	float sum;
-	int width,widthMax,widthMaxMax,widthLimit;
-	int houghposn;
-	int usepgplot; /*flag to use pgplot or to write data out to file */
-	int usequikgray,usequadratic;
-	float *snrMap,*snrMapPtr;
-	float *houghplot,*finalsubint;
-
-	int writejreaper,writelogfile;
-	double deltaT,truePeriod; 
-	float max,min,maxMax,minMax;
-	float tr[6];
-	float x1,x2,y1,y2,xleft,xright,ytop,ybottom,xscale,yscale,scale;
-	float pf,af,jf;
-	/* set up default globals */
-
-	fftperiod=fftdm=fftsnr=-1.0;
-	usepgplot=baseline=ascii=multiple=1;
-	npuls=binary=totalpower=accumulate=0;
-	time_offset=acceleration=skip_time=read_time=0.0;
-	asciipol=psrfits=stream=headerless=npulses=0;
-	phase_start=folding_period=dump_time=tsamp_user=0.0;
-	phase_finish=pfactor=1.0;
-	jyfactor=sefd=userbase=0.0;
-	nbins=0; /* this will get set in the folding routine if not set by user */
-	strcpy(polyco_file,"");
-	psnum = 0;
-	usequadratic=usequikgray=writejreaper = 0;
-	maxMax = -1000;
-	nsubints = 128;
-	nbins = 64;
-	baseline=0;
-	pf=af=jf=1.0;
-	strcpy(format,"/XSERV");
-	ndms = 0;
-	/* check the command line parameters */
-	i=1;
-	while (i<argc) {
-		print_version(argv[0],argv[1]);
-		if (strings_equal(argv[i],"-o")) {
-			/* get and open file for output */
-			i++;
-			strcpy(outfile,argv[i]);
-			output=fopen(outfile,"wb");
-			opened_output=1;
-		}else if (strings_equal(argv[i],"-format")) {
-			/* get output format*/
-			i++;
-			strcpy(format,argv[i]);
-		}else if (strings_equal(argv[i],"-jreaper")) {
-			/* set writejreaper*/
-			writejreaper=1;
-			i++;
-			strcpy(jreaperfilename,argv[i]);
-
-		}else if (strings_equal(argv[i],"-quikgray")) {
-			/* set quikgray*/
-			usequikgray=1;
-
-		}else if (strings_equal(argv[i],"-quadgray")) {
-			/* set quadratic*/
-			usequadratic=1;
-		}else if (strings_equal(argv[i],"logfile")) {
-			/* set writejreaper*/
-			writejreaper=1;
-			i++;
-			strcpy(jreaperfilename,argv[i]);
-
-
-		}else if (strings_equal(argv[i],"-bestfile")) {
-			/* load dmcurv and params from 'best' output */
-			i++;
-			strcpy(string,argv[i]);
-			bestfile = fopen(string,"r");
-			fscanf(bestfile,"%s",inpfile);
-			input=open_file(inpfile,"rb");
-			opened_input=1;
-
-
-			fscanf(bestfile,"%lf %lf %lf %d\n",&fftperiod,&fftsnr,&fftdm,&hrmnum);
-			folding_period = fftperiod;
-			realDM=fftdm;
-			ndms = 0;
-			while(!feof(bestfile)){
-				fscanf(bestfile,"%d %f %f\n",&j,dmcurvidx+ndms,dmcurve+ndms);
-				ndms++;
-			}
-
-			fclose(bestfile);
-
-		} else if (strings_equal(argv[i],"-m")) {
-			multiple=atoi(argv[++i]);
-		} else if (strings_equal(argv[i],"-p")) {
-			/* get folding period */
-			i++;
-			if (file_exists(argv[i])) {
-				strcpy(polyco_file,argv[i]);
-				folding_period=-1.0;
-			} else {
-				folding_period=atof(argv[i]);
-			}
-		} else if (strings_equal(argv[i],"-dt")) {
-			/* add a time offset in seconds to tstart */
-			time_offset=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-mjd")) {
-			/* change the start time completely! */
-			newmjd=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-sk")) {
-			/* skip the first skip_time seconds before folding */
-			skip_time=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-re")) {
-			/* read and fold only read_time seconds of data */
-			read_time=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-a")) {
-			/* get acceleration for folding */
-			acceleration=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-d")) {
-			/* get dumptime or number of pulses for subintegrations */
-			i++;
-			if (strcspn(".",argv[i])) {
-				npulses=atoi(argv[i]);
-			} else {
-				dump_time=atof(argv[i]);
-			}
-		} else if (strings_equal(argv[i],"-t")) {
-			/* get user-supplied sampling time */
-			i++;
-			tsamp_user=atof(argv[i]);
-		} else if (strings_equal(argv[i],"-j")) {
-			/* get user-supplied Jansky calibration factor */
-			jyfactor=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-s")) {
-			/* get user-supplied SEFD */
-			sefd=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-b")) {
-			/* get user-supplied baseline */
-			baseline=0;
-			userbase=atof(argv[++i]);
-		} else if (strings_equal(argv[i],"-f")) {
-			/* get period multiplication factor */
-			i++;
-			pfactor=atof(argv[i]);
-		} else if (strings_equal(argv[i],"-l")) {
-			/* get leading phase of pulse */
-			i++;
-			phase_start=atof(argv[i]);
-			if ( (phase_start < 0.0) || (phase_start > 1.0) ) 
-				error_message("start pulse phase out of range!");
-		} else if (strings_equal(argv[i],"-r")) {
-			/* get trailing phase of pulse */
-			i++;
-			phase_finish=atof(argv[i]);
-			if ( (phase_finish < 0.0) || (phase_finish > 1.0) ) 
-				error_message("final pulse phase out of range!");
-		} else if (strings_equal(argv[i],"-n")) {
-			/* get number of bins */
-			i++;
-			nbins=atoi(argv[i]);
-		} else if (strings_equal(argv[i],"-sub")) {
-			/* get number of subints */
-			i++;
-			nsubints=atoi(argv[i]);
-
-		} else if (strings_equal(argv[i],"-pf")) {
-			/* get period multiplication factor */
-			i++;
-			pf=atof(argv[i]);
-		} else if (strings_equal(argv[i],"-af")) {
-			/* get period multiplication factor */
-			i++;
-			af=atof(argv[i]);
-		} else if (strings_equal(argv[i],"-jf")) {
-			/* get period multiplication factor */
-			i++;
-			jf=atof(argv[i]);
-		} else if (strings_equal(argv[i],"-ascii")) {
-			/* write data as ASCII numbers */
-			ascii=1;
-		} else if (strings_equal(argv[i],"-totalpower")) {
-			/* sum polarizations 1+2 before writing */
-			totalpower=1;
-		} else if (strings_equal(argv[i],"-epn")) {
-			/* write data in EPN format */
-			ascii=0;
-		} else if (strings_equal(argv[i],"-bin")) {
-			/* write data in SIGPROC binary format */
-			binary=1;
-		} else if (strings_equal(argv[i],"-acc")) {
-			/* write out accumulated pulse profiles in subints */
-			accumulate=1;
-		} else if (strings_equal(argv[i],"-asciipol")) {
-			/* write data as ASCII numbers for Jim's polarization code */
-			asciipol=1;
-		} else if (strings_equal(argv[i],"-psrfits")) {
-			/* write data in PSRFITS format */
-			ascii=0;
-			psrfits=1;
-#ifndef PSRFITS
-			error_message("-psrfits option not supported in this compilation...\nConsult the SIGPROC manual for further information about PSRFITS.");
-#endif
-		} else if (strings_equal(argv[i],"-stream")) {
-			/* write data as ASCII streams */
-			stream=1;
-		} else if (strings_equal(argv[i],"-sub")) {
-			/* shorthand for -nobaseline -stream -d x */
-			stream=1;
-			baseline=0;
-			i++;
-			if (strcspn(".",argv[i])) {
-				npulses=atoi(argv[i]);
-			} else {
-				dump_time=atof(argv[i]);
-			}
-		} else if (strings_equal(argv[i],"-nobaseline")) {
-			/* processing correlation functions so don't subtract baseline */
-			baseline=0;
-		} else if (file_exists(argv[i])) {
-			/* get and open file for input */
-			strcpy(inpfile,argv[i]);
-			input=open_file(inpfile,"rb");
-			opened_input=1;
-		} else if (help_required(argv[i])) {
-			tune_help();
-			exit(0);
-		} else {
-			/* unknown argument passed down - stop! */
-			fold_help();
-			sprintf(string,"unknown argument (%s) passed to %s",argv[i],argv[0]);
-			error_message(string);
-		}
-		i++;
-	}
-
-	/* get appropriate calibration factor from SEFD and baseline */
-	if (sefd != 0.0 && userbase != 0.0) jyfactor=sefd/userbase;
-
-	/* multiply folding period by user-supplied factor */
-	if (folding_period != -1.0) folding_period*=pfactor;
-
-	/* check start and end phase of pulse */
-	if (phase_start >= phase_finish) 
-		error_message("silly pulse phases selected!");
-
-	/* check npulses versus dump_time */
-	if (npulses < 0) error_message("npulses < 0!");
-	if ((npulses > 0) && (dump_time > 0.0)) 
-		error_message("can't have npulses AND dumptime defined!");
-
-	/* check for folding period still set to zero - if so, look for polyco.dat */
-	if (folding_period == 0.0) {
-		strcpy(polyco_file,"polyco.dat");
-		if (file_exists(polyco_file)) {
-			folding_period=-1.0;
-		} else {
-			error_message("folding period not specified and no polyco.dat found!");
-		}
-	}
-
-	if (!opened_input) {
-		/* no input file selected, use standard input */
-		input=stdin;
-		strcpy(inpfile,"stdin");
-	}
-
-	/* read in the header parameters from the input stream */
-	if (!(headersize=read_header(input))) 
-		error_message("could not read header parameters!");
-
-	/*if (acceleration != 0.0) {*/
-	tobs=tsamp*(double)nsamples(inpfile,headersize,nbits,nifs,nchans);
-	if (tobs <= 0.0) error_message("could not get sensible observation time");
-	/*} */
-
-	/* override the header */
-	if (newmjd!=0.0) tstart=newmjd;
-
-	if (!opened_output) {
-		/* no output file selected, use standard output */
-		output=stdout;
-		strcpy(outfile,"stdout");
-	}
-
-	/* open the raw data file and establish its origin and header pars */
-	switch(data_type) {
-		case 1: 
-		case 2:
-		case 6:
-			open_log("fold.monitor");
-			/*   folded_profiles=fold_data();*/
-			break;
-		default:
-			error_message("input data is of unknown origin!!!");
-	}
-
-
-	if(nbins > (folding_period/1000.0)/tsamp) nbins = (int)((folding_period/1000.0)/tsamp +0.0001);
-	/* let people know we are about to start */
-
-	while(tobs/nsubints < folding_period/1000.0){
-		nsubints /= 2;
-	}
-
-	nbins150 = (int)(1.6*nbins);
-	sumProfile = malloc(sizeof(float)*nbins150);
-
-
-	param.minPer = -0.5/pf;
-	param.maxPer =  0.5/pf;
-	param.incPer =  0.01/pf;
-
-	/*
-	   param.minPer =  -0;
-	   param.maxPer =  0;
-	   param.incPer =  2/(double)nsubints;
-	 */
-
-	param.minAcc = -0.01/af;
-	param.maxAcc =  0.01/af;
-	param.incAcc =  0.0005/af;
-
-	param.minAcc =  -0.;
-	param.maxAcc =  0.;
-	param.incAcc =  0.02/(double)nsubints;
-
-	param.minJer = -0.001/jf;
-	param.maxJer =  0.001/jf;
-	param.incJer =  0.0006/jf;
-
-
-	param.minJer =  0.000;
-	param.maxJer =  0.000;
-	param.incJer =  0.02/(double)nsubints;
-
-
-
-
-	deltaT = param.maxPer * nsubints * (folding_period/1000.0) / nbins;
-	perMaxMax = folding_period  * (1.0 + deltaT/tobs);
-	deltaT = param.minPer * nsubints * (folding_period/1000.0) / nbins;
-	perMaxMin = folding_period  * (1.0 + deltaT/tobs);
-	deltaT = param.incPer * nsubints * (folding_period/1000.0) / nbins;
-	perFactor = folding_period  * (deltaT/tobs);
-
-
-
-	deltaT = param.maxAcc * nsubints * (folding_period/1000.0) / nbins;
-	accMaxMax =     SPEED_OF_LIGHT * deltaT/(tobs * folding_period/1000.0);
-	deltaT = param.minAcc * nsubints * (folding_period/1000.0) / nbins;
-	accMaxMin =     SPEED_OF_LIGHT * deltaT/(tobs * folding_period/1000.0);
-	deltaT = param.incAcc * nsubints * (folding_period/1000.0) / nbins;
-	accFactor =     SPEED_OF_LIGHT * deltaT/(tobs * folding_period/1000.0);
-
-	deltaT = param.maxJer * nsubints * (folding_period/1000.0) / nbins;
-	jerMaxMax = SPEED_OF_LIGHT * deltaT/(tobs*tobs*folding_period/1000.0);
-	deltaT = param.minJer * nsubints * (folding_period/1000.0) / nbins;
-	jerMaxMin =  SPEED_OF_LIGHT * deltaT/(tobs*tobs*folding_period/1000.0);
-	deltaT = param.incJer * nsubints * (folding_period/1000.0) / nbins;
-	jerFactor =  SPEED_OF_LIGHT * deltaT/(tobs*tobs*folding_period/1000.0);
-
-
-	printf("Num Per: %d (%f,%f,%e) ms\n",(int)((param.maxPer - param.minPer)/param.incPer +1),perMaxMin,perMaxMax,perFactor);
-	printf("Num Acc: %d (%f,%f,%f) m/s/s\n",(int)((param.maxAcc - param.minAcc)/param.incAcc +1),accMaxMin,accMaxMax,accFactor);
-	printf("Num Jer: %d (%g,%g,%g) m/s/s/s\n",(int)((param.maxJer - param.minJer)/param.incJer +1),jerMaxMin,jerMaxMax,jerFactor);
-
-	printf("Total Trials: %d\n",(int)((param.maxPer - param.minPer)/param.incPer +1)*(int)((param.maxAcc - param.minAcc)/param.incAcc +1)*(int)((param.maxJer - param.minJer)/param.incJer +1));
-
-
-	skip_time = 0.0;
-	sub_time = tobs/nsubints;
-	subintArray = malloc(sizeof(float*)*nsubints);
-	fortranSubintArray = malloc(sizeof(float)*nsubints*nbins);
-
-	i = (int)(sub_time / (folding_period/1000.0));
-
-	sub_time = (folding_period/1000.0) * i;
-
-	read_time = sub_time;
-
-
-	max = -10000.0f;
-	min = 10000.0f;
-	printf("Generating %d subints:\nTobs: %lf",nsubints,tobs);
-
-
-	for(j = 0;j<nsubints;j++){	
-		/*	printf("%4.3lf %4.3lf %4.2lf %4.2lf %4.2f\n",tobs,tsamp,read_time,skip_time,sub_time);*/
-		subintArray[j]=fold_data();
-
-		/* 	printf("%4.3lf %4.3lf %4.2lf %4.2lf\n",tobs,tsamp,read_time,skip_time);*/
-		/* 	write_profiles(subintArray[j],nbins,nchans,nifs,output);*/
-
-		for(i = 0; i < nbins; i++){
-			fortranSubintArray[i+nbins*j] = subintArray[j][i]*subintArray[j][i];
-			if(subintArray[j][i] < min)min = subintArray[j][i];
-			if(subintArray[j][i] > max) max = subintArray[j][i];
-		}
-		rewind(input);
-		read_header(input);
-		skip_time = (j+1)*sub_time;
-		read_time = sub_time;
-	}
-	for(j = 0;j<nsubints;j++){
-		for(i = 0; i < nbins; i++){
-			subintArray[j][i] = (subintArray[j][i]-min)/(max - min);	
-			fortranSubintArray[i+nbins*j] = (fortranSubintArray[i+nbins*j]-min)/(max - min);	
-		}
-	}
-
-	max = -10000.0f;
-	min = 10000.0f;
-
-
-
-	variance = 0.000498;
-	mean = 0.0;
-	snrMap = malloc(sizeof(float)*(int)((param.maxAcc - param.minAcc)/param.incAcc +1)*(int)((param.maxPer - param.minPer)/param.incPer +1));
-
-	houghplot = malloc(sizeof(float)*nbins150*(int)((param.maxPer - param.minPer)/param.incPer +1));
-	finalsubint = malloc(sizeof(float)*nbins*nsubints);
-
-	for(j = 0; j < nbins150*(int)((param.maxPer - param.minPer)/param.incPer +1) ;j++) houghplot[j]=0.0f;
-
-	snrMapPtr = snrMap;
-	snrMaxMax = -10000;
-	widthMaxMax = 0;
-
-	accMaxMax = 0;
-	jerMaxMax = 0;
-
-	printf("Tuning period\n");
-	jerFactor = param.minJer;
-
-	while(jerFactor <= param.maxJer){
-
-		accFactor = param.minAcc;
-		while(accFactor <= param.maxAcc){
-			houghposn = -1;
-			perMaxMax = 0;
-			perFactor = param.minPer;
-
-			while(perFactor <= param.maxPer){
-
-				houghposn++;
-				/*printf("test3 %f / %f : %d / %d \n",accFactor,param.maxAcc,houghposn,(int)((param.maxAcc - param.minAcc)/param.incAcc +1));
-
-				/*for(j = 0; j < nbins;j++) sumProfile[j]=0.0f;*/
-
-				for(j = 0;j<nsubints;j++){
-
-					fPtr = subintArray[j] + (int)(perFactor * (j) + accFactor*j*j +jerFactor*j*j*j + 0.5);
-					while((fPtr) < subintArray[j]) fPtr += nbins;		
-					for(i = 0; i < nbins150; i++){
-						while((fPtr + i) >= subintArray[j]+nbins){
-							fPtr -= nbins;
-						}
-						houghplot[i+houghposn*nbins150] += *(fPtr+i);
-						/*printf("%f , %f\n",*(fPtr+i),sumProfile[j]);*/	
-
-					}
-
-				}
-				sum = 0;
-				for(j = 0; j < nbins150;j++){
-					houghplot[j+houghposn*nbins150] /= nsubints;
-					sum += houghplot[j+houghposn*nbins150];
-				}
-				mean = sum / nbins150;
-				snrMax = -100000;
-
-
-				width = 1;
-				while(width < nbins/2){
-					s = 0;
-					sMax = -100000;
-					for(i = 0; i < width; i++){
-						s += houghplot[i+houghposn*nbins150];
-						s -= mean;
-					}
-
-					for(i = 0; i < nbins; i++){
-						s -= houghplot[i+houghposn*nbins150];
-						s += houghplot[i+width+houghposn*nbins150];
-						if(s > sMax){
-							sMax = s;
-						}
-					}
-
-					snrMax = sMax/(float)sqrt(width);
-
-					if(snrMax > snrMaxMax){
-						snrMaxMax   = snrMax;
-						perMaxMax   = perFactor;
-						accMaxMax   = accFactor;
-						jerMaxMax   = jerFactor;
-						widthMaxMax = width;
-						maxMax = -10000000.0f;
-						minMax = 100000000.0f;
-						for(i = 0; i < nbins150; i++){
-							sumProfile[i] = houghplot[i+houghposn*nbins150];
-							if(sumProfile[i] > maxMax) maxMax = sumProfile[i];
-							if(sumProfile[i] < minMax) minMax = sumProfile[i];
-
-						}
-					}
-					width *= 2;
-				}
-
-
-				perFactor += param.incPer;
-				snrMapPtr++;
-			}
-
-
-			accFactor += param.incAcc;
-
-		}
-		jerFactor += param.incJer;
-	}
-
-
-	/* convert to a real SNR value! */
-
-	for(i = 0; i < nbins150; i++){
-
-		sumProfile[i] = (sumProfile[i] - minMax)/(maxMax - minMax);
-	}
-
-
-	n = (int)(((float)nbins / 6.0) + 0.5); /* The number of 'quiet' bins to find */	
-
-
-	if(n < 10) n = (int)(((float)nbins / 2.0) + 0.5);
-	if(n < 4) n = (nbins-widthMaxMax);
-	s = 0.0;
-	sSquared = 0.0;
-
-	for(i = 0; i < n; i++){
-		s += sumProfile[i];
-		sSquared += sumProfile[i]*sumProfile[i]; 
-	}
-	sMax = s;
-	sSquMax = sSquared;
-	j = 0;
-	for(i = 0; i < nbins; i++){
-		s -= sumProfile[i];
-		s += sumProfile[i+n];
-		sSquared -= sumProfile[i]*sumProfile[i]; 
-		sSquared += sumProfile[i+n]*sumProfile[i+n];
-
-		if(s < sMax){
-			sMax = s;
-			sSquMax = sSquared;
-			j = i;
-		}
-	}
-	mean = (sMax / n);
-
-	variance = sSquMax/n - mean*mean;
-	s = 0.0;
-
-	for(i = 0; i < widthMaxMax; i++){
-		s += sumProfile[i]-mean;
-	}
-	sMax = s;
-	j = 0;
-	for(i = 0; i < nbins; i++){
-		s +=  sumProfile[i+widthMaxMax] - mean;
-		s -= sumProfile[i]-mean;
-		if(s > sMax){
-			sMax = s;
-			j = i;
-		}
-
-	}
-
-
-
-
-	snr = sMax/(sqrt(variance*widthMaxMax));
-
-	printf("Using %d/%d 'Quiet bins' for snr\n",n,nbins);
-
-	printf("Drawing plot\n");
-
-	/***** Generate the final subint profile for the plot. *****/
-
-
-	for(j = 0;j<nsubints;j++){
-
-		fPtr = subintArray[j] + (int)(perMaxMax * (j) + accMaxMax*j*j +jerMaxMax*j*j*j + 0.5);
-		while((fPtr) < subintArray[j]) fPtr += nbins;
-		for(i = 0; i < nbins; i++){
-			while((fPtr + i) >= subintArray[j]+nbins){
-				fPtr -= nbins;
-			}
-			if(usequadratic){
-				finalsubint[i+j*nbins] += *(fPtr+i) * *(fPtr+i);
-			}else{
-				finalsubint[i+j*nbins] += *(fPtr+i);
-			}
-			/*printf("%f , %f\n",*(fPtr+i),sumProfile[j]);*/
-
-		}
-
-	}
-
-
-
-	/***** BEGIN generating plot data and drawing ******/
-	deltaT = perMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realPer = folding_period  * (1.0 + deltaT/tobs);
-
-
-
-	deltaT = accMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realAcc =     SPEED_OF_LIGHT * deltaT/(tobs * folding_period/1000.0);
-
-	deltaT = jerMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realJer = SPEED_OF_LIGHT * deltaT/(tobs*tobs*folding_period/1000.0);
-
-
-
-	if(writejreaper){
-
-		jreaperfile = fopen(jreaperfilename,"wa");
-		fprintf(jreaperfile,inpfile);	
-		fprintf(jreaperfile,"\n%lf %lf %lf\n",src_raj,src_dej,tstart);
-		fprintf(jreaperfile,"%lf %lf %lf\n",fftperiod,fftsnr,fftdm);
-		fprintf(jreaperfile,"%f %f %f %d %f\n", realPer,realAcc,realJer,widthMaxMax,snr);
-		fprintf(jreaperfile,"#GID# %s\n",source_name);
-
-	}	
-
-
-	/**** PGPLOT stuff for hough test ****/
-
-	max = -10000.0f;
-	min = 10000.0f;
-
-	for(i = 0; i < nbins150 * houghposn; i++){
-		if(max < houghplot[i]) max = houghplot[i];
-		if(min > houghplot[i]) min = houghplot[i];
-	}
-
-
-
-
-
-	max -= min;
-	for(i = 0; i < nbins150 * houghposn; i++){
-		houghplot[i] -= min;
-		if(houghplot[i] < 0.75 * max) houghplot[i] =0;
-	}
-	min = 0.75 * max;
-	/*if(max > maxMax){
-	  accMaxMax = accFactor;
-	  jerMaxMax = jerFactor;
-	  maxMax = max;
-	  }*/
-	sprintf(string,format,psnum);
-	psnum++;
-
-
-	cpgbeg(0, string, 1, 1);
-	cpgsch(0.8);
-	/* Draw Hough Plot */
-	cpgsvp(0.05,0.45,0.425,0.55);
-	cpgswin(0.0, (float)nbins, 0, (float)houghposn);
-
-	cpgqwin( &x1, &x2, &y1, &y2 );
-
-	xscale = ( x2 - x1 ) / nbins;
-	yscale = ( y2 - y1 ) / houghposn;
-	scale = ( xscale < yscale ) ? xscale : yscale;
-
-
-	xleft   = 0.5f * ( x1 + x2 - nbins * scale );
-	xright  = 0.5f * ( x1 + x2 + nbins * scale );
-	ybottom = 0.5f * ( y1 + y2 - houghposn * scale );
-	ytop    = 0.5f * ( y1 + y2 + houghposn * scale );
-
-
-	tr[0] = xleft - 0.5f * scale;
-	tr[1] = scale;
-	tr[2] = 0.0f;
-	tr[3] = ybottom - 0.5f * scale;
-	tr[4] = 0.0f;
-	tr[5] = scale;
-
-
-
-	cpglab("Bin", "Period step","");
-
-	cpggray(houghplot,nbins150,houghposn,1,nbins,1,houghposn,max,min,tr);
-
-	cpgbox("ABCN",0.0,0,"ABCN",0.0,0);
-
-
-	if(writejreaper){
-		fprintf(jreaperfile,"#HOUGH# %d %d\n",nbins,houghposn);
-		for(i = 0; i < houghposn; i++){
-			for(j = 0; j < nbins; j++){
-				fprintf(jreaperfile,"%2.2f ",houghplot[j+nbins150*i]);
-			}
-		}
-	}
-
-
-
-
-	/* Draw best profile */
-
-	cpgsvp(0.55,0.95,0.1,0.325);
-	cpgswin(0.0, (float)nbins, 0.0, 1.0);
-	cpgbox("ABCSN",0.0,0,"ABCN",0.0,0);
-
-	cpgmove(0.0,sumProfile[nbins-1]);
-	for(i = 0; i < nbins; i++){
-		cpgdraw(i,sumProfile[i]);
-		cpgmove(i,sumProfile[i]);
-
-	}
-
-	if(writejreaper){
-		fprintf(jreaperfile,"\n#BESTPROFILE# %d\n",nbins);
-		for(i = 0; i < nbins; i++){
-			fprintf(jreaperfile,"%1.2f ",sumProfile[i]-minMax);
-
-		}
-	}
-
-	/* Draw origianal Profile */
-	maxMax = -100000;
-	minMax = 100000;
-
-	for(j = 0; j < nbins; j++){
-		sumProfile[j] = 0;
-	}
-	for(i = 0; i < nsubints; i++){
-		for(j = 0; j < nbins; j++){
-			sumProfile[j] = sumProfile[j] + subintArray[i][j];
-		}
-	}
-	for(j = 0; j < nbins; j++){
-		if(sumProfile[j] > maxMax)maxMax = sumProfile[j];
-		if(sumProfile[j] < minMax)minMax = sumProfile[j];
-	}
-	cpgsvp(0.05,0.45,0.1,0.325);
-
-	for(i = 0; i < nbins; i++){
-
-		sumProfile[i] = (sumProfile[i] - minMax)/(maxMax - minMax);
-
-	}
-
-	cpgswin(0.0, (float)nbins, 0.0, 1);
-	cpgbox("ABCSN",0.0,0,"ABCN",0.0,0);
-	cpgmove(0.0,sumProfile[nbins-1]);
-	for(i = 0; i < nbins; i++){
-		cpgdraw(i,sumProfile[i]);
-		cpgmove(i,sumProfile[i]);
-
-	}
-
-	if(writejreaper){
-		fprintf(jreaperfile,"\n#ORIGPROFILE# %d\n",nbins);
-		for(i = 0; i < nbins; i++){
-			fprintf(jreaperfile,"%1.2f ",sumProfile[i]-minMax);
-
-		}
-	}
-
-
-	/* Draw DM curve if we have one */
-
-	if(ndms > 0){
-		/* we have some dms in the dm curve, so draw it*/
-		maxMax = -100000;
-		minMax = 100000;
-
-		for(i = 0; i < ndms; i++){
-			if(dmcurve[i] > maxMax)maxMax = dmcurve[i];
-			if(dmcurve[i] < minMax)minMax = dmcurve[i];
-		}                                                                                                             
-
-		cpgsvp(0.05,0.45,0.65,0.825);
-		cpgswin(dmcurvidx[0], dmcurvidx[ndms-1], 0.0, maxMax-minMax);
-		cpgbox("ABCSN",0.0,0,"ABCN",0.0,0);
-
-
-		cpgmove(dmcurvidx[0],dmcurve[0]-minMax);
-		for(i = 0; i < ndms; i++){
-			cpgdraw(dmcurvidx[i],dmcurve[i]-minMax);
-			cpgmove(dmcurvidx[i],dmcurve[i]-minMax);
-			/*cpgpt1(dmcurvidx[i],dmcurve[i]-minMax,-1);*/
-
-		}                                                                                                              
-		if(writejreaper){
-			fprintf(jreaperfile,"\n#DMCURVEIDX# %d\n",ndms);
-			for(i = 0; i < ndms; i++){
-				fprintf(jreaperfile,"%f ",dmcurvidx[i]);
-
-			}
-			fprintf(jreaperfile,"\n#DMCURVE# %d\n",ndms);
-			for(i = 0; i < ndms; i++){
-				fprintf(jreaperfile,"%f ",dmcurve[i]-minMax);
-			}
-		}
-
-
-	}
-
-
-
-	/* Draw subints */
-
-
-	max = -10000.0f;
-	min = 10000.0f;
-
-	for(i = 0; i < nbins * nsubints; i++){
-		if(max < finalsubint[i]) max = finalsubint[i];
-		if(min > finalsubint[i]) min = finalsubint[i];
-	}
-	for(i = 0; i < nbins * nsubints; i++){
-		finalsubint[i] = (finalsubint[i]-min)/(max-min);
-	}
-	/*max = (max - min)/2.0;
-	  for(i = 0; i < nbins * nsubints; i++){
-	  fortranSubintArray[i] = fortranSubintArray[i] - min;
-	  if(fortranSubintArray[i] > max) fortranSubintArray[i] = max;
-	  }*/
-
-	cpgsvp(0.55,0.95,0.45,0.825);
-
-	if(!usequikgray){
-		cpgswin(0.0, (float)nbins, 0, (float)nsubints);
-		cpgqwin( &x1, &x2, &y1, &y2 );
-
-		xscale = ( x2 - x1 ) / nbins;
-		yscale = ( y2 - y1 ) / nsubints;
-		scale = ( xscale < yscale ) ? xscale : yscale;
-
-
-		xleft   = 0.5f * ( x1 + x2 - nbins * scale );
-		xright  = 0.5f * ( x1 + x2 + nbins * scale );
-		ybottom = 0.5f * ( y1 + y2 - nsubints * scale );
-		ytop    = 0.5f * ( y1 + y2 + nsubints * scale );
-
-
-		tr[0] = xleft - 0.5f * scale;
-		tr[1] = scale;
-		tr[2] = 0.0f;
-		tr[3] = ybottom - 0.5f * scale;
-		tr[4] = 0.0f;
-		tr[5] = scale;
-
-
-
-
-		cpgswin(0.0,((float)nbins),0.0,(float)nsubints);
-
-		cpggray(finalsubint,nbins,nsubints,1,nbins,1,nsubints,1.0,0.0,tr);
-	}else{	
-		cpgswin(0.0,((float)nbins),0.0,(float)nsubints);
-
-		quikgray(finalsubint,nbins,nsubints,nbins);
-	}
-	cpgbox("ABCN",0.0,0,"ABCN",0.0,0);
-
-	cpgsch(0.9);
-
-	if(writejreaper){
-		fprintf(jreaperfile,"\n#SUBINTS# %d %d\n",nbins,nsubints);
-		for(i = 0; i < nbins*nsubints; i++){
-			fprintf(jreaperfile,"%1.2f ",finalsubint[i]);
-
-		}
-	}
-
-
-
-	/* draw title */
-
-	cpgsvp(0.0,1.0,0.0,1.0);
-
-        sprintf(string,"Tune Params: Period: %f, Freq: %f, Width: %d, SNR: %f",                 realPer,1000./realPer,widthMaxMax,snr);
-	cpgswin(0.0,1.0,0.0,1.0);
-	cpgtext(0.1,0.98,string);
-	sprintf(string,"RA: %6.2lf DEC: %6.2lf Infile: %s MJD: %9.3lf" ,                        src_raj,src_dej,inpfile,tstart);
-	cpgtext(0.1,0.95,string);
-
-	sprintf(string,"Acc: %f, Jer: %f",realAcc,realJer);
-	cpgtext(0.1,0.9,string);
-	if(fftperiod > 0){
-
-		sprintf(string,"Seek params: Period %lf, DM: %lf, SNR:%lf",fftperiod,fftdm,fftsnr);
-		cpgtext(0.1,0.925,string);
-
-	}	
-
-
-	cpgsch(0.8);                        
-	sprintf(string,"Sub Integrations");
-	cpgtext(0.55,0.85,string);
-	sprintf(string,"DM Curve");
-	cpgtext(0.05,0.85,string);
-	sprintf(string,"Hough Plane");
-	cpgtext(0.05,0.575,string);
-	sprintf(string,"Pre Tune profile");
-	cpgtext(0.05,0.35,string);
-	sprintf(string,"Post Tune profile");
-	cpgtext(0.55,0.35,string);
-
-
-	cpgend();
-
-
-	if(writejreaper){
-		fclose(jreaperfile);
-	}
-
-	deltaT = perMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realPer = folding_period  * (1.0 + deltaT/tobs);
-
-
-
-	deltaT = accMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realAcc =     SPEED_OF_LIGHT * deltaT/(tobs * folding_period/1000.0);
-
-	deltaT = jerMaxMax * nsubints * (folding_period/1000.0) / nbins;
-	realJer = SPEED_OF_LIGHT * deltaT/(tobs*tobs*folding_period/1000.0);
-
-	/* hack - originally started by MK
-	   - fiddled by SJ and DRL to get the output we want
-	   - these first lines extract the directory file name from the entire dm name */
-	if(writejreaper){
-		i=0;
-		for (j=0; j<strlen(inpfile); j++) {
-			if (inpfile[j] == '_') i++;
-			if (i == 3) break;
-		}
-		strncpy(stemname,inpfile,j);
-		strncpy(susname,jreaperfilename,10);
-		strcat(susname,".ps");
-		tunelistfile = fopen("tune.lis","a");
-		fprintf(tunelistfile,"%s %s %s %8.6lf %6.2lf %6.2lf %d %8.6f %6.2f %6.2f %4d %6.2f %6.2f\n",source_name,stemname,susname,fftperiod,fftsnr,fftdm,hrmnum,realPer,snr,realDM,widthMaxMax,realAcc,realJer);
-		fclose(tunelistfile);	
-	}
-
-
-	printf("\n=========\nPeriod: %f, Acc: %f, Jerk: %f\n",realPer,realAcc,realJer);
-	printf("Width: %d, SNR: %f\nDone.\n",widthMaxMax,snr);
-	/* all done, update and close logfile */
-	update_log("finished");
-	close_log();
-	i=0;
-#ifdef PSRFITS
-	if (psrfits) fits_close_file(fits,&i);
-#endif
-
-
-
-
-
-
-	free(snrMap);
-	free(sumProfile);
-	free(subintArray);
-	free(finalsubint);
-	exit(0);
-}
-
-void     quikgray(float*dat,int nx,int ny,int nxx)
-{
-	/*
-	   Coarse grey-scale plot using PG plot routines
-	   Assumed that viewport and window defined outside routine
-	   nx and ny are the areas of the array display, the x dimension is
-	   repeated out to nxx, for multiple cycles.
-	 */
-
-	int ksym[8]={0,1,20,21,2,3,17,18};
-	float s=0.;
-	float ss=0.;
-	float smin=1.e30;
-	float smax=-1.e30;
-	float aa,rms,x,y;
-	int i,ii,j,k;
-
-	for (i=0;i<nx*ny;i=i+1)
-	{
-		aa=dat[i];
-		s=s+aa;
-		ss=ss+aa*aa;
-		if(aa > smax)smax=aa;
-		if(aa < smin)smin=aa;
-	}
-
-	s=s/(float)(nx*ny);
-	rms=sqrt(ss/(float)(nx*ny)-s*s);
-	if(s+7*rms > smax) rms=(smax-s)/7.0;
-	printf("max: %f min %f mean: %f rms: %f\n",smax,smin,s,rms);
-	for (j=0;j<ny;j=j+1)
-	{
-		ii=0;
-		for (i=0;i<nxx;i=i+1)
-		{
-			ii=ii+1;
-			if(ii==nx) ii=0;
-			k=(int)((dat[(int)(j*nx+ii)]-s)/rms);
-			if (k>7) k=7;
-			x=(float)i+1;y=(float)j+1;
-			if (k>0) cpgpt(1,&x,&y,ksym[k]);
-		}
-	}
-}
-
diff --git a/filterbank-gmrt/typeof_inputdata.c b/filterbank-gmrt/typeof_inputdata.c
deleted file mode 100644
index 18055f4..0000000
--- a/filterbank-gmrt/typeof_inputdata.c
+++ /dev/null
@@ -1,851 +0,0 @@
-/* 
-   look at the raw data file and establish origin and whether it's readable 
-   the following data types are currently recognizable:
-   
-   0 - sigproc binary profiles
-   1 - pspm search
-   2 - pspm timing
-   3 - wapp search
-   4 - wapp timing
-   5 - bpp search
-   6 - bpp timing
-   7 - aoftm search (no timing mode for this machine)
-   8 - ooty search  (no timing mode for this machine)
-   9 - parkes 1-bit
-
-*/
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "sigproc.h"
-#include "header.h"
-
-#include "pspmhdr.h"
-PSPM_TIMING_HEADER pspm_timing;
-PSPM_SEARCH_HEADER pspm_search;
-
-#include "wapp_header.h"
-#include "key.h"
-struct WAPP_HEADER *wapp;
-struct WAPP_HEADER head;
-
-#include "bpphdr.h"
-BPP_TIMING_HEADER bpp_timing;
-BPP_SEARCH_HEADER bpp_search;  
-
-#include "scamp_header.h"
-int scamp_block_size, scamp_rawdata;
-SCAMP_HEADER schead;
-char *get_scamp_header(char *header_parameter, int nbytes) {
-  char *string;
-  string=(char *) malloc(nbytes);
-  strcpy(string,"");
-  strncat(string,header_parameter,nbytes);
-  return(string);
-}
-
-int invert_band, wapp_lagtrunc;
-int wapp_file, wapp_lagformat, wapp_sum, wapp_level, wapp_flip, obits, *chtab;
-int wapp_header_size,wapp_incfile_length,wapp_isalfa,wapp_number;
-double wapp_obstime, alfa_ang, alfa_raj[7], alfa_dej[7];
-
-int scamp_ignore[1024],scamp_chans;
-int data_fmt;
-
-int typeof_inputdata(FILE *fptr, char *filename) /* includefile */
-{ 
-  FILE *hdr, *ignore_file;
-  char *string, *label, junk[14];
-  int dayno,year,scan,hh,mm,ss,mo,dd,swap_bytes,rah,ram,ded,dem,i,j;
-  double ras,des,a,b;
-  struct HEADERKEY *key;
-  struct HEADERP *h;
-  int fsys;
-  char *dummy;
-  unsigned short gmrt[3];
-
-  /* set machine and telescope ID to unknown type initially */
-  machine_id=telescope_id=0;
-  rewind(fptr);
-
-  nbeams = 1;
-  ibeam = 1;
-  if (read_header(fptr)) {
-    if (data_type == 3) return(0);
-  }
-
-
-  /* Try reading as GMRT fast-sampled data -> case 10 */
-  rewind(fptr);
-  for (i=1;i<=3;i++) fread(&gmrt[i],2,1,fptr);
-  /*fprintf(stderr,"%d %d %d\n",gmrt[1],gmrt[2],gmrt[3]);exit(0);*/
-  if ((gmrt[2]==32768)) { 
-  }
-  /* GMRT USB 256 usec data */
-  if( data_fmt == 0 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    fch1=626.031250;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    tsamp=0.000256;
-    nifs=1;
-    return(10);
-  }
-  /* GMRT USB 512 usec data */
-  if( data_fmt == 1 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    fch1=626.031250;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    tsamp=0.000512;
-    nifs=1;
-    return(10);
-  }
-  /* GMRT LSB 256 usec data */
-  if( data_fmt == 2 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    fch1=610.031250;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    tsamp=0.000256;
-    nifs=1;
-    return(11);
-  }
-  /* GMRT LSB 256 usec data at 235 MHz*/
-  if( data_fmt == 3 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    fch1=243.96875;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    tsamp=0.000256;
-    nifs=1;
-    return(11);
-  }
-  /* GMRT USB data with user supplies samp time and rf freq*/
-  if( data_fmt == 4 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    nifs=1;
-    return(10);
-  }
-  /* GMRT LSB data with user supplies samp time and rf freq**/
-  if( data_fmt == 5 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    foff=-0.0625;
-    nchans=256;
-    nbits=16;
-    nifs=1;
-    return(11);
-  }
-  /* GMRT USB data with user supplies samp time and rf freq and bw*/
-  if( data_fmt == 6 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    nchans=256;
-    nbits=16;
-    nifs=1;
-    return(10);
-  }
-  /* GMRT LSB data with user supplies samp time and rf freq and bw**/
-  if( data_fmt == 7 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    nchans=256;
-    nbits=16;
-    nifs=1;
-    return(11);
-  }
-   /* GMRT Both sideband comb data with user supplies samp time and rf freq */
-  if( data_fmt == 8 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    foff=-0.0625;
-    nchans=512;
-    nbits=16;
-    nifs=1;
-    return(12);
-  }
-  /* GMRT GSB 512 channel data with user supplies samp time and rf freq */
-  if( data_fmt == 9 ) {
-    rewind(fptr);
-    machine_id=7;
-    telescope_id=7;
-    data_type=1;
-    foff=-0.065104160156;
-    nchans=512;
-    nbits=16;
-    nifs=1;
-    return(13);
-  }
-  /* GMRT GWB varaiable channel data with user supplies samp time, rf freq, 
-bandwidth and number of channels, Higher LO reverse order */
-  if( data_fmt == 10 ) {
-    rewind(fptr);
-//    machine_id=8;
-    machine_id=14;
-    telescope_id=7;
-    data_type=1;
-    nbits=16;
-    nifs=1;
-    return(14);
-  }
-  /* GMRT GWB varaiable channel data with user supplies samp time, rf freq, 
-bandwidth and number of channels, Lower LO forward order */
-  if( data_fmt == 11 ) {
-    rewind(fptr);
-//    machine_id=8;
-    machine_id=14;
-    telescope_id=7;
-    data_type=1;
-    nbits=16;
-    nifs=1;
-    return(15);
-  }
-
-
-  /* 
-     Try reading as Parkes fast-sampled data       -> case 9 
-     N.B. key is to check first integer read in - this should be 48/24k.
-     48k is the usual case where one filter system has been used
-     24k is the rarer case where two systems were used but only one
-         was read back from tape (functionality to read this added 4/7/04)
-	 **** note that currently it is not possible to deal with the
-              case where both systems have been read into the same file ****
-     In any case, depending on whether the data were written by big/little 
-     endian machines, the integer will need to be swapped - so try both 
-     possibilities. Since the rest of the data are chars, no further byte 
-     swapping required. This trick allows one to read the data regardless 
-     of the origin of the tape reader.
-  */
-  rewind(fptr);
-  scamp_block_size=0;
-  fread(&junk,10,1,fptr); /* dummy pad to ensure correct read */
-  fread(&schead,sizeof(schead),1,fptr);
-  string=get_scamp_header((schead.telid),sizeof(schead.telid));
-  if (strings_equal(string,"PARKES    ")) {
-    scamp_rawdata=1;
-    scamp_block_size=49152;
-  } else {
-    scamp_rawdata=0;
-    rewind(fptr);
-    fread(&i,4,1,fptr);
-    j=i;
-    swap_int(&j);
-    if (i == 49152 || j == 49152) scamp_block_size=49152;
-    if (i == 24576 || j == 24576) scamp_block_size=24576;
-  }
-  if (scamp_block_size) {
-    if (!scamp_rawdata) {
-      string=(char *) malloc(strlen(filename)+1);
-      strcpy(string,"");
-      strncat(string,filename,strlen(filename)-3);
-      strcat(string,"hdr");
-      hdr=open_file(string,"rb");
-      fread(&junk,14,1,hdr); /* dummy pad to ensure correct read */
-      fread(&schead,sizeof(schead),1,hdr);
-      fclose(hdr);
-    }
-    string=get_scamp_header(schead.ra,sizeof(schead.ra));
-    rah=atoi(strtok(string,":"));
-    ram=atoi(strtok(NULL,":"));
-    ras=atof(strtok(NULL,":"));
-    src_raj=ras+ram*100.0+rah*10000.0;
-    string=get_scamp_header(schead.dec,sizeof(schead.dec));
-    ded=atoi(strtok(string,":"));
-    dem=atoi(strtok(NULL,":"));
-    des=atof(strtok(NULL,":"));
-    src_dej=des+100.0*dem+10000.0*abs(ded);
-    if (ded<0) src_dej*=-1.0;
-    string=get_scamp_header(schead.mjd,sizeof(schead.mjd));
-    tstart=atof(string);
-    string=get_scamp_header(schead.ut,sizeof(schead.ut));
-    tstart+=atof(strtok(string,":"))/24.0+atof(strtok(NULL,":"))/1440.0+
-      atof(strtok(NULL,":"))/86400.0;
-    string=get_scamp_header(schead.nsys,sizeof(schead.nsys));
-    fsys=atoi(string)-1; /* get the index of the filter system to use */
-    if (fsys<0) fsys=0;
-    if (scamp_rawdata) fsys=0;
-    string=get_scamp_header(schead.fch1[fsys],sizeof(schead.fch1[fsys]));
-    fch1=atof(string);
-    string=get_scamp_header(schead.chbw[fsys],sizeof(schead.chbw[fsys]));
-    foff=atof(string);
-    string=get_scamp_header(schead.nchan[fsys],sizeof(schead.nchan[fsys]));
-    nchans=atoi(string);
-    scamp_chans=nchans;
-    /* read in list of segments to ignore */
-    for (i=0;i<1024;i++) scamp_ignore[i]=0;
-    if (file_exists("scamp.ignore")) {
-      ignore_file=open_file("scamp.ignore","r");
-      while (1) {
-	fscanf(ignore_file,"%d",&i);
-	if (feof(ignore_file)) break;
-	scamp_ignore[i]=1;
-	nchans-=8;
-      }
-      fclose(ignore_file);
-    }
-    raw_fch1 = fch1;
-    raw_foff = foff;
-    if (foff>0) {
-      invert_band=1;
-      fch1+=foff*(double)(nchans-1);
-      foff*=-1.0;
-    }
-    
-
-    string=get_scamp_header(schead.l,sizeof(schead.l));
-    gal_l=atof(string);
-    string=get_scamp_header(schead.b,sizeof(schead.b));
-    gal_b=atof(string);
-    
-    string=get_scamp_header(schead.nbeam,sizeof(schead.nbeam));
-    while(*string==' ')string++;
-    nbeams=atoi(string);
-    string=get_scamp_header(schead.ibeam,sizeof(schead.ibeam));
-    while(*string==' ')string++;
-    ibeam=atoi(string);
-    string=get_scamp_header(schead.obstime,sizeof(schead.obstime));
-    header_tobs = atof(string); 
-    string=get_scamp_header(schead.tsamp[fsys],sizeof(schead.tsamp[fsys]));
-    tsamp=atof(string)*1.0e-3;
-    string=get_scamp_header(schead.telid,sizeof(schead.telid));
-    telescope_id=5;
-    if (!strncmp(string,"PARKES",6)) telescope_id=4;
-    if (!strncmp(string,"JODRELL",7)) telescope_id=5;
-    string=get_scamp_header(schead.psrname,sizeof(schead.psrname));
-    strcpy(source_name,strtok(string," "));
-    free(string);
-    machine_id=6;
-    data_type=1;
-    nbits=1;
-    nifs=1;
-    return 9;
-  }
-
-  /* Try reading as PSPM/BPP timing-mode data */
-  rewind(fptr);
-  fread(&bpp_timing,BPP_HEADER_SIZE,1,fptr); 
-
-  /* establish whether we need to swap bytes (PSPM/BPPs are big endian) */
-  swap_bytes=little_endian();
-  if (swap_bytes) {
-    swap_long(&bpp_timing.HEADER_TYPE);
-    swap_long(&bpp_timing.BACKEND_TYPE);
-  }
-  if (bpp_timing.HEADER_TYPE == 1 || bpp_timing.HEADER_TYPE == 3) {
-
-    switch (bpp_timing.BACKEND_TYPE) {
-    case 0:
-      /* this is PSPM data */
-      machine_id=1;
-      telescope_id=1;
-      break;
-    case 2:
-      /* this is NBPP data */
-      machine_id=4;
-      telescope_id=3;
-      break;
-    default:
-      error_message("unknown backend in BPP/PSPM timing file?!?");
-      break;
-    }
-
-    switch (machine_id) {
-    case 1:
-      /* this is PSPM data */
-      rewind(fptr);
-      fread(&pspm_timing,PSPM_HEADER_SIZE,1,fptr); 
-      if (swap_bytes) {
-	swap_long(&pspm_timing.scan_num);
-	swap_long(&pspm_timing.tc);
-	swap_double(&pspm_timing.tick_offset);
-	swap_double(&pspm_timing.freq);
-	swap_long(&pspm_timing.num_phase_bins);
-	swap_long(&pspm_timing.num_chans);
-	swap_long(&pspm_timing.num_periods);
-	swap_double(&pspm_timing.psr_period);
-	swap_double(&pspm_timing.psr_dm);
-      }
-      /* get number of seconds since midnight (tstart) on MJD mjd_obs */
-      tstart=pspm_tstart(pspm_timing.scan_num, pspm_timing.start_time,
-		       pspm_timing.tick_offset,&mjdobs);
-      read_aoscan(pspm_timing.scan_num,&dayno,&year,&scan_number);
-      return 2;
-      break;
-    case 4:
-      /* this is BPP data */
-      if (swap_bytes) {
-	swap_long(&bpp_timing.scan_num);
-	swap_double(&bpp_timing.tick_offset);
-	swap_long(&bpp_timing.num_phase_bins);
-	swap_long(&bpp_timing.num_chans);
-	swap_long(&bpp_timing.num_periods);
-	swap_double(&bpp_timing.psr_period);
-	swap_double(&bpp_timing.psr_dm);
-	swap_double(&bpp_timing.bandwidth);
-	swap_double(&bpp_timing.rf_lo);
-	swap_int(&bpp_timing.mb_start_address);
-	swap_int(&bpp_timing.mb_end_address);
-	swap_int(&bpp_timing.mb_start_board);
-	swap_int(&bpp_timing.mb_end_board);
-	for (i=0;i<MAXNUMCB;i++) 
-	  swap_int(&bpp_timing.cb_id[i]);
-	for (i=0;i<MAX_NUM_LO_BOARDS;i++) 
-	  swap_double(&bpp_timing.aib_los[i]);
-	for (i=0;i<FB_CHAN_PER_BRD;i++)
-	  swap_float(&bpp_timing.dfb_sram_freqs[i]);
-      }
-      /* parse search date dayno:year */
-      string=(char *)malloc(strlen(bpp_timing.date));
-      strcpy(string,bpp_timing.date);
-      dayno=atoi(strtok(string,":"));
-      dayno=atoi(strtok(NULL,":"));
-      year=atoi(strtok(NULL,":"))+1900;
-      free(string);
-      /* parse UT start time hh:mm:ss */
-      string=(char *)malloc(strlen(bpp_timing.start_time));
-      strcpy(string,bpp_timing.start_time);
-      hh=atoi(strtok(string,":"));
-      mm=atoi(strtok(NULL,":"));
-      ss=atoi(strtok(NULL,":"));
-      free(string);
-      /* calculate MJD start time based on the above info */
-      tstart=mjd(year,1,1)+(double)dayno-1.0;
-      tstart+=(double)hh/24.0+(double)mm/1440.0+(double)ss/86400.0;
-      mjdobs=floor(tstart);
-      tstart=(tstart-mjdobs)*86400.0;
-      /* 
-	 calculate nchans from other header info as 
-	 num_chans from NBPP seems to be incorrect! 
-      */
-      bpp_timing.num_chans = 
-	(bpp_timing.mb_end_address/2-bpp_timing.mb_start_address/2+1)*
-	(bpp_timing.mb_end_board-bpp_timing.mb_start_board+1)*4;
-      return 6;
-      break;
-    default:
-      error_message("coding in typeof_intputdata not yet done!");
-      break;
-    }
-
-  }
-
-  /* Try reading as PSPM search-mode data */
-  rewind(fptr);
-  fread(&pspm_search,PSPM_HEADER_SIZE,1,fptr);
-
-  /* establish whether we need to swap bytes (PSPM is big endian) */
-  swap_bytes=little_endian();
-  if (swap_bytes) {
-    swap_long(&pspm_search.HEADER_TYPE);
-    swap_long(&pspm_search.BACKEND_TYPE);
-  }
-
-  if (pspm_search.BACKEND_TYPE == 0 && ((pspm_search.HEADER_TYPE==0) || (pspm_search.HEADER_TYPE==2))) {
-    machine_id=1;
-
-    /* perform byte swapping on header parameters of interest if necessary */
-    if (swap_bytes) {
-      swap_double(&pspm_search.samp_rate);
-      swap_double(&pspm_search.chan_spacing);
-      swap_double(&pspm_search.rf_freq);
-      swap_long(&pspm_search.num_chans);
-      swap_long(&pspm_search.bit_mode);
-      swap_long(&pspm_search.scan_num);
-      swap_long(&pspm_search.scan_file_number);
-      swap_double(&pspm_search.tick_offset);
-      swap_double(&pspm_search.user_az);
-      swap_double(&pspm_search.user_za);
-      swap_double(&pspm_search.user_ra);
-      swap_double(&pspm_search.user_dec);
-    }
-
-    tsamp=pspm_search.samp_rate*1.0e-6;
-    nchans=pspm_search.num_chans;
-    nifs=1;
-    nbits=pspm_search.bit_mode;
-
-    pspm_search.chan_spacing=0.062; 
-    fch1=pspm_search.rf_freq+nchans*pspm_search.chan_spacing/2;
-    foff=-1.0*pspm_search.chan_spacing;
-
-    /* get number of seconds since midnight (tstart) on MJD mjd_obs */
-    tstart=pspm_tstart(pspm_search.scan_num, pspm_search.start_time,
-		       pspm_search.tick_offset,&mjdobs);
-
-    /* 
-       if this is drift scan data - correct tstart to start of this file
-       each file is 10 lots of pow(2,19) 80 us samples, but only the first
-       9 are independent, hence offset is pow(2,19)*9*80e-6 = 377.48736 s 
-       N.B. pspm_search.scan_file_number gives number starting at 1
-    */
-    if (pspm_search.scan_file_number > 1)  
-      tstart+=(pspm_search.scan_file_number-1)*377.48736;
-
-    tstart=mjdobs+tstart/86400.0;
-
-    /* get telescope az and za */
-    az_start=pspm_search.user_az;
-    za_start=pspm_search.user_za;
-
-    /* get source ra and dec */
-    src_raj=pspm_search.user_ra;
-    src_dej=pspm_search.user_dec;
-
-    strcpy(source_name,pspm_search.psr_name);
-    read_aoscan(pspm_search.scan_num,&dayno,&year,&scan_number);
-
-    telescope_id=1;
-    return 1;
-  } 
-
-  /* Try reading as BPP fast-sampled data        -> case 6 */
-  rewind(fptr);
-  fread(&bpp_search,BPP_HEADER_SIZE,1,fptr);
-  /* establish whether we need to swap bytes (BPPs are big endian) */
-  swap_bytes=little_endian();
-  if (swap_bytes) swap_long(&bpp_search.BACKEND_TYPE);
-if (bpp_search.BACKEND_TYPE == 0 || bpp_search.BACKEND_TYPE == 1 || bpp_search.BACKEND_TYPE == 4) {
-    machine_id=4;
-    telescope_id=6;
-    nifs=1;
-    if (swap_bytes) {
-      swap_double(&bpp_search.samp_rate);
-      swap_double(&bpp_search.bandwidth);
-      swap_double(&bpp_search.rf_lo);
-      swap_long(&bpp_search.bit_mode);
-      swap_long(&bpp_search.num_chans);
-      swap_long(&bpp_search.scan_file_number);
-      swap_long(&bpp_search.file_size);
-      swap_int(&bpp_search.mb_start_address);
-      swap_int(&bpp_search.mb_end_address);
-      swap_int(&bpp_search.mb_start_board);
-      swap_int(&bpp_search.mb_end_board);
-      for (i=0;i<MAXNUMCB;i++) 
-	swap_int(&bpp_search.cb_id[i]);
-      for (i=0;i<MAX_NUM_LO_BOARDS;i++) 
-	swap_double(&bpp_search.aib_los[i]);
-      for (i=0;i<FB_CHAN_PER_BRD;i++)
-	swap_float(&bpp_search.dfb_sram_freqs[i]);
-      swap_double(&bpp_search.ra_1950);
-      swap_double(&bpp_search.dec_1950);
-    }
-    /* parse search date dayno:year */
-    string=(char *)malloc(strlen(bpp_search.date));
-    strcpy(string,bpp_search.date);
-    dayno=atoi(strtok(string,":"));
-    year=atoi(strtok(NULL,":"));
-    free(string);
-    /* parse UT start time hh:mm:ss */
-    string=(char *)malloc(strlen(bpp_search.start_time));
-    strcpy(string,bpp_search.start_time);
-    hh=atoi(strtok(string,":"));
-    mm=atoi(strtok(NULL,":"));
-    ss=atoi(strtok(NULL,":"));
-    free(string);
-    /* calculate MJD start time based on the above info */
-    tstart=mjd(year,1,1)+(double)dayno; /* day0=jan1 for BCPM!!! */
-    tstart+=(double)hh/24.0+(double)mm/1440.0+(double)ss/86400.0;
-    tstart+=1.0/86400.0; /* now add on the mysterious 1-s offset */
-    tsamp=bpp_search.samp_rate*1.0e-6;
-    nchans=bpp_search.num_chans;
-    nbits=bpp_search.bit_mode;
-    /* get source name and ra and dec */
-    src_raj=bpp_search.ra_1950;
-    src_dej=bpp_search.dec_1950;
-    strcpy(source_name,bpp_search.target_name);
-
-    src_raj=src_dej=az_start=za_start=0.0;
-    chtab=bpp_chans(bpp_search.bandwidth,bpp_search.mb_start_address,
-		    bpp_search.mb_end_address,bpp_search.mb_start_board,
-		    bpp_search.mb_end_board,bpp_search.cb_id,
-		    bpp_search.aib_los,bpp_search.dfb_sram_freqs,
-		    bpp_search.rf_lo);
-    if (foff>0.0) foff*=-1.0;
-    return 5;
-  }
-
-  /* Try reading as WAPP data */
-  rewind(fptr);
-  wapp = &head;
-  if ( (h = head_parse( filename )) != NULL) {
-    fetch_hdrval(h,"wapp_time",&(wapp->wapp_time),sizeof(wapp->wapp_time));
-
-    /* establish whether we need to swap bytes (WAPP is little endian) */
-    swap_bytes=big_endian();
-
-    fetch_hdrval(h,"src_name",&(wapp->src_name),sizeof(wapp->src_name));
-    strcpy(source_name,wapp->src_name);
-
-    fetch_hdrval(h,"obs_type",&(wapp->obs_type),sizeof(wapp->obs_type));
-
-    fetch_hdrval(h,"obs_time",&(wapp->obs_time),sizeof(wapp->obs_time));
-    if (swap_bytes) swap_double(&wapp->obs_time);
-    wapp_obstime=wapp->obs_time;
-    fetch_hdrval(h,"header_size",&(wapp->header_size),sizeof(wapp->header_size));
-    if (swap_bytes) swap_long(&wapp->header_size);
-    wapp_header_size=wapp->header_size;
-
-    /* get the date and start time from the header and convert to MJD */
-    fetch_hdrval(h,"obs_date",&(wapp->obs_date),sizeof(wapp->obs_date));
-    sscanf(wapp->obs_date,"%4d%2d%2d",&year,&mo,&dd);
-    fetch_hdrval(h,"start_time",&(wapp->start_time),sizeof(wapp->start_time));
-    sscanf(wapp->start_time,"%d:%d:%d",&hh,&mm,&ss);
-    tstart=mjd(year,mo,dd)+hh/24.0+mm/1440.0+ss/86400.0;
-
-    /* for data between April 17 and May 8 inclusive, the start times are
-       off by 0.5 days due to the ntp daemon not running... fix here.
-       this also occured on May 17! hopefully will not happen again... */
-    if ( ((tstart >= 52016.0) && (tstart <= 52039.0)) 
-	 || (floor(tstart) == 52046.0)) {
-      fprintf(stderr,"WARNING: MJD start time off by 0.5 days! fixed...\n");
-      tstart-=0.5;
-    }
-
-    fetch_hdrval(h, "samp_time", &(wapp->samp_time),sizeof(wapp->samp_time));
-    if (swap_bytes) {
-      swap_double(&wapp->wapp_time);
-      swap_double(&wapp->samp_time);
-    }
-    tsamp=(wappcorrect(tstart)+(wapp->wapp_time))*1.0e-6;   
-    fetch_hdrval(h,"num_lags",&(wapp->num_lags),sizeof(wapp->num_lags));
-    nchans=wapp->num_lags;
-    if (swap_bytes) swap_int(&nchans);
-    if (swap_bytes) swap_long(&wapp->num_lags);
-
-    /* get scan number from the file name's last four digits */
-    scan_number=atoi(&filename[strlen(filename)-4]);
-    if (strstr(filename,"wapp1") != NULL) wapp_number=1;
-    if (strstr(filename,"wapp2") != NULL) wapp_number=2;
-    if (strstr(filename,"wapp3") != NULL) wapp_number=3;
-    if (strstr(filename,"wapp4") != NULL) wapp_number=4;
-    /*
-    fetch_hdrval(h,"scan_number",&(wapp->scan_number),
-		 sizeof(wapp->scan_number));
-    if (swap_bytes) swap_long(&wapp->scan_number);
-    scan_number=(int) wapp->scan_number;
-    */
-
-    wapp_isalfa=0;
-    fetch_hdrval(h,"isalfa",&(wapp->isalfa),sizeof(wapp->isalfa));
-    i=wapp->isalfa;
-    if (swap_bytes) swap_int(&i);
-    wapp_isalfa=i;
-
-    alfa_ang=0.0;
-    fetch_hdrval(h,"alfa_ang",&(wapp->alfa_ang),sizeof(wapp->alfa_ang));
-    alfa_ang=wapp->alfa_ang;
-    if (swap_bytes) swap_double(&alfa_ang);
-
-    fetch_hdrval(h,"alfa_raj",&(wapp->alfa_raj),sizeof(wapp->alfa_raj));
-    fetch_hdrval(h,"alfa_decj",&(wapp->alfa_decj),sizeof(wapp->alfa_decj));
-    for (i=0;i<7;i++) {
-      alfa_raj[i]=wapp->alfa_raj[i];
-      alfa_dej[i]=wapp->alfa_decj[i];
-      if (swap_bytes) {
-	swap_double(&alfa_raj[i]);
-	swap_double(&alfa_dej[i]);
-      }
-    }
-
-    fetch_hdrval(h,"nifs",&(wapp->nifs),sizeof(wapp->nifs));
-    nifs=wapp->nifs;
-    if (swap_bytes) swap_int(&wapp->nifs);
-    if (swap_bytes) swap_int(&nifs);
-
-    /* set a global to show 3/9 level sampling */
-    fetch_hdrval(h,"level",&(wapp->level),sizeof(wapp->level));
-    if (swap_bytes) swap_int(&wapp->level); 
-    wapp_level=(wapp->level == 1) ? 3 : 9;  
-
-    /* determine number of bits */
-    fetch_hdrval(h,"lagformat",&(wapp->lagformat),sizeof(wapp->lagformat));
-    if (swap_bytes) swap_int(&wapp->lagformat);
-    switch (wapp->lagformat) {
-    case 0:
-      nbits=16;
-      break;
-    case 1:
-      nbits=32;
-      break;
-    case 3: /* timing mode data - not relevant, but needs to work! */
-      break;
-    case 4:
-      nbits=8;
-      break;
-    default:
-      error_message("lagformat variable in header should be 0, 1 or 4");
-      break;
-    }
-
-    /* save lag truncation for use in wapp2fb later on */
-    fetch_hdrval(h,"lagtrunc",&(wapp->lagtrunc),sizeof(wapp->lagtrunc));
-    if (swap_bytes) swap_int(&wapp->lagtrunc);
-    wapp_lagtrunc = wapp->lagtrunc;
-
-    fetch_hdrval(h,"bandwidth",&(wapp->bandwidth),sizeof(wapp->bandwidth));
-    fetch_hdrval(h,"freqinversion",&(wapp->freqinversion),
-		 sizeof(wapp->freqinversion));
-    if (swap_bytes) {
-      swap_double(&wapp->bandwidth);
-      swap_int(&wapp->freqinversion);
-    }
-
-    foff=-1.0*wapp->bandwidth/nchans;
-    if (!wapp->freqinversion) {
-      wapp_flip=1;
-    } else {
-      wapp_flip=0;
-    }
-    if (invert_band) wapp_flip=!wapp_flip; /* force user-specified inversion */
-
-    fetch_hdrval(h,"src_ra",&(wapp->src_ra),sizeof(wapp->src_ra));
-    fetch_hdrval(h,"src_dec",&(wapp->src_dec),sizeof(wapp->src_dec));
-    fetch_hdrval(h,"start_az",&(wapp->start_az),sizeof(wapp->start_az));
-    fetch_hdrval(h,"start_za",&(wapp->start_za),sizeof(wapp->start_za));
-    if (swap_bytes) {
-      swap_double(&wapp->src_ra);
-      swap_double(&wapp->src_dec);
-      swap_double(&wapp->start_az);
-      swap_double(&wapp->start_za);
-    }
-    src_raj=wapp->src_ra;
-    src_dej=wapp->src_dec;
-    az_start=wapp->start_az;
-    za_start=wapp->start_za;
-    angle_split(src_raj,&rah,&ram,&ras);
-    angle_split(src_dej,&ded,&dem,&des);
-    cel2gal(rah,ram,ras,ded,dem,des,&srcl,&srcb);
-
-    fetch_hdrval(h,"cent_freq",&(wapp->cent_freq),sizeof(wapp->cent_freq));
-    if (swap_bytes) swap_double(&wapp->cent_freq);
-    fch1=wapp->cent_freq-nchans*foff/2.0;
-
-    fetch_hdrval(h,"lagformat",&(wapp->lagformat),sizeof(wapp->lagformat));
-    fetch_hdrval(h,"sum",&(wapp->sum),sizeof(wapp->sum));
-    wapp_lagformat=wapp->lagformat; 
-    if (swap_bytes) {
-      swap_int(&wapp->lagformat);
-      swap_int(&wapp_lagformat);
-      swap_int(&wapp->sum); 
-    }
-    wapp_sum=wapp->sum; 
-    wapp_file=h->fd;
-    machine_id=2;
-    /* get additional header values */
-
-    fetch_hdrval(h, "az", &(wapp->start_az),sizeof(wapp->start_az));
-    fetch_hdrval(h, "za", &(wapp->start_za),sizeof(wapp->start_za));
-    fetch_hdrval(h, "ast", &(wapp->start_ast),sizeof(wapp->start_ast));
-    fetch_hdrval(h, "lst", &(wapp->start_lst),sizeof(wapp->start_lst));
-    if (swap_bytes) {
-      swap_double(&wapp->start_az);
-      swap_double(&wapp->start_za);
-      swap_double(&wapp->start_ast);
-      swap_double(&wapp->start_lst);
-      az_start=wapp->start_az;
-      za_start=wapp->start_za;
-      ast0=wapp->start_ast;
-      lst0=wapp->start_lst;
-    }
-    fetch_hdrval(h,"project_id",&(wapp->project_id),sizeof(wapp->project_id));
-    strcpy(project,wapp->project_id);
-
-    fetch_hdrval(h,"observers",&(wapp->observers),sizeof(wapp->observers));
-    strcpy(culprits,wapp->observers);
-
-    fetch_hdrval(h,"psr_dm",&(wapp->psr_dm),sizeof(wapp->psr_dm));
-    if (swap_bytes) swap_double(&(wapp->psr_dm)); 
-
-    fetch_hdrval(h,"dumptime",&(wapp->dumptime),sizeof(wapp->dumptime));
-    if (swap_bytes) swap_double(&(wapp->dumptime));
-
-    telescope_id=1;
-
-    /* get number of bins which will be non zero in folding mode */
-    fetch_hdrval(h,"nbins",&(wapp->nbins),sizeof(wapp->nbins));
-    if (swap_bytes) swap_int(&(wapp->nbins));
-    fetch_hdrval(h,"isfolding",&(wapp->isfolding),sizeof(wapp->isfolding));
-    if (swap_bytes) swap_int(&(wapp->isfolding));
-
-    /* get polyco information */
-
-    fetch_hdrval(h,"rphase",&(wapp->rphase),sizeof(wapp->rphase));
-    if (swap_bytes) for (i=0;i<16;i++) swap_double(&wapp->rphase[i]);
-    fetch_hdrval(h,"psr_f0",&(wapp->psr_f0),sizeof(wapp->psr_f0));
-    if (swap_bytes) for (i=0;i<16;i++) swap_double(&wapp->psr_f0[i]);
-    fetch_hdrval(h,"poly_tmid",&(wapp->poly_tmid),sizeof(wapp->poly_tmid));
-    if (swap_bytes) for (i=0;i<16;i++) swap_double(&wapp->poly_tmid[i]);
-    fetch_hdrval(h,"coeff",&(wapp->coeff),sizeof(wapp->coeff));
-    if (swap_bytes) for (i=0;i<192;i++) swap_double(&wapp->coeff[i]);
-    fetch_hdrval(h,"num_coeffs",&(wapp->num_coeffs),sizeof(wapp->num_coeffs));
-    if (swap_bytes) for (i=0;i<16;i++) swap_int(&wapp->num_coeffs[i]);
-
-    if (wapp->isfolding) {
-      mjdobs=floor(tstart);
-      tstart=(tstart-mjdobs)*86400.0;
-      return 4; /*folding mode*/
-    } else {
-      return 3; /*fast-sampled mode*/
-    }
-  }
-
-
-  /* Try reading as AOFTM fast-sampled data      -> case 5 */
-  rewind(fptr);
- if (aoftm_read_header(filename)) {
-    machine_id=3;
-    telescope_id=1;
-    data_type=1;
-    nifs=1;
-    obits=8;
-    return 7;
-  }
-  /* Try reading as OOTY fast-sampled data       -> case 8 */
-  rewind(fptr);
-  machine_id=5;
-  telescope_id=2;
-  data_type=1;
-  foff=-0.03125;
-  fch1=330.5+foff/2.0;
-  nchans=256;
-  nbits=1;
-  tstart=0.0;
-  tsamp=0.00025800387;
-  nifs=1;
-  return 8;
-
-  /* unknown data type */
-  return 0;
-}
diff --git a/filterbank-gmrt/update_log.c b/filterbank-gmrt/update_log.c
deleted file mode 100644
index 7e1df8b..0000000
--- a/filterbank-gmrt/update_log.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include <stdio.h>
-FILE *logfile;
-char inpfile[80], outfile[80];
-int logging_mode;
-void update_log(char *string) /* includefile */
-{
-  if (logging_mode) {
-    fprintf(logfile,"input %s status %s output %s\n",inpfile,string,outfile);
-    fflush(logfile);
-  }
-}
diff --git a/filterbank-gmrt/uttime.c b/filterbank-gmrt/uttime.c
deleted file mode 100644
index 03046b6..0000000
--- a/filterbank-gmrt/uttime.c
+++ /dev/null
@@ -1,11 +0,0 @@
-#include <math.h>
-/* return UT hours minutes and seconds given an MJD */
-void uttime(double mjd, int *hh, int *mm, float *ss) /*includefile*/
-{
-  mjd=(mjd-floor(mjd))*24.0; /* get UT in hours */
-  *hh=(int) mjd;
-  mjd=(mjd-floor(mjd))*60.0; /* get remainder in minutes */
-  *mm=(int) mjd;
-  mjd=(mjd-floor(mjd))*60.0; /* get remainder in seconds */
-  *ss=(float) mjd;
-}
diff --git a/filterbank-gmrt/vanvleck.c b/filterbank-gmrt/vanvleck.c
deleted file mode 100644
index c20be70..0000000
--- a/filterbank-gmrt/vanvleck.c
+++ /dev/null
@@ -1,170 +0,0 @@
-#include <math.h>
-#define NO    0
-#define YES   1
-/*------------------------------------------------------------------------*
- * Van Vleck Correction for 9-level sampling/correlation
- *  Samples {-4,-3,-2,-1,0,1,2,3,4}
- * Uses Zerolag to adjust correction
- *   data_array -> Points into autocorrelation function of at least 'count' points
- * this routine takes the first value as the zerolag and corrects the remaining
- * count-1 points.  Zerolag is set to a normalized 1
- * NOTE - The available routine works on lags normaized to -16<rho<16, so
- *  I need to adjust the values before/after the fit
- * Coefficent ranges
- *   c1 
- *     all
- *   c2
- *     r0 > 4.5
- *     r0 < 2.1
- *     rest 
- * NOTE - correction is done INPLACE ! Original values are destroyed
- * As reported by M. Lewis -> the polynomial fits are OK, but could be improved
- *------------------------------------------------------------------------*/
-void vanvleck9lev(double *rho,int npts) /* includefile */
-{
-  static double coef1[5] = { 1.105842267, -0.053258115, 0.011830276,-0.000916417, 0.000033479 };
-
-  static double coef2rg4p5[5] = { 0.111705575, -0.066425925, 0.014844439, -0.001369796, 0.000044119 };
-  static double coef2rl2p1[5] =  { 1.285303775, -1.472216011, 0.640885537, -0.123486209, 0.008817175 };
-  static double coef2rother[5] = { 0.519701391, -0.451046837, 0.149153116, -0.021957940, 0.001212970 };
-
-  static double coef3rg2p0[5] = { 1.244495105, -0.274900651, 0.022660239, -0.000760938, -1.993790548 };
-  static double coef3rother[5] = { 1.249032787, 0.101951346, -0.126743165, 0.015221707, -2.625961708 };
-
-  static double coef4rg3p15[5] = { 0.664003237, -0.403651682, 0.093057131, -0.008831547, 0.000291295 };
-  static double coef4rother[5] = { 9.866677289, -12.858153787, 6.556692205, -1.519871179, 0.133591758 };
-
-  static double coef5rg4p0[4] = { 0.033076469, -0.020621902, 0.001428681, 0.000033733};
-  static double coef5rg2p2[4] = { 5.284269565, 6.571535249, -2.897741312, 0.443156543};
-  static double coef5rother[4] = {-1.475903733, 1.158114934, -0.311659264, 0.028185170};
-
-  double acoef[5],dtmp,zl,ro;
-  int i;
-  ro = *rho;
-  zl = (*rho)*16;
-/*  for(i=0; i<npts; i++) 
-    *(rho+i) *= *(rho+i)/ro; */
- 
-  
-  acoef[0] = ((((coef1[4]*zl + coef1[3])*zl + coef1[2])*zl +coef1[1])*zl +coef1[0]);
-
-  if( zl > 4.50)
-    acoef[1] =((((coef2rg4p5[4]*zl + coef2rg4p5[3])*zl + coef2rg4p5[2])*zl + coef2rg4p5[1])*zl + coef2rg4p5[0]);
-  else if(zl < 2.10)  
-    acoef[1] =((((coef2rl2p1[4]*zl + coef2rl2p1[3])*zl + coef2rl2p1[2])*zl + coef2rl2p1[1])*zl + coef2rl2p1[0]);
-  else
-    acoef[1] =((((coef2rother[4]*zl + coef2rother[3])*zl + coef2rother[2])*zl + coef2rother[1])*zl + coef2rother[0]);
-
-  if( zl > 2.00)
-    acoef[2] = coef3rg2p0[4]/zl + (((coef3rg2p0[3]*zl + coef3rg2p0[2])*zl + coef3rg2p0[1])*zl + coef3rg2p0[0]);
-  else
-    acoef[2] = coef3rother[4]/zl + (((coef3rother[3]*zl + coef3rother[2])*zl + coef3rother[1])*zl + coef3rother[0]);  
-  
-  if( zl > 3.15)
-    acoef[3] = ((((coef4rg3p15[4]*zl + coef4rg3p15[3])*zl + coef4rg3p15[2])*zl + coef4rg3p15[1])*zl + coef4rg3p15[0]);
-  else
-    acoef[3] = ((((coef4rg3p15[4]*zl + coef4rother[3])*zl + coef4rother[2])*zl + coef4rother[1])*zl + coef4rother[0]);  
-
-  if( zl > 4.00)
-    acoef[4] =(((coef5rg4p0[3]*zl + coef5rg4p0[2])*zl + coef5rg4p0[1])*zl + coef5rg4p0[0]);
-  else if(zl < 2.2)  
-    acoef[4] =(((coef5rg2p2[3]*zl + coef5rg2p2[2])*zl + coef5rg2p2[1])*zl + coef5rg2p2[0]);
-  else
-    acoef[4] =(((coef5rother[3]*zl + coef5rother[2])*zl + coef5rother[1])*zl + coef5rother[0]);
-  
- /* printf("(0)-> %g (1)-> %g (2)-> %g (3)-> %g (4)-> %g\n",acoef[0],acoef[1],acoef[2],acoef[3],acoef[4]);*/
-  for(i=1; i<npts; i++)
-  {
-    dtmp = *(rho+i);
-    *(rho+i) =((((acoef[4]*dtmp + acoef[3])*dtmp + acoef[2])*dtmp + acoef[1])*dtmp + acoef[0])*dtmp;
-  }
-  *(rho) = 1.0;
-  return;
-}
-/*------------------------------------------------------------------------*
- * Van Vleck Correction for 3-level sampling/correlation
- *  Samples {-1,0,1}
- * Uses Zerolag to adjust correction
- *   data_array -> Points into autocorrelation function of at least 'count' points
- * this routine takes the first value as the zerolag and corrects the remaining
- * count-1 points.  Zerolag is set to a normalized 1
- * 
- * NOTE - correction is done INPLACE ! Original values are destroyed
- *------------------------------------------------------------------------*/
-int vanvleck3lev(double *rho,int npts) /* includefile */
-{
-    static double lo_const[3][4] = {
-         { 0.939134371719, -0.567722496249, 1.02542540932, 0.130740914912 },
-         { -0.369374472755, -0.430065136734, -0.06309459132, -0.00253019992917},
-         { 0.888607422108, -0.230608118885, 0.0586846424223, 0.002012775510695}
-         };
-    static double high_const[5][4] = {
-         {-1.83332160595, 0.719551585882, 1.214003774444, 7.15276068378e-5},
-         {1.28629698818, -1.45854382672, -0.239102591283, -0.00555197725185},
-         {-7.93388279993, 1.91497870485, 0.351469403030, 0.00224706453982},
-         {8.04241371651, -1.51590759772, -0.18532022393, -0.00342644824947},
-         {-13.076435520, 0.769752851477, 0.396594438775, 0.0164354218208}
-         };
-
-    double lo_u[3],lo_h[3];
-    double high_u[5],high_h[5];
-    double lo_coefficient[3];
-    double high_coefficient[5];
-    double zho,zho_3;
-    double temp_data;
-    double temp_data_1;
-    int  ichan,ico,flag_any_high;
-/* Perform Lo correction on All data that is not flaged for high correction --*/
-    zho=(double)rho[0];
-    
-    zho_3=zho*zho*zho;
-
-    lo_u[0]=zho;
-    lo_u[1]=zho_3-(61.0/512.0);
-    lo_u[2]=zho-(63.0/128.0);
-
-    lo_h[0]=zho*zho;
-    lo_h[2]=zho_3*zho_3*zho;         /* zlag ^7 */
-    lo_h[1]=zho*lo_h[2];               /* zlag ^8 */
-/* determine lo-correct coefficents -*/
-    for(ico=0; ico<3; ico++)
-    {
-         lo_coefficient[ico]=(lo_u[ico]*(lo_u[ico]*(lo_u[ico]*lo_const[ico][0]+lo_const[ico][1])+lo_const[ico][2])+lo_const[ico][3])/lo_h[ico];
-    }
-/* perform correction --*/
-    for(ichan=1,flag_any_high=NO; ichan<npts; ichan++)
-    {
-        temp_data=(double)rho[ichan];
-        if(fabs(temp_data) > 0.199)
-        {
-            if(flag_any_high==NO)
-            {
-                   high_u[0]=lo_h[2];                  /* zlag ^7 */
-                   high_u[1]=zho-(63.0/128.0);
-                   high_u[2]=zho*zho-(31.0/128.0);
-                   high_u[3]=zho_3-(61.0/512.0);
-                   high_u[4]=zho-(63.0/128.0);
-
-                   high_h[0]=lo_h[1];               /* zlag ^8 */
-                   high_h[1]=lo_h[1];               /* zlag ^8 */
-                   high_h[2]=lo_h[1]*zho_3*zho;   /* zlag ^12 */
-                   high_h[3]=lo_h[1]*lo_h[1]*zho;  /* zlag ^17 */
-                   high_h[4]=high_h[3];             /* zlag ^17 */
-                   for(ico=0; ico<5; ico++)
-                   {
-                      high_coefficient[ico]=(high_u[ico]*(high_u[ico]*(high_u[ico]*high_const[ico][0]+high_const[ico][1])+high_const[ico][2])+high_const[ico][3])/high_h[ico];
-                   }
-                   flag_any_high=YES;
-              }
-              temp_data_1=fabs(temp_data*temp_data*temp_data);
-              rho[ichan]=(temp_data*(temp_data_1*(temp_data_1*(temp_data_1*(temp_data_1*high_coefficient[4]+high_coefficient[3])+high_coefficient[2])+high_coefficient[1])+high_coefficient[0]));
-         } else
-         {
-              temp_data_1=temp_data*temp_data;
-              rho[ichan]=(temp_data*(temp_data_1*(temp_data_1*lo_coefficient[2]+lo_coefficient[1])+lo_coefficient[0]));
-         }
-    }
-    rho[0] = 1.0;
-    return(0);
-}
-
diff --git a/filterbank-gmrt/vers.inc b/filterbank-gmrt/vers.inc
deleted file mode 100644
index c93115a..0000000
--- a/filterbank-gmrt/vers.inc
+++ /dev/null
@@ -1,2 +0,0 @@
-      character*60 version
-      parameter(version='is part of SIGPROC version: 3.7')
diff --git a/filterbank-gmrt/version.h b/filterbank-gmrt/version.h
deleted file mode 100644
index c85fd7d..0000000
--- a/filterbank-gmrt/version.h
+++ /dev/null
@@ -1 +0,0 @@
-#define SIGPROC_VERSION 3.7
diff --git a/filterbank-gmrt/version.history b/filterbank-gmrt/version.history
deleted file mode 100644
index 080dc6a..0000000
--- a/filterbank-gmrt/version.history
+++ /dev/null
@@ -1,30 +0,0 @@
-\begin{verbatim}
-1.0  - 2001/02/26 - first version developed between summer 1999 and early 2001
-1.1  - 2001/11/16 - filterbank now accepts multiple files as input
-1.2  - 2001/12/20 - filterbank can now accept Parkes/Jodrell 1-bit data
-1.3  - 2002/01/17 - merged IHS modifications to dedisperse WAPP folded data
-1.4  - 2002/01/29 - fixed bug in period calculation and check source name
-1.5  - 2002/02/07 - added -invert to filterbank and <50MHz bw to wapp2fb
-1.6  - 2002/02/19 - upgraded old BACSPIN reader to read BCPM search data
-1.7  - 2002/04/15 - added profile program, wapp2fb can now read 8-bit data
-1.8  - 2002/05/16 - fixed bug in updating polyco when folding long timeseries
-1.9  - 2002/06/25 - fold can now take constant acceleration to update period
-2.0  - 2003/04/02 - added SIGPROC binary profile format for input to dedisperse
-2.1  - 2003/06/03 - added pgplotter utility and frequency tables in headers
-2.2  - 2003/09/20 - works for new WAPP format (use 2.1 for _very_ early data)
-2.3  - 2003/10/24 - added depolyco utility for resampling time series
-2.4  - 2003/10/29 - dedisperse profiles using Ingrid/Joe's fftshift routines
-2.5  - 2004/06/21 - fix polyco bug, write PSRFITS profiles, Ingrid's WAPP mods
-2.6  - 2004/07/02 - re-introduced use of FFTW libraries
-2.7  - 2004/08/18 - updated quickplot and filterbank following first ALFA run
-2.8  - 2004/08/22 - added barycentre program and, unofficially, find and best
-2.9  - 2004/09/06 - small changes to scripts and capability to read >2 GB files
-3.0  - 2004/11/06 - fold now dumps at exact tsec intervals. *new* blanker prog
-3.1  - 2005/03/24 - fix single-pulse time stamps and correct TEMPO site in .prf
-3.2  - 2005/04/18 - find.f now changed to seek.f npts.inc changed to 2**23
-3.3  - 2005/05/02 - incorporated Ramach's implementation of the tree algorithm!
-3.4  - 2005/07/15 - filterbank can now read GMRT fast-sampled filterbank data
-3.5  - 2006/01/16 - fake does binaries (ta Mike and Ralph!) and peak.f from seek
-3.6  - 2006/02/28 - added dice.c and Maura's mods to single-pulse searching
-3.7  - 2006/03/01 - added Mike's tune.c and mods from MMB search processing
-\end{verbatim}
diff --git a/filterbank-gmrt/vmax.c b/filterbank-gmrt/vmax.c
deleted file mode 100644
index acef0de..0000000
--- a/filterbank-gmrt/vmax.c
+++ /dev/null
@@ -1,8 +0,0 @@
-/* returns the maximum value of a vector */
-float vmax(float *vec, float n) /*includefile*/
-{
-  float maxvalue; int i;
-  maxvalue=vec[0];
-  for (i=1;i<n;i++) if (vec[i]>maxvalue) maxvalue=vec[i];
-  return (maxvalue);
-}
diff --git a/filterbank-gmrt/vmin.c b/filterbank-gmrt/vmin.c
deleted file mode 100644
index 256dee1..0000000
--- a/filterbank-gmrt/vmin.c
+++ /dev/null
@@ -1,9 +0,0 @@
-/* returns the minimum value of a vector */
-float vmin(float *vec, float n) /*includefile*/
-{
-  float minvalue; int i;
-  minvalue=vec[0];
-  for (i=1;i<n;i++) if (vec[i]<minvalue) minvalue=vec[i];
-  return (minvalue);
-}
-
diff --git a/filterbank-gmrt/wapp2fb.c b/filterbank-gmrt/wapp2fb.c
deleted file mode 100644
index 61a9303..0000000
--- a/filterbank-gmrt/wapp2fb.c
+++ /dev/null
@@ -1,378 +0,0 @@
-/* 
-   wapp2fb - converts WAPP search-mode data into "filterbank" data 
-
-   Created from earlier wapp2fbfm code (which itself was based on routines 
-   written by Andy Dowd and Jeff Hagen) --- dunc@naic.edu --- Aug 23, 2000.
-
-   Aug 18, 2004 - added ALFA demultiplexing mode
-   Mar 24, 2005 - added Jeff's code to get positions if not in header
-*/
-
-#include "filterbank.h"
-#include "wapp_header.h"
-#include <string.h>
-#include <fcntl.h>
-
-#include "alfa_position.c"
-
-/* 
-   From version 2.6 onwards, FFTW can be substituted if version 3 of
-   the libraries has been installed on the system. The compiler directive
-   FFTW is used to switch on these libraries --- can give 30% speed-up
-   for this particular application (real-to-real FFT)
-*/
-#ifdef FFTW
-#include <fftw3.h>
-#endif
-
-/* time between correlator dumps in us */
-#define WAPP_DEAD_TIME 0.34
-
-int wapp_lagtrunc, wapp_file, wapp_lagformat, wapp_sum, wapp_level, wapp_flip;
-int wapp_header_size, wapp_incfile_length, wapp_isalfa, wapp_number;
-double wapp_obstime, alfa_ang, alfa_raj[7], alfa_dej[7];
-
-void wapp2fb(FILE *input, FILE *output) /* includefile */
-{
-  FILE *bptr, *fpou, *alfa[2];
-  int pixel[2];
-  double pra, pdec;
-  double bw, bandwidth, scale, power, hweight, tsamp_us, crate, lmst;
-  double *lag, *sum, *acf, *window, jan1, days, epoch, ras,des,rahr,dede; 
-  float zerolag,*block,smin,smax;
-  int doit,i,j,k,two_nlags,nlags,stat,rec_size,idump,swap_bytes,ifnum,opened;
-  int filesize,headersize,beam,utsecs,iymdf[4],rah,ram,ded,dem;
-  unsigned char *cblock, zuc;
-  unsigned short *sblock, zus; 
-  unsigned long zul;
-  char message[80], outfile[80];
-  void *dump;
-  static float realtime=0.0;
-
-#ifdef FFTW
-  fftw_plan fftplan;
-#endif
-  /* establish whether we need to swap bytes (WAPP is little endian) */
-  swap_bytes=big_endian();
-
-  /* initialise correlator parameters used below */
-  nlags=nchans;  two_nlags=2*nlags;  bandwidth=foff*nlags;
-  tsamp_us=tsamp*1.0e6;
-  if (bandwidth<0.0) bandwidth *= -1.0;
-
-#ifdef FFTW
-  acf = fftw_malloc(sizeof(double) * two_nlags);
-  lag = fftw_malloc(sizeof(double) * two_nlags);
-  /* set up fftw table and acf array when computing power spectra */
-  fftplan=fftw_plan_r2r_1d(two_nlags,acf,lag,FFTW_R2HC,FFTW_PATIENT);
-#endif
-#ifndef FFTW
-  /* set up acf array when computing power spectra */
-  acf = (double *) malloc(two_nlags * sizeof(double));
-  lag = (double *) malloc(two_nlags * sizeof(double));
-#endif
-
-  if (compute_spectra) {
-    /* ranges for scaling spectra */
-    smin=0.0;smax=3.0;
-  } else {
-    /* ranges for scaling correlation functions */
-    smin=-0.5;smax=1.0;
-  }
-
-  /* set up the weights for windowing of ACF to monimize FFT leakage */
-  if (hanning) {
-    /* Hanning window */
-    hweight=0.50;
-  } else if (hamming) {
-    /* Hamming window */
-    hweight=0.54;
-  } else {
-    /* no window (default) */
-    hweight=1.00;
-  }
-
-  /* define the smoothing window to be applied base on the above weight */
-  window = (double *) malloc(nlags * sizeof(double));
-  for (j=0; j<nlags; j++) window[j]=(hweight+(1.0-hweight)*cos(PI*j/nlags));
-
-  /* work out number of IFs to loop over */
-  if (sumifs && (nifs>1)) {
-    smin*=2.0;
-    smax*=2.0;
-    ifnum=2;
-  } else {
-    sumifs=0;
-    ifnum=nifs;
-  }
-
-  /* calculate required record size for reading - i.e. number of bytes/dump */
-  rec_size = nifs*nlags*(nbits/8);
-  dump = malloc(rec_size); /* pointer to the correlator dump */
-
-  /* correlator data rate */
-  crate = 1.0/(tsamp_us-WAPP_DEAD_TIME); 
-  /* scale factor to normalize correlation functions */
-  if (bandwidth < 50.0) 
-    bw=50.0; /* correct scaling for narrow-band use */
-  else
-    bw=bandwidth;
-
-  scale = crate/bw;
-  if (wapp_level==9) scale/=16.0; /* 9-level sampling */
-  if (wapp_sum) scale/=2.0;  /* summed IFs (search mode) */
-  scale*=pow(2.0,(double)wapp_lagtrunc); /* needed for truncation modes */
-
-  /* now define a number of working arrays to store lags and spectra */
-  block = (float *) malloc(nlags * sizeof(float));
-  cblock = (unsigned char *) malloc(nlags * sizeof(unsigned char));
-  sblock = (unsigned short *) malloc(nlags * sizeof(unsigned short));
-
-  /* if the file is ALFA data --- do the demultiplexing to two files */
-  if (wapp_isalfa) {
-
-    angle_split(src_raj,&rah,&ram,&ras);
-    rahr=(double)rah+(double)ram/60.0+(double)ras/3600.0;
-    angle_split(src_dej,&ded,&dem,&des);
-    if (ded>0)
-      dede=(double)ded+(double)dem/60.0+(double)des/3600.0;
-    else
-      dede=(double)ded-(double)dem/60.0-(double)des/3600.0;
-    /* calculate local sidereal time in hours */
-    lmst=slaGmst(tstart)*12.0/4.0/atan(1.0)-4.4502051459439667;
-    if (lmst<0.0) lmst+=24.0;
-    slaDjcal(5,tstart,iymdf,&stat);
-    slaCaldj(iymdf[0],1,1,&jan1,&stat);
-    days=tstart-jan1+1.0;
-    epoch=(double)iymdf[0]+days/365.25;
-    utsecs=86400*(tstart-floor(tstart));
-
-    pixel[0]=(wapp_number-1)*2;
-    pixel[1]=pixel[0]+1;
-    puts("opening output files for demultiplexed ALFA data...");
-    for (i=0; i<2; i++) {
-      if (alfa_raj[pixel[i]] == 0.0) {
-      alfa_position(rahr,dede,lmst,epoch,alfa_ang,0.0,0.0,pixel[i],&pra,&pdec);
-      src_raj=h2hms(pra);
-      src_dej=deg2dms(pdec);
-      } else {
-      src_raj=h2hms(alfa_raj[pixel[i]]);
-      src_dej=deg2dms(alfa_dej[pixel[i]]);
-      }
-      sprintf(outfile,"%s_%.0f_%05d_%04d_%s_%d.fil",
-	    project,floor(tstart),utsecs,
-	    scan_number,source_name,pixel[i]);
-      alfa[i]=open_file(outfile,"wb");
-      puts(outfile);
-      filterbank_header(alfa[i]);
-    }
-    beam=0;
-  }
-
-  if (headerfile) {
-    /* write output ASCII header file */
-    fpou=open_file("head","w");  
-    fprintf(fpou,"Original WAPP file: %s\n",inpfile);
-    fprintf(fpou,"Sample time (us): %f\n",tsamp_us);
-    fprintf(fpou,"Observation time (s): %f\n",wapp_obstime);
-    fprintf(fpou,"Time stamp (MJD): %18.12f\n",tstart);
-    fprintf(fpou,"Number of samples/record: %d\n",512);
-    fprintf(fpou,"Center freq (MHz): %f\n",fch1+(float)nlags*foff/2.0);
-    fprintf(fpou,"Channel band (kHz): %f\n",bandwidth*1000.0/nlags);
-    fprintf(fpou,"Number of channels/record: %d\n",nlags);
-    fprintf(fpou,"Nifs: %d\n",ifnum);
-    fprintf(fpou,"RA (J2000): %f\n",src_raj);
-    fprintf(fpou,"DEC (J2000):  %f\n",src_dej);
-    fprintf(fpou,"Gal l: %.4f\n",srcl);
-    fprintf(fpou,"Gal b: %.4f\n",srcb); 
-    fprintf(fpou,"Name: %s\n",source_name);
-    fprintf(fpou,"Lagformat: %d\n",wapp_lagformat);
-    fprintf(fpou,"Sum: %d\n",wapp_sum);
-    fprintf(fpou,"Level: %d\n",wapp_level);
-    fprintf(fpou,"AZ at start: %f\n",az_start);
-    fprintf(fpou,"ZA at start: %f\n",za_start);
-    fprintf(fpou,"AST at start: %f\n",ast0);
-    fprintf(fpou,"LST at start: %f\n",lst0);
-    fprintf(fpou,"Project ID: %s\n",project);
-    fprintf(fpou,"Observers: %s\n",culprits);
-    filesize=sizeof_file(inpfile);
-    fprintf(fpou,"File size (bytes): %d\n",filesize);
-    headersize=wapp_header_size+wapp_incfile_length;
-    fprintf(fpou,"Data size (bytes): %d\n",filesize-headersize);
-    fprintf(fpou,"Number of samples: %d\n",nsamples(inpfile,headersize,nbits,nifs,nchans));
-    fclose(fpou);
-  }
-
-  /* initialise various counters and flags */
-  opened=idump=i=j=0; 
-
-  /* main loop reading data from infile until no more left to read */
-  while( (stat=read(wapp_file,dump,rec_size)) == rec_size) {
-
-    /* calculate elapsed time and determine whether we process this record */
-    realtime += (float) tsamp;
-    if ( (doit=process(realtime,start_time,final_time)) == -1) break;
-
-    if (doit) {
-
-      /* set ALFA beam output if necessary */
-      if (wapp_isalfa) {
-	output=alfa[beam];       /* set output file for this loop */
-	beam=!(beam);            /* flip file for next iteration */
-      }
-
-      /* clear zerolag and blocksum arrays */
-      zerolag=0.0;
-      for (j=0; j<nlags; j++) block[j]=0.0;
-
-      /* loop over the IFs */
-      for (i=0; i<ifnum; i++) {
-	if (ifstream[i]=='Y') {
-	  if (zerolagdump) {
-	    /* only interested in the zero lag term for each IF */
-	    switch (nbits) {
-	    case 8:
-	      zuc = *(((unsigned char *)dump)+i*nlags);
-	      zerolag+=zuc;
-	      break;
-	    case 16:
-	      zus = *(((unsigned short *)dump)+i*nlags);
-	      if (swap_bytes) swap_short(&zus); 
-	      zerolag+=zus;
-	      break;
-	    case 32:
-	      zul = *(((unsigned long *)dump)+i*nlags);
-	      if (swap_bytes) swap_long(&zul); 
-	      zerolag+=zul;
-	      break;
-	    }
-	    /* write out the data checking IF number for summed mode */
-	    if ( (sumifs && (i==1)) || (!sumifs) ) {
-	      if (obits==32) {
-		if (swapout) swap_float(&zerolag);
-		fwrite(&zerolag,sizeof(float),1,output);
-	      } else {
-		sprintf(message,"cannot write %d bits in zerolag mode",obits);
-		error_message(message);
-	      }
-	    }
-	  } else {
-	    /* fill lag array with scaled CFs */
-	    for (j=0; j<nlags; j++) {
-	      switch (nbits) {
-	      case 8:
-		zuc = *(((unsigned char *)dump)+j+i*nlags);
-		lag[j] = scale * (double) zuc - 1.0;
-		break;
-	      case 16:
-		zus = *(((unsigned short *)dump)+j+i*nlags);
-		if (swap_bytes) swap_short(&zus);
-		lag[j] = scale * (double) zus - 1.0;
-		break;
-	      case 32:
-		zul = *(((unsigned long  *)dump)+j+i*nlags);
-		if (swap_bytes) swap_long(&zul);
-		lag[j] = scale * (double) zul - 1.0;
-		break;
-	      }
-	    }
-	    /* calculate power and correct for finite level quantization */
-	    power = inv_cerf(lag[0]);
-	    power = 0.1872721836/power/power;
-	    if (i<2) {
-	      if (do_vanvleck) { 
-		if (wapp_level==3) {
-		  /* apply standard 3-level van vleck correction */
-		  vanvleck3lev(lag,nlags);
-		} else if (wapp_level==9) {
-		  /* apply 9-level van vleck correction */
-		  vanvleck9lev(lag,nlags);
-		}
-	      }
-	    }
-
-	    if (compute_spectra) {
-	      /* form windowed even ACF in array */
-	      for(j=1; j<nlags; j++) {
-		acf[j]=window[j]*lag[j]*power;
-		acf[two_nlags-j]=acf[j];
-	      }   
-	      acf[nlags]=0.0;
-	      acf[0]=lag[0]*power; 
-	      /* FFT the ACF (which is real and even) -> real and even FFT */
-#ifdef FFTW
-	      fftw_execute(fftplan);
-#endif
-#ifndef FFTW
-	      rfft(two_nlags,acf,lag);
-#endif
-	      /* if the band needs to be flipped --- do it here */
-	      if (wapp_flip) {
-		/* use acf as temporary array */
-		for (j=0;j<nlags;j++) acf[j]=lag[j]; 
-		k=nlags-1;
-		for (j=0;j<nlags;j++) {
-		  lag[k]=acf[j];
-		  k--;
-		}
-	      }
-  	      /* add lags to block array */
-	      for (j=0; j<nlags; j++) block[j]+=lag[j];
-	    } else {			
-	      /* just copy correlation functions into block */
-	      for (j=0; j<nlags; j++) block[j]=lag[j];	
-	    }
-	    /* write out data block checking IF number for summed mode */
-	    if ( (sumifs && (i==1)) || (!sumifs) ) {
-	      if (obits==32) {
-		if (swapout) for (j=0; j<nlags; j++) swap_float(&block[j]);
-		fwrite(block,sizeof(float),nlags,output);
-	      } else if (obits==16) {
-		float2short(block,nlags,smin,smax,sblock);
-		if (swapout) for (j=0; j<nlags; j++) swap_short(&sblock[j]);
-		fwrite(sblock,sizeof(unsigned short),nlags,output);
-	      } else if (obits==8) {
-		float2char(block,nlags,smin,smax,cblock);
-		fwrite(cblock,sizeof(unsigned char),nlags,output);
-	      } else if (obits==4) {
-		float2four(block,nlags,smin,smax,cblock);
-		fwrite(cblock,sizeof(unsigned char),nlags/2,output);
-	      } else {
-		sprintf(message,"cannot write %d bits in wapp2fb",obits);
-		error_message(message);
-	      }
-	    }
-	  } /* end of zerolagdump if */
-
-	  if (!sumifs) { /* reset block and zerolag if not summing */
-	    zerolag=0.0;
-	    for (j=0; j<nlags; j++) block[j]=0.0;
-	  }
-	}          /* end of IFstream if */
-      }            /* end of loop over IFs */
-    }              /* end of processing if */
-
-    /* increment dump counter and update logfile every 512 dumps */
-    idump++;
-    if (idump%512 == 0) {
-      if (!opened) {
-	/* open up logfile */
-	open_log("filterbank.monitor");
-	opened=1;
-      }
-      sprintf(message,"time:%.1fs",realtime);
-      update_log(message);
-    }
-  }                /* end of main read loop*/
-
-    
-  /* job done - free up remaining arrays */
-  free(dump);free(block);free(sblock);free(cblock);free(window);
-#ifdef FFTW
-  fftw_destroy_plan(fftplan);
-  fftw_free(acf); fftw_free(lag);
-#endif
-#ifndef FFTW
-  free(acf); free(lag);
-#endif
-}
diff --git a/filterbank-gmrt/wapp_header.c b/filterbank-gmrt/wapp_header.c
deleted file mode 100644
index f0682ee..0000000
--- a/filterbank-gmrt/wapp_header.c
+++ /dev/null
@@ -1,295 +0,0 @@
-
-#include <stdio.h>
-#include <fcntl.h>
-
-void head_input( char *, int *, int );
-int linecount = 1;
-
-#define YY_INPUT(buf,result,max) head_input(buf,&result,max)
-#include "mkheaderlex.c"
-
-#include "key.h"
-
-
-struct HEADERP *yacc_input = NULL;
-
-/* this routine is not re-entrant, (because of yyparse and yacc_input) */
-
-struct HEADERP *head_parse( FILE *fptr )
-{
-  int fd, count, ret;
-  unsigned char byte;
-  struct HEADERKEY *key;
-  struct HEADERP *h;
-
-  count = 0;
-  while( (ret = fread( &byte, 1, 1, fptr)) == 1 ) {
-    if( byte == 0 )
-      break;
-    count++;
-  }
-
-  if( ret < 1 )
-    return(NULL);
-
-  h = ( struct HEADERP *)malloc( sizeof(struct HEADERP));
-  bzero( h, sizeof(struct HEADERP));
-
-  h->offset = count+1;
-  h->fd = fd;
-  h->buf = (char *)malloc( h->offset);
-  lseek(fd, 0, SEEK_SET);
-  read(h->buf, sizeof(h->buf), h->offset, fptr );
-
-  yacc_input = h;
-
-  while(yyparse()); /* use yacc to parse the header */
-  yyparse();
-
-  h->headlen = count_size(h);
-  h->header = (void *)malloc( h->headlen );
-  if( fread( h->header, sizeof(h->header), h->headlen, fptr ) != h->headlen ) {
-    perror("read header");
-    return(NULL);
-  }
-
-  key = h->head;
-  count = 0;
-  while( key ) {
-    key->len = key_sizes(key->type);
-    key->offset = count;
-    count  += key->len* key->alen;
-    key = key->next;
-  }
-
-  return(h);
-}
-
-count_size(h)
-struct HEADERP *h;
-{
-  struct HEADERKEY *k;
-  int count;
-
-  k = h->head;
-  count = 0;
-  while(k) {
-    count += key_sizes(k->type)*k->alen;
-    k = k->next;
-  }
-  return(count);
-}
-
-int key_sizes(type)
-int type;
-{
-  switch( type ) {
-    case INTEGER:
-      return sizeof(int);
-    case LONG:
-      return sizeof(long);
-    case LONGLONG:
-      return sizeof(long long);
-    case DOUBLE:
-      return sizeof(double);
-    case FLOAT:
-      return sizeof(float);
-    case CHARSTAR:
-      return sizeof(char);
-    default:
-      printf("key_sizes error, bad type %d\n", type );
-      return 0;
-  }
-}
-
-int find_hdrval( h, name, hdrval )
-struct HEADERP *h;
-char *name;
-struct HEADERVAL *hdrval;
-{
-  struct HEADERKEY *key;
-  puts("???");
-  key = h->head;
-  while( key ) {
-    if( strcmp( name, key->name ) == 0 )
-      break;
-    key = key->next;
-  }
-
-  if( key ) {
-    if( hdrval ) {
-      hdrval->value = (void *)((unsigned char *)h->header + key->offset);
-      hdrval->key = key;
-    }
-  } else if( hdrval ) {
-    bzero( hdrval, sizeof(struct HEADERVAL));
-  }
-
-  return(!key);
-}
-
-int set_hdrval( h, name, data, ix )
-struct HEADERP *h;
-char *name;
-void *data;
-int ix;
-{
-  struct HEADERVAL val;
-  void *value;
-
-  if( find_hdrval( h, name, &val ) )
-    return(-1);
-
-  if( val.key->alen == 1 )
-    ix = 0;
-
-  if( ix >= val.key->alen )
-    return(-1);
-
-  value = (char *)val.value + val.key->len*ix;
-
-  bcopy( data, value, val.key->len );
-  return(0);
-}
-
-int write_hdr( h )
-struct HEADERP *h;
-{
-  lseek( h->fd, h->offset, SEEK_SET );
-  if( write( h->fd, h->header, h->headlen ) != h->headlen ) {
-    perror("write_hdr write");
-    return(-1);
-  }
-  return(0);
-}
-
-ignore()
-{ 
-}
-
-
-struct HEADERKEY *new_header()
-{
-  struct HEADERKEY *p;
-  extern struct HEADERP *yacc_input;
-
-  p = (struct HEADERKEY *)malloc( sizeof(struct HEADERKEY));
-  bzero( p, sizeof(struct HEADERKEY));
-
-  if( !yacc_input->head  )
-    yacc_input->head = p;
-
-  if( yacc_input->tail )
-    yacc_input->tail->next = p;
-
-  yacc_input->tail = p;
-  return(p);
-}
-
-add_notchar(v, name)
-int v;
-char *name;
-{
-  
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  p->type = v;
-  p->alen = 1;
-}
-
-
-add_array(v, name, sz)
-int v;
-char *name, *sz;
-{
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  p->type = v;
-  if( sz )
-    p->alen = atoi(sz);
-  else
-    p->alen = 1;
-}
-
-
-comment(p)
-char *p;
-{
-  free(p);
-}
-
-add_char(name, sz)
-char *name, *sz;
-{
-  struct HEADERKEY *p = new_header();
-
-  p->name = name;
-  p->type = CHARSTAR;
-  if( sz )
-    p->alen = atoi(sz);
-  else
-    p->alen = 1;
-}
-
-got_construct( name )
-char *name;
-{
-  /* printf("got construct\n"); */
-}
-
-
-void head_input( buf, result, max )
-char *buf;
-int *result;
-int max;
-{
-  extern struct HEADERP *yacc_input;  
-  int ct;
-
-  ct = yacc_input->offset -  yacc_input->yacc_offset;
-  if( ct <=0 ) {
-    *buf = 0;
-    *result = 0;
-    return;
-  }
-  if( ct < max ) {
-    bcopy( &yacc_input->buf[yacc_input->yacc_offset], buf, ct );
-    yacc_input->yacc_offset = yacc_input->offset;
-    *result = ct;
-  } else { 
-    bcopy( &yacc_input->buf[yacc_input->yacc_offset], buf, max );
-    yacc_input->yacc_offset += max;
-    *result = max;
-  }
-}
-
-close_parse( h )
-struct HEADERP *h;
-{
-  struct HEADERKEY *key, *fr;
-
-  close(h->fd);
-
-  key = h->head;
-  while( key ) {
-    fr = key;
-    key = key->next;
-    free(fr);
-  }
-  
-  free(h->buf);
-  free(h->header);
-  free(h);
-}
-
-int jgetc( FILE *a)
-{
-  static count = 0; 
-
-  if( count < yacc_input->offset )
-    return( yacc_input->buf[count++]);
-  else
-    return(EOF);
-}
diff --git a/filterbank-gmrt/wapp_header.h b/filterbank-gmrt/wapp_header.h
deleted file mode 100644
index 21cf38c..0000000
--- a/filterbank-gmrt/wapp_header.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* 
-  RCS: $Id: wapp_header.h,v 1.8 2004/02/17 13:13:25 wapp Exp wapp $
-   wapp_head.h - header parameters for WAPP (Wideband Arecibo Pulsar Processor)
-   This structure (WAPP_HEADER) is based on the PSPM-style headers but has
-   been somewhat simplified to include just essential/relevant parameters. 
-*/
-
-#define HEADER_VERSION 8
-
-/* lagformat for wapp_header */
-
-#define INTLAGS   0   /* 16 bit integers - searching only      */
-#define LONGLAGS  1   /* 32 bit integers - searching only      */
-#define FLOATLAGS 2   /* 32 bit float ACF/CCFs folding only    */
-#define FLOATSPEC 3   /* 32 bit float fftd ACFs folding only   */
-#define BYTELAGS  4   /* 8 bit integers ACF/CCF searching only */
-#define NIBBLAGS  5   /* 4 bit integers ACF/CCF searching only */
-#define FOLD32    8   /* bit mask with FLOATLAGS and FLOATSPEC */
-                      /* if on 32 bit folding is turned on     */
-
-struct WAPP_HEADER {
-
-    long header_version; /* some integer that increments with each revision */
-    long header_size;    /* size (in bytes) of this header (nom =1024) */
-    char obs_type[24];   /* what kind of observation is this */
-                         /* PULSAR_SEARCH */
-                         /* PULSAR_FOLDING */
-                         /* SPECTRA_TOTALPOWER */
-/* 
-    The following are obtained from current telescope status display
-    note that start AST/LST are for reference purposes only and should 
-    not be taken as accurate time stamps. The time stamp can be derived
-    from the obs_date/start_time variables further down in the structure.
-*/
-    double src_ra;       /* requested ra J2000 (10000*hr+100*min+sec) */
-    double src_dec;      /* requested dec J2000 (10000*deg+100*min+sec) */
-    double start_az;     /* telescope azimuth at start of scan (deg) */
-    double start_za;     /* telescope zenith angle at start of scan (deg) */
-    double start_ast;    /* AST at start of scan (sec) */
-    double start_lst;    /* local siderial time at start of scan (sec) */
-/*  
-    In the following, anything not supplied/requested by the user
-    is assumed to be calculated by WAPP when it writes the header
-*/
-    double cent_freq;    /* user-supplied band center frequency (MHz) */
-    double obs_time;     /* user-requested length of this integration (s) */
-    double samp_time;    /* user-requested sample time (us) */
-    double wapp_time;    /* actual sample time (us) i.e. requested+dead time */
-    double bandwidth;    /* total bandwidth (MHz) for this observation */
-
-    long num_lags;       /* user-requested number of lags per dump per spect */
-    long scan_number;    /* built by WAPP from year+daynumber+3-digit-number */
-
-    char src_name[24];   /* user-supplied source name (usually pulsar name) */
-    char obs_date[24];   /* built by WAPP from yyyymmdd */
-    char start_time[24]; /* UT seconds after midnight (start on 1-sec tick) */
-    char project_id[24]; /* user-supplied AO proposal number (XYYYY) */
-    char observers[24];  /* observer(s) name(s) */
-
-    int nifs;            /* user-requested: number of IFs to be recorded     */
-    int level;           /* user-requested: 1 means 3-level; 2 mean 9-level  */
-    int sum;             /* user-requested: 1 means that data is sum of IFs  */
-    int freqinversion;   /* 1 band is inverted, else band is not inverted    */
-    long long timeoff;   /* number of reads between obs start and snap block */
-    int lagformat;       /* 0=16 bit uint lags , 1=32 bit uint lags          */
-                         /* 2=32 bit float lags, 3=32 bit float spectra      */
-    int lagtrunc;        /* if we truncate data (0 no trunc)                 */
-                         /* for 16 bit lagmux modes, selects which 16 bits   */
-                         /* of the 32 are included as data                   */
-                         /* 0 is bits 15-0 1,16-1 2,17-2...7,22-7            */
-    int firstchannel;    /* 0 when correlator channel a is first, 1 if b     */
-    int nbins;           /* number of time bins for pulsar folding mode      */
-                         /* doulbles as maxrecs for snap mode                */
-    int isfolding;       /* is folding selected                              */
-    int isalfa;          /* is ALFA selected                                 */
-    double dumptime;     /* folded integrations for this period of time      */
-    double power_analog[2];   /* Power measured by Analog Detector           */
-/*    
-    In the following, pulsar-specific information is recorded for use 
-    by folding programs e.g. the quick-look software. This is passed to 
-    WAPP by psrcontrol at the start of the observation. 
-
-    The apparent pulse phase and frequency at time "dt" minutes with
-    respect to the start of the observation are then calculated as:
-
-    phase = rphase + dt*60*f0 + coeff[0] + dt*coeff[1] + dt*dt*coeff[2] + ...
-    freq(Hz) = f0 + (1/60)*(coeff[1] + 2*dt*coeff[2] + 3*dt*dt*coeff[3] + ...)
-
-    where the C notation has been used (i.e. coeff[0] is first coefficient etc)
-    for details, see TEMPO notes (http://www.naic.edu/~pulsar/docs/tempo.txt)
-*/
-    double psr_dm;         /* pulsar's dispersion measure (cm-3 pc) */
-    double rphase[16];      /* reference phase of pulse (0-1) */
-    double psr_f0[16];      /* pulse frequency at reference epoch (Hz) */
-    double poly_tmid[16];   /* mid point of polyco in (MJD) modified Julian date */     
-    double coeff[192];     /* polynomial coefs made by TEMPO, 16 sets of 12 */
-    int num_coeffs[16];     /* number of coefficients */
-    char hostname[24];    /* ascii hostname of machine that took this data */
-    int fold_bits;        /* 0 if 16 bits (old default) 1 if 32 bit folding */
-    int iflo_flip;        /* consider entire iflo and determine flip */
-    int attena;           /* first board parallel port value */
-    int attenb;           /* second board parallel port value */
-
-/* alfa info */
-
-    double rfeed_offaz[7];  /* deg az rotated offset all alfa beam to center */
-    double rfeed_offza[7];  /* deg za rotated offset all alfa beam to center */
-    double prfeed_offaz;  /* deg az offset to center of alfa beam */
-    double prfeed_offza;  /* deg za offset to center of alfa beam */
-    double alfa_raj[7];   /* hr starting actual ra position of alfa beams */
-    double alfa_decj[7];  /* deg starting actual dec position of alfa beams */
-    double alfa_az[7];    /* deg starting actual az position of alfa beams */
-    double alfa_za[7];    /* deg starting actual za postion of alfa beams */
-    double alfa_ang;      /* deg alfa rotation angle  */
-    double para_ang;      /* deg paralactic angle of center beam */
-    char frontend[24];    /* receiver abbrev name */
-
-/* add iflo data */
-
-    double syn1;      /* upstairs synthesizer freq Hz */
-    double synfrq[4]; /* downstairs synthesizers (Hz) */
-
-
-    unsigned char prfeed;  /* centered alfa beam */
-    unsigned char shcl;    /* true if receiver shutter closed */
-    unsigned char sbshcl;   /* true if Sband receiver shutter closed */
-
-    unsigned char rfnum;     /* position of the receiver selectror */
-    unsigned char zmnormal;  /* transfer switch to reverse channels, true normal */
-    unsigned char rfattn[2];  /* attenuator position */
-    unsigned char ifnum;      /* if selector, 1/300 2/750, 3/1500, 4/10GHz1500, 5-thru */
-    unsigned char ifattn[2];  /* IF attenuator positions */
-    unsigned char fiber;      /* true fi fiber is chosen (always the case) */
-    unsigned char ac2sw;      /* ac power to various instruments and other stuff */
-    unsigned char if750nb;    /* narrow band 750 filter selected */
-
-    unsigned char phbsig;     /* converter combiner signal phase adjust */
-    unsigned char hybrid;     /* converter combiner hybrid  */
-    unsigned char phblo;      /* convert combiner lo phase adjust */
-
-/* downstairs */
-
-    unsigned char xfnormal;   /* transfer switch true if normal */
-    unsigned char noise;      /* noise on */
-    unsigned char gain[2];    /* gain of downstairs amps */
-    unsigned char inpfrq;     /* input distributor position */
-    unsigned char mixer[4];   /* mixer source switches */
-    unsigned char vlbainp;    /* vlba input switch position */
-    unsigned char ampinp[4];  /* amplifier input source switches */
-    unsigned char extinp[4];  /* external input selector switches */
-    unsigned char syndest[4]; /* synthesizer destinations */
-    unsigned char calsrc;     /* cal source bit */
-
-    unsigned char vis30mhz;   /* greg 1 ch 0 */
-    unsigned char pwrmet;     /* power meter input switch */
-    unsigned char blank430;   /* 430 blanking on */
-    unsigned char fill[6];    /* fill */
-};
diff --git a/filterbank-gmrt/wapp_prof.c b/filterbank-gmrt/wapp_prof.c
deleted file mode 100644
index 42c6bdf..0000000
--- a/filterbank-gmrt/wapp_prof.c
+++ /dev/null
@@ -1,50 +0,0 @@
-#include <stdio.h>
-#include <fcntl.h>
-#include "sigproc.h"
-int wapp_file;
-
-/* read in profiles from wapp timing-mode data returns a pointer to them */
-float *wapp_prof(int nbins, int nchans, int nifs, int np1, int np2) /*includefile*/
-{
-  int swap_bytes,i,ip,b,c,n,rec_size;
-  float *profile, *dump; 
-  double pavg;
- 
-  swap_bytes=big_endian();
-  rec_size=nchans*nifs*nbins*sizeof(float);
-  profile = (float *) malloc(rec_size); 
-  dump = (float *) malloc(rec_size);
-
-  for(n=0;n<nchans*nifs*nbins;n++) profile[n]=0.;
-
-  for(ip=0;ip<np1;ip++) 
-    if ((read(wapp_file,dump,rec_size)) != rec_size) 
-      error_message("reading WAPP profile...");
-
-  pavg = (double)(np2-np1+1.);
-  for(ip=np1;ip<=np2;ip++) {
-    if ((read(wapp_file,dump,rec_size)) == rec_size) {
-      n=0;
-      for (c=0;c<nchans;c++) {
-	for (i=0;i<nifs;i++) {
-	  for (b=0;b<nbins;b++) {
-	    if (swap_bytes) swap_float(&dump[b*nifs*nchans+i*nchans+c]);
-	    profile[n]+=dump[b*nifs*nchans+i*nchans+c]/pavg;
-	    /*	printf("%d %d %d %d %f\n",c,i,b,n,profile[n]); */
-	    n++;
-	  }
-	}
-      }
-    }
-    else {
-      if(ip == np1)
-	error_message("reading WAPP profile...");
-      else 
-	break;
-    }
-  }
-
-
-  free(dump);
-  return(profile);
-}
diff --git a/filterbank-gmrt/wappcorrect.c b/filterbank-gmrt/wappcorrect.c
deleted file mode 100644
index 4df7101..0000000
--- a/filterbank-gmrt/wappcorrect.c
+++ /dev/null
@@ -1,22 +0,0 @@
-#include <stdio.h>
-#include <math.h>
-/* subroutine to return correction to wapp_time (us) based on mjd */
-double wappcorrect(double mjd) /*includefile*/
-{
-  double correction;
-
-  /* assume no correction initially */
-  correction=0.0;
-
-  if ( (mjd >= 51829.0) && (mjd < 51834.0) ) correction=-0.08;
-  if ( (mjd >= 51834.0) && (mjd < 51859.0) ) correction=-0.68;
-  if ( (mjd >= 51859.0) && (mjd < 51969.0) ) correction=+0.04;
-
-  if (correction != 0.0) {
-    fprintf(stderr,"WARNING: correction %f us applied for MJD %.1f\n",
-	    correction,mjd);
-    fflush(stderr);
-  }
-
-  return(correction);
-}
diff --git a/filterbank-gmrt/whiten.c b/filterbank-gmrt/whiten.c
deleted file mode 100644
index 473b7d4..0000000
--- a/filterbank-gmrt/whiten.c
+++ /dev/null
@@ -1,44 +0,0 @@
-#include <stdio.h>
-#include <math.h>
-#include <malloc.h>
-float select(unsigned long, unsigned long, float *);
-/*
- Routine to whiten a data stream of length npts by subtracting a running 
- median so that it has zero mean and then normalizing the data to unit rms.
- Used to flatten sloping baselines in amplitude spectra of noisy time series.
- Has the advantage over similar algorithms using running mean which can be
- biased by large spectral features. 
- 
- dlorimer@atnf.csiro.au - 2001/10/12 - initial version for use in FIND
-*/
-void whiten_(float *data, int npts, int nsegments) 
-{
-  int i,j,k;
-  unsigned long nwrk;
-  float *work, *median, sumsq, rms;
-
-  /* allocate space to store medians and data segments */
-  nwrk=npts/nsegments;
-  median=(float *) malloc(nsegments*sizeof(float));
-  work=(float *) malloc(nwrk*sizeof(float));
-
-  /* find the median of each segment */
-  for (i=0; i<nsegments; i++) {
-    k=0;
-    for (j=i*nwrk; j<(i+1)*nwrk; j++) work[k++]=data[j];
-    median[i]=select(nwrk/2,nwrk,work-1);
-  }
-
-  /* subtract running median and sum squares every npts/1024 samples */
-  sumsq=0.0;  j=npts/1024;
-  for (i=0; i<npts; i++) {
-    if (data[i] != 0.0) data[i]-=median[i/nwrk];
-    if (i%j == 0) sumsq+=data[i]*data[i];
-  }
-
-  /* normalize to unit rms */
-  rms=sqrt(sumsq/1024.0);  for (i=0; i<npts; i++) data[i]/=rms;
-
-  /* job done - free up space and return */
-  free(median);  free(work);
-}
diff --git a/filterbank-gmrt/write_epn.c b/filterbank-gmrt/write_epn.c
deleted file mode 100644
index e95a3e5..0000000
--- a/filterbank-gmrt/write_epn.c
+++ /dev/null
@@ -1,34 +0,0 @@
-#include <stdio.h>
-#include "epn.h"
-/* write an epn file */
-void write_epn(FILE *fptr, struct EPN epn) /*includefile*/
-{
-  int counter,nlines,i;
-
-  nlines=epn.nbins/20;
-  if ((epn.nbins-epn.nbins/20)>0) nlines++;
-  counter=6+epn.npol*(nlines+2);
-  fprintf(fptr,"EPN 6.00%4d%68s",counter,epn.history);
-  fprintf(fptr,"%12s%12s%16.12f%8.3f%10.3f%6s%8s%8s",
-  epn.jname,epn.cname,epn.pbar,epn.dm,epn.rm,epn.catref,epn.bibref," ");
-
-  fprintf(fptr,"%10.3f%11.3f%-8s%10.3f%8.3f%1c%1c%31s",
-  epn.raj,epn.dec,epn.telname,epn.epoch,epn.opos,epn.paflag,epn.timflag," "); 
-
-  fprintf(fptr,"%17.5f%17.5f%17.5f%29s",epn.xtel,epn.ytel,epn.ztel," ");
-
-  fprintf(fptr,"%02d%02d%4d%04d%04d%02d%04d%04d%12.6f%12.6f%06d%04d%4d%1c%15s",
-  epn.day,epn.month,epn.year,epn.scanno,epn.subscan,epn.npol,epn.nfreq,
-  epn.nbins,epn.tbin,epn.tres,epn.nint,epn.ncal,epn.lcal,epn.fluxflag, " ");
-  
-  fprintf(fptr,"--------------------------------------------------------------------------------");
-
-  fprintf(fptr,"%8s%4d%4d%12.6f%8s%12.6f%8s%17.5f%7s",
-  epn.idfield,epn.nband,epn.navg,epn.f0,epn.uf,epn.df,epn.ud,epn.tstart," ");
-
-  fprintf(fptr,"%#12G%#12G%#12G%16.12f%28s",
-  epn.scale,epn.offset,epn.rms,epn.papp," ");
-
-  for (i=0;i<epn.nbins;i++) fprintf(fptr,"%04X",epn.iprofile[i]);
-  for (i=1;i<=20-(epn.nbins-(epn.nbins/20)*20);i++) fprintf(fptr,"0000");
-}
diff --git a/filterbank-gmrt/write_profiles.c b/filterbank-gmrt/write_profiles.c
deleted file mode 100644
index 21de85c..0000000
--- a/filterbank-gmrt/write_profiles.c
+++ /dev/null
@@ -1,547 +0,0 @@
-#include "fold.h"
-/* 
-   write_profiles.c:
-
-   this subroutine does some final user-defined processing (scaling, baseline
-   subtraction and IF summing) before writing out the folded pulse profiles 
-   in a number of different formats. The time stamp and folding period in the 
-   profiles refers to the START of a given integration. This routine is 
-   normally called from within fold_data.c to dump profiles after a pre-defined
-   subintegration. 
-
-   Modification history:
-
-   April 2, 2003 - added IF summing and checked time stamps (drl@jb.man.ac.uk)
-   June 22, 2004 - added psrfits option (drl@jb.man.ac.uk)
-*/
-#define MAX_BLKS 20
-#define MAX_COEFF 15
-double tsta, tsec, tadd, pfld0, window;
-long int pulsecount;
-void write_profiles(float *prof,int nbins, int nchan, int nifs, FILE *out)/*includefile*/
-{
-  int i,j,c,b,k,m,year,month,day;
-  float *profile,scale,offset,rms,epoch;
-  double usec,tbin,tres,psec;
-  static int first=1;
-  struct EPN epn;
-
-  int sta=0;
-  short int sj;
-  float x,binned_freq[16384],binned_weight[16384],
-    binned_offset[16384],binned_scale[16384],binned_data[16384];
-  int bitpix=8, naxis=0, nrcvr, nrows, ncols, col;
-  static int subint_cnt;
-  char datestr[10],timestr[8];
-  char Cstr16[16], Estr16[16], Istr16[16];
-  char *ttype[20], *tform[20], *tunit[20];
-  long naxes[4];
-  int junk,rah,ram,ded,dem,subint_hdu,hh,mm;
-  float ss;
-  int last_scanhdr_hdu;
-  double ras,des,dx;
-  char rastr[80], destr[80], sra[80], sde[80];
-  char date_time[24];
-  char *pch[MAX_BLKS];
-  char site[MAX_BLKS][2];
-  short int nspan[MAX_BLKS];
-  short int ncoeff[MAX_BLKS];
-  double rfreq[MAX_BLKS];
-  double rmjd[MAX_BLKS];
-  double rphase[MAX_BLKS];
-  double lgfiterr[MAX_BLKS];
-  double f0[MAX_BLKS];
-  double coeff[MAX_BLKS][MAX_COEFF];
-  static double srcl, srcb;
-  /* For Pulsar History BINTABLE */
- 
-  static char *PHtype[18] = {
-    "DATE_PRO","PROC_CMD","POL_TYPE","NPOL    ","NBIN    ","NBIN_PRD","TBIN    ","CTR_FREQ",
-    "NCHAN   ","CHAN_BW ","PAR_CORR","RM_CORR ","DEDISP  ","DDS_MTHD","SC_MTHD ","CAL_MTHD",
-    "CAL_FILE","RFI_MTHD"
-  };
-  
-  static char *PHform[18] = {
-    "24A     ","80A     ","8A      ","1I      ","1I      ","1I      ","1D      ","1D      ",
-    "1I      ","1D      ","1I      ","1I      ","1I      ","32A     ","32A     ","32A     ",
-    "32A     ","32A     "
-  };
-  
-  static char *PHunit[18] = {
-    "        ","        ","        ","        ","        ","        ","s       ","MHz     ",
-    "        ","MHz     ","        ","        ","        ","        ","        ","        ",
-    "        ","        "
-  };
-
-
-
-  /* subtract baseline from outgoing profiles if requested */
-  if (userbase != 0.0) for (i=0;i<multiple*nbins*nifs*nchans;i++) 
-    prof[i]-=userbase;
-
-  /* multiply outgoing profiles by Jansky calibration factor if supplied */
-  if (jyfactor != 0.0) for (i=0;i<multiple*nbins*nifs*nchans;i++) 
-    prof[i]*=jyfactor;
-
-  /* sum first two polarizations together if requested */
-  if (totalpower && (nifs > 1)) {
-    for (i=0;i<multiple*nbins*nchans;i++) 
-      prof[i]+=prof[i+multiple*nbins*nchans];
-    nifs=1;
-  }
-
-  if (binary) {
-    /* write out profiles in binary format */
-    folding_period=pfld0*1000.0;
-    tadd=tstart;
-    tstart=tstart+tsta/86400.0;
-    npuls=pulsecount;
-    fold_header();
-    tstart=tadd;
-    for (i=0; i<nifs; i++) {
-      for (c=0; c<nchan; c++) {
-	for (b=0; b<nbins; b++) 
-	  fwrite(&prof[i*nchan*nbins+c*nbins+b],sizeof(float),1,out);
-      }
-    }
-  } else if (stream) {
-    /* write out profiles as ASCII streams with START/STOP boundaries */
-    k=0;
-    for (i=0;i<nifs;i++) {
-      for (c=0;c<nchan;c++) {
-	fprintf(out,"#START %d %f %f\n",nbins,tsta,fch1+foff*(float)c);
-	for (m=0;m<multiple;m++) {
-	  for (b=0;b<nbins;b++) {
-	    fprintf(out,"%d %f\n",b+m*nbins,prof[i*nchan*nbins+c*nbins+b]);
-	  }
-	}
-	fprintf(out,"#STOP\n");
-      }
-    }
-  } else if (asciipol) {
-    /* write profiles in format for Jim's polarization code */
-    for (b=0;b<nbins;b++) 
-      for (i=0;i<nifs;i++)
-	for (c=0;c<nchan;c++) 
-	  fprintf(out,"%d %d %d %f\n",b,i,c,prof[i*nchan*nbins+c*nbins+b]);
-  } else if (ascii) {
-    fprintf(output,"# %.1f %.7f %.10f %ld %.3f %.3f %d %c %d %s\n",
-     floor(tstart),(tstart-floor(tstart))*86400.0+tsta,pfld0,pulsecount,fch1,refdm,nbins,tempo_site(telescope_id),1,source_name);
-    for (b=0;b<nbins;b++) {
-      fprintf(out,"%d",b+1);
-      for (i=0;i<nifs;i++) {
-	for (c=0;c<nchan;c++) fprintf(out," %f",prof[i*nchan*nbins+c*nbins+b]);
-      }
-      fprintf(out,"\n");
-    }
-#ifdef PSRFITS
-  } else if (psrfits) {
-    if (first) {
-      first=0;
-      /* write profile in PSRFITS format */
-      fits_create_file(&fits, "stdout", &sta);
-      fits_create_img(fits,bitpix,naxis,naxes,&sta);
-      fits_write_date(fits,&sta);
-      /* Get DateTime string - required in various BINTABLEs */
-      fits_get_system_time(date_time,&junk,&sta);
-      fits_update_key(fits,TSTRING,"HDRVER","1.19","Header version",&sta);
-      fits_update_key(fits,TSTRING,"OBSERVER",culprits,
-		      "Observer name(s)",&sta);
-      fits_update_key(fits,TSTRING,"PROJID",project,"Project name",&sta);
-      fits_update_key(fits,TSTRING,"TELESCOP",telescope_name(telescope_id),
-		      "Telescope name", &sta);
-      fits_update_key(fits,TSTRING,"BACKEND",backend_name(machine_id),
-		      "Backend ID",&sta);
-      if (nifs>1) 
-	nrcvr=2;
-      else
-	nrcvr=1;
-      fits_update_key(fits,TINT,"NRCVR",&nrcvr,
-		      "Number of receiver channels (I)",&sta);
-      fits_update_key(fits,TSTRING,"OBS_MODE", "PSR",
-		      "(PSR, CAL, SEARCH)", &sta);
-      fits_update_key(fits,TSTRING,"SRC_NAME", source_name,
-		      "Source or scan ID", &sta);
-      fits_update_key(fits,TSTRING,"COORD_MD", "J2000",
-		      "Coordinate mode (J2000, Gal, Ecliptic, etc.)", &sta);
-      
-      angle_split(src_raj,&rah,&ram,&ras);
-      if (ras<10.0) 
-	sprintf(sra,"0%.3f",ras);
-      else
-	sprintf(sra,"%.3f",ras);
-      sprintf(rastr,"%02d:%02d:%s",rah,ram,sra);
-      angle_split(src_dej,&ded,&dem,&des);
-      if (des<10.0) 
-	sprintf(sde,"0%.3f",des);
-      else
-	sprintf(sde,"%.3f",des);
-      sprintf(destr,"%02d:%02d:%s",ded,dem,sde);
-      cel2gal(rah,ram,ras,ded,dem,des,&srcl,&srcb);
-
-      fits_update_key(fits, TSTRING, "STT_CRD1", rastr,
-		      "Start coord 1 (hh:mm:ss.sss or ddd.ddd)", &sta);
-      fits_update_key(fits, TSTRING, "STT_CRD2", destr,
-		      "Start coord 2 (-dd:mm:ss.sss or -dd.ddd)", &sta);
-      fits_update_key(fits, TSTRING, "TRK_MODE", "TRACK",
-		      "Track mode (TRACK, SCANGC, SCANLAT)", &sta);
-      fits_update_key(fits, TSTRING, "STP_CRD1", rastr,
-		      "Stop coord 1 (hh:mm:ss.sss or ddd.ddd)", &sta);
-      fits_update_key(fits, TSTRING, "STP_CRD2", destr,
-		      "Stop coord 2 (-dd:mm:ss.sss or -dd.ddd)", &sta);
-      fits_update_key(fits, TSTRING, "CAL_MODE", "OFF",
-		      "Cal mode (OFF, SYNC, EXT1, EXT2)", &sta);
-      fits_create_tbl(fits,BINARY_TBL,0,18,PHtype,
-		      PHform,PHunit,"HISTORY",&sta);
-      pch[0] = date_time;
-      fits_write_col(fits,  TSTRING, 1, 1, 1, 1, pch, &sta);
-      pch[0] = "SIGPROC";
-      fits_write_col(fits,  TSTRING, 2, 1, 1, 1, pch, &sta);
-      pch[0] = "??";
-      fits_write_col(fits,  TSTRING, 3, 1, 1, 1, pch, &sta);
-      /* Nr of pols  - i.e. actually written out */
-      sj = nifs;
-      fits_write_col(fits, TSHORT, 4, 1, 1, 1, &sj, &sta );
-      
-      /* Nr of bins per product (0 for SEARCH mode) */
-      sj = nbins;
-      fits_write_col( fits, TSHORT, 5, 1, 1, 1, &sj, &sta );
-      
-      /* Nr of bins per period */
-      fits_write_col( fits, TSHORT, 6, 1, 1, 1, &sj, &sta );
-      
-      /* Bin time */
-      dx =  folding_period/sj;
-      fits_write_col( fits, TDOUBLE, 7, 1, 1, 1, &dx, &sta );
-      
-      /* Centre freq. */
-      dx = ((double)(nchans/2)-1.0)*foff+fch1;
-      fits_write_col( fits, TDOUBLE, 8, 1, 1, 1, &dx, &sta );
-      
-      /* Number of channels */
-      sj = nchans;
-      fits_write_col( fits, TSHORT, 9, 1, 1, 1, &sj, &sta );
-      
-      /* Channel bandwidth */
-      dx = foff;
-      fits_write_col( fits, TDOUBLE, 10, 1, 1, 1, &dx, &sta );
-      
-      /* Create frequency array for later */
-      /* Get freq. of first channel */
-      if ((fch1==0.0) && (foff==0.0)) {
-	for (i=0; i<nchans; i++) binned_freq[i]=(float) frequency_table[i];
-      } else {
-	for (i=0; i<nchans; i++) 
-	  binned_freq[i]=fch1+i*foff;
-      }
-      
-      for (i=0; i<16384; i++) {
-	binned_scale[i]=1.0;
-	binned_offset[i]=0.0;
-	binned_weight[i]=1.0;
-      }
-      
-      sj = 0;
-      /* Parallactic angle correction applied */
-      fits_write_col( fits, TSHORT, 11, 1, 1, 1, &sj, &sta );
-      /* RM correction applied */
-      fits_write_col( fits, TSHORT, 12, 1, 1, 1, &sj, &sta );
-      /* Data dedispersed */
-      fits_write_col( fits, TSHORT, 13, 1, 1, 1, &sj, &sta );
-      /* Dedispersion method */
-      pch[0] = "NONE";
-      fits_write_col( fits, TSTRING, 14, 1, 1, 1, pch, &sta );
-      /* Scattered power correction method */
-      pch[0] = "NONE";
-      fits_write_col( fits, TSTRING, 15, 1, 1, 1, pch, &sta );
-      /* Calibration method */
-      pch[0] = "NONE";
-      fits_write_col( fits, TSTRING, 16, 1, 1, 1, pch, &sta );
-      /* Name of calibration file */
-      pch[0] = "NONE";
-      fits_write_col( fits, TSTRING, 17, 1, 1, 1, pch, &sta );
-      /* RFI excision method */
-      pch[0] = "NONE";
-      fits_write_col( fits, TSTRING, 18, 1, 1, 1, pch, &sta );
-      /* Store last header hdu number */
-      fits_get_hdu_num( fits, &last_scanhdr_hdu );
-
-      subint_cnt=1;
-      /* Add START TIME to primary HDU */
-      /* Move to primary HDU */
-      fits_movabs_hdu( fits, 1, NULL, &sta );
-      cal(tstart,&epn.year,&epn.month,&epn.day);
-      sprintf(datestr,"%4d-%02d-%02d",epn.year,epn.month,epn.day);
-      fits_update_key( fits, TSTRING, "STT_DATE", datestr,
-		       "Start UT date (YYYY-MM-DD)", &sta);
-      uttime(tstart,&hh,&mm,&ss);
-      sprintf(timestr,"%02d:%02d:%02d",hh,mm,ss);
-      fits_update_key( fits, TSTRING, "STT_TIME", timestr,
-		       "Start UT (hh:mm:ss)", &sta);
-      dx=86400*(tstart-floor(tstart));
-      fits_update_key( fits, TINT, "STT_SMJD", &dx,
-		     "[s] Start time (sec past UTC 00h) (J)", &sta);
-      /* Move to last created HDU in scan header */
-      fits_movabs_hdu( fits, last_scanhdr_hdu, NULL, &sta );
-
-      /* Create SUBINT BINTABLE */
-      ttype[0] = "ISUBINT ";/* Subint number. If NAXIS=-1, 0 indicates EOD. */
-      tform[0] = "1J      ";
-      tunit[0] = "";
-      ttype[1] = "INDEXVAL";    /* Optionally used if INT_TYPE != TIME */
-      tform[1] = "1D      ";
-      tunit[1] = "";
-      ttype[2] = "TSUBINT ";    /* [s] Length of subintegration */
-      tform[2] = "1D      ";
-      tunit[2] = "";
-      ttype[3] = "OFFS_SUB"; /* [s] Offset from Start UTC of subint centre */
-      tform[3] = "1D      ";
-      tunit[3] = "";
-      ttype[4] = "LST_SUB ";    /* [s] LST at subint centre */
-      tform[4] = "1D      ";
-      tunit[4] = "";
-      ttype[5] = "RA_SUB  ";    /* [turns] RA (J2000) at subint centre */
-      tform[5] = "1D      ";
-      tunit[5] = "";
-      ttype[6] = "DEC_SUB ";    /* [turns] Dec (J2000) at subint centre */
-      tform[6] = "1D      ";
-      tunit[6] = "";
-      ttype[7] = "GLON_SUB";    /* [deg] Gal longitude at subint centre */
-      tform[7] = "1D      ";
-      tunit[7] = "";
-      ttype[8] = "GLAT_SUB";    /* [deg] Gal latitude at subint centre */
-      tform[8] = "1D      ";
-      tunit[8] = "";
-      ttype[9] = "FD_ANG  ";    /* [deg] Feed angle at subint centre */
-      tform[9] = "1E      ";
-      tunit[9] = "";
-      ttype[10] = "POS_ANG ";/*[deg] Position angle of feed at subint centre */
-      tform[10] = "1E      ";
-      tunit[10] = "";
-      ttype[11] = "PAR_ANG ";    /* [deg] Parallactic angle at subint centre */
-      tform[11] = "1E      ";
-      tunit[11] = "";
-      ttype[12] = "TEL_AZ  ";    /* [deg] Telescope azimuth at subint centre */
-      tform[12] = "1E      ";
-      tunit[12] = "";
-      ttype[13] = "TEL_ZEN ";/*[deg] Telescope zenith angle at subint centre */
-      tform[13] = "1E      ";
-      tunit[13] = "";
-
-      sprintf( Cstr16, "%dE", nchans );
-      ttype[14] = "DAT_FREQ";
-      tform[14] = Cstr16;
-      tunit[14] = "";
-      ttype[15] = "DAT_WTS ";
-      tform[15] = Cstr16;
-      tunit[15] = "";
-      
-      sprintf( Estr16, "%dE", nifs*nchans );
-      ttype[16] = "DAT_OFFS";
-      tform[16] = Estr16;
-      tunit[16] = "";
-      ttype[17] = "DAT_SCL ";
-      tform[17] = Estr16;
-      tunit[17] = "";
-      
-      sprintf( Istr16, "%dE", nifs*nchans*nbins );
-      ttype[18] = "DATA    ";
-      tform[18] = Istr16;
-      tunit[18] = "Jy      ";
-      
-      nrows = 0; /* naxis2 - Let CFITSIO sort this out */
-      ncols = 19; /* tfields */
-      fits_create_tbl( fits, BINARY_TBL, nrows, ncols, 
-		       ttype, tform, tunit, "SUBINT  ", &sta);
-      
-      /* Add dimensions of column 'ncols' = SUBINT Data */
-      naxes[0] = nbins;
-      naxes[1] = nchans;
-      naxes[2] = nifs;
-    
-      fits_write_tdim( fits, ncols, 3, naxes, &sta );
-      
-      /* Add keywords */
-      fits_update_key( fits, TSTRING, "INT_TYPE", "TIME",
-		       "Time axis (TIME, BINPHSPERI, BINLNGASC, etc)", &sta);
-      
-      fits_update_key( fits, TSTRING, "INT_UNIT", "SEC",
-		       "Unit of time axis (SEC, PHS (0-1), DEG)", &sta);
-      
-      fits_update_key( fits, TINT, "NCH_FILE", &nchans,
-		       "Number of channels/sub-bands in this file (I)", &sta);
-      j = 0;
-      fits_update_key( fits, TINT, "NCH_STRT", &j,
-		     "Start channel/sub-band number (0 to NCHAN-1) (I)", &sta);
-    
-      /* Store subint hdu number */
-      fits_get_hdu_num( fits, &subint_hdu );
-    }
-    
-    /* Write SUBINT BINTABLE columns */
-    
-    /* Fill in columns of table */
-    col = 1;
-    
-    /* Subint number. If NAXIS=-1, 0 indicates EOD. */
-    j=subint_cnt;
-    fits_write_col( fits, TINT, col, subint_cnt, 1, 1, &j, &sta );
-    col++;
-    
-    /* INDEXVAL - Optionally used if INT_TYPE != TIME */
-    dx = 0.0;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-    
-    /* [s] Length of subint */
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dump_time, &sta );
-    col++;
-    
-    /* [s] Offset from Start UTC of subint centre */
-    dx = 0.0;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-    
-    /* [s] LST at subint centre */
-    dx=0.0;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-    
-    /* [turns] RA (J2000) at subint centre */
-    dx=src_raj/360.0;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-    
-    /* [turns] Dec (J2000) at subint centre */
-    dx=src_dej/360.0;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-    
-    /* [deg] Gal longitude at subint centre */
-    dx=srcl;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-
-    /* [deg] Gal latitude at subint centre */
-    dx=srcb;
-    fits_write_col( fits, TDOUBLE, col, subint_cnt, 1, 1, &dx, &sta );
-    col++;
-
-    /* [deg] Feed angle at subint centre */
-    x=0.0;
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-    col++;
-
-    /* [deg] Parallactic angle at subint centre */
-
-    /* [deg] Position angle of feed at subint centre */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-    col++;
-
-    /* [deg] Parallactic angle at subint centre */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-    col++;
-
-    /* [deg] Telescope azimuth at subint centre */
-    x=(float) az_start;
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-    col++;
-
-    /* [deg] Telescope zenith angle at subint centre */
-    x=(float) za_start;
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, 1, &x, &sta );
-    col++;
-
-    /* Centre freq. for each channel - NCHAN floats */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1,nchans,binned_freq,&sta );
-    col++;
-
-    /* Weights for each channel -  NCHAN floats */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, nchans,
-		    binned_weight, &sta );
-    col++;
-
-    /* Data offset for each channel - NCHAN*NPOL floats */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, nchans*nifs,
-		    binned_offset, &sta );
-    col++;
-
-    /* Data scale factor for each channel - NCHAN*NPOL floats */
-    fits_write_col( fits, TFLOAT, col, subint_cnt, 1, nchans*nifs, 
-		    binned_scale, &sta );
-    col++;
-
-    /* Subint data table - Dimensions of data table = (NBIN,NCHAN,NPOL) */
-    for (i=0;i<nchans*nifs*nbins;i++) binned_data[i]=prof[i];
-
-    fits_write_col(fits,TFLOAT,col, subint_cnt, 1, nbins*nchans*nifs, 
-		   binned_data, &sta );
-
-    subint_cnt++;
-    if (sta) fits_report_error(stderr,sta);
-#endif
-  } else {
-    /* EPN format requested - set up some general EPN variables */
-    sprintf(epn.history,"%s %s fast-sampled data reduced using fold",
-	    telescope_name(telescope_id),backend_name(machine_id));
-    while (strlen(epn.history)<65) strcat(epn.history," ");
-    strcpy(epn.jname,"");
-    strcpy(epn.cname,"");
-    epn.pbar=pfld0;
-    epn.dm=refdm;
-    epn.rm=0.0;
-    strcpy(epn.catref,"none");
-    strcpy(epn.bibref,"none");
-    epn.raj=0.0;
-    epn.dec=0.0;
-    strcpy(epn.telname,telescope_name(telescope_id));
-    epn.epoch=(float) floor(tstart);
-    epn.opos=0.0;
-    epn.paflag=' ';
-    epn.timflag='U';
-    epn.xtel=0.0;
-    epn.ytel=0.0;
-    epn.ztel=0.0;
-    cal((double)epn.epoch,&epn.year,&epn.month,&epn.day);
-    epn.scanno=0;
-    epn.subscan=0;
-    epn.npol=nifs;
-    epn.nfreq=nchan;
-    epn.nbins=nbins;
-    epn.tbin=1.0e6*pfld0/(double)nbins;
-    epn.nint=0;
-    epn.ncal=0;
-    epn.lcal=0;
-    epn.tres=epn.tbin;
-    epn.fluxflag='U';
-    epn.navg=1;
-    strcpy(epn.uf,"MHz ");
-    epn.df=1000.0*fabs(foff);
-    strcpy(epn.ud,"kHz ");
-    if (epn.df>=10000.0) {
-      epn.df/=1000.0;
-      strcpy(epn.ud,"MHz ");
-    }
-    epn.tstart=0.0;
-    epn.iprofile=(unsigned long *) malloc(epn.nbins*sizeof(long));
-    profile = (float *) malloc(sizeof(float)*nbins);
-    for (i=0;i<nifs;i++) {
-      strcpy(epn.idfield,"I");
-      for (c=0;c<nchan;c++) {
-	for (b=0;b<nbins;b++) {
-	  profile[b]=prof[i*nchan*nbins+c*nbins+b];
-	}
-	scale_prof(profile,nbins,epn.iprofile,&epn.scale,&epn.offset);
-	epn.f0=fch1+foff*c;
-	epn.nband=c+1;
-	epn.papp=pfld0;
-	epn.rms=0.0;
-	epn.tres=tbin=1.0e6*pfld0*window/(double)nbins;
-	write_epn(out,epn);
-      }
-    }
-    fflush(out);
-    free(profile);
-    free(epn.iprofile);
-  }
-}
diff --git a/filterbank-gmrt/write_pulses.c b/filterbank-gmrt/write_pulses.c
deleted file mode 100644
index 09ee609..0000000
--- a/filterbank-gmrt/write_pulses.c
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-  This routine will write out the results of any pulses found.
-
-*/
-#include <errno.h>
-#include <fcntl.h>
-#include <malloc.h>
-#include <math.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <string.h>
-#include "pulse.h"
-
-int write_pulses(ns, npulse, pulse, ndm, scrdsk)
-int ns;
-int npulse;
-char scrdsk[];
-Pulsus pulse[];
-{
-  int i;
-  int nchar;
-  char *outfile;
-  FILE *fd;
-  char dir1[132];
-
-  strcpy(dir1,scrdsk);
-  strcat(dir1, "/best_tmp"); 
-
-  /*
-    Compose the file name based on the DM channel and amount of 
-    smoothing.
-    */
- 
-  if ( (outfile=(char *)malloc( 200)) == NULL ) 
-    {
-      if ( fprintf(stderr, "malloc failed in write_pulses at\n") == EOF ) 
-	exit( EOF );
-      if ( fprintf(stderr, "%d  %d  %d\n", ndm, ns, npulse) == EOF ) 
-	exit( EOF );
-      return( 1 );
-    }
-      
-  sprintf(outfile, dir1);
- 
-  /*
-    First, open the output data file for writing.
-    */
-
-  if ( (fd=fopen(outfile, "a")) == NULL ) 
-    {
-      if ( fprintf(stderr, "File open failed in write_pulses for\n") == EOF )
-	exit( EOF );
-      if ( fprintf(stderr, "%s\n", outfile) == EOF ) exit( EOF );
-      return( EOF );
-    }
-
-  /*
-    Write results.
-    */
-
-  for (i=0; i<npulse; i++)
-    if ( fprintf(fd, 
-		 "%d  %d  %d  %f  %f  %f\n", 
-		 ndm, ns, pulse[i].index, 
-                 pulse[i].amp, pulse[i].mean, pulse[i].rms) 
-	== EOF ) 
-      {
-	if ( fprintf(stderr, "File write failed in write_pulses for\n") == EOF ) 
-	  exit( EOF );
-	return( EOF );
-      }
-
-  /*
-    Close file.
-    */
- 
-  fclose(fd);
-
-}
diff --git a/filterbank-gmrt/writeepn.f b/filterbank-gmrt/writeepn.f
deleted file mode 100644
index 87a5166..0000000
--- a/filterbank-gmrt/writeepn.f
+++ /dev/null
@@ -1,128 +0,0 @@
-C***********************************************************************
-      subroutine writeepn(profile,nbins,ppsr,refdm,sfreq,chbw,
-     &tsamp,mjd,tst,epnfile,prfsnr,header)
-C***********************************************************************
-      implicit none
-      include 'epnhdr.inc'
-      integer nbins,i
-      real profile(nbins),prfsnr,peak,refdm,mean,sfreq,chbw
-      character*80 header
-      logical first
-      data first/.true./
-      real*8 ppsr,tsamp,tst,mjd
-      save
-      real kwmax,smmax
-      character*(*) epnfile
-c     
-c     set up the EPN variables...
-c
-      history=header
-      jname=' '
-      cname=' ' 
-
-      pbar=ppsr
-      dm=refdm
-      rm=0.0
-
-      catref=' '
-      bibref=' '
-
-      timflag=' '
-      
-      rah=0
-      ram=0
-      ras=0
-      ded=0
-      dem=0
-      des=0
-
-      telname=' '
-      xtel=0.0
-      ytel=0.0
-      ztel=0.0
-
-      epoch=int(mjd)
-      if (epoch.gt.0.0) timflag='U'
-      opos=0.0
-      paflag=' '
-
-c      call idate(cdm,cdd,cdy)
-      cdy=cdy+1900   
-      cdy=1998
-      cdm=01
-      cdd=01
-
-      scanno=1
-      subscan=1
-      npol=1 
-      nfreq=1
-
-      nbin=nbins
-      tbin=tsamp*1.0e6
-      tres=tbin
-      fluxflag='U'
-      nint=0
-      ncal=0
-      lcal=0
-      fcal=1.0
-c
-c     Sub-header variables...
-c
-      do i=1,npol
-         rms(i)=0.0
-         idfield(i)=epnfile
-         nband(i)=i
-         navg(i)=1
-         f0(i)=sfreq/1000.0
-         f0u(i)=' GHz'
-         df(i)=chbw
-         dfu(i)=' MHz'
-         tstart(i) = tst
-         if (timflag.eq.'U') tstart(i)=(mjd-epoch)*86400.0*1.0e6
-         papp(i)=ppsr
-      enddo
-
-      mean=0.0
-      do i=1,nbins
-         rawdata(1,i)=profile(i)
-         mean=mean+profile(i)
-      enddo
-      mean=mean/real(nbins)
-      do i=1,nbins
-         rawdata(1,i)=rawdata(1,i)-mean
-      enddo
-
-      peak=-1.0e32
-      do i=1,nbins
-         peak=max(rawdata(1,i),peak)
-      enddo
-
-      if (first) then
-         recno=-1
-         first=.false.
-      else
-         recno=0          ! just keep writing to the same file...
-      endif
-c      write(*,'('' Folded profile written to '',a)') epnfile
-      filename=epnfile
-      readwri=1        ! writing required
-      padout=.false.   ! don't pad out the data 
-c
-c     Now call the interface routine...
-c
-      call rwepn(filename, readwri, recno, padout)
-c
-c     Calculate PRFSNR
-c
-c
-      prfsnr=0.0
-      if (peak.gt.0.0) prfsnr=peak/rms(1)
-      return
-      do i=1,nbins
-         profile(i)=rawdata(1,i)
-      enddo
-      call smooth(profile,nbins,kwmax,prfsnr,smmax)
-      return
-      end
-
-
diff --git a/filterbank-gmrt/writespec.f b/filterbank-gmrt/writespec.f
deleted file mode 100644
index 1bc03a5..0000000
--- a/filterbank-gmrt/writespec.f
+++ /dev/null
@@ -1,36 +0,0 @@
-c=============================================================================
-      subroutine writespec(llg,pfile,fold,ssnr,dm,ac,tsamp,npf)
-c=============================================================================
-c
-c     Writes out a power spectrum 
-c
-c     99/07/12 - dunc@naic.edu -- added dm and ac to header info
-c      
-c=============================================================================
-      implicit none
-      real dm, ac
-      integer fold,npf
-      real*8 tsamp
-      real ssnr(*)
-      integer i,lun,llg
-      character*9 fname
-      character*(*) pfile
-C      byte bdat(2**23)
-C      real scale,offset
-
-      write(fname,'(''fold'',i1,''.spc'')')fold
-
-      call glun(lun)
-      open(unit=lun,file=pfile,status='unknown',form='unformatted')
-c      open(unit=lun,file=fname,status='unknown',form='unformatted')
-      write(lun) dm, ac ! new 
-      write(lun) tsamp,npf,fold
-      write(lun) (ssnr(i),i=1,npf)
-C      call reatfbin(ssnr,npf,bdat,scale,offset,1)
-C      write(lun) scale,offset
-C      write(lun) (bdat(i),i=1,npf)
-      close(unit=lun)
-c      write(llg,*) 'Dumped fold to file: ',fname
-      write(llg,'(a,a)') ' Dumped fold to file: ',
-     &    pfile(1:index(pfile,' ')-1)
-      end
diff --git a/filterbank-gmrt/y.tab.c b/filterbank-gmrt/y.tab.c
deleted file mode 100644
index 8049f01..0000000
--- a/filterbank-gmrt/y.tab.c
+++ /dev/null
@@ -1,510 +0,0 @@
-#ifndef lint
-static char const 
-yyrcsid[] = "$FreeBSD: src/usr.bin/yacc/skeleton.c,v 1.28 2000/01/17 02:04:06 bde Exp $";
-#endif
-#include <stdlib.h>
-#define YYBYACC 1
-#define YYMAJOR 1
-#define YYMINOR 9
-#define YYLEX yylex()
-#define YYEMPTY -1
-#define yyclearin (yychar=(YYEMPTY))
-#define yyerrok (yyerrflag=0)
-#define YYRECOVERING() (yyerrflag!=0)
-static int yygrowstack();
-#define YYPREFIX "yy"
-#line 2 "mkheader.y"
-
-/*
- * Cactus File @(#)mkgs.y	1.2
- *         SID 1.2
- *        Date 8/6/96
- */
-
-#include <stdio.h>
-#include <ctype.h>
-
-#line 14 "mkheader.y"
-typedef union {
-         char *var;
-         int tok;
-       } YYSTYPE;
-#line 33 "y.tab.c"
-#define YYERRCODE 256
-#define STRUCT 257
-#define LBRACE 258
-#define RBRACE 259
-#define SEMI 260
-#define LB 261
-#define RB 262
-#define DOUBLE 263
-#define INTEGER 264
-#define LONG 265
-#define LONGLONG 266
-#define FLOAT 267
-#define SHORT 268
-#define UNSIGNED 269
-#define CHARSTAR 270
-#define BYTE 271
-#define VAR 272
-#define COMMENT 273
-const short yylhs[] = {                                        -1,
-    0,    0,    0,    0,    1,    4,    4,    5,    5,    5,
-    5,    5,    5,    5,    2,    2,    2,    3,    3,    3,
-    3,    3,    3,
-};
-const short yylen[] = {                                         2,
-    0,    2,    2,    2,    6,    2,    1,    1,    6,    3,
-    6,    9,    7,    4,    1,    2,    2,    1,    1,    1,
-    1,    1,    1,
-};
-const short yydefred[] = {                                      1,
-    0,    3,    0,    4,    2,    0,    0,    0,   18,   22,
-   20,   21,   19,   23,    0,    0,    8,    0,   15,    0,
-    7,    0,   17,   16,    0,    0,    0,    6,    0,    0,
-   10,    0,    5,   14,    0,    0,    0,    0,    0,    0,
-    0,    9,   11,    0,   13,    0,    0,   12,
-};
-const short yydgoto[] = {                                       1,
-    5,   18,   19,   20,   21,
-};
-const short yysindex[] = {                                      0,
- -256,    0, -269,    0,    0, -253, -241, -242,    0,    0,
-    0,    0,    0,    0, -230, -233,    0, -229,    0, -255,
-    0, -228,    0,    0, -216, -254, -214,    0, -240, -225,
-    0, -224,    0,    0, -223, -243, -231, -212, -209, -219,
- -208,    0,    0, -218,    0, -207, -204,    0,
-};
-const short yyrindex[] = {                                      0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-    0,    0,    0,    0,    0,    0,    0,    0,
-};
-const short yygindex[] = {                                      0,
-    0,    0,   38,    0,   37,
-};
-#define YYTABLESIZE 57
-const short yytable[] = {                                       2,
-    3,    8,    6,   27,    7,   31,   32,    9,   10,   11,
-   12,   13,   14,   15,   16,    8,    4,   17,   39,   34,
-   35,    9,   10,   11,   12,   13,   14,   15,   16,   22,
-   40,   17,    9,   10,   11,   12,   13,   14,   25,   23,
-   43,   44,   26,   29,   30,   33,   36,   37,   38,   41,
-   42,   45,   24,   46,   47,   48,   28,
-};
-const short yycheck[] = {                                     256,
-  257,  257,  272,  259,  258,  260,  261,  263,  264,  265,
-  266,  267,  268,  269,  270,  257,  273,  273,  262,  260,
-  261,  263,  264,  265,  266,  267,  268,  269,  270,  272,
-  262,  273,  263,  264,  265,  266,  267,  268,  272,  270,
-  260,  261,  272,  272,  261,  260,  272,  272,  272,  262,
-  260,  260,   15,  272,  262,  260,   20,
-};
-#define YYFINAL 1
-#ifndef YYDEBUG
-#define YYDEBUG 1
-#endif
-#define YYMAXTOKEN 273
-#if YYDEBUG
-const char * const yyname[] = {
-"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"STRUCT","LBRACE","RBRACE","SEMI",
-"LB","RB","DOUBLE","INTEGER","LONG","LONGLONG","FLOAT","SHORT","UNSIGNED",
-"CHARSTAR","BYTE","VAR","COMMENT",
-};
-const char * const yyrule[] = {
-"$accept : list",
-"list :",
-"list : list construct",
-"list : list error",
-"list : list COMMENT",
-"construct : STRUCT VAR LBRACE vars RBRACE SEMI",
-"vars : vars line",
-"vars : line",
-"line : COMMENT",
-"line : CHARSTAR VAR LB VAR RB SEMI",
-"line : notchar VAR SEMI",
-"line : notchar VAR LB VAR RB SEMI",
-"line : notchar VAR LB VAR RB LB VAR RB SEMI",
-"line : STRUCT VAR VAR LB VAR RB SEMI",
-"line : STRUCT VAR VAR SEMI",
-"notchar : typepp",
-"notchar : UNSIGNED typepp",
-"notchar : UNSIGNED CHARSTAR",
-"typepp : DOUBLE",
-"typepp : FLOAT",
-"typepp : LONG",
-"typepp : LONGLONG",
-"typepp : INTEGER",
-"typepp : SHORT",
-};
-#endif
-#if YYDEBUG
-#include <stdio.h>
-#endif
-#ifdef YYSTACKSIZE
-#undef YYMAXDEPTH
-#define YYMAXDEPTH YYSTACKSIZE
-#else
-#ifdef YYMAXDEPTH
-#define YYSTACKSIZE YYMAXDEPTH
-#else
-#define YYSTACKSIZE 10000
-#define YYMAXDEPTH 10000
-#endif
-#endif
-#define YYINITSTACKSIZE 200
-int yydebug;
-int yynerrs;
-int yyerrflag;
-int yychar;
-short *yyssp;
-YYSTYPE *yyvsp;
-YYSTYPE yyval;
-YYSTYPE yylval;
-short *yyss;
-short *yysslim;
-YYSTYPE *yyvs;
-int yystacksize;
-#line 85 "mkheader.y"
-
-yyerror(s)
-char *s;
-{
-  extern int linecount;
-
-  fprintf( stderr, "%s at line %d\n", s, linecount );
-}
-
-yywrap() { return(1); }
-#line 188 "y.tab.c"
-/* allocate initial stack or double stack size, up to YYMAXDEPTH */
-static int yygrowstack()
-{
-    int newsize, i;
-    short *newss;
-    YYSTYPE *newvs;
-
-    if ((newsize = yystacksize) == 0)
-        newsize = YYINITSTACKSIZE;
-    else if (newsize >= YYMAXDEPTH)
-        return -1;
-    else if ((newsize *= 2) > YYMAXDEPTH)
-        newsize = YYMAXDEPTH;
-    i = yyssp - yyss;
-    newss = yyss ? (short *)realloc(yyss, newsize * sizeof *newss) :
-      (short *)malloc(newsize * sizeof *newss);
-    if (newss == NULL)
-        return -1;
-    yyss = newss;
-    yyssp = newss + i;
-    newvs = yyvs ? (YYSTYPE *)realloc(yyvs, newsize * sizeof *newvs) :
-      (YYSTYPE *)malloc(newsize * sizeof *newvs);
-    if (newvs == NULL)
-        return -1;
-    yyvs = newvs;
-    yyvsp = newvs + i;
-    yystacksize = newsize;
-    yysslim = yyss + newsize - 1;
-    return 0;
-}
-
-#define YYABORT goto yyabort
-#define YYREJECT goto yyabort
-#define YYACCEPT goto yyaccept
-#define YYERROR goto yyerrlab
-
-#ifndef YYPARSE_PARAM
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG void
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif	/* ANSI-C/C++ */
-#else	/* YYPARSE_PARAM */
-#ifndef YYPARSE_PARAM_TYPE
-#define YYPARSE_PARAM_TYPE void *
-#endif
-#if defined(__cplusplus) || __STDC__
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM_TYPE YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else	/* ! ANSI-C/C++ */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL YYPARSE_PARAM_TYPE YYPARSE_PARAM;
-#endif	/* ANSI-C/C++ */
-#endif	/* ! YYPARSE_PARAM */
-
-int
-yyparse (YYPARSE_PARAM_ARG)
-    YYPARSE_PARAM_DECL
-{
-    register int yym, yyn, yystate;
-#if YYDEBUG
-    register const char *yys;
-
-    if ((yys = getenv("YYDEBUG")))
-    {
-        yyn = *yys;
-        if (yyn >= '0' && yyn <= '9')
-            yydebug = yyn - '0';
-    }
-#endif
-
-    yynerrs = 0;
-    yyerrflag = 0;
-    yychar = (-1);
-
-    if (yyss == NULL && yygrowstack()) goto yyoverflow;
-    yyssp = yyss;
-    yyvsp = yyvs;
-    *yyssp = yystate = 0;
-
-yyloop:
-    if ((yyn = yydefred[yystate])) goto yyreduce;
-    if (yychar < 0)
-    {
-        if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, reading %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-    }
-    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: state %d, shifting to state %d\n",
-                    YYPREFIX, yystate, yytable[yyn]);
-#endif
-        if (yyssp >= yysslim && yygrowstack())
-        {
-            goto yyoverflow;
-        }
-        *++yyssp = yystate = yytable[yyn];
-        *++yyvsp = yylval;
-        yychar = (-1);
-        if (yyerrflag > 0)  --yyerrflag;
-        goto yyloop;
-    }
-    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
-    {
-        yyn = yytable[yyn];
-        goto yyreduce;
-    }
-    if (yyerrflag) goto yyinrecovery;
-#if defined(lint) || defined(__GNUC__)
-    goto yynewerror;
-#endif
-yynewerror:
-    yyerror("syntax error");
-#if defined(lint) || defined(__GNUC__)
-    goto yyerrlab;
-#endif
-yyerrlab:
-    ++yynerrs;
-yyinrecovery:
-    if (yyerrflag < 3)
-    {
-        yyerrflag = 3;
-        for (;;)
-        {
-            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
-                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: state %d, error recovery shifting\
- to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
-#endif
-                if (yyssp >= yysslim && yygrowstack())
-                {
-                    goto yyoverflow;
-                }
-                *++yyssp = yystate = yytable[yyn];
-                *++yyvsp = yylval;
-                goto yyloop;
-            }
-            else
-            {
-#if YYDEBUG
-                if (yydebug)
-                    printf("%sdebug: error recovery discarding state %d\n",
-                            YYPREFIX, *yyssp);
-#endif
-                if (yyssp <= yyss) goto yyabort;
-                --yyssp;
-                --yyvsp;
-            }
-        }
-    }
-    else
-    {
-        if (yychar == 0) goto yyabort;
-#if YYDEBUG
-        if (yydebug)
-        {
-            yys = 0;
-            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-            if (!yys) yys = "illegal-symbol";
-            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
-                    YYPREFIX, yystate, yychar, yys);
-        }
-#endif
-        yychar = (-1);
-        goto yyloop;
-    }
-yyreduce:
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
-                YYPREFIX, yystate, yyn, yyrule[yyn]);
-#endif
-    yym = yylen[yyn];
-    yyval = yyvsp[1-yym];
-    switch (yyn)
-    {
-case 2:
-#line 32 "mkheader.y"
-{ got_construct(yyvsp[0].var); }
-break;
-case 3:
-#line 34 "mkheader.y"
-{ yyerrok; yyclearin; YYACCEPT; }
-break;
-case 5:
-#line 39 "mkheader.y"
-{ yyval.var = yyvsp[-4].var; }
-break;
-case 8:
-#line 47 "mkheader.y"
-{ comment(yyvsp[0].var); }
-break;
-case 9:
-#line 49 "mkheader.y"
-{ add_char(yyvsp[-4].var, yyvsp[-2].var ); }
-break;
-case 10:
-#line 51 "mkheader.y"
-{ add_notchar( yyvsp[-2].tok, yyvsp[-1].var); }
-break;
-case 11:
-#line 53 "mkheader.y"
-{ add_array(yyvsp[-5].tok, yyvsp[-4].var, yyvsp[-2].var); }
-break;
-case 12:
-#line 55 "mkheader.y"
-{ printf( "/* skipping %s */\n", yyvsp[-7].var );}
-break;
-case 13:
-#line 57 "mkheader.y"
-{ printf( "/* skipping struct array %s %s */\n", yyvsp[-5].var, yyvsp[-4].var );}
-break;
-case 15:
-#line 62 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 16:
-#line 64 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 17:
-#line 66 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 18:
-#line 70 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 19:
-#line 72 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 20:
-#line 74 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 21:
-#line 76 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 22:
-#line 78 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-case 23:
-#line 80 "mkheader.y"
-{ yyval.tok = yyvsp[0].tok; }
-break;
-#line 455 "y.tab.c"
-    }
-    yyssp -= yym;
-    yystate = *yyssp;
-    yyvsp -= yym;
-    yym = yylhs[yyn];
-    if (yystate == 0 && yym == 0)
-    {
-#if YYDEBUG
-        if (yydebug)
-            printf("%sdebug: after reduction, shifting from state 0 to\
- state %d\n", YYPREFIX, YYFINAL);
-#endif
-        yystate = YYFINAL;
-        *++yyssp = YYFINAL;
-        *++yyvsp = yyval;
-        if (yychar < 0)
-        {
-            if ((yychar = yylex()) < 0) yychar = 0;
-#if YYDEBUG
-            if (yydebug)
-            {
-                yys = 0;
-                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
-                if (!yys) yys = "illegal-symbol";
-                printf("%sdebug: state %d, reading %d (%s)\n",
-                        YYPREFIX, YYFINAL, yychar, yys);
-            }
-#endif
-        }
-        if (yychar == 0) goto yyaccept;
-        goto yyloop;
-    }
-    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
-            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
-        yystate = yytable[yyn];
-    else
-        yystate = yydgoto[yym];
-#if YYDEBUG
-    if (yydebug)
-        printf("%sdebug: after reduction, shifting from state %d \
-to state %d\n", YYPREFIX, *yyssp, yystate);
-#endif
-    if (yyssp >= yysslim && yygrowstack())
-    {
-        goto yyoverflow;
-    }
-    *++yyssp = yystate;
-    *++yyvsp = yyval;
-    goto yyloop;
-yyoverflow:
-    yyerror("yacc stack overflow");
-yyabort:
-    return (1);
-yyaccept:
-    return (0);
-}
diff --git a/filterbank-gmrt/y.tab.h b/filterbank-gmrt/y.tab.h
deleted file mode 100644
index e6dcd9c..0000000
--- a/filterbank-gmrt/y.tab.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef YYERRCODE
-#define YYERRCODE 256
-#endif
-
-#define STRUCT 257
-#define LBRACE 258
-#define RBRACE 259
-#define SEMI 260
-#define LB 261
-#define RB 262
-#define DOUBLE 263
-#define INTEGER 264
-#define LONG 265
-#define LONGLONG 266
-#define FLOAT 267
-#define SHORT 268
-#define UNSIGNED 269
-#define CHARSTAR 270
-#define BYTE 271
-#define VAR 272
-#define COMMENT 273
-typedef union {
-         char *var;
-         int tok;
-       } YYSTYPE;
-extern YYSTYPE yylval;
diff --git a/filterbank-gmrt/zap_birdies.f b/filterbank-gmrt/zap_birdies.f
deleted file mode 100644
index 93da466..0000000
--- a/filterbank-gmrt/zap_birdies.f
+++ /dev/null
@@ -1,314 +0,0 @@
-c mar 8, 2006
-c drl nadgered this file so that it just works on sp seq 1 and 2
-c i.e. the samplers and the mains --- for the MMB survey
-c
-c
-C @(#)zap_birdies.f	3.2 18 Feb 1994
-c------------------------------------------------------------
-      subroutine zap_birdies(dat,nf,nf1,tsmp_data,sprms,mean,ifold)
-c------------------------------------------------------------
-c
-c     Zaps the birdies from the spectrum dat(nf) if above
-c     four sigma (sig4) threshold DRL 92/06/17 (hijacked from
-c     kill_birdies.f)
-c
-c JFB 971010  Mods cMJFB to fix quantisation problems for low freq filters
-c             Pass around freqs rather bins to stop quantisation spreading
-c             to higher harmonics
-cDCS 971013   routine now zaps reflected harmonics for any number
-c             of reflections
-c VMK 980618  added special case handling of the 135 Hz birdie and
-c             keeps track of the number of bins zapped.
-cDCS increased range of intermodulation zapping
-c VMK 980723  Added internal zapping of 4.096 s birdie and harmonics,
-c             and changed internal zapping of 135 Hz intermodulation
-c             freqs so does not assume 135 Hz is in std filter list.
-c IHS 981028  Commented out writes to fort.61 and fort.135 - hope that's OK
-c AGL 000120  Restructure to allow multiple special sequences
-c GBH 011019  Made changes to the sequences:
-c              - added wide sidelobes to 135 Hz sequence
-c              - slight changes to widths for most sequences.
-c              - widths now do not increase with harmonic number
-c              - added 0.14704*ii sequences (removed from bhbird)
-
-      implicit none
-
-      include 'birdies.inc'
-      include 'find_summary.inc'
-
-      integer nf, nf1,ifold
-      real dat(nf), sprms, mean
-      double precision tsmp_data
-
-      integer nb, nh, n1, n2, n1store, n2store, nt, tempn1
-      real snhrm, sig4, fnyq, fnyq2, fnyq4
-      integer j
-      integer maxspseq, nspecial
-c      parameter (maxspseq=1166, nspecial=5)
-cGBH Changed maxspseq=2500 as sequence 2 now has 2392 filters
-      parameter (maxspseq=2500,nspecial=5)
-      integer ii, jj, k,  maxnh, nspseqf(nspecial)
-      real freq, spseqf(nspecial,maxspseq), spseqw(nspecial,maxspseq)
-      real binwidth,f1,f2
-
-cAGL  the special sequences are those which are essentially endemic to
-cAGL  the whole of the survey database.  Many contain harmonics which 
-cAGL  may be individually small but add up to something significant when
-cAGL  folded.  Others are not straight harmonic sequences.
-cDCS  maxspseq = max no of features in any special sequence = 41+75*15 = 1166
-
-      fnyq=500./tsmp_data
-      fnyq2=2.*fnyq
-      fnyq4=4.*fnyq
-
-cGBH: Frequencies for the 135 and 99.9Hz sequences
-      f1=134.99776
-      f2=99.99592 
-
-cGBH: Width of a bin
-
-      binwidth = fnyq/nf
-      
-c     Special sequence 1: 'Sample counter': Harmonics of 8192 ms
-      k=1
-      do ii=1,15
-        do jj=1,10
-           freq=abs(2d0**(ii-1)/8.192d0)*(1.+2*(jj-1))
-           if(freq.le.fnyq) then 
-              spseqf(1,k)=freq
-c              spseqw(1,k)=0.0005
-              spseqw(1,k)=binwidth
-
-              k = k + 1
-           endif
-        enddo
-      enddo
-      nspseqf(1) = k-1
-
-c     Special sequence 2: f = 50.0*i
-      k = 1
-      do ii=1,fnyq/50. - 1
-         freq=ii*50.
-         spseqf(2,k)=freq
-         spseqw(2,k)=0.1
-         k = k + 1
-      enddo
-      nspseqf(2) = k-1
-
-c Special sequence 3: f = 135*i + 100*j
-      k=1
-      do ii=0,160
-         if(ii.eq.0) then
-            do jj=0,120
-c               freq = abs(ii*134.99779 + jj*99.99570)
-               freq = abs(jj*f2)
-               freq = mod(freq,fnyq2)
-
-               if (freq.gt.fnyq) freq=fnyq2-freq
-c     GBH: Don't zap below 2Hz
-               if (freq.gt.2.0) then
-                  spseqf(3,k)=freq
-c     spseqw(3,k)=0.015
-                  spseqw(3,k)=0.05
-                  k = k + 1
-               endif
-            enddo
-         else
-            if (ii.le.50) then
-               do jj=-20,20
-                  freq = abs(ii*f1 + jj*f2)
-                  freq = mod(freq,fnyq2)
-                  if (freq.gt.fnyq) freq=fnyq2-freq
-                  if (freq.gt.1.00) then
-                     spseqf(3,k)=freq
-                     spseqw(3,k)=0.020
-                     k = k + 1                     
-                  endif
-               enddo
-            else
-               freq = abs(ii*f1)
-               freq = mod(freq,fnyq2)
-               if (freq.gt.fnyq) freq = fnyq2-freq
-               spseqf(3,k)=freq
-               spseqw(3,k)=0.020
-               k = k + 1                     
-               
-            endif
-         endif
-      enddo
-C 135Hz and 0.0308 sidelobes (covered with one 0.2 Hz filter)
-
-      do ii=1,fnyq4/f1
-         freq = abs(ii*f1)
-         freq = mod(freq,fnyq2)
-
-         if (freq.gt.fnyq) freq=fnyq2-freq
-         spseqf(3,k)=freq
-         spseqw(3,k)=0.2
-         k = k + 1      
-      enddo
-
-c 135 Hz, wide sidelobes of f = 135ii
-      do ii=1,fnyq2/f1
-         freq = abs(ii*f1)
-         freq = mod(freq,fnyq2)
-         if (freq.gt.fnyq) freq=fnyq2-freq
-
-         spseqf(3,k)=freq-3.90
-         spseqw(3,k)=0.15
-         k = k + 1      
-
-         spseqf(3,k)=freq+3.90
-         spseqw(3,k)=0.15
-         k = k + 1      
-      enddo
-      nspseqf(3) = k-1
-            
-c     Special sequence 4: f = 200 + 1.0*i
-      k=1
-      do ii=-20,20
-         freq=200.+ii*1.0
-         spseqf(4,k)=freq
-C         spseqw(4,k)=0.1
-         spseqw(4,k)=0.13
-         k = k + 1
-      enddo
-      nspseqf(4) = k-1
-      
-cGBH     Special sequence 5: f=0.14704*ii
-      k=1
-      do ii=1,100
-         freq = 0.14704*ii
-         spseqf(4,k)=freq
-         spseqw(4,k)=max(0.0012,binwidth)
-         k = k + 1
-      enddo
-      nspseqf(5) = k-1
-
-      zapped=0
-
-      sig4 = mean + 4.0 * sprms
-c      write(61,*)nf,nf1,tsmp_data,sprms
-c      write(*,*) nbrd,nspecial 
-c      do nb=1,nbrd + nspecial
-      do nb=1,2
-
-cDCS if a standard filter is not valid for this beam then nba and nbb
-cDCS will be set to zero
-         if (nb.le.nbrd) then
-            if(bffa(nb).eq.0..and.bffb(nb).eq.0.)go to 55
-            if(ifold.eq.1)snbrd(nb)=0.
-            maxnh = nint(abs(float(nhbrd(nb))))
-         else
-            maxnh = nspseqf(nb-nbrd)
-         endif
-
-cAGL Now the zapping loop.
-         do nh = 1, maxnh
-            if (nb.gt.nbrd)  then
-               n1=nint(0.001*(spseqf(nb-nbrd,nh) - spseqw(nb-nbrd,nh))
-     &              * tsmp_data*nf*2)
-               n2=nint(0.001*(spseqf(nb-nbrd,nh) + spseqw(nb-nbrd,nh))
-     &              * tsmp_data*nf*2)
-            else
-cMJFB the 0.5 is the replacements for the delta that was in find_find_hum
-               n1=nint(nh*0.001*bffa(nb)*tsmp_data*nf*2 - 0.5)
-               n2=nint(nh*0.001*bffb(nb)*tsmp_data*nf*2 + 0.5)
-            endif
-            
-            n1store=n1
-            n2store=n2
-
-
-cVMK  Only do zapping of aliases of birdies past the Nyquist for the two
-cVMK  special cases to avoid zapping of huge parts of the spectrum at low freq. 
-            if ((n1.gt.nf).and.(nb.le.nbrd)) go to 55
-
-c            if(nb.le.nbrd)then
-c            write(61,610)nb,nh,nh*(bffb(nb)+bffa(nb))/2.,
-c     +         nh*(bffb(nb)-bffa(nb)),n1,n2,n2-n1+1,1000.*(n2-n1+1)/nf
-c            else
-c            write(61,610)nb,nh,spseqf(nb-nbrd,nh),spseqw(nb-nbrd,nh)
-c     +         ,n1,n2,n2-n1+1,1000.*(n2-n1+1)/nf
-c            endif
-c 610        format(2i6,f10.3,f10.5,3i10,f8.3)
-
-cDCS remove multiples of 2*Nyquist frequency from the filter range and,
-cDCS if the frequency is still greater than the Nyquist frequency, reflect
-cDCS about the Nyquist frequency
-            n1=max(mod(n1,2*nf),1) ! Avoid n1=0 case 
-            n2=max(mod(n2,2*nf),1) ! Avoid n2=0 case 
-            if (n1.gt.nf)n1=2*nf-n1
-            if (n2.gt.nf)n2=2*nf-n2
-c     DCS make sure that n2 is greater than n1 as later loops rely on this
-            if (n1.gt.n2) then
-               tempn1=n1
-               n1=n2
-               n2=tempn1
-            endif
-cDCS check to see if n1 and n2 are derived from a different number of
-cDCS reflections.  If so then make the filter as big as possible by setting
-cDCS n1 or n2 to the nearest extreme frequency.
-            if ((n1store/nf).ne.(n2store/nf))then
-              ! check which frequency extreme is straddled
-              ! note that this is a check for an odd number of reflections
-               if (n2store/nf.ne.2*(n2store/(2*nf)))then
-                  n2=nf
-               else
-                  n1=1
-               endif
-            endif
-c
-c  work out the s/n in each harmonic and only 
-c  zap it if above threshhold
-c
-
-            snhrm=0.0
-            do j=n1,n2
-               snhrm=max(snhrm,dat(j))
-            end do
-
-cvmk Make sure not to count intermodulation frequencies here.
-cIHS I think the point here is that we always want to zap 2^n harmonics
-cIHS since they will harmonically sum to trouble, and to let every other 
-cIHS sequence be zapped only if it needs to be.
-
-cIHS Make 2^n the first sequence so if the 135 sequence picks up 2^n things,
-cIHS they won't be counted as zapped multiple times
-
-            if ((ifold.eq.1).and.(nb.le.nbrd))
-     +           snbrd(nb)=max(snbrd(nb),snhrm)
-            if ((snhrm.gt.sig4).or.(nb.eq.nbrd+1)) then
-               do j=n1,n2
-                  if ( (dat(j).gt.sig4).or.(nh.le.2).or.
-     +                 (nb.eq.nbrd+1))then
-                     dat(j)=0.0
-                     zapped = zapped+1
-C     write(61,*) '    zapping j=',j
-                  endif
-               enddo
-            endif
-            nt=nt+n2-n1
-         end do
- 55      continue
-      end do
-cvmk   endif
-
-c     Delete Nyq freq. 
-      
-      dat(nf-1)=0.
-      dat(nf)=0.
-
-c     Turn birdie amps into snrs
-      if(ifold.eq.1) then
-         do nb=1,nbrd
-            snbrd(nb)=snbrd(nb)/sprms
-         enddo
-      endif
-
-      perzapped = (float(zapped)/float(nf))*100.0
-      write(*,'('' Zap:'',i4,f8.5,f6.2)')ifold,tsmp_data,perzapped
-
-      end
-
-
diff --git a/filterbank-gmrt/zapit.f b/filterbank-gmrt/zapit.f
deleted file mode 100644
index ea9d9b6..0000000
--- a/filterbank-gmrt/zapit.f
+++ /dev/null
@@ -1,127 +0,0 @@
-c==============================================================================
-      subroutine zapit(llog,fold,zapfile,spec,npts,tsamp)
-c==============================================================================
-c
-c     Zeros portions of the amplitude spectrum that are regularly occupied
-c     by RFI signals: the mains power line etc. The frequency ranges are read
-c     from a free-format ASCII file containing, per line, the minimum
-c     and maximum frequency to zap in the spectrum.
-c
-c     llog    - i4  - logical unit number for all but warning messages.
-c     fold    - i4  - harmonic fold index
-c     zapfile - ch  - name of the ASCII file containing zap-freq ranges.
-c     spec    - r4  - array containing the amplitude spectrum.
-c     npts    - i4  - number of points in the amplitude spectrum.
-c     tsamp   - r8  - sampling time in the time domain (s).
-c
-c     Created: November 1997 (dunc@mpifr-bonn.mpg.de)
-c      
-c     Modification history:
-c      
-c     98/04/10 (drl@jb.man.ac.uk) works out the bin numbers to zap (faster!)
-c     98/04/28 (dunc@mpifr-bonn.mpg.de) just return if zapfile is empty.
-c     98/04/29 (dunc@mpifr-bonn.mpg.de) range check on bin numbers.
-c     98/04/29 (dunc@mpifr-bonn.mpg.de) fold number passed down.
-c     02/02/26 (drl@jb.man.ac.uk) widths of filters in proportion to frequency
-c
-c     To do:
-c
-c     Something more sensible... e.g. what the GW people are proposing!
-c      
-c==============================================================================
-c      
-      implicit none
-      character*(*) zapfile
-      real spec(*)
-      real*8 tsamp
-      integer npts,llog,fold
-c      
-c     local variables...
-c
-      character*80 line
-      integer nb
-      real blo,bhi,bf,df
-      integer i,j,lun,nlo,nhi,fbin,nh,nz
-      logical first,static
-      data first/.true./
-      save
-c
-c     Initialize
-c      
-      nz=0
-      nb=0
-c
-c     Get a free logical unit number
-c
-      call glun(lun)
-c
-c     Attempt to open the file and read in the birdies
-c      
-      open(unit=lun,file=zapfile,status='old',err=3)
-      do while(.true.)
-         read(lun,'(a)',end=1) line
-	 if (line.eq.' ') return      ! return if file empty
-         if (line(1:1).ne.'#') then
-            read(line,*,err=4) blo,bhi,nh
-	    write(llog,*)
-     &      'Filter:',blo,' ->',bhi,' Hz.',nh,' harmonic(s)'
-            nb=nb+1
-            bf=0.5*(bhi+blo)
-            df=0.5*(bhi-blo)
-            if (nh.lt.0) then
-		static=.true.
-		nh=-1*nh
-            else
-		static=.false.
-            endif
-            do i=1,nh
-	       if (static) then
-                  blo=bf*real(i)-df
-                  bhi=bf*real(i)+df
-                else
-                  blo=(bf-df)*real(i)
-                  bhi=(bf+df)*real(i)
-	        endif
-c
-c              Convert frequencies to bin numbers
-c
-               nlo=fbin(tsamp,npts,fold,blo)
-               nhi=fbin(tsamp,npts,fold,bhi)
-c
-c              Zero spectrum within these ranges provided
-c              that they are sensible (i.e. within npts)
-c
-                do j=nlo,nhi
-                   if (spec(j).ne.0.0.and.j.le.npts.and.j.ge.1) then
-                     nz=nz+1
-                     spec(j)=0.0
-                   endif
-                enddo
-            enddo
-         endif
-      enddo
- 1    close(unit=lun)
-      write(llog,'(i5,a,f7.3,a)') nz,' spectral bins blown away (',
-     & 100.0*real(nz)/real(npts),'% of spectrum)'
- 2    format(i3,a,a,a)
-      return
-c
-c     issue warning message (first time only) if the file was not opened
-c      
- 3    if (first) write(*,*) 'WARNING - birdie file not found...'
-      first=.false.
-      return
-c
-c     stop here if an error occured when reading a filter
-c
- 4    write(*,'('' Error reading filters from: '',a)')zapfile
-      write(*,*) 'Please supply filters in the following way:'
-      write(*,*) '#flo (Hz) fhi (Hz) nharm (integer)'
-      write(*,*) '49.9 50.1 1'
-      write(*,*)
-      write(*,*) 'The # mark can be used to comment the file'
-      write(*,*) 'Happy zapping!'
-      stop
-      end
-c      
-c=============================================================================
diff --git a/fmt_pdmp_out.sh b/fmt_pdmp_out.sh
new file mode 100755
index 0000000..ddba5ee
--- /dev/null
+++ b/fmt_pdmp_out.sh
@@ -0,0 +1,9 @@
+summary_file=pinta_summary.txt
+echo "" >> $summary_file
+echo "pinta Output Summary" >> $summary_file
+echo "Generated using pdmp" >> $summary_file
+echo "User : " `whoami` >> $summary_file
+echo "Time : " `date -Iseconds` >> $summary_file
+echo "FILENAME    MJD    DM    S/N" >> $summary_file
+awk '{print $8, $1, $4, $7}' pdmp.per >> $summary_file
+
diff --git a/pinta b/pinta
index 3e68f48..2be8cf8 100755
--- a/pinta
+++ b/pinta
@@ -1,4 +1,4 @@
-#!/usr/bin/python3.6
+#!/usr/bin/python3
 
 """ Generate and execute commands to reduce the raw uGMRT data into TIMER format.
 
@@ -37,9 +37,12 @@ for idx, item in enumerate(session.pipeline_items):
     if session.run_rficlean:
         #rfic_hdrfilename = "{}/{}-{}-ttemp-gm.info".format(session.working_dir, item.jname, item.idx)
         utils.make_rficlean_hdrfile(item.rfic_hdrfilename, item.jname, item.freq, item.nchan, item.chanwidth, item.tsmpl, item.sideband)
-        os.system('ls -l *.info')
         pexec.rficlean_branch(session, item)
 
+    print("[CMD] Creating summary file pinta_summary.txt")
+    if not session.test_mode:
+        os.system("fmt_pdmp_out.sh")
+
     if session.retain_aux:
         utils.move_aux_files(session, item)
     else:
diff --git a/pintaexec.py b/pintaexec.py
index 35f941a..4d95dad 100644
--- a/pintaexec.py
+++ b/pintaexec.py
@@ -4,9 +4,12 @@ import time
 import pintautils as utils
 import sys
 
-def exec_cmd(session, item, branch, program):
-    outfile = log_file_name(session, item, branch, program, 'out')
-    errfile = log_file_name(session, item, branch, program, 'err')
+def exec_cmd(session, item, branch, program, xnbin=False):
+
+    # xnbin option is valid for dspsr, pdmp and ps2pdf.
+
+    outfile = log_file_name(session, item, branch, program, 'out', xnbin)
+    errfile = log_file_name(session, item, branch, program, 'err', xnbin)
     
     print("[LOG] {}/{} stdout will be written to {}".format(branch, program, outfile))
     print("[LOG] {}/{} stderr will be written to {}".format(branch, program, errfile))
@@ -17,15 +20,38 @@ def exec_cmd(session, item, branch, program):
         #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
     elif program == 'dspsr':
         fil_file = output_file_name(session, item, branch, 'fil')
-        #fits_file_prefix = "{}/{}.{}".format(session.working_dir, item.output_root, branch)
-        fits_file_prefix = "./{}.{}".format(item.output_root, branch)
-        cmd = "dspsr -N {} -d {} -b {} -E {} -L {} -m {} -A {} -O {} -e fits".format(item.jname, item.npol, item.nbin, item.parfile, item.tsubint, item.timestamp, fil_file, fits_file_prefix)
-        #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
+        if not xnbin:
+            #fits_file_prefix = "{}/{}.{}".format(session.working_dir, item.output_root, branch)
+            fits_file_prefix = "./{}.{}".format(item.output_root, branch)
+            cmd = "dspsr -N {} -d {} -b {} -E {} -L {} -m {} -A {} -O {} -e fits".format(item.jname, item.npol, item.nbin, item.parfile, item.tsubint, item.timestamp, fil_file, fits_file_prefix)
+            #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
+        else:
+            fits_file_prefix = "./{}.{}.{}xNBin".format(item.output_root, branch, session.xnbinfac)
+            cmd = "dspsr -N {} -d {} -b {} -E {} -L {} -m {} -A {} -O {} -e fits".format(item.jname, item.npol, int(item.nbin*session.xnbinfac), item.parfile, item.tsubint, item.timestamp, fil_file, fits_file_prefix)
+    elif program == 'psredit':
+        if not xnbin:
+            fits_file = output_file_name(session, item, branch, 'fits')
+            cmd = "psredit -c name={},be:name=GWB,coord={} -m {}".format(item.jname, item.coordstr, fits_file)
+        else:
+            fits_file = output_file_name(session, item, branch, '{}xNBin.fits'.format(session.xnbinfac))
+            cmd = "psredit -c name={},be:name=GWB,coord={} -m {}".format(item.jname, item.coordstr, fits_file)
+    elif program == 'pam':
+        if not xnbin:
+            fits_file = output_file_name(session, item, branch, 'fits')
+            cmd = "pam -a PSRFITS -m {}".format(fits_file)
+        else:
+            fits_file = output_file_name(session, item, branch, '{}xNBin.fits'.format(session.xnbinfac))
+            cmd = "pam -a PSRFITS -m {}".format(fits_file)
     elif program == 'pdmp':
-        fits_file = output_file_name(session, item, branch, 'fits')
-        summary_file = output_file_name(session, item, branch, 'summary.ps')
-        cmd = "pdmp -mc 64 -g {}/cps {}".format(summary_file, fits_file)
-        #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
+        if not xnbin:
+            fits_file = output_file_name(session, item, branch, 'fits')
+            summary_file = output_file_name(session, item, branch, 'summary.ps')
+            cmd = "pdmp -mc 64 -g {}/cps {}".format(summary_file, fits_file)
+            #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
+        else:
+            fits_file = output_file_name(session, item, branch, '{}xNBin.fits'.format(session.xnbinfac))
+            summary_file = output_file_name(session, item, branch, '{}xNBin.summary.ps'.format(session.xnbinfac))
+            cmd = "pdmp -mc 64 -g {}/cps {}".format(summary_file, fits_file)
     elif branch == 'rfiClean' and program == 'rfiClean':
         fil_file = output_file_name(session, item, branch, 'fil')
         #rfic_hdrfilename = "{}/{}-{}-ttemp-gm.info".format(session.working_dir, item.jname, item.idx)
@@ -34,10 +60,15 @@ def exec_cmd(session, item, branch, program):
         ## now use absolute delta-freq. instead of Fourier-bins (whose width can change with tsamp,block-size)
         cmd = 'crp_rficlean_gm.sh {} {} {} {} {} \"-psrf {} -psrfdf 8.0 -gmtstamp {}\"'.format(fil_file, session.rfic_conf_file, Nprocess, os.path.basename(item.rawdatafile), item.rfic_hdrfilename, item.f0psr, os.path.basename(item.timestampfile))
         #cmd_split = ["crp_rficlean_gm.sh", fil_file, session.rfic_conf_file, str(Nprocess), item.rawdatafile, rfic_hdrfilename, rficlean_flags]
+    elif program == 'ps2pdf':
+        if not xnbin:
+            summary_file = output_file_name(session, item, branch, 'summary.ps')
+            cmd = "ps2pdf {}".format(summary_file)
+        else:
+            summary_file = output_file_name(session, item, branch, '{}xNBin.summary.ps'.format(session.xnbinfac))
+            cmd = "ps2pdf {}".format(summary_file)
     
     print("[CMD]", cmd)
-    
-    #cmd_split = filter(lambda x: len(x)>0, cmd.split(' '))
      
     try:
         if not session.test_mode:
@@ -60,8 +91,11 @@ def output_file_name(session, item, branch, ext):
     #return "{}/{}.{}.{}".format(session.working_dir, item.output_root, branch, ext)
     return "{}/{}.{}.{}".format('.', item.output_root, branch, ext)
 
-def log_file_name(session, item, branch, program, dev):
-    return "{}/{}.{}.{}".format(item.logdir, program, branch, dev)
+def log_file_name(session, item, branch, program, dev, xnbin=False):
+    if not xnbin:
+        return "{}/{}.{}.{}".format(item.logdir, program, branch, dev)
+    else:
+        return "{}/{}.{}.{}xNBin.{}".format(item.logdir, program, branch, session.xnbinfac, dev)
 
 def print_exec_time(branch, program, exectime):
     print("[TIME] Execution time for {}/{} = {} s".format(branch, program, exectime))
@@ -91,7 +125,9 @@ def run_filterbank(session, item, branch):
         filterbank_in_file = './' + os.path.basename(item.rawdatafile)
     
     fil_file = output_file_name(session, item, branch, 'fil')
-    cmd = "filterbank {} -mjd {} -rf {} -nch {} -bw {} -ts {} -df {} > {}".format(filterbank_in_file, item.timestamp, item.freq, item.nchan, item.chanwidth, item.tsmpl, item.sideband_code, fil_file)
+    #cmd = "filterbank {} -mjd {} -rf {} -nch {} -bw {} -ts {} -df {} > {}".format(filterbank_in_file, item.timestamp, item.freq, item.nchan, item.chanwidth, item.tsmpl, item.sideband_code, fil_file)
+    sideband_opt = "-u" if item.sideband=='USB' else ''
+    cmd = "ugmrt2fil -i {} -o {} -j {} -d {} -f {} -c {} -w {} -t {} {}".format(filterbank_in_file, fil_file, item.jname, item.timestamp, item.freq, item.nchan, item.chanwidth, item.tsmpl, sideband_opt)
     
     print("[CMD]", cmd)
     
@@ -102,13 +138,36 @@ def run_filterbank(session, item, branch):
         
         print_exec_time(branch, program, stop_time-start_time)
 
-def run_dspsr(session, item, branch):
+def run_dspsr(session, item, branch, xnbin=False):
     program = 'dspsr'
-    exec_cmd(session, item, branch, program)
-        
-def run_pdmp(session, item, branch):
+    exec_cmd(session, item, branch, program, xnbin=xnbin)
+    
+    # Checking if output file is created
+    if not xnbin:
+        fits_file = "./" + output_file_name(session, item, branch, 'fits')
+    else:
+        fits_file = "./" + output_file_name(session, item, branch, '{}xNBin.fits'.format(session.xnbinfac))
+    
+    if not os.access(fits_file, os.F_OK) and not session.test_mode:
+        print("[ERROR] dspsr failed to create file {} ... Quitting...".format(fits_file))
+        raise OSError
+
+
+def run_psredit(session, item, branch, xnbin=False):
+    program = 'psredit'
+    exec_cmd(session, item, branch, program, xnbin=xnbin)
+
+def run_pam(session, item, branch, xnbin=False):
+    program = 'pam'
+    exec_cmd(session, item, branch, program, xnbin=xnbin)
+
+def run_pdmp(session, item, branch, xnbin=False):
     program = 'pdmp'
-    exec_cmd(session, item, branch, program)
+    exec_cmd(session, item, branch, program, xnbin=xnbin)
+    
+def run_ps2pdf(session, item, branch, xnbin=False):
+    program = 'ps2pdf'
+    exec_cmd(session, item, branch, program, xnbin=xnbin)
 
 def run_rficlean(session, item, branch):
     #print("[INFO] Trying to make the rficlean-gmhdr file ...")
@@ -124,8 +183,21 @@ def norfix_branch(session, item):
     branch = 'norfix'
     run_filterbank(session, item, branch)
     run_dspsr(session, item, branch)
-    remove_tmp_file(session, item, branch, 'fil')
+    run_psredit(session, item, branch)
+    run_pam(session, item, branch)
     run_pdmp(session, item, branch)
+    run_ps2pdf(session, item, branch)
+    remove_tmp_file(session, item, branch, 'summary.ps')
+    
+    if session.fold_extra_nbin:
+        run_dspsr(session, item, branch, xnbin=True)
+        run_psredit(session, item, branch, xnbin=True)
+        run_pam(session, item, branch, xnbin=True)
+        run_pdmp(session, item, branch, xnbin=True)
+        run_ps2pdf(session, item, branch, xnbin=True)
+        remove_tmp_file(session, item, branch, '{}xNBin.summary.ps'.format(session.xnbinfac))
+    
+    remove_tmp_file(session, item, branch, 'fil')    
 
 def gptool_branch(session, item):
     branch = 'gptool'
@@ -133,15 +205,41 @@ def gptool_branch(session, item):
     run_filterbank(session, item, branch)
     remove_tmp_file(session, item, branch, 'gpt.dat')
     run_dspsr(session, item, branch)
-    remove_tmp_file(session, item, branch, 'fil')
+    run_psredit(session, item, branch)
+    run_pam(session, item, branch)
     run_pdmp(session, item, branch)
+    run_ps2pdf(session, item, branch)
+    remove_tmp_file(session, item, branch, 'summary.ps')
+    
+    if session.fold_extra_nbin:
+        run_dspsr(session, item, branch, xnbin=True)
+        run_psredit(session, item, branch, xnbin=True)
+        run_pam(session, item, branch, xnbin=True)
+        run_pdmp(session, item, branch, xnbin=True)
+        run_ps2pdf(session, item, branch, xnbin=True)
+        remove_tmp_file(session, item, branch, '{}xNBin.summary.ps'.format(session.xnbinfac))
+    
+    remove_tmp_file(session, item, branch, 'fil')
 
 def rficlean_branch(session, item):
     branch = 'rfiClean'
     run_rficlean(session, item, branch)
     run_dspsr(session, item, branch)
-    remove_tmp_file(session, item, branch, 'fil')
+    run_psredit(session, item, branch)
+    run_pam(session, item, branch)
     run_pdmp(session, item, branch)
+    run_ps2pdf(session, item, branch)
+    remove_tmp_file(session, item, branch, 'summary.ps')
+    
+    if session.fold_extra_nbin:
+        run_dspsr(session, item, branch, xnbin=True)
+        run_psredit(session, item, branch, xnbin=True)
+        run_pam(session, item, branch, xnbin=True)
+        run_pdmp(session, item, branch, xnbin=True)
+        run_ps2pdf(session, item, branch, xnbin=True)
+        remove_tmp_file(session, item, branch, '{}xNBin.summary.ps'.format(session.xnbinfac))
+    
+    remove_tmp_file(session, item, branch, 'fil')
 
 def setup_input_ln(session, item):
     if not session.samedir:
diff --git a/pintasession.py b/pintasession.py
index 82e91cd..eb09023 100644
--- a/pintasession.py
+++ b/pintasession.py
@@ -11,7 +11,7 @@ import socket
 import pintatests as tests
 import pintautils as utils
 
-helpmsg = "Usage:\npinta.py [--help] [--test] [--no-gptool] [--no-rficlean] [--nodel] [--retain-aux] [--log-to-file] [--gptdir <...>] [--pardir <...>] [--rficconf <...>] <input_dir> <working_dir>"
+helpmsg = "Usage:\npinta [--help] [--test] [--no-gptool] [--no-rficlean] [--nodel] [--retain-aux] [--log-to-file] [--gptdir <...>] [--pardir <...>] [--rficconf <...>] <input_dir> <working_dir>"
 
 class Session:
     """  
@@ -22,7 +22,7 @@ class Session:
         
         #= Parsing command line ========================================================================================
         cmdargs = sys.argv[1:]
-        opts, args = getopt.gnu_getopt(cmdargs, "", ["gptdir=", "pardir=", "rficconf=", "help", "test", "no-gptool", "no-rficlean", "nodel", "retain-aux", "log-to-file"])
+        opts, args = getopt.gnu_getopt(cmdargs, "", ["gptdir=", "pardir=", "rficconf=", "help", "test", "no-gptool", "no-rficlean", "nodel", "retain-aux", "log-to-file", "xnbin="])
         opts = dict(opts)
         
         #= Displaying help =============================================================================================
@@ -98,6 +98,7 @@ class Session:
                 print("[CONFIG] gptool.in directory provided in command line.")
                 self.gptool_in_dir = tests.test_read_dir( os.path.realpath( opts.get("--gptdir") ) )
             else:
+                print("[CONFIG]" + "\033[91m" + " gptool.in directory NOT provided. The default may not be optimal for this dataset." + "\033[0m")
                 self.gptool_in_dir = tests.test_read_dir( os.path.realpath( config['pinta']['gptdir'] ) )
         
         if self.run_rficlean:
@@ -118,7 +119,7 @@ class Session:
         
         #= Checking if all required programs are present ===============================================================
         #program_list = ['gptool','dspsr','filterbank','tempo2','pdmp','crp_rficlean_gm.sh']
-        program_list = ['dspsr','filterbank','tempo2','pdmp']
+        program_list = ['dspsr','ugmrt2fil','tempo2','pdmp']
         if self.run_gptool:
             program_list += ['gptool']
         if self.run_rficlean:
@@ -131,6 +132,15 @@ class Session:
         if self.run_gptool:
             for freq in [499,749,1459]:
                 tests.test_input_file("{}/gptool.in.{}".format(self.gptool_in_dir,freq))
+                
+        #= Checking whether to apply extra binning =====================================================================
+        self.fold_extra_nbin = opts.get("--xnbin") is not None 
+        if self.fold_extra_nbin:
+            self.xnbinfac = int(opts.get("--xnbin"))
+            print("[CONFIG] Will fold the data to {}*NBin bins in addition to the NBin given in pipeline.in file.".format(self.xnbinfac))
+        else:
+            pass
+            #print("[CONFIG] Will not fold the data to Nyquist nbin.")
         
         #= Checking and reading pipeline.in ============================================================================
         self.pipeline_in_file = tests.test_input_file("%s/pipeline.in"%(self.working_dir))
@@ -181,7 +191,7 @@ class Session:
         self.lockfile = "{}/{}".format(self.working_dir, 'pinta.lock')
         if os.access(self.lockfile, os.F_OK):
             print("[ERROR] Another instance of pinta seems to be running on this directory.")
-            print("[ERROR] *IMPORTANT* If you are /sure/ this is a mistake, please remove pinta.lock manualy and try again. DOING THIS MAY CORRUPT THE DATA.")
+            print("[ERROR] *IMPORTANT* If you are /sure/ this is a mistake, please remove pinta.lock manually and try again. DOING THIS MAY CORRUPT THE DATA.")
             self.lockfail = True
             raise OSError()
         else:
@@ -266,6 +276,13 @@ class PipelineItem:
         self.f0psr = utils.fetch_f0(self.parfile)
         if self.f0psr <= 0:
             raise OSError("Could not read pulsar frequency from par file {}.".format(self.parfile))
+        
+        self.coordstr = ''.join(utils.fetch_RAJ_DECJ(self.parfile))
+        
+        # Default binning
+        if self.nbin == -1:
+            self.nbin = utils.find_nyquist_nbin(session, self)
+        
     
     def desc(self):
         return '{}, MJD {}, {} MHz, {}'.format(self.jname, int(self.timestamp), self.intfreq, "CDP" if self.cohded else "PA")
diff --git a/pintautils.py b/pintautils.py
index b54ae59..3c5ac46 100644
--- a/pintautils.py
+++ b/pintautils.py
@@ -7,6 +7,7 @@ import astropy.time as astrotime
 import getopt
 import time
 import glob
+import astropy.units as astrounit
 
 def touch_file(fname):
     with open(fname, 'w'):
@@ -53,6 +54,82 @@ def fetch_f0(parfile_name):
     print ("[INPUT] Pulsar spin-frequency found :  %f "%f0)
     return f0
 
+def prepare_par_line(line):
+    return line.strip().replace('\t',' ').replace('\n','')
+
+def rad_to_hms(α):
+    # α will be in [-pi,pi]
+    if α<0:
+        α += 2*np.pi
+    hrs = α * 12 / np.pi
+    
+    hh = int(hrs)
+    mm = int((hrs - hh)*60)
+    ss = int((hrs - hh - mm/60)*3600)
+    sf = (hrs - hh - mm/60)*3600 - ss
+    sfs = str(sf).split('.')[1]
+    
+    return f'{hh:02}:{mm:02}:{ss:02}.{sfs}'    
+
+def rad_to_dms(δ):
+    # δ will be in [-pi/2, pi/2]
+    sgn = np.sign(δ)
+    pm = '-' if sgn<0 else '+'
+    
+    degs = np.abs(δ) * 180 / np.pi
+    
+    dd = int(degs)
+    mm = int((degs - dd)*60)
+    ss = int((degs - dd - mm/60)*3600)
+    sf = (degs - dd - mm/60)*3600 - ss
+    sfs = str(sf).split('.')[1]
+    
+    return f'{pm}{dd:02}:{mm:02}:{ss:02}.{sfs}'
+
+def ecliptic_to_equatorial(elat, elong):
+    """
+    https://en.wikipedia.org/wiki/Astronomical_coordinate_systems#Equatorial_%E2%86%94_ecliptic
+    """
+    
+    # Obliquity value taken from PINT
+    # https://github.com/nanograv/PINT/blob/master/src/pint/data/runtime/ecliptic.dat
+    ε = astrounit.Quantity(84381.406000, astrounit.arcsec).to(astrounit.rad).value
+    
+    β = astrounit.Quantity(elat,  astrounit.deg).to(astrounit.rad).value 
+    λ = astrounit.Quantity(elong, astrounit.deg).to(astrounit.rad).value 
+    
+    α = np.arctan2(np.cos(β)*np.sin(λ)*np.cos(ε) - np.sin(β)*np.sin(ε),
+                   np.cos(β)*np.cos(λ))
+    δ = np.arcsin(np.sin(β)*np.cos(ε) + np.cos(β)*np.sin(λ)*np.sin(ε))
+    
+    return rad_to_hms(α), rad_to_dms(δ)
+
+def fetch_RAJ_DECJ(parfile_name):
+    with open(parfile_name, 'r') as par_file:
+        par_lines = par_file.readlines()
+        
+        par_tokens = dict([list(filter(lambda x: len(x)>0, 
+                                       prepare_par_line(line).split(' ')
+                                      )
+                               )[:2] for line in par_lines
+                          ])
+        
+        if "RAJ" in par_tokens and "DECJ" in par_tokens:
+            raj = par_tokens["RAJ"]
+            decj = par_tokens["DECJ"]
+            return raj, decj
+        elif "ELAT" in par_tokens and "ELONG" in par_tokens:
+            elat = par_tokens["ELAT"]
+            elong = par_tokens["ELONG"]
+            return ecliptic_to_equatorial(elat, elong)
+        elif "LAMBDA" in par_tokens and "BETA" in par_tokens:
+            elat = par_tokens["BETA"]
+            elong = par_tokens["LAMBDA"]
+            return ecliptic_to_equatorial(elat, elong)
+        else:
+            print("[ERROR] Unable to read coordinates from par file. Setting 00:00:00+00:00:00.")
+            return "00:00:00","+00:00:00"
+
 def make_rficlean_hdrfile(file_name, psrj,frequency,nchannels,bandwidth,samplingtime,whichband):
         
         print('[INFO] Removing any previous rfiClean-gmhdr file %s   ...  '%(file_name), end=' ')
@@ -124,7 +201,19 @@ def check_mkdir(dirname):
         print("[INFO] Creating directory", dirname)
         os.mkdir(dirname)
     
-aux_files_wcards = ["*.info", "*.gpt", "pdmp.*", 'gptool.in*']
+aux_files_wcards = [    "bandshape.gpt", 
+                        "benchmark_fillTime.gpt", 
+                        "benchmark.gpt", 
+                        "benchmark_readtime.gpt", 
+                        "benchmark_threadtime.gpt", 
+                        "benchmark_threadtime_indv.gpt",
+                        "log.gpt",
+                        "stats.gpt",
+                        "gptool.in",
+                        "gptool.in.oldver",
+                        "pdmp.per",
+                        "pdmp.posn",
+                        "*-ttemp-gm.info" ]
 
 def move_aux_files(session, item):
     glb = lambda f : glob.glob("{}/{}".format(session.working_dir, f))
@@ -146,3 +235,9 @@ def print_log(session, message):
     if session.log_to_file:
         session.logfile.write(message+"\n")
 
+def find_nyquist_nbin(session, item):
+    F0 = item.f0psr
+    Tsmpl = item.tsmpl
+    nbin_nyq = 2**( int(np.log2( 1/(Tsmpl*F0) )) )
+    print ("[INFO] Default NBin =  %d"%nbin_nyq)
+    return nbin_nyq
